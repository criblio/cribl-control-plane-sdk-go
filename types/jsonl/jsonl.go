// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package jsonl

import (
	"bufio"
	"bytes"
	"io"
)

const (
	LF          = 0x0a
	CR          = 0x0d
	RIGHT_BRACE = 0x7d
)

var messageBoundaries = [][]byte{
	{RIGHT_BRACE, CR, LF},
	{RIGHT_BRACE, LF},
}

type JsonLStream[T any] struct {
	reader   io.Reader
	scanner  *bufio.Scanner
	decoder  func(rawEvent []byte) (T, error)
	buffer   []byte
	position int
}

func NewJsonLStream[T any](
	reader io.Reader,
	decoder func(rawEvent []byte) (T, error),
) *JsonLStream[T] {
	scanner := bufio.NewScanner(reader)
	scanner.Split(scanJsonL)

	return &JsonLStream[T]{
		reader:  reader,
		scanner: scanner,
		decoder: decoder,
	}
}

func scanJsonL(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}

	for _, boundary := range messageBoundaries {
		if len(data) < len(boundary) {
			continue
		}

		for i := 0; i <= len(data)-len(boundary); i++ {
			if bytes.Equal(data[i:i+len(boundary)], boundary) {
				return i + len(boundary), data[:i+1], nil
			}
		}
	}

	if atEOF {
		return len(data), data, nil
	}

	return 0, nil, nil
}

func (js *JsonLStream[T]) Next() bool {
	if !js.scanner.Scan() {
		return false
	}

	return true
}

func (js *JsonLStream[T]) Value() (T, error) {
	data := js.scanner.Bytes()
	return js.decoder(data)
}

func (js *JsonLStream[T]) Err() error {
	return js.scanner.Err()
}

func (js *JsonLStream[T]) Close() error {
	if closer, ok := js.reader.(io.Closer); ok {
		return closer.Close()
	}
	return nil
}
