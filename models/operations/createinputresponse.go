// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
	"github.com/criblio/cribl-control-plane-sdk-go/models/components"
)

type CreateInputTypeCriblHTTP string

const (
	CreateInputTypeCriblHTTPCriblHTTP CreateInputTypeCriblHTTP = "cribl_http"
)

func (e CreateInputTypeCriblHTTP) ToPointer() *CreateInputTypeCriblHTTP {
	return &e
}
func (e *CreateInputTypeCriblHTTP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_http":
		*e = CreateInputTypeCriblHTTP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeCriblHTTP: %v", v)
	}
}

type CreateInputInputCriblHTTP struct {
	// Unique ID for this input
	ID       string                   `json:"id"`
	Type     CreateInputTypeCriblHTTP `json:"type"`
	Disabled *bool                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
	AuthTokens []components.ItemsTypeAuthTokens      `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputCriblHTTP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputCriblHTTP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputCriblHTTP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputCriblHTTP) GetType() CreateInputTypeCriblHTTP {
	if c == nil {
		return CreateInputTypeCriblHTTP("")
	}
	return c.Type
}

func (c *CreateInputInputCriblHTTP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputCriblHTTP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputCriblHTTP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputCriblHTTP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputCriblHTTP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputCriblHTTP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputCriblHTTP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputCriblHTTP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputCriblHTTP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputCriblHTTP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputCriblHTTP) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputCriblHTTP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputCriblHTTP) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputCriblHTTP) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputCriblHTTP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputCriblHTTP) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputCriblHTTP) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputCriblHTTP) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputCriblHTTP) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputCriblHTTP) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputCriblHTTP) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputCriblHTTP) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputCriblHTTP) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputCriblHTTP) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputCriblHTTP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputCriblHTTP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputCriblHTTP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeCriblTCP string

const (
	CreateInputTypeCriblTCPCriblTCP CreateInputTypeCriblTCP = "cribl_tcp"
)

func (e CreateInputTypeCriblTCP) ToPointer() *CreateInputTypeCriblTCP {
	return &e
}
func (e *CreateInputTypeCriblTCP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_tcp":
		*e = CreateInputTypeCriblTCP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeCriblTCP: %v", v)
	}
}

type CreateInputInputCriblTCP struct {
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     CreateInputTypeCriblTCP `json:"type"`
	Disabled *bool                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `json:"enableLoadBalancing,omitempty"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
	AuthTokens  []components.ItemsTypeAuthTokens `json:"authTokens,omitempty"`
	Description *string                          `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputCriblTCP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputCriblTCP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputCriblTCP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputCriblTCP) GetType() CreateInputTypeCriblTCP {
	if c == nil {
		return CreateInputTypeCriblTCP("")
	}
	return c.Type
}

func (c *CreateInputInputCriblTCP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputCriblTCP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputCriblTCP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputCriblTCP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputCriblTCP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputCriblTCP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputCriblTCP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputCriblTCP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputCriblTCP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputCriblTCP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputCriblTCP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputCriblTCP) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputCriblTCP) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputInputCriblTCP) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputInputCriblTCP) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputInputCriblTCP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputCriblTCP) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputCriblTCP) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputInputCriblTCP) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputCriblTCP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputCriblTCP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputCriblTCP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeCribl string

const (
	CreateInputTypeCriblCribl CreateInputTypeCribl = "cribl"
)

func (e CreateInputTypeCribl) ToPointer() *CreateInputTypeCribl {
	return &e
}
func (e *CreateInputTypeCribl) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl":
		*e = CreateInputTypeCribl(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeCribl: %v", v)
	}
}

type CreateInputInputCribl struct {
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     CreateInputTypeCribl `json:"type"`
	Disabled *bool                `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	Filter      *string                                   `json:"filter,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
}

func (c CreateInputInputCribl) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputCribl) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputCribl) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputCribl) GetType() CreateInputTypeCribl {
	if c == nil {
		return CreateInputTypeCribl("")
	}
	return c.Type
}

func (c *CreateInputInputCribl) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputCribl) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputCribl) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputCribl) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputCribl) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputCribl) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputCribl) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputCribl) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputCribl) GetFilter() *string {
	if c == nil {
		return nil
	}
	return c.Filter
}

func (c *CreateInputInputCribl) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputCribl) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeGooglePubsub string

const (
	CreateInputTypeGooglePubsubGooglePubsub CreateInputTypeGooglePubsub = "google_pubsub"
)

func (e CreateInputTypeGooglePubsub) ToPointer() *CreateInputTypeGooglePubsub {
	return &e
}
func (e *CreateInputTypeGooglePubsub) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "google_pubsub":
		*e = CreateInputTypeGooglePubsub(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeGooglePubsub: %v", v)
	}
}

type CreateInputInputGooglePubsub struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputTypeGooglePubsub `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
	TopicName string `json:"topicName"`
	// ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
	SubscriptionName string `json:"subscriptionName"`
	// Use when the subscription is not created by this Source and topic is not known
	MonitorSubscription *bool `json:"monitorSubscription,omitempty"`
	// Create topic if it does not exist
	CreateTopic *bool `json:"createTopic,omitempty"`
	// Create subscription if it does not exist
	CreateSubscription *bool `json:"createSubscription,omitempty"`
	// Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
	Region *string `json:"region,omitempty"`
	// Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
	GoogleAuthMethod *components.GoogleAuthenticationMethodOptions `json:"googleAuthMethod,omitempty"`
	// Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`
	// Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`
	// If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
	MaxBacklog *float64 `json:"maxBacklog,omitempty"`
	// How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
	Concurrency *float64 `json:"concurrency,omitempty"`
	// Pull request timeout, in milliseconds
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
	OrderedDelivery *bool `json:"orderedDelivery,omitempty"`
	// Binds 'topicName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'topicName' at runtime.
	TemplateTopicName *string `json:"__template_topicName,omitempty"`
	// Binds 'subscriptionName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'subscriptionName' at runtime.
	TemplateSubscriptionName *string `json:"__template_subscriptionName,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
}

func (c CreateInputInputGooglePubsub) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputGooglePubsub) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputGooglePubsub) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputGooglePubsub) GetType() CreateInputTypeGooglePubsub {
	if c == nil {
		return CreateInputTypeGooglePubsub("")
	}
	return c.Type
}

func (c *CreateInputInputGooglePubsub) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputGooglePubsub) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputGooglePubsub) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputGooglePubsub) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputGooglePubsub) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputGooglePubsub) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputGooglePubsub) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputGooglePubsub) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputGooglePubsub) GetTopicName() string {
	if c == nil {
		return ""
	}
	return c.TopicName
}

func (c *CreateInputInputGooglePubsub) GetSubscriptionName() string {
	if c == nil {
		return ""
	}
	return c.SubscriptionName
}

func (c *CreateInputInputGooglePubsub) GetMonitorSubscription() *bool {
	if c == nil {
		return nil
	}
	return c.MonitorSubscription
}

func (c *CreateInputInputGooglePubsub) GetCreateTopic() *bool {
	if c == nil {
		return nil
	}
	return c.CreateTopic
}

func (c *CreateInputInputGooglePubsub) GetCreateSubscription() *bool {
	if c == nil {
		return nil
	}
	return c.CreateSubscription
}

func (c *CreateInputInputGooglePubsub) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputInputGooglePubsub) GetGoogleAuthMethod() *components.GoogleAuthenticationMethodOptions {
	if c == nil {
		return nil
	}
	return c.GoogleAuthMethod
}

func (c *CreateInputInputGooglePubsub) GetServiceAccountCredentials() *string {
	if c == nil {
		return nil
	}
	return c.ServiceAccountCredentials
}

func (c *CreateInputInputGooglePubsub) GetSecret() *string {
	if c == nil {
		return nil
	}
	return c.Secret
}

func (c *CreateInputInputGooglePubsub) GetMaxBacklog() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBacklog
}

func (c *CreateInputInputGooglePubsub) GetConcurrency() *float64 {
	if c == nil {
		return nil
	}
	return c.Concurrency
}

func (c *CreateInputInputGooglePubsub) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputGooglePubsub) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputGooglePubsub) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputGooglePubsub) GetOrderedDelivery() *bool {
	if c == nil {
		return nil
	}
	return c.OrderedDelivery
}

func (c *CreateInputInputGooglePubsub) GetTemplateTopicName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTopicName
}

func (c *CreateInputInputGooglePubsub) GetTemplateSubscriptionName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateSubscriptionName
}

func (c *CreateInputInputGooglePubsub) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

type CreateInputTypeFirehose string

const (
	CreateInputTypeFirehoseFirehose CreateInputTypeFirehose = "firehose"
)

func (e CreateInputTypeFirehose) ToPointer() *CreateInputTypeFirehose {
	return &e
}
func (e *CreateInputTypeFirehose) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "firehose":
		*e = CreateInputTypeFirehose(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeFirehose: %v", v)
	}
}

type CreateInputInputFirehose struct {
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     CreateInputTypeFirehose `json:"type"`
	Disabled *bool                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputFirehose) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputFirehose) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputFirehose) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputFirehose) GetType() CreateInputTypeFirehose {
	if c == nil {
		return CreateInputTypeFirehose("")
	}
	return c.Type
}

func (c *CreateInputInputFirehose) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputFirehose) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputFirehose) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputFirehose) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputFirehose) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputFirehose) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputFirehose) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputFirehose) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputFirehose) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputFirehose) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputFirehose) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputFirehose) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputFirehose) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputFirehose) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputFirehose) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputFirehose) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputFirehose) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputFirehose) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputFirehose) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputFirehose) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputFirehose) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputFirehose) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputFirehose) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputFirehose) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputFirehose) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputFirehose) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputFirehose) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputInputExecType string

const (
	CreateInputInputExecTypeExec CreateInputInputExecType = "exec"
)

func (e CreateInputInputExecType) ToPointer() *CreateInputInputExecType {
	return &e
}
func (e *CreateInputInputExecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = CreateInputInputExecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputInputExecType: %v", v)
	}
}

// CreateInputScheduleType - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type CreateInputScheduleType string

const (
	CreateInputScheduleTypeInterval     CreateInputScheduleType = "interval"
	CreateInputScheduleTypeCronSchedule CreateInputScheduleType = "cronSchedule"
)

func (e CreateInputScheduleType) ToPointer() *CreateInputScheduleType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputScheduleType) IsExact() bool {
	if e != nil {
		switch *e {
		case "interval", "cronSchedule":
			return true
		}
	}
	return false
}

type CreateInputInputExec struct {
	// Unique ID for this input
	ID       string                   `json:"id"`
	Type     CreateInputInputExecType `json:"type"`
	Disabled *bool                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `json:"retries,omitempty"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *CreateInputScheduleType `json:"scheduleType,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `json:"interval,omitempty"`
	// Cron schedule to execute the command on.
	CronSchedule *string `json:"cronSchedule,omitempty"`
}

func (c CreateInputInputExec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputExec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputExec) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputExec) GetType() CreateInputInputExecType {
	if c == nil {
		return CreateInputInputExecType("")
	}
	return c.Type
}

func (c *CreateInputInputExec) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputExec) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputExec) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputExec) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputExec) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputExec) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputExec) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputExec) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputExec) GetCommand() string {
	if c == nil {
		return ""
	}
	return c.Command
}

func (c *CreateInputInputExec) GetRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.Retries
}

func (c *CreateInputInputExec) GetScheduleType() *CreateInputScheduleType {
	if c == nil {
		return nil
	}
	return c.ScheduleType
}

func (c *CreateInputInputExec) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputExec) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputExec) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputExec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputExec) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputExec) GetCronSchedule() *string {
	if c == nil {
		return nil
	}
	return c.CronSchedule
}

type CreateInputTypeEventhub string

const (
	CreateInputTypeEventhubEventhub CreateInputTypeEventhub = "eventhub"
)

func (e CreateInputTypeEventhub) ToPointer() *CreateInputTypeEventhub {
	return &e
}
func (e *CreateInputTypeEventhub) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eventhub":
		*e = CreateInputTypeEventhub(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeEventhub: %v", v)
	}
}

type CreateInputInputEventhub struct {
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     CreateInputTypeEventhub `json:"type"`
	Disabled *bool                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
	Brokers []string `json:"brokers"`
	// The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
	Topics []string `json:"topics"`
	// The consumer group this instance belongs to. Default is 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	// Start reading from earliest available data; relevant only during initial subscription
	FromBeginning *bool `json:"fromBeginning,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `json:"maxRetries,omitempty"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `json:"maxBackOff,omitempty"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `json:"initialBackoff,omitempty"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `json:"backoffRate,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `json:"authenticationTimeout,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `json:"reauthenticationThreshold,omitempty"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType1       `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideType `json:"tls,omitempty"`
	//       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
	//       Value must be lower than rebalanceTimeout.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	SessionTimeout *float64 `json:"sessionTimeout,omitempty"`
	//       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	RebalanceTimeout *float64 `json:"rebalanceTimeout,omitempty"`
	//       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	HeartbeatInterval *float64 `json:"heartbeatInterval,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `json:"maxBytesPerPartition,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `json:"maxBytes,omitempty"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `json:"maxSocketErrors,omitempty"`
	// Minimize duplicate events by starting only one consumer for each topic partition
	MinimizeDuplicates *bool `json:"minimizeDuplicates,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
}

func (c CreateInputInputEventhub) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputEventhub) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputEventhub) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputEventhub) GetType() CreateInputTypeEventhub {
	if c == nil {
		return CreateInputTypeEventhub("")
	}
	return c.Type
}

func (c *CreateInputInputEventhub) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputEventhub) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputEventhub) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputEventhub) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputEventhub) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputEventhub) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputEventhub) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputEventhub) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputEventhub) GetBrokers() []string {
	if c == nil {
		return []string{}
	}
	return c.Brokers
}

func (c *CreateInputInputEventhub) GetTopics() []string {
	if c == nil {
		return []string{}
	}
	return c.Topics
}

func (c *CreateInputInputEventhub) GetGroupID() *string {
	if c == nil {
		return nil
	}
	return c.GroupID
}

func (c *CreateInputInputEventhub) GetFromBeginning() *bool {
	if c == nil {
		return nil
	}
	return c.FromBeginning
}

func (c *CreateInputInputEventhub) GetConnectionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ConnectionTimeout
}

func (c *CreateInputInputEventhub) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputEventhub) GetMaxRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRetries
}

func (c *CreateInputInputEventhub) GetMaxBackOff() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBackOff
}

func (c *CreateInputInputEventhub) GetInitialBackoff() *float64 {
	if c == nil {
		return nil
	}
	return c.InitialBackoff
}

func (c *CreateInputInputEventhub) GetBackoffRate() *float64 {
	if c == nil {
		return nil
	}
	return c.BackoffRate
}

func (c *CreateInputInputEventhub) GetAuthenticationTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.AuthenticationTimeout
}

func (c *CreateInputInputEventhub) GetReauthenticationThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.ReauthenticationThreshold
}

func (c *CreateInputInputEventhub) GetSasl() *components.AuthenticationType1 {
	if c == nil {
		return nil
	}
	return c.Sasl
}

func (c *CreateInputInputEventhub) GetTLS() *components.TLSSettingsClientSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputEventhub) GetSessionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SessionTimeout
}

func (c *CreateInputInputEventhub) GetRebalanceTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RebalanceTimeout
}

func (c *CreateInputInputEventhub) GetHeartbeatInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.HeartbeatInterval
}

func (c *CreateInputInputEventhub) GetAutoCommitInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitInterval
}

func (c *CreateInputInputEventhub) GetAutoCommitThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitThreshold
}

func (c *CreateInputInputEventhub) GetMaxBytesPerPartition() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytesPerPartition
}

func (c *CreateInputInputEventhub) GetMaxBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytes
}

func (c *CreateInputInputEventhub) GetMaxSocketErrors() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxSocketErrors
}

func (c *CreateInputInputEventhub) GetMinimizeDuplicates() *bool {
	if c == nil {
		return nil
	}
	return c.MinimizeDuplicates
}

func (c *CreateInputInputEventhub) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputEventhub) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeOffice365MsgTrace string

const (
	CreateInputTypeOffice365MsgTraceOffice365MsgTrace CreateInputTypeOffice365MsgTrace = "office365_msg_trace"
)

func (e CreateInputTypeOffice365MsgTrace) ToPointer() *CreateInputTypeOffice365MsgTrace {
	return &e
}
func (e *CreateInputTypeOffice365MsgTrace) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_msg_trace":
		*e = CreateInputTypeOffice365MsgTrace(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeOffice365MsgTrace: %v", v)
	}
}

// CreateInputAuthenticationMethodOffice365MsgTrace - Select authentication method.
type CreateInputAuthenticationMethodOffice365MsgTrace string

const (
	CreateInputAuthenticationMethodOffice365MsgTraceManual      CreateInputAuthenticationMethodOffice365MsgTrace = "manual"
	CreateInputAuthenticationMethodOffice365MsgTraceSecret      CreateInputAuthenticationMethodOffice365MsgTrace = "secret"
	CreateInputAuthenticationMethodOffice365MsgTraceOauth       CreateInputAuthenticationMethodOffice365MsgTrace = "oauth"
	CreateInputAuthenticationMethodOffice365MsgTraceOauthSecret CreateInputAuthenticationMethodOffice365MsgTrace = "oauthSecret"
	CreateInputAuthenticationMethodOffice365MsgTraceOauthCert   CreateInputAuthenticationMethodOffice365MsgTrace = "oauthCert"
)

func (e CreateInputAuthenticationMethodOffice365MsgTrace) ToPointer() *CreateInputAuthenticationMethodOffice365MsgTrace {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputAuthenticationMethodOffice365MsgTrace) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "oauth", "oauthSecret", "oauthCert":
			return true
		}
	}
	return false
}

// CreateInputLogLevelOffice365MsgTrace - Log Level (verbosity) for collection runtime behavior.
type CreateInputLogLevelOffice365MsgTrace string

const (
	CreateInputLogLevelOffice365MsgTraceError CreateInputLogLevelOffice365MsgTrace = "error"
	CreateInputLogLevelOffice365MsgTraceWarn  CreateInputLogLevelOffice365MsgTrace = "warn"
	CreateInputLogLevelOffice365MsgTraceInfo  CreateInputLogLevelOffice365MsgTrace = "info"
	CreateInputLogLevelOffice365MsgTraceDebug CreateInputLogLevelOffice365MsgTrace = "debug"
	CreateInputLogLevelOffice365MsgTraceSilly CreateInputLogLevelOffice365MsgTrace = "silly"
)

func (e CreateInputLogLevelOffice365MsgTrace) ToPointer() *CreateInputLogLevelOffice365MsgTrace {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputLogLevelOffice365MsgTrace) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug", "silly":
			return true
		}
	}
	return false
}

type CreateInputCertOptions struct {
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	// Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
	PrivKeyPath string `json:"privKeyPath"`
	// Passphrase to use to decrypt the private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
	CertPath string `json:"certPath"`
}

func (c CreateInputCertOptions) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputCertOptions) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputCertOptions) GetCertificateName() *string {
	if c == nil {
		return nil
	}
	return c.CertificateName
}

func (c *CreateInputCertOptions) GetPrivKeyPath() string {
	if c == nil {
		return ""
	}
	return c.PrivKeyPath
}

func (c *CreateInputCertOptions) GetPassphrase() *string {
	if c == nil {
		return nil
	}
	return c.Passphrase
}

func (c *CreateInputCertOptions) GetCertPath() string {
	if c == nil {
		return ""
	}
	return c.CertPath
}

type CreateInputInputOffice365MsgTrace struct {
	// Unique ID for this input
	ID       string                           `json:"id"`
	Type     CreateInputTypeOffice365MsgTrace `json:"type"`
	Disabled *bool                            `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// URL to use when retrieving report data.
	URL string `json:"url"`
	// How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
	Interval float64 `json:"interval"`
	// Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
	StartDate *string `json:"startDate,omitempty"`
	// Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
	EndDate *string `json:"endDate,omitempty"`
	// HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
	Timeout *float64 `json:"timeout,omitempty"`
	// Disables time filtering of events when a date range is specified.
	DisableTimeFilter *bool `json:"disableTimeFilter,omitempty"`
	// Select authentication method.
	AuthType *CreateInputAuthenticationMethodOffice365MsgTrace `json:"authType,omitempty"`
	// Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `json:"rescheduleDroppedTasks,omitempty"`
	// Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float64 `json:"maxTaskReschedule,omitempty"`
	// Log Level (verbosity) for collection runtime behavior.
	LogLevel *CreateInputLogLevelOffice365MsgTrace `json:"logLevel,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	RetryRules  *components.RetryRulesType1    `json:"retryRules,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Username to run Message Trace API call.
	Username *string `json:"username,omitempty"`
	// Password to run Message Trace API call.
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials.
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// client_secret to pass in the OAuth request parameter.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Directory ID (tenant identifier) in Azure Active Directory.
	TenantID *string `json:"tenantId,omitempty"`
	// client_id to pass in the OAuth request parameter.
	ClientID *string `json:"clientId,omitempty"`
	// Resource to pass in the OAuth request parameter.
	Resource *string `json:"resource,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `json:"planType,omitempty"`
	// Select or create a secret that references your client_secret to pass in the OAuth request parameter.
	TextSecret  *string                 `json:"textSecret,omitempty"`
	CertOptions *CreateInputCertOptions `json:"certOptions,omitempty"`
	// Binds 'url' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'url' at runtime.
	TemplateURL *string `json:"__template_url,omitempty"`
	// Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime.
	TemplateTenantID *string `json:"__template_tenantId,omitempty"`
	// Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime.
	TemplateClientID *string `json:"__template_clientId,omitempty"`
	// Binds 'resource' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'resource' at runtime.
	TemplateResource *string `json:"__template_resource,omitempty"`
}

func (c CreateInputInputOffice365MsgTrace) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputOffice365MsgTrace) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputOffice365MsgTrace) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputOffice365MsgTrace) GetType() CreateInputTypeOffice365MsgTrace {
	if c == nil {
		return CreateInputTypeOffice365MsgTrace("")
	}
	return c.Type
}

func (c *CreateInputInputOffice365MsgTrace) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputOffice365MsgTrace) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputOffice365MsgTrace) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputOffice365MsgTrace) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputOffice365MsgTrace) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputOffice365MsgTrace) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputOffice365MsgTrace) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputOffice365MsgTrace) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputOffice365MsgTrace) GetURL() string {
	if c == nil {
		return ""
	}
	return c.URL
}

func (c *CreateInputInputOffice365MsgTrace) GetInterval() float64 {
	if c == nil {
		return 0.0
	}
	return c.Interval
}

func (c *CreateInputInputOffice365MsgTrace) GetStartDate() *string {
	if c == nil {
		return nil
	}
	return c.StartDate
}

func (c *CreateInputInputOffice365MsgTrace) GetEndDate() *string {
	if c == nil {
		return nil
	}
	return c.EndDate
}

func (c *CreateInputInputOffice365MsgTrace) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputInputOffice365MsgTrace) GetDisableTimeFilter() *bool {
	if c == nil {
		return nil
	}
	return c.DisableTimeFilter
}

func (c *CreateInputInputOffice365MsgTrace) GetAuthType() *CreateInputAuthenticationMethodOffice365MsgTrace {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputOffice365MsgTrace) GetRescheduleDroppedTasks() *bool {
	if c == nil {
		return nil
	}
	return c.RescheduleDroppedTasks
}

func (c *CreateInputInputOffice365MsgTrace) GetMaxTaskReschedule() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxTaskReschedule
}

func (c *CreateInputInputOffice365MsgTrace) GetLogLevel() *CreateInputLogLevelOffice365MsgTrace {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputInputOffice365MsgTrace) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputInputOffice365MsgTrace) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputInputOffice365MsgTrace) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputInputOffice365MsgTrace) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputInputOffice365MsgTrace) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputInputOffice365MsgTrace) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputOffice365MsgTrace) GetRetryRules() *components.RetryRulesType1 {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputInputOffice365MsgTrace) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputOffice365MsgTrace) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputInputOffice365MsgTrace) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputInputOffice365MsgTrace) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputInputOffice365MsgTrace) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateInputInputOffice365MsgTrace) GetTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TenantID
}

func (c *CreateInputInputOffice365MsgTrace) GetClientID() *string {
	if c == nil {
		return nil
	}
	return c.ClientID
}

func (c *CreateInputInputOffice365MsgTrace) GetResource() *string {
	if c == nil {
		return nil
	}
	return c.Resource
}

func (c *CreateInputInputOffice365MsgTrace) GetPlanType() *components.SubscriptionPlanOptions {
	if c == nil {
		return nil
	}
	return c.PlanType
}

func (c *CreateInputInputOffice365MsgTrace) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputOffice365MsgTrace) GetCertOptions() *CreateInputCertOptions {
	if c == nil {
		return nil
	}
	return c.CertOptions
}

func (c *CreateInputInputOffice365MsgTrace) GetTemplateURL() *string {
	if c == nil {
		return nil
	}
	return c.TemplateURL
}

func (c *CreateInputInputOffice365MsgTrace) GetTemplateTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTenantID
}

func (c *CreateInputInputOffice365MsgTrace) GetTemplateClientID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientID
}

func (c *CreateInputInputOffice365MsgTrace) GetTemplateResource() *string {
	if c == nil {
		return nil
	}
	return c.TemplateResource
}

type CreateInputTypeOffice365Service string

const (
	CreateInputTypeOffice365ServiceOffice365Service CreateInputTypeOffice365Service = "office365_service"
)

func (e CreateInputTypeOffice365Service) ToPointer() *CreateInputTypeOffice365Service {
	return &e
}
func (e *CreateInputTypeOffice365Service) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_service":
		*e = CreateInputTypeOffice365Service(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeOffice365Service: %v", v)
	}
}

type CreateInputContentConfigOffice365Service struct {
	// Office 365 Services API Content Type
	ContentType *string `json:"contentType,omitempty"`
	// If interval type is minutes the value entered must evenly divisible by 60 or save will fail
	Description *string  `json:"description,omitempty"`
	Interval    *float64 `json:"interval,omitempty"`
	// Collector runtime Log Level
	LogLevel *components.LogLevelOptionsContentConfigItems `json:"logLevel,omitempty"`
	Enabled  *bool                                         `json:"enabled,omitempty"`
}

func (c CreateInputContentConfigOffice365Service) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputContentConfigOffice365Service) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputContentConfigOffice365Service) GetContentType() *string {
	if c == nil {
		return nil
	}
	return c.ContentType
}

func (c *CreateInputContentConfigOffice365Service) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputContentConfigOffice365Service) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputContentConfigOffice365Service) GetLogLevel() *components.LogLevelOptionsContentConfigItems {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputContentConfigOffice365Service) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

type CreateInputInputOffice365Service struct {
	// Unique ID for this input
	ID       string                          `json:"id"`
	Type     CreateInputTypeOffice365Service `json:"type"`
	Disabled *bool                           `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `json:"planType,omitempty"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `json:"timeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []CreateInputContentConfigOffice365Service `json:"contentConfig,omitempty"`
	RetryRules    *components.RetryRulesType1                `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `json:"authType,omitempty"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime.
	TemplateTenantID *string `json:"__template_tenantId,omitempty"`
	// Binds 'appId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'appId' at runtime.
	TemplateAppID *string `json:"__template_appId,omitempty"`
	// Binds 'clientSecret' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientSecret' at runtime.
	TemplateClientSecret *string `json:"__template_clientSecret,omitempty"`
}

func (c CreateInputInputOffice365Service) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputOffice365Service) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputOffice365Service) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputOffice365Service) GetType() CreateInputTypeOffice365Service {
	if c == nil {
		return CreateInputTypeOffice365Service("")
	}
	return c.Type
}

func (c *CreateInputInputOffice365Service) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputOffice365Service) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputOffice365Service) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputOffice365Service) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputOffice365Service) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputOffice365Service) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputOffice365Service) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputOffice365Service) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputOffice365Service) GetPlanType() *components.SubscriptionPlanOptions {
	if c == nil {
		return nil
	}
	return c.PlanType
}

func (c *CreateInputInputOffice365Service) GetTenantID() string {
	if c == nil {
		return ""
	}
	return c.TenantID
}

func (c *CreateInputInputOffice365Service) GetAppID() string {
	if c == nil {
		return ""
	}
	return c.AppID
}

func (c *CreateInputInputOffice365Service) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputInputOffice365Service) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputInputOffice365Service) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputInputOffice365Service) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputInputOffice365Service) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputInputOffice365Service) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputInputOffice365Service) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputOffice365Service) GetContentConfig() []CreateInputContentConfigOffice365Service {
	if c == nil {
		return nil
	}
	return c.ContentConfig
}

func (c *CreateInputInputOffice365Service) GetRetryRules() *components.RetryRulesType1 {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputInputOffice365Service) GetAuthType() *components.AuthenticationMethodOptions1 {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputOffice365Service) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputOffice365Service) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateInputInputOffice365Service) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputOffice365Service) GetTemplateTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTenantID
}

func (c *CreateInputInputOffice365Service) GetTemplateAppID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAppID
}

func (c *CreateInputInputOffice365Service) GetTemplateClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientSecret
}

type CreateInputTypeOffice365Mgmt string

const (
	CreateInputTypeOffice365MgmtOffice365Mgmt CreateInputTypeOffice365Mgmt = "office365_mgmt"
)

func (e CreateInputTypeOffice365Mgmt) ToPointer() *CreateInputTypeOffice365Mgmt {
	return &e
}
func (e *CreateInputTypeOffice365Mgmt) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_mgmt":
		*e = CreateInputTypeOffice365Mgmt(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeOffice365Mgmt: %v", v)
	}
}

type CreateInputContentConfigOffice365Mgmt struct {
	// Office 365 Management Activity API Content Type
	ContentType *string `json:"contentType,omitempty"`
	// If interval type is minutes the value entered must evenly divisible by 60 or save will fail
	Description *string  `json:"description,omitempty"`
	Interval    *float64 `json:"interval,omitempty"`
	// Collector runtime Log Level
	LogLevel *components.LogLevelOptionsContentConfigItems `json:"logLevel,omitempty"`
	Enabled  *bool                                         `json:"enabled,omitempty"`
}

func (c CreateInputContentConfigOffice365Mgmt) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputContentConfigOffice365Mgmt) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputContentConfigOffice365Mgmt) GetContentType() *string {
	if c == nil {
		return nil
	}
	return c.ContentType
}

func (c *CreateInputContentConfigOffice365Mgmt) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputContentConfigOffice365Mgmt) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputContentConfigOffice365Mgmt) GetLogLevel() *components.LogLevelOptionsContentConfigItems {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputContentConfigOffice365Mgmt) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

type CreateInputInputOffice365Mgmt struct {
	// Unique ID for this input
	ID       string                       `json:"id"`
	Type     CreateInputTypeOffice365Mgmt `json:"type"`
	Disabled *bool                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType components.SubscriptionPlanOptions `json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `json:"timeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
	PublisherIdentifier *string `json:"publisherIdentifier,omitempty"`
	// Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []CreateInputContentConfigOffice365Mgmt `json:"contentConfig,omitempty"`
	// Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
	IngestionLag *float64                    `json:"ingestionLag,omitempty"`
	RetryRules   *components.RetryRulesType1 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `json:"authType,omitempty"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime.
	TemplateTenantID *string `json:"__template_tenantId,omitempty"`
	// Binds 'appId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'appId' at runtime.
	TemplateAppID *string `json:"__template_appId,omitempty"`
	// Binds 'publisherIdentifier' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'publisherIdentifier' at runtime.
	TemplatePublisherIdentifier *string `json:"__template_publisherIdentifier,omitempty"`
	// Binds 'clientSecret' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientSecret' at runtime.
	TemplateClientSecret *string `json:"__template_clientSecret,omitempty"`
}

func (c CreateInputInputOffice365Mgmt) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputOffice365Mgmt) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputOffice365Mgmt) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputOffice365Mgmt) GetType() CreateInputTypeOffice365Mgmt {
	if c == nil {
		return CreateInputTypeOffice365Mgmt("")
	}
	return c.Type
}

func (c *CreateInputInputOffice365Mgmt) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputOffice365Mgmt) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputOffice365Mgmt) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputOffice365Mgmt) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputOffice365Mgmt) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputOffice365Mgmt) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputOffice365Mgmt) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputOffice365Mgmt) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputOffice365Mgmt) GetPlanType() components.SubscriptionPlanOptions {
	if c == nil {
		return components.SubscriptionPlanOptions("")
	}
	return c.PlanType
}

func (c *CreateInputInputOffice365Mgmt) GetTenantID() string {
	if c == nil {
		return ""
	}
	return c.TenantID
}

func (c *CreateInputInputOffice365Mgmt) GetAppID() string {
	if c == nil {
		return ""
	}
	return c.AppID
}

func (c *CreateInputInputOffice365Mgmt) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputInputOffice365Mgmt) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputInputOffice365Mgmt) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputInputOffice365Mgmt) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputInputOffice365Mgmt) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputInputOffice365Mgmt) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputInputOffice365Mgmt) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputOffice365Mgmt) GetPublisherIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.PublisherIdentifier
}

func (c *CreateInputInputOffice365Mgmt) GetContentConfig() []CreateInputContentConfigOffice365Mgmt {
	if c == nil {
		return nil
	}
	return c.ContentConfig
}

func (c *CreateInputInputOffice365Mgmt) GetIngestionLag() *float64 {
	if c == nil {
		return nil
	}
	return c.IngestionLag
}

func (c *CreateInputInputOffice365Mgmt) GetRetryRules() *components.RetryRulesType1 {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputInputOffice365Mgmt) GetAuthType() *components.AuthenticationMethodOptions1 {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputOffice365Mgmt) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputOffice365Mgmt) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateInputInputOffice365Mgmt) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputOffice365Mgmt) GetTemplateTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTenantID
}

func (c *CreateInputInputOffice365Mgmt) GetTemplateAppID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAppID
}

func (c *CreateInputInputOffice365Mgmt) GetTemplatePublisherIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePublisherIdentifier
}

func (c *CreateInputInputOffice365Mgmt) GetTemplateClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientSecret
}

type CreateInputTypeEdgePrometheus string

const (
	CreateInputTypeEdgePrometheusEdgePrometheus CreateInputTypeEdgePrometheus = "edge_prometheus"
)

func (e CreateInputTypeEdgePrometheus) ToPointer() *CreateInputTypeEdgePrometheus {
	return &e
}
func (e *CreateInputTypeEdgePrometheus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "edge_prometheus":
		*e = CreateInputTypeEdgePrometheus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeEdgePrometheus: %v", v)
	}
}

// CreateInputDiscoveryTypeEdgePrometheus - Target discovery mechanism. Use static to manually enter a list of targets.
type CreateInputDiscoveryTypeEdgePrometheus string

const (
	// CreateInputDiscoveryTypeEdgePrometheusStatic Static
	CreateInputDiscoveryTypeEdgePrometheusStatic CreateInputDiscoveryTypeEdgePrometheus = "static"
	// CreateInputDiscoveryTypeEdgePrometheusDNS DNS
	CreateInputDiscoveryTypeEdgePrometheusDNS CreateInputDiscoveryTypeEdgePrometheus = "dns"
	// CreateInputDiscoveryTypeEdgePrometheusEc2 AWS EC2
	CreateInputDiscoveryTypeEdgePrometheusEc2 CreateInputDiscoveryTypeEdgePrometheus = "ec2"
	// CreateInputDiscoveryTypeEdgePrometheusK8sNode Kubernetes Node
	CreateInputDiscoveryTypeEdgePrometheusK8sNode CreateInputDiscoveryTypeEdgePrometheus = "k8s-node"
	// CreateInputDiscoveryTypeEdgePrometheusK8sPods Kubernetes Pods
	CreateInputDiscoveryTypeEdgePrometheusK8sPods CreateInputDiscoveryTypeEdgePrometheus = "k8s-pods"
)

func (e CreateInputDiscoveryTypeEdgePrometheus) ToPointer() *CreateInputDiscoveryTypeEdgePrometheus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputDiscoveryTypeEdgePrometheus) IsExact() bool {
	if e != nil {
		switch *e {
		case "static", "dns", "ec2", "k8s-node", "k8s-pods":
			return true
		}
	}
	return false
}

// CreateInputAuthenticationMethodEdgePrometheus - Enter credentials directly, or select a stored secret
type CreateInputAuthenticationMethodEdgePrometheus string

const (
	CreateInputAuthenticationMethodEdgePrometheusManual     CreateInputAuthenticationMethodEdgePrometheus = "manual"
	CreateInputAuthenticationMethodEdgePrometheusSecret     CreateInputAuthenticationMethodEdgePrometheus = "secret"
	CreateInputAuthenticationMethodEdgePrometheusKubernetes CreateInputAuthenticationMethodEdgePrometheus = "kubernetes"
)

func (e CreateInputAuthenticationMethodEdgePrometheus) ToPointer() *CreateInputAuthenticationMethodEdgePrometheus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputAuthenticationMethodEdgePrometheus) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "kubernetes":
			return true
		}
	}
	return false
}

type CreateInputTarget struct {
	// Protocol to use when collecting metrics
	Protocol *components.ProtocolOptionsTargetsItems `json:"protocol,omitempty"`
	// Name of host from which to pull metrics.
	Host string `json:"host"`
	// The port number in the metrics URL for discovered targets.
	Port *float64 `json:"port,omitempty"`
	// Path to use when collecting metrics from discovered targets
	Path *string `json:"path,omitempty"`
}

func (c CreateInputTarget) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputTarget) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputTarget) GetProtocol() *components.ProtocolOptionsTargetsItems {
	if c == nil {
		return nil
	}
	return c.Protocol
}

func (c *CreateInputTarget) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputTarget) GetPort() *float64 {
	if c == nil {
		return nil
	}
	return c.Port
}

func (c *CreateInputTarget) GetPath() *string {
	if c == nil {
		return nil
	}
	return c.Path
}

type CreateInputPodFilter struct {
	// JavaScript expression applied to pods objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (c CreateInputPodFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputPodFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputPodFilter) GetFilter() string {
	if c == nil {
		return ""
	}
	return c.Filter
}

func (c *CreateInputPodFilter) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputInputEdgePrometheus struct {
	// Unique ID for this input
	ID       string                        `json:"id"`
	Type     CreateInputTypeEdgePrometheus `json:"type"`
	Disabled *bool                         `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType CreateInputDiscoveryTypeEdgePrometheus `json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval float64 `json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64                     `json:"timeout,omitempty"`
	Persistence *components.DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *CreateInputAuthenticationMethodEdgePrometheus `json:"authType,omitempty"`
	Description *string                                        `json:"description,omitempty"`
	Targets     []CreateInputTarget                            `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `json:"recordType,omitempty"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `json:"scrapePort,omitempty"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *components.ProtocolOptionsTargetsItems `json:"scrapeProtocol,omitempty"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `json:"scrapePath,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `json:"usePublicIp,omitempty"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `json:"scrapeProtocolExpr,omitempty"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `json:"scrapePortExpr,omitempty"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `json:"scrapePathExpr,omitempty"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []CreateInputPodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
}

func (c CreateInputInputEdgePrometheus) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputEdgePrometheus) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputEdgePrometheus) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputEdgePrometheus) GetType() CreateInputTypeEdgePrometheus {
	if c == nil {
		return CreateInputTypeEdgePrometheus("")
	}
	return c.Type
}

func (c *CreateInputInputEdgePrometheus) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputEdgePrometheus) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputEdgePrometheus) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputEdgePrometheus) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputEdgePrometheus) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputEdgePrometheus) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputEdgePrometheus) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputEdgePrometheus) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputEdgePrometheus) GetDimensionList() []string {
	if c == nil {
		return nil
	}
	return c.DimensionList
}

func (c *CreateInputInputEdgePrometheus) GetDiscoveryType() CreateInputDiscoveryTypeEdgePrometheus {
	if c == nil {
		return CreateInputDiscoveryTypeEdgePrometheus("")
	}
	return c.DiscoveryType
}

func (c *CreateInputInputEdgePrometheus) GetInterval() float64 {
	if c == nil {
		return 0.0
	}
	return c.Interval
}

func (c *CreateInputInputEdgePrometheus) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputInputEdgePrometheus) GetPersistence() *components.DiskSpoolingType {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputInputEdgePrometheus) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputEdgePrometheus) GetAuthType() *CreateInputAuthenticationMethodEdgePrometheus {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputEdgePrometheus) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputEdgePrometheus) GetTargets() []CreateInputTarget {
	if c == nil {
		return nil
	}
	return c.Targets
}

func (c *CreateInputInputEdgePrometheus) GetRecordType() *components.RecordTypeOptions {
	if c == nil {
		return nil
	}
	return c.RecordType
}

func (c *CreateInputInputEdgePrometheus) GetScrapePort() *float64 {
	if c == nil {
		return nil
	}
	return c.ScrapePort
}

func (c *CreateInputInputEdgePrometheus) GetNameList() []string {
	if c == nil {
		return nil
	}
	return c.NameList
}

func (c *CreateInputInputEdgePrometheus) GetScrapeProtocol() *components.ProtocolOptionsTargetsItems {
	if c == nil {
		return nil
	}
	return c.ScrapeProtocol
}

func (c *CreateInputInputEdgePrometheus) GetScrapePath() *string {
	if c == nil {
		return nil
	}
	return c.ScrapePath
}

func (c *CreateInputInputEdgePrometheus) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputEdgePrometheus) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputEdgePrometheus) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputEdgePrometheus) GetUsePublicIP() *bool {
	if c == nil {
		return nil
	}
	return c.UsePublicIP
}

func (c *CreateInputInputEdgePrometheus) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if c == nil {
		return nil
	}
	return c.SearchFilter
}

func (c *CreateInputInputEdgePrometheus) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputEdgePrometheus) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputInputEdgePrometheus) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputEdgePrometheus) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputEdgePrometheus) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputEdgePrometheus) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputEdgePrometheus) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputEdgePrometheus) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputEdgePrometheus) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputEdgePrometheus) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputEdgePrometheus) GetScrapeProtocolExpr() *string {
	if c == nil {
		return nil
	}
	return c.ScrapeProtocolExpr
}

func (c *CreateInputInputEdgePrometheus) GetScrapePortExpr() *string {
	if c == nil {
		return nil
	}
	return c.ScrapePortExpr
}

func (c *CreateInputInputEdgePrometheus) GetScrapePathExpr() *string {
	if c == nil {
		return nil
	}
	return c.ScrapePathExpr
}

func (c *CreateInputInputEdgePrometheus) GetPodFilter() []CreateInputPodFilter {
	if c == nil {
		return nil
	}
	return c.PodFilter
}

func (c *CreateInputInputEdgePrometheus) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputInputEdgePrometheus) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputInputEdgePrometheus) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputInputEdgePrometheus) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

func (c *CreateInputInputEdgePrometheus) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputEdgePrometheus) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputEdgePrometheus) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputEdgePrometheus) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

type CreateInputTypePrometheus string

const (
	CreateInputTypePrometheusPrometheus CreateInputTypePrometheus = "prometheus"
)

func (e CreateInputTypePrometheus) ToPointer() *CreateInputTypePrometheus {
	return &e
}
func (e *CreateInputTypePrometheus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prometheus":
		*e = CreateInputTypePrometheus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypePrometheus: %v", v)
	}
}

// CreateInputDiscoveryTypePrometheus - Target discovery mechanism. Use static to manually enter a list of targets.
type CreateInputDiscoveryTypePrometheus string

const (
	// CreateInputDiscoveryTypePrometheusStatic Static
	CreateInputDiscoveryTypePrometheusStatic CreateInputDiscoveryTypePrometheus = "static"
	// CreateInputDiscoveryTypePrometheusDNS DNS
	CreateInputDiscoveryTypePrometheusDNS CreateInputDiscoveryTypePrometheus = "dns"
	// CreateInputDiscoveryTypePrometheusEc2 AWS EC2
	CreateInputDiscoveryTypePrometheusEc2 CreateInputDiscoveryTypePrometheus = "ec2"
)

func (e CreateInputDiscoveryTypePrometheus) ToPointer() *CreateInputDiscoveryTypePrometheus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputDiscoveryTypePrometheus) IsExact() bool {
	if e != nil {
		switch *e {
		case "static", "dns", "ec2":
			return true
		}
	}
	return false
}

// CreateInputLogLevelPrometheus - Collector runtime log level
type CreateInputLogLevelPrometheus string

const (
	CreateInputLogLevelPrometheusError CreateInputLogLevelPrometheus = "error"
	CreateInputLogLevelPrometheusWarn  CreateInputLogLevelPrometheus = "warn"
	CreateInputLogLevelPrometheusInfo  CreateInputLogLevelPrometheus = "info"
	CreateInputLogLevelPrometheusDebug CreateInputLogLevelPrometheus = "debug"
)

func (e CreateInputLogLevelPrometheus) ToPointer() *CreateInputLogLevelPrometheus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputLogLevelPrometheus) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug":
			return true
		}
	}
	return false
}

// CreateInputMetricsProtocol - Protocol to use when collecting metrics
type CreateInputMetricsProtocol string

const (
	CreateInputMetricsProtocolHTTP  CreateInputMetricsProtocol = "http"
	CreateInputMetricsProtocolHTTPS CreateInputMetricsProtocol = "https"
)

func (e CreateInputMetricsProtocol) ToPointer() *CreateInputMetricsProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputMetricsProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "http", "https":
			return true
		}
	}
	return false
}

type CreateInputInputPrometheus struct {
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     CreateInputTypePrometheus `json:"type"`
	Disabled *bool                     `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *CreateInputDiscoveryTypePrometheus `json:"discoveryType,omitempty"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval float64 `json:"interval"`
	// Collector runtime log level
	LogLevel CreateInputLogLevelPrometheus `json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `json:"timeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptionsSasl `json:"authType,omitempty"`
	Description *string                                     `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `json:"recordType,omitempty"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `json:"scrapePort,omitempty"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *CreateInputMetricsProtocol `json:"scrapeProtocol,omitempty"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `json:"scrapePath,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `json:"usePublicIp,omitempty"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Binds 'logLevel' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'logLevel' at runtime.
	TemplateLogLevel *string `json:"__template_logLevel,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
}

func (c CreateInputInputPrometheus) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputPrometheus) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputPrometheus) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputPrometheus) GetType() CreateInputTypePrometheus {
	if c == nil {
		return CreateInputTypePrometheus("")
	}
	return c.Type
}

func (c *CreateInputInputPrometheus) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputPrometheus) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputPrometheus) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputPrometheus) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputPrometheus) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputPrometheus) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputPrometheus) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputPrometheus) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputPrometheus) GetDimensionList() []string {
	if c == nil {
		return nil
	}
	return c.DimensionList
}

func (c *CreateInputInputPrometheus) GetDiscoveryType() *CreateInputDiscoveryTypePrometheus {
	if c == nil {
		return nil
	}
	return c.DiscoveryType
}

func (c *CreateInputInputPrometheus) GetInterval() float64 {
	if c == nil {
		return 0.0
	}
	return c.Interval
}

func (c *CreateInputInputPrometheus) GetLogLevel() CreateInputLogLevelPrometheus {
	if c == nil {
		return CreateInputLogLevelPrometheus("")
	}
	return c.LogLevel
}

func (c *CreateInputInputPrometheus) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputPrometheus) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputInputPrometheus) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputInputPrometheus) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputInputPrometheus) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputInputPrometheus) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputInputPrometheus) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputInputPrometheus) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputPrometheus) GetAuthType() *components.AuthenticationMethodOptionsSasl {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputPrometheus) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputPrometheus) GetTargetList() []string {
	if c == nil {
		return nil
	}
	return c.TargetList
}

func (c *CreateInputInputPrometheus) GetRecordType() *components.RecordTypeOptions {
	if c == nil {
		return nil
	}
	return c.RecordType
}

func (c *CreateInputInputPrometheus) GetScrapePort() *float64 {
	if c == nil {
		return nil
	}
	return c.ScrapePort
}

func (c *CreateInputInputPrometheus) GetNameList() []string {
	if c == nil {
		return nil
	}
	return c.NameList
}

func (c *CreateInputInputPrometheus) GetScrapeProtocol() *CreateInputMetricsProtocol {
	if c == nil {
		return nil
	}
	return c.ScrapeProtocol
}

func (c *CreateInputInputPrometheus) GetScrapePath() *string {
	if c == nil {
		return nil
	}
	return c.ScrapePath
}

func (c *CreateInputInputPrometheus) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputPrometheus) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputPrometheus) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputPrometheus) GetUsePublicIP() *bool {
	if c == nil {
		return nil
	}
	return c.UsePublicIP
}

func (c *CreateInputInputPrometheus) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if c == nil {
		return nil
	}
	return c.SearchFilter
}

func (c *CreateInputInputPrometheus) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputPrometheus) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputInputPrometheus) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputPrometheus) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputPrometheus) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputPrometheus) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputPrometheus) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputPrometheus) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputPrometheus) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputPrometheus) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputInputPrometheus) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputInputPrometheus) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputInputPrometheus) GetTemplateLogLevel() *string {
	if c == nil {
		return nil
	}
	return c.TemplateLogLevel
}

func (c *CreateInputInputPrometheus) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

func (c *CreateInputInputPrometheus) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputPrometheus) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputPrometheus) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputPrometheus) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

type CreateInputTypePrometheusRw string

const (
	CreateInputTypePrometheusRwPrometheusRw CreateInputTypePrometheusRw = "prometheus_rw"
)

func (e CreateInputTypePrometheusRw) ToPointer() *CreateInputTypePrometheusRw {
	return &e
}
func (e *CreateInputTypePrometheusRw) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prometheus_rw":
		*e = CreateInputTypePrometheusRw(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypePrometheusRw: %v", v)
	}
}

type CreateInputInputPrometheusRw struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputTypePrometheusRw `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
	PrometheusAPI string `json:"prometheusAPI"`
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `json:"authType,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	Username    *string                        `json:"username,omitempty"`
	Password    *string                        `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'prometheusAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'prometheusAPI' at runtime.
	TemplatePrometheusAPI *string `json:"__template_prometheusAPI,omitempty"`
}

func (c CreateInputInputPrometheusRw) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputPrometheusRw) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputPrometheusRw) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputPrometheusRw) GetType() CreateInputTypePrometheusRw {
	if c == nil {
		return CreateInputTypePrometheusRw("")
	}
	return c.Type
}

func (c *CreateInputInputPrometheusRw) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputPrometheusRw) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputPrometheusRw) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputPrometheusRw) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputPrometheusRw) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputPrometheusRw) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputPrometheusRw) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputPrometheusRw) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputPrometheusRw) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputPrometheusRw) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputPrometheusRw) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputPrometheusRw) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputPrometheusRw) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputPrometheusRw) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputPrometheusRw) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputPrometheusRw) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputPrometheusRw) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputPrometheusRw) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputPrometheusRw) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputPrometheusRw) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputPrometheusRw) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputPrometheusRw) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputPrometheusRw) GetPrometheusAPI() string {
	if c == nil {
		return ""
	}
	return c.PrometheusAPI
}

func (c *CreateInputInputPrometheusRw) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputPrometheusRw) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputPrometheusRw) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputPrometheusRw) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputInputPrometheusRw) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputInputPrometheusRw) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputInputPrometheusRw) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputInputPrometheusRw) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputPrometheusRw) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputPrometheusRw) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputInputPrometheusRw) GetTemplatePrometheusAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePrometheusAPI
}

type CreateInputTypeLoki string

const (
	CreateInputTypeLokiLoki CreateInputTypeLoki = "loki"
)

func (e CreateInputTypeLoki) ToPointer() *CreateInputTypeLoki {
	return &e
}
func (e *CreateInputTypeLoki) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "loki":
		*e = CreateInputTypeLoki(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeLoki: %v", v)
	}
}

type CreateInputInputLoki struct {
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     CreateInputTypeLoki `json:"type"`
	Disabled *bool               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
	LokiAPI string `json:"lokiAPI"`
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `json:"authType,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	Username    *string                        `json:"username,omitempty"`
	Password    *string                        `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputLoki) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputLoki) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputLoki) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputLoki) GetType() CreateInputTypeLoki {
	if c == nil {
		return CreateInputTypeLoki("")
	}
	return c.Type
}

func (c *CreateInputInputLoki) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputLoki) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputLoki) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputLoki) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputLoki) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputLoki) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputLoki) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputLoki) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputLoki) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputLoki) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputLoki) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputLoki) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputLoki) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputLoki) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputLoki) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputLoki) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputLoki) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputLoki) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputLoki) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputLoki) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputLoki) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputLoki) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputLoki) GetLokiAPI() string {
	if c == nil {
		return ""
	}
	return c.LokiAPI
}

func (c *CreateInputInputLoki) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputLoki) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputLoki) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputLoki) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputInputLoki) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputInputLoki) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputInputLoki) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputInputLoki) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputLoki) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputLoki) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputInputGrafanaType2 string

const (
	CreateInputInputGrafanaType2Grafana CreateInputInputGrafanaType2 = "grafana"
)

func (e CreateInputInputGrafanaType2) ToPointer() *CreateInputInputGrafanaType2 {
	return &e
}
func (e *CreateInputInputGrafanaType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = CreateInputInputGrafanaType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputInputGrafanaType2: %v", v)
	}
}

type CreateInputPrometheusAuth2 struct {
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `json:"authType,omitempty"`
	Username *string                                             `json:"username,omitempty"`
	Password *string                                             `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputPrometheusAuth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputPrometheusAuth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputPrometheusAuth2) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputPrometheusAuth2) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputPrometheusAuth2) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputPrometheusAuth2) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputPrometheusAuth2) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputPrometheusAuth2) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputLokiAuth2 struct {
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `json:"authType,omitempty"`
	Username *string                                       `json:"username,omitempty"`
	Password *string                                       `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputLokiAuth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputLokiAuth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputLokiAuth2) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputLokiAuth2) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputLokiAuth2) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputLokiAuth2) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputLokiAuth2) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputLokiAuth2) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputInputGrafanaGrafana2 struct {
	// Unique ID for this input
	ID       string                       `json:"id"`
	Type     CreateInputInputGrafanaType2 `json:"type"`
	Disabled *bool                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
	PrometheusAPI *string `json:"prometheusAPI,omitempty"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
	LokiAPI        string                      `json:"lokiAPI"`
	PrometheusAuth *CreateInputPrometheusAuth2 `json:"prometheusAuth,omitempty"`
	LokiAuth       *CreateInputLokiAuth2       `json:"lokiAuth,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputGrafanaGrafana2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputGrafanaGrafana2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputGrafanaGrafana2) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputGrafanaGrafana2) GetType() CreateInputInputGrafanaType2 {
	if c == nil {
		return CreateInputInputGrafanaType2("")
	}
	return c.Type
}

func (c *CreateInputInputGrafanaGrafana2) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputGrafanaGrafana2) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputGrafanaGrafana2) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputGrafanaGrafana2) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputGrafanaGrafana2) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputGrafanaGrafana2) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputGrafanaGrafana2) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputGrafanaGrafana2) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputGrafanaGrafana2) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputGrafanaGrafana2) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputGrafanaGrafana2) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputGrafanaGrafana2) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputGrafanaGrafana2) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputGrafanaGrafana2) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputGrafanaGrafana2) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputGrafanaGrafana2) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputGrafanaGrafana2) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputGrafanaGrafana2) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputGrafanaGrafana2) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputGrafanaGrafana2) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputGrafanaGrafana2) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputGrafanaGrafana2) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputGrafanaGrafana2) GetPrometheusAPI() *string {
	if c == nil {
		return nil
	}
	return c.PrometheusAPI
}

func (c *CreateInputInputGrafanaGrafana2) GetLokiAPI() string {
	if c == nil {
		return ""
	}
	return c.LokiAPI
}

func (c *CreateInputInputGrafanaGrafana2) GetPrometheusAuth() *CreateInputPrometheusAuth2 {
	if c == nil {
		return nil
	}
	return c.PrometheusAuth
}

func (c *CreateInputInputGrafanaGrafana2) GetLokiAuth() *CreateInputLokiAuth2 {
	if c == nil {
		return nil
	}
	return c.LokiAuth
}

func (c *CreateInputInputGrafanaGrafana2) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputGrafanaGrafana2) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputGrafanaGrafana2) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputGrafanaGrafana2) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputInputGrafanaType1 string

const (
	CreateInputInputGrafanaType1Grafana CreateInputInputGrafanaType1 = "grafana"
)

func (e CreateInputInputGrafanaType1) ToPointer() *CreateInputInputGrafanaType1 {
	return &e
}
func (e *CreateInputInputGrafanaType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = CreateInputInputGrafanaType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputInputGrafanaType1: %v", v)
	}
}

type CreateInputPrometheusAuth1 struct {
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `json:"authType,omitempty"`
	Username *string                                             `json:"username,omitempty"`
	Password *string                                             `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputPrometheusAuth1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputPrometheusAuth1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputPrometheusAuth1) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputPrometheusAuth1) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputPrometheusAuth1) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputPrometheusAuth1) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputPrometheusAuth1) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputPrometheusAuth1) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputLokiAuth1 struct {
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `json:"authType,omitempty"`
	Username *string                                       `json:"username,omitempty"`
	Password *string                                       `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputLokiAuth1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputLokiAuth1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputLokiAuth1) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputLokiAuth1) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputLokiAuth1) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputLokiAuth1) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputLokiAuth1) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputLokiAuth1) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputInputGrafanaGrafana1 struct {
	// Unique ID for this input
	ID       string                       `json:"id"`
	Type     CreateInputInputGrafanaType1 `json:"type"`
	Disabled *bool                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
	PrometheusAPI string `json:"prometheusAPI"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
	LokiAPI        *string                     `json:"lokiAPI,omitempty"`
	PrometheusAuth *CreateInputPrometheusAuth1 `json:"prometheusAuth,omitempty"`
	LokiAuth       *CreateInputLokiAuth1       `json:"lokiAuth,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputGrafanaGrafana1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputGrafanaGrafana1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputGrafanaGrafana1) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputGrafanaGrafana1) GetType() CreateInputInputGrafanaType1 {
	if c == nil {
		return CreateInputInputGrafanaType1("")
	}
	return c.Type
}

func (c *CreateInputInputGrafanaGrafana1) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputGrafanaGrafana1) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputGrafanaGrafana1) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputGrafanaGrafana1) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputGrafanaGrafana1) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputGrafanaGrafana1) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputGrafanaGrafana1) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputGrafanaGrafana1) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputGrafanaGrafana1) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputGrafanaGrafana1) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputGrafanaGrafana1) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputGrafanaGrafana1) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputGrafanaGrafana1) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputGrafanaGrafana1) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputGrafanaGrafana1) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputGrafanaGrafana1) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputGrafanaGrafana1) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputGrafanaGrafana1) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputGrafanaGrafana1) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputGrafanaGrafana1) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputGrafanaGrafana1) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputGrafanaGrafana1) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputGrafanaGrafana1) GetPrometheusAPI() string {
	if c == nil {
		return ""
	}
	return c.PrometheusAPI
}

func (c *CreateInputInputGrafanaGrafana1) GetLokiAPI() *string {
	if c == nil {
		return nil
	}
	return c.LokiAPI
}

func (c *CreateInputInputGrafanaGrafana1) GetPrometheusAuth() *CreateInputPrometheusAuth1 {
	if c == nil {
		return nil
	}
	return c.PrometheusAuth
}

func (c *CreateInputInputGrafanaGrafana1) GetLokiAuth() *CreateInputLokiAuth1 {
	if c == nil {
		return nil
	}
	return c.LokiAuth
}

func (c *CreateInputInputGrafanaGrafana1) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputGrafanaGrafana1) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputGrafanaGrafana1) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputGrafanaGrafana1) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputInputGrafanaUnionType string

const (
	CreateInputInputGrafanaUnionTypeCreateInputInputGrafanaGrafana1 CreateInputInputGrafanaUnionType = "createInput_InputGrafana_Grafana_1"
	CreateInputInputGrafanaUnionTypeCreateInputInputGrafanaGrafana2 CreateInputInputGrafanaUnionType = "createInput_InputGrafana_Grafana_2"
)

type CreateInputInputGrafanaUnion struct {
	CreateInputInputGrafanaGrafana1 *CreateInputInputGrafanaGrafana1 `queryParam:"inline" union:"member"`
	CreateInputInputGrafanaGrafana2 *CreateInputInputGrafanaGrafana2 `queryParam:"inline" union:"member"`

	Type CreateInputInputGrafanaUnionType
}

func CreateCreateInputInputGrafanaUnionCreateInputInputGrafanaGrafana1(createInputInputGrafanaGrafana1 CreateInputInputGrafanaGrafana1) CreateInputInputGrafanaUnion {
	typ := CreateInputInputGrafanaUnionTypeCreateInputInputGrafanaGrafana1

	return CreateInputInputGrafanaUnion{
		CreateInputInputGrafanaGrafana1: &createInputInputGrafanaGrafana1,
		Type:                            typ,
	}
}

func CreateCreateInputInputGrafanaUnionCreateInputInputGrafanaGrafana2(createInputInputGrafanaGrafana2 CreateInputInputGrafanaGrafana2) CreateInputInputGrafanaUnion {
	typ := CreateInputInputGrafanaUnionTypeCreateInputInputGrafanaGrafana2

	return CreateInputInputGrafanaUnion{
		CreateInputInputGrafanaGrafana2: &createInputInputGrafanaGrafana2,
		Type:                            typ,
	}
}

func (u *CreateInputInputGrafanaUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var createInputInputGrafanaGrafana1 CreateInputInputGrafanaGrafana1 = CreateInputInputGrafanaGrafana1{}
	if err := utils.UnmarshalJSON(data, &createInputInputGrafanaGrafana1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CreateInputInputGrafanaUnionTypeCreateInputInputGrafanaGrafana1,
			Value: &createInputInputGrafanaGrafana1,
		})
	}

	var createInputInputGrafanaGrafana2 CreateInputInputGrafanaGrafana2 = CreateInputInputGrafanaGrafana2{}
	if err := utils.UnmarshalJSON(data, &createInputInputGrafanaGrafana2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CreateInputInputGrafanaUnionTypeCreateInputInputGrafanaGrafana2,
			Value: &createInputInputGrafanaGrafana2,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputInputGrafanaUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputInputGrafanaUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(CreateInputInputGrafanaUnionType)
	switch best.Type {
	case CreateInputInputGrafanaUnionTypeCreateInputInputGrafanaGrafana1:
		u.CreateInputInputGrafanaGrafana1 = best.Value.(*CreateInputInputGrafanaGrafana1)
		return nil
	case CreateInputInputGrafanaUnionTypeCreateInputInputGrafanaGrafana2:
		u.CreateInputInputGrafanaGrafana2 = best.Value.(*CreateInputInputGrafanaGrafana2)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputInputGrafanaUnion", string(data))
}

func (u CreateInputInputGrafanaUnion) MarshalJSON() ([]byte, error) {
	if u.CreateInputInputGrafanaGrafana1 != nil {
		return utils.MarshalJSON(u.CreateInputInputGrafanaGrafana1, "", true)
	}

	if u.CreateInputInputGrafanaGrafana2 != nil {
		return utils.MarshalJSON(u.CreateInputInputGrafanaGrafana2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateInputInputGrafanaUnion: all fields are null")
}

type CreateInputTypeConfluentCloud string

const (
	CreateInputTypeConfluentCloudConfluentCloud CreateInputTypeConfluentCloud = "confluent_cloud"
)

func (e CreateInputTypeConfluentCloud) ToPointer() *CreateInputTypeConfluentCloud {
	return &e
}
func (e *CreateInputTypeConfluentCloud) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "confluent_cloud":
		*e = CreateInputTypeConfluentCloud(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeConfluentCloud: %v", v)
	}
}

type CreateInputInputConfluentCloud struct {
	// Unique ID for this input
	ID       string                        `json:"id"`
	Type     CreateInputTypeConfluentCloud `json:"type"`
	Disabled *bool                         `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
	Brokers []string                                                 `json:"brokers"`
	TLS     *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `json:"fromBeginning,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `json:"maxRetries,omitempty"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `json:"maxBackOff,omitempty"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `json:"initialBackoff,omitempty"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `json:"backoffRate,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `json:"authenticationTimeout,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `json:"reauthenticationThreshold,omitempty"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType `json:"sasl,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `json:"sessionTimeout,omitempty"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `json:"rebalanceTimeout,omitempty"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `json:"heartbeatInterval,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `json:"maxBytesPerPartition,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `json:"maxBytes,omitempty"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `json:"maxSocketErrors,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
}

func (c CreateInputInputConfluentCloud) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputConfluentCloud) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputConfluentCloud) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputConfluentCloud) GetType() CreateInputTypeConfluentCloud {
	if c == nil {
		return CreateInputTypeConfluentCloud("")
	}
	return c.Type
}

func (c *CreateInputInputConfluentCloud) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputConfluentCloud) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputConfluentCloud) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputConfluentCloud) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputConfluentCloud) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputConfluentCloud) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputConfluentCloud) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputConfluentCloud) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputConfluentCloud) GetBrokers() []string {
	if c == nil {
		return []string{}
	}
	return c.Brokers
}

func (c *CreateInputInputConfluentCloud) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputConfluentCloud) GetTopics() []string {
	if c == nil {
		return []string{}
	}
	return c.Topics
}

func (c *CreateInputInputConfluentCloud) GetGroupID() *string {
	if c == nil {
		return nil
	}
	return c.GroupID
}

func (c *CreateInputInputConfluentCloud) GetFromBeginning() *bool {
	if c == nil {
		return nil
	}
	return c.FromBeginning
}

func (c *CreateInputInputConfluentCloud) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if c == nil {
		return nil
	}
	return c.KafkaSchemaRegistry
}

func (c *CreateInputInputConfluentCloud) GetConnectionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ConnectionTimeout
}

func (c *CreateInputInputConfluentCloud) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputConfluentCloud) GetMaxRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRetries
}

func (c *CreateInputInputConfluentCloud) GetMaxBackOff() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBackOff
}

func (c *CreateInputInputConfluentCloud) GetInitialBackoff() *float64 {
	if c == nil {
		return nil
	}
	return c.InitialBackoff
}

func (c *CreateInputInputConfluentCloud) GetBackoffRate() *float64 {
	if c == nil {
		return nil
	}
	return c.BackoffRate
}

func (c *CreateInputInputConfluentCloud) GetAuthenticationTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.AuthenticationTimeout
}

func (c *CreateInputInputConfluentCloud) GetReauthenticationThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.ReauthenticationThreshold
}

func (c *CreateInputInputConfluentCloud) GetSasl() *components.AuthenticationType {
	if c == nil {
		return nil
	}
	return c.Sasl
}

func (c *CreateInputInputConfluentCloud) GetSessionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SessionTimeout
}

func (c *CreateInputInputConfluentCloud) GetRebalanceTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RebalanceTimeout
}

func (c *CreateInputInputConfluentCloud) GetHeartbeatInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.HeartbeatInterval
}

func (c *CreateInputInputConfluentCloud) GetAutoCommitInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitInterval
}

func (c *CreateInputInputConfluentCloud) GetAutoCommitThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitThreshold
}

func (c *CreateInputInputConfluentCloud) GetMaxBytesPerPartition() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytesPerPartition
}

func (c *CreateInputInputConfluentCloud) GetMaxBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytes
}

func (c *CreateInputInputConfluentCloud) GetMaxSocketErrors() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxSocketErrors
}

func (c *CreateInputInputConfluentCloud) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputConfluentCloud) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeElastic string

const (
	CreateInputTypeElasticElastic CreateInputTypeElastic = "elastic"
)

func (e CreateInputTypeElastic) ToPointer() *CreateInputTypeElastic {
	return &e
}
func (e *CreateInputTypeElastic) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "elastic":
		*e = CreateInputTypeElastic(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeElastic: %v", v)
	}
}

type CreateInputAuthenticationTypeElastic string

const (
	// CreateInputAuthenticationTypeElasticNone None
	CreateInputAuthenticationTypeElasticNone CreateInputAuthenticationTypeElastic = "none"
	// CreateInputAuthenticationTypeElasticBasic Basic
	CreateInputAuthenticationTypeElasticBasic CreateInputAuthenticationTypeElastic = "basic"
	// CreateInputAuthenticationTypeElasticCredentialsSecret Basic (credentials secret)
	CreateInputAuthenticationTypeElasticCredentialsSecret CreateInputAuthenticationTypeElastic = "credentialsSecret"
	// CreateInputAuthenticationTypeElasticAuthTokens Auth Tokens
	CreateInputAuthenticationTypeElasticAuthTokens CreateInputAuthenticationTypeElastic = "authTokens"
)

func (e CreateInputAuthenticationTypeElastic) ToPointer() *CreateInputAuthenticationTypeElastic {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputAuthenticationTypeElastic) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "credentialsSecret", "authTokens":
			return true
		}
	}
	return false
}

// CreateInputAPIVersion - The API version to use for communicating with the server
type CreateInputAPIVersion string

const (
	// CreateInputAPIVersionSixDot8Dot4 6.8.4
	CreateInputAPIVersionSixDot8Dot4 CreateInputAPIVersion = "6.8.4"
	// CreateInputAPIVersionEightDot3Dot2 8.3.2
	CreateInputAPIVersionEightDot3Dot2 CreateInputAPIVersion = "8.3.2"
	// CreateInputAPIVersionCustom Custom
	CreateInputAPIVersionCustom CreateInputAPIVersion = "custom"
)

func (e CreateInputAPIVersion) ToPointer() *CreateInputAPIVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputAPIVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "6.8.4", "8.3.2", "custom":
			return true
		}
	}
	return false
}

// CreateInputProxyModeAuthenticationMethod - Enter credentials directly, or select a stored secret
type CreateInputProxyModeAuthenticationMethod string

const (
	CreateInputProxyModeAuthenticationMethodNone   CreateInputProxyModeAuthenticationMethod = "none"
	CreateInputProxyModeAuthenticationMethodManual CreateInputProxyModeAuthenticationMethod = "manual"
	CreateInputProxyModeAuthenticationMethodSecret CreateInputProxyModeAuthenticationMethod = "secret"
)

func (e CreateInputProxyModeAuthenticationMethod) ToPointer() *CreateInputProxyModeAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputProxyModeAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "manual", "secret":
			return true
		}
	}
	return false
}

type CreateInputProxyModeElastic struct {
	// Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details.
	Enabled bool `json:"enabled"`
	// Enter credentials directly, or select a stored secret
	AuthType *CreateInputProxyModeAuthenticationMethod `json:"authType,omitempty"`
	Username *string                                   `json:"username,omitempty"`
	Password *string                                   `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200
	URL *string `json:"url,omitempty"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// List of headers to remove from the request to proxy
	RemoveHeaders []string `json:"removeHeaders,omitempty"`
	// Amount of time, in seconds, to wait for a proxy request to complete before canceling it
	TimeoutSec *float64 `json:"timeoutSec,omitempty"`
	// Binds 'url' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'url' at runtime.
	TemplateURL *string `json:"__template_url,omitempty"`
}

func (c CreateInputProxyModeElastic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputProxyModeElastic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputProxyModeElastic) GetEnabled() bool {
	if c == nil {
		return false
	}
	return c.Enabled
}

func (c *CreateInputProxyModeElastic) GetAuthType() *CreateInputProxyModeAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputProxyModeElastic) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputProxyModeElastic) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputProxyModeElastic) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputProxyModeElastic) GetURL() *string {
	if c == nil {
		return nil
	}
	return c.URL
}

func (c *CreateInputProxyModeElastic) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputProxyModeElastic) GetRemoveHeaders() []string {
	if c == nil {
		return nil
	}
	return c.RemoveHeaders
}

func (c *CreateInputProxyModeElastic) GetTimeoutSec() *float64 {
	if c == nil {
		return nil
	}
	return c.TimeoutSec
}

func (c *CreateInputProxyModeElastic) GetTemplateURL() *string {
	if c == nil {
		return nil
	}
	return c.TemplateURL
}

type CreateInputInputElastic struct {
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     CreateInputTypeElastic `json:"type"`
	Disabled *bool                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
	ElasticAPI string                                `json:"elasticAPI"`
	AuthType   *CreateInputAuthenticationTypeElastic `json:"authType,omitempty"`
	// The API version to use for communicating with the server
	APIVersion *CreateInputAPIVersion `json:"apiVersion,omitempty"`
	// Headers to add to all events
	ExtraHTTPHeaders []components.ItemsTypeExtraHTTPHeaders `json:"extraHttpHeaders,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	ProxyMode   *CreateInputProxyModeElastic   `json:"proxyMode,omitempty"`
	Description *string                        `json:"description,omitempty"`
	Username    *string                        `json:"username,omitempty"`
	Password    *string                        `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Bearer tokens to include in the authorization header
	AuthTokens []string `json:"authTokens,omitempty"`
	// Custom version information to respond to requests
	CustomAPIVersion *string `json:"customAPIVersion,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputElastic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputElastic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputElastic) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputElastic) GetType() CreateInputTypeElastic {
	if c == nil {
		return CreateInputTypeElastic("")
	}
	return c.Type
}

func (c *CreateInputInputElastic) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputElastic) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputElastic) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputElastic) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputElastic) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputElastic) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputElastic) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputElastic) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputElastic) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputElastic) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputElastic) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputElastic) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputElastic) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputElastic) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputElastic) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputElastic) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputElastic) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputElastic) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputElastic) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputElastic) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputElastic) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputElastic) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputElastic) GetElasticAPI() string {
	if c == nil {
		return ""
	}
	return c.ElasticAPI
}

func (c *CreateInputInputElastic) GetAuthType() *CreateInputAuthenticationTypeElastic {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputElastic) GetAPIVersion() *CreateInputAPIVersion {
	if c == nil {
		return nil
	}
	return c.APIVersion
}

func (c *CreateInputInputElastic) GetExtraHTTPHeaders() []components.ItemsTypeExtraHTTPHeaders {
	if c == nil {
		return nil
	}
	return c.ExtraHTTPHeaders
}

func (c *CreateInputInputElastic) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputElastic) GetProxyMode() *CreateInputProxyModeElastic {
	if c == nil {
		return nil
	}
	return c.ProxyMode
}

func (c *CreateInputInputElastic) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputElastic) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputInputElastic) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputInputElastic) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputInputElastic) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputElastic) GetCustomAPIVersion() *string {
	if c == nil {
		return nil
	}
	return c.CustomAPIVersion
}

func (c *CreateInputInputElastic) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputElastic) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeAzureBlob string

const (
	CreateInputTypeAzureBlobAzureBlob CreateInputTypeAzureBlob = "azure_blob"
)

func (e CreateInputTypeAzureBlob) ToPointer() *CreateInputTypeAzureBlob {
	return &e
}
func (e *CreateInputTypeAzureBlob) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azure_blob":
		*e = CreateInputTypeAzureBlob(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeAzureBlob: %v", v)
	}
}

type CreateInputInputAzureBlob struct {
	// Unique ID for this input
	ID       string                   `json:"id"`
	Type     CreateInputTypeAzureBlob `json:"type"`
	Disabled *bool                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// The duration (in seconds) which pollers should be validated and restarted if exited
	ServicePeriodSecs *float64 `json:"servicePeriodSecs,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                                `json:"parquetChunkDownloadTimeout,omitempty"`
	AuthType                    *components.AuthenticationMethodOptions `json:"authType,omitempty"`
	Description                 *string                                 `json:"description,omitempty"`
	// Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// The name of your Azure storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`
	// The service principal's tenant ID
	TenantID *string `json:"tenantId,omitempty"`
	// The service principal's client ID
	ClientID *string `json:"clientId,omitempty"`
	// The Azure cloud to use. Defaults to Azure Public Cloud.
	AzureCloud *string `json:"azureCloud,omitempty"`
	// Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
	EndpointSuffix *string `json:"endpointSuffix,omitempty"`
	// Select or create a stored text secret
	ClientTextSecret *string                                                `json:"clientTextSecret,omitempty"`
	Certificate      *components.CertificateTypeAzureBlobAuthTypeClientCert `json:"certificate,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'connectionString' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'connectionString' at runtime.
	TemplateConnectionString *string `json:"__template_connectionString,omitempty"`
	// Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime.
	TemplateTenantID *string `json:"__template_tenantId,omitempty"`
	// Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime.
	TemplateClientID *string `json:"__template_clientId,omitempty"`
}

func (c CreateInputInputAzureBlob) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputAzureBlob) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputAzureBlob) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputAzureBlob) GetType() CreateInputTypeAzureBlob {
	if c == nil {
		return CreateInputTypeAzureBlob("")
	}
	return c.Type
}

func (c *CreateInputInputAzureBlob) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputAzureBlob) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputAzureBlob) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputAzureBlob) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputAzureBlob) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputAzureBlob) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputAzureBlob) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputAzureBlob) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputAzureBlob) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputInputAzureBlob) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputInputAzureBlob) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputInputAzureBlob) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputInputAzureBlob) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputInputAzureBlob) GetServicePeriodSecs() *float64 {
	if c == nil {
		return nil
	}
	return c.ServicePeriodSecs
}

func (c *CreateInputInputAzureBlob) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputInputAzureBlob) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputAzureBlob) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputAzureBlob) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputAzureBlob) GetParquetChunkSizeMB() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkSizeMB
}

func (c *CreateInputInputAzureBlob) GetParquetChunkDownloadTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkDownloadTimeout
}

func (c *CreateInputInputAzureBlob) GetAuthType() *components.AuthenticationMethodOptions {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputAzureBlob) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputAzureBlob) GetConnectionString() *string {
	if c == nil {
		return nil
	}
	return c.ConnectionString
}

func (c *CreateInputInputAzureBlob) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputAzureBlob) GetStorageAccountName() *string {
	if c == nil {
		return nil
	}
	return c.StorageAccountName
}

func (c *CreateInputInputAzureBlob) GetTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TenantID
}

func (c *CreateInputInputAzureBlob) GetClientID() *string {
	if c == nil {
		return nil
	}
	return c.ClientID
}

func (c *CreateInputInputAzureBlob) GetAzureCloud() *string {
	if c == nil {
		return nil
	}
	return c.AzureCloud
}

func (c *CreateInputInputAzureBlob) GetEndpointSuffix() *string {
	if c == nil {
		return nil
	}
	return c.EndpointSuffix
}

func (c *CreateInputInputAzureBlob) GetClientTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientTextSecret
}

func (c *CreateInputInputAzureBlob) GetCertificate() *components.CertificateTypeAzureBlobAuthTypeClientCert {
	if c == nil {
		return nil
	}
	return c.Certificate
}

func (c *CreateInputInputAzureBlob) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputInputAzureBlob) GetTemplateConnectionString() *string {
	if c == nil {
		return nil
	}
	return c.TemplateConnectionString
}

func (c *CreateInputInputAzureBlob) GetTemplateTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTenantID
}

func (c *CreateInputInputAzureBlob) GetTemplateClientID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientID
}

type CreateInputTypeSplunkHec string

const (
	CreateInputTypeSplunkHecSplunkHec CreateInputTypeSplunkHec = "splunk_hec"
)

func (e CreateInputTypeSplunkHec) ToPointer() *CreateInputTypeSplunkHec {
	return &e
}
func (e *CreateInputTypeSplunkHec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_hec":
		*e = CreateInputTypeSplunkHec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeSplunkHec: %v", v)
	}
}

type CreateInputAuthTokenSplunkHec struct {
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	// Shared secret to be provided by any client (Authorization: <token>)
	Token   string `json:"token"`
	Enabled *bool  `json:"enabled,omitempty"`
	// Optional token description
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
}

func (c CreateInputAuthTokenSplunkHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputAuthTokenSplunkHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputAuthTokenSplunkHec) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputAuthTokenSplunkHec) GetTokenSecret() *string {
	if c == nil {
		return nil
	}
	return c.TokenSecret
}

func (c *CreateInputAuthTokenSplunkHec) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CreateInputAuthTokenSplunkHec) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputAuthTokenSplunkHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputAuthTokenSplunkHec) GetAllowedIndexesAtToken() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexesAtToken
}

func (c *CreateInputAuthTokenSplunkHec) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

type CreateInputInputSplunkHec struct {
	// Unique ID for this input
	ID       string                   `json:"id"`
	Type     CreateInputTypeSplunkHec `json:"type"`
	Disabled *bool                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []CreateInputAuthTokenSplunkHec       `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `json:"keepAliveTimeout,omitempty"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
	SplunkHecAPI string `json:"splunkHecAPI"`
	// Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Enable Splunk HEC acknowledgements
	SplunkHecAcks *bool `json:"splunkHecAcks,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `json:"useFwdTimezone,omitempty"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `json:"dropControlFields,omitempty"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `json:"emitTokenMetrics,omitempty"`
	Description      *string `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime.
	TemplateSplunkHecAPI *string `json:"__template_splunkHecAPI,omitempty"`
}

func (c CreateInputInputSplunkHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSplunkHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSplunkHec) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSplunkHec) GetType() CreateInputTypeSplunkHec {
	if c == nil {
		return CreateInputTypeSplunkHec("")
	}
	return c.Type
}

func (c *CreateInputInputSplunkHec) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSplunkHec) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSplunkHec) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSplunkHec) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSplunkHec) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSplunkHec) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSplunkHec) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSplunkHec) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSplunkHec) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputSplunkHec) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputSplunkHec) GetAuthTokens() []CreateInputAuthTokenSplunkHec {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputSplunkHec) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputSplunkHec) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputSplunkHec) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputSplunkHec) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputSplunkHec) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputSplunkHec) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputSplunkHec) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputSplunkHec) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputSplunkHec) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputSplunkHec) GetEnableHealthCheck() any {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputSplunkHec) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputSplunkHec) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputSplunkHec) GetSplunkHecAPI() string {
	if c == nil {
		return ""
	}
	return c.SplunkHecAPI
}

func (c *CreateInputInputSplunkHec) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSplunkHec) GetAllowedIndexes() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexes
}

func (c *CreateInputInputSplunkHec) GetSplunkHecAcks() *bool {
	if c == nil {
		return nil
	}
	return c.SplunkHecAcks
}

func (c *CreateInputInputSplunkHec) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputSplunkHec) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputSplunkHec) GetUseFwdTimezone() *bool {
	if c == nil {
		return nil
	}
	return c.UseFwdTimezone
}

func (c *CreateInputInputSplunkHec) GetDropControlFields() *bool {
	if c == nil {
		return nil
	}
	return c.DropControlFields
}

func (c *CreateInputInputSplunkHec) GetExtractMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractMetrics
}

func (c *CreateInputInputSplunkHec) GetAccessControlAllowOrigin() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowOrigin
}

func (c *CreateInputInputSplunkHec) GetAccessControlAllowHeaders() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowHeaders
}

func (c *CreateInputInputSplunkHec) GetEmitTokenMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.EmitTokenMetrics
}

func (c *CreateInputInputSplunkHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputSplunkHec) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputSplunkHec) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputInputSplunkHec) GetTemplateSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplateSplunkHecAPI
}

type CreateInputTypeSplunkSearch string

const (
	CreateInputTypeSplunkSearchSplunkSearch CreateInputTypeSplunkSearch = "splunk_search"
)

func (e CreateInputTypeSplunkSearch) ToPointer() *CreateInputTypeSplunkSearch {
	return &e
}
func (e *CreateInputTypeSplunkSearch) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_search":
		*e = CreateInputTypeSplunkSearch(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeSplunkSearch: %v", v)
	}
}

type CreateInputEndpointParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (c CreateInputEndpointParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputEndpointParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputEndpointParam) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateInputEndpointParam) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

type CreateInputEndpointHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (c CreateInputEndpointHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputEndpointHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputEndpointHeader) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateInputEndpointHeader) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

// CreateInputLogLevelSplunkSearch - Collector runtime log level (verbosity)
type CreateInputLogLevelSplunkSearch string

const (
	CreateInputLogLevelSplunkSearchError CreateInputLogLevelSplunkSearch = "error"
	CreateInputLogLevelSplunkSearchWarn  CreateInputLogLevelSplunkSearch = "warn"
	CreateInputLogLevelSplunkSearchInfo  CreateInputLogLevelSplunkSearch = "info"
	CreateInputLogLevelSplunkSearchDebug CreateInputLogLevelSplunkSearch = "debug"
)

func (e CreateInputLogLevelSplunkSearch) ToPointer() *CreateInputLogLevelSplunkSearch {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputLogLevelSplunkSearch) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug":
			return true
		}
	}
	return false
}

// CreateInputAuthenticationTypeSplunkSearch - Splunk Search authentication type
type CreateInputAuthenticationTypeSplunkSearch string

const (
	// CreateInputAuthenticationTypeSplunkSearchNone None
	CreateInputAuthenticationTypeSplunkSearchNone CreateInputAuthenticationTypeSplunkSearch = "none"
	// CreateInputAuthenticationTypeSplunkSearchBasic Basic
	CreateInputAuthenticationTypeSplunkSearchBasic CreateInputAuthenticationTypeSplunkSearch = "basic"
	// CreateInputAuthenticationTypeSplunkSearchCredentialsSecret Basic (credentials secret)
	CreateInputAuthenticationTypeSplunkSearchCredentialsSecret CreateInputAuthenticationTypeSplunkSearch = "credentialsSecret"
	// CreateInputAuthenticationTypeSplunkSearchToken Token
	CreateInputAuthenticationTypeSplunkSearchToken CreateInputAuthenticationTypeSplunkSearch = "token"
	// CreateInputAuthenticationTypeSplunkSearchTextSecret Token (text secret)
	CreateInputAuthenticationTypeSplunkSearchTextSecret CreateInputAuthenticationTypeSplunkSearch = "textSecret"
)

func (e CreateInputAuthenticationTypeSplunkSearch) ToPointer() *CreateInputAuthenticationTypeSplunkSearch {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputAuthenticationTypeSplunkSearch) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "credentialsSecret", "token", "textSecret":
			return true
		}
	}
	return false
}

type CreateInputInputSplunkSearch struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputTypeSplunkSearch `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitempty"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitempty"`
	// A cron schedule on which to run this job
	CronSchedule string `json:"cronSchedule"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode components.OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional request parameters to send to the endpoint
	EndpointParams []CreateInputEndpointParam `json:"endpointParams,omitempty"`
	// Optional request headers to send to the endpoint
	EndpointHeaders []CreateInputEndpointHeader `json:"endpointHeaders,omitempty"`
	// Collector runtime log level (verbosity)
	LogLevel *CreateInputLogLevelSplunkSearch `json:"logLevel,omitempty"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitempty"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType     `json:"retryRules,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Splunk Search authentication type
	AuthType    *CreateInputAuthenticationTypeSplunkSearch `json:"authType,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputInputSplunkSearch) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSplunkSearch) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSplunkSearch) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSplunkSearch) GetType() CreateInputTypeSplunkSearch {
	if c == nil {
		return CreateInputTypeSplunkSearch("")
	}
	return c.Type
}

func (c *CreateInputInputSplunkSearch) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSplunkSearch) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSplunkSearch) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSplunkSearch) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSplunkSearch) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSplunkSearch) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSplunkSearch) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSplunkSearch) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSplunkSearch) GetSearchHead() string {
	if c == nil {
		return ""
	}
	return c.SearchHead
}

func (c *CreateInputInputSplunkSearch) GetSearch() string {
	if c == nil {
		return ""
	}
	return c.Search
}

func (c *CreateInputInputSplunkSearch) GetEarliest() *string {
	if c == nil {
		return nil
	}
	return c.Earliest
}

func (c *CreateInputInputSplunkSearch) GetLatest() *string {
	if c == nil {
		return nil
	}
	return c.Latest
}

func (c *CreateInputInputSplunkSearch) GetCronSchedule() string {
	if c == nil {
		return ""
	}
	return c.CronSchedule
}

func (c *CreateInputInputSplunkSearch) GetEndpoint() string {
	if c == nil {
		return ""
	}
	return c.Endpoint
}

func (c *CreateInputInputSplunkSearch) GetOutputMode() components.OutputModeOptionsSplunkCollectorConf {
	if c == nil {
		return components.OutputModeOptionsSplunkCollectorConf("")
	}
	return c.OutputMode
}

func (c *CreateInputInputSplunkSearch) GetEndpointParams() []CreateInputEndpointParam {
	if c == nil {
		return nil
	}
	return c.EndpointParams
}

func (c *CreateInputInputSplunkSearch) GetEndpointHeaders() []CreateInputEndpointHeader {
	if c == nil {
		return nil
	}
	return c.EndpointHeaders
}

func (c *CreateInputInputSplunkSearch) GetLogLevel() *CreateInputLogLevelSplunkSearch {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputInputSplunkSearch) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputSplunkSearch) GetUseRoundRobinDNS() *bool {
	if c == nil {
		return nil
	}
	return c.UseRoundRobinDNS
}

func (c *CreateInputInputSplunkSearch) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputSplunkSearch) GetEncoding() *string {
	if c == nil {
		return nil
	}
	return c.Encoding
}

func (c *CreateInputInputSplunkSearch) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputInputSplunkSearch) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputInputSplunkSearch) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputInputSplunkSearch) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputInputSplunkSearch) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputInputSplunkSearch) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSplunkSearch) GetRetryRules() *components.RetryRulesType {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputInputSplunkSearch) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputSplunkSearch) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputSplunkSearch) GetAuthType() *CreateInputAuthenticationTypeSplunkSearch {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputSplunkSearch) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputSplunkSearch) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputInputSplunkSearch) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputInputSplunkSearch) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputInputSplunkSearch) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputInputSplunkSearch) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputTypeSplunk string

const (
	CreateInputTypeSplunkSplunk CreateInputTypeSplunk = "splunk"
)

func (e CreateInputTypeSplunk) ToPointer() *CreateInputTypeSplunk {
	return &e
}
func (e *CreateInputTypeSplunk) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk":
		*e = CreateInputTypeSplunk(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeSplunk: %v", v)
	}
}

type CreateInputAuthTokenSplunk struct {
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	Token       string  `json:"token"`
	Description *string `json:"description,omitempty"`
}

func (c CreateInputAuthTokenSplunk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputAuthTokenSplunk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputAuthTokenSplunk) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CreateInputAuthTokenSplunk) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

// CreateInputMaxS2SVersion - The highest S2S protocol version to advertise during handshake
type CreateInputMaxS2SVersion string

const (
	// CreateInputMaxS2SVersionV3 v3
	CreateInputMaxS2SVersionV3 CreateInputMaxS2SVersion = "v3"
	// CreateInputMaxS2SVersionV4 v4
	CreateInputMaxS2SVersionV4 CreateInputMaxS2SVersion = "v4"
)

func (e CreateInputMaxS2SVersion) ToPointer() *CreateInputMaxS2SVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputMaxS2SVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "v3", "v4":
			return true
		}
	}
	return false
}

// CreateInputCompression - Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
type CreateInputCompression string

const (
	// CreateInputCompressionDisabled Disabled
	CreateInputCompressionDisabled CreateInputCompression = "disabled"
	// CreateInputCompressionAuto Automatic
	CreateInputCompressionAuto CreateInputCompression = "auto"
	// CreateInputCompressionAlways Always
	CreateInputCompressionAlways CreateInputCompression = "always"
)

func (e CreateInputCompression) ToPointer() *CreateInputCompression {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputCompression) IsExact() bool {
	if e != nil {
		switch *e {
		case "disabled", "auto", "always":
			return true
		}
	}
	return false
}

type CreateInputInputSplunk struct {
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     CreateInputTypeSplunk `json:"type"`
	Disabled *bool                 `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	AuthTokens []CreateInputAuthTokenSplunk `json:"authTokens,omitempty"`
	// The highest S2S protocol version to advertise during handshake
	MaxS2Sversion *CreateInputMaxS2SVersion `json:"maxS2Sversion,omitempty"`
	Description   *string                   `json:"description,omitempty"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `json:"useFwdTimezone,omitempty"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `json:"dropControlFields,omitempty"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`
	// Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
	Compress *CreateInputCompression `json:"compress,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputSplunk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSplunk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSplunk) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSplunk) GetType() CreateInputTypeSplunk {
	if c == nil {
		return CreateInputTypeSplunk("")
	}
	return c.Type
}

func (c *CreateInputInputSplunk) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSplunk) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSplunk) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSplunk) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSplunk) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSplunk) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSplunk) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSplunk) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSplunk) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputSplunk) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputSplunk) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputSplunk) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputSplunk) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputSplunk) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputInputSplunk) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputInputSplunk) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputInputSplunk) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputSplunk) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSplunk) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputSplunk) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputSplunk) GetAuthTokens() []CreateInputAuthTokenSplunk {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputSplunk) GetMaxS2Sversion() *CreateInputMaxS2SVersion {
	if c == nil {
		return nil
	}
	return c.MaxS2Sversion
}

func (c *CreateInputInputSplunk) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputSplunk) GetUseFwdTimezone() *bool {
	if c == nil {
		return nil
	}
	return c.UseFwdTimezone
}

func (c *CreateInputInputSplunk) GetDropControlFields() *bool {
	if c == nil {
		return nil
	}
	return c.DropControlFields
}

func (c *CreateInputInputSplunk) GetExtractMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractMetrics
}

func (c *CreateInputInputSplunk) GetCompress() *CreateInputCompression {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputInputSplunk) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputSplunk) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeHTTP string

const (
	CreateInputTypeHTTPHTTP CreateInputTypeHTTP = "http"
)

func (e CreateInputTypeHTTP) ToPointer() *CreateInputTypeHTTP {
	return &e
}
func (e *CreateInputTypeHTTP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = CreateInputTypeHTTP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeHTTP: %v", v)
	}
}

type CreateInputInputHTTP struct {
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     CreateInputTypeHTTP `json:"type"`
	Disabled *bool               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `json:"criblAPI,omitempty"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `json:"elasticAPI,omitempty"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `json:"splunkHecAPI,omitempty"`
	SplunkHecAcks *bool   `json:"splunkHecAcks,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime.
	TemplateSplunkHecAPI *string `json:"__template_splunkHecAPI,omitempty"`
}

func (c CreateInputInputHTTP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputHTTP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputHTTP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputHTTP) GetType() CreateInputTypeHTTP {
	if c == nil {
		return CreateInputTypeHTTP("")
	}
	return c.Type
}

func (c *CreateInputInputHTTP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputHTTP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputHTTP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputHTTP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputHTTP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputHTTP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputHTTP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputHTTP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputHTTP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputHTTP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputHTTP) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputHTTP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputHTTP) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputHTTP) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputHTTP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputHTTP) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputHTTP) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputHTTP) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputHTTP) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputHTTP) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputHTTP) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputHTTP) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputHTTP) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputHTTP) GetCriblAPI() *string {
	if c == nil {
		return nil
	}
	return c.CriblAPI
}

func (c *CreateInputInputHTTP) GetElasticAPI() *string {
	if c == nil {
		return nil
	}
	return c.ElasticAPI
}

func (c *CreateInputInputHTTP) GetSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.SplunkHecAPI
}

func (c *CreateInputInputHTTP) GetSplunkHecAcks() *bool {
	if c == nil {
		return nil
	}
	return c.SplunkHecAcks
}

func (c *CreateInputInputHTTP) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputHTTP) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if c == nil {
		return nil
	}
	return c.AuthTokensExt
}

func (c *CreateInputInputHTTP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputHTTP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputHTTP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputInputHTTP) GetTemplateSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplateSplunkHecAPI
}

type CreateInputTypeMsk string

const (
	CreateInputTypeMskMsk CreateInputTypeMsk = "msk"
)

func (e CreateInputTypeMsk) ToPointer() *CreateInputTypeMsk {
	return &e
}
func (e *CreateInputTypeMsk) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "msk":
		*e = CreateInputTypeMsk(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeMsk: %v", v)
	}
}

type CreateInputInputMsk struct {
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     CreateInputTypeMsk `json:"type"`
	Disabled *bool              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `json:"fromBeginning,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `json:"sessionTimeout,omitempty"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `json:"rebalanceTimeout,omitempty"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `json:"heartbeatInterval,omitempty"`
	// Fields to add to events from this input
	Metadata            []components.ItemsTypeMetadata                    `json:"metadata,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `json:"maxRetries,omitempty"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `json:"maxBackOff,omitempty"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `json:"initialBackoff,omitempty"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `json:"backoffRate,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `json:"authenticationTimeout,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `json:"reauthenticationThreshold,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                               `json:"awsSecretKey,omitempty"`
	// Region where the MSK cluster is located
	Region string `json:"region"`
	// MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing MSK cluster requests
	SignatureVersion *components.SignatureVersionOptions `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64                                                 `json:"durationSeconds,omitempty"`
	TLS             *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `json:"maxBytesPerPartition,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `json:"maxBytes,omitempty"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `json:"maxSocketErrors,omitempty"`
	Description     *string  `json:"description,omitempty"`
	AwsAPIKey       *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputInputMsk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputMsk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputMsk) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputMsk) GetType() CreateInputTypeMsk {
	if c == nil {
		return CreateInputTypeMsk("")
	}
	return c.Type
}

func (c *CreateInputInputMsk) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputMsk) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputMsk) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputMsk) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputMsk) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputMsk) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputMsk) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputMsk) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputMsk) GetBrokers() []string {
	if c == nil {
		return []string{}
	}
	return c.Brokers
}

func (c *CreateInputInputMsk) GetTopics() []string {
	if c == nil {
		return []string{}
	}
	return c.Topics
}

func (c *CreateInputInputMsk) GetGroupID() *string {
	if c == nil {
		return nil
	}
	return c.GroupID
}

func (c *CreateInputInputMsk) GetFromBeginning() *bool {
	if c == nil {
		return nil
	}
	return c.FromBeginning
}

func (c *CreateInputInputMsk) GetSessionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SessionTimeout
}

func (c *CreateInputInputMsk) GetRebalanceTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RebalanceTimeout
}

func (c *CreateInputInputMsk) GetHeartbeatInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.HeartbeatInterval
}

func (c *CreateInputInputMsk) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputMsk) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if c == nil {
		return nil
	}
	return c.KafkaSchemaRegistry
}

func (c *CreateInputInputMsk) GetConnectionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ConnectionTimeout
}

func (c *CreateInputInputMsk) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputMsk) GetMaxRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRetries
}

func (c *CreateInputInputMsk) GetMaxBackOff() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBackOff
}

func (c *CreateInputInputMsk) GetInitialBackoff() *float64 {
	if c == nil {
		return nil
	}
	return c.InitialBackoff
}

func (c *CreateInputInputMsk) GetBackoffRate() *float64 {
	if c == nil {
		return nil
	}
	return c.BackoffRate
}

func (c *CreateInputInputMsk) GetAuthenticationTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.AuthenticationTimeout
}

func (c *CreateInputInputMsk) GetReauthenticationThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.ReauthenticationThreshold
}

func (c *CreateInputInputMsk) GetAwsAuthenticationMethod() components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return components.AuthenticationMethodOptionsS3CollectorConf("")
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputMsk) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputMsk) GetRegion() string {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateInputInputMsk) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputMsk) GetSignatureVersion() *components.SignatureVersionOptions {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputMsk) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputMsk) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputMsk) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputMsk) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputMsk) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputMsk) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputMsk) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputMsk) GetAutoCommitInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitInterval
}

func (c *CreateInputInputMsk) GetAutoCommitThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitThreshold
}

func (c *CreateInputInputMsk) GetMaxBytesPerPartition() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytesPerPartition
}

func (c *CreateInputInputMsk) GetMaxBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytes
}

func (c *CreateInputInputMsk) GetMaxSocketErrors() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxSocketErrors
}

func (c *CreateInputInputMsk) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputMsk) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputMsk) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputMsk) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputMsk) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputMsk) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputMsk) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputInputMsk) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputTypeKafka string

const (
	CreateInputTypeKafkaKafka CreateInputTypeKafka = "kafka"
)

func (e CreateInputTypeKafka) ToPointer() *CreateInputTypeKafka {
	return &e
}
func (e *CreateInputTypeKafka) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kafka":
		*e = CreateInputTypeKafka(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeKafka: %v", v)
	}
}

type CreateInputInputKafka struct {
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     CreateInputTypeKafka `json:"type"`
	Disabled *bool                `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `json:"fromBeginning,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `json:"maxRetries,omitempty"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `json:"maxBackOff,omitempty"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `json:"initialBackoff,omitempty"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `json:"backoffRate,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `json:"authenticationTimeout,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `json:"reauthenticationThreshold,omitempty"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType                           `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `json:"sessionTimeout,omitempty"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `json:"rebalanceTimeout,omitempty"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `json:"heartbeatInterval,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `json:"maxBytesPerPartition,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `json:"maxBytes,omitempty"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `json:"maxSocketErrors,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
}

func (c CreateInputInputKafka) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputKafka) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputKafka) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputKafka) GetType() CreateInputTypeKafka {
	if c == nil {
		return CreateInputTypeKafka("")
	}
	return c.Type
}

func (c *CreateInputInputKafka) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputKafka) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputKafka) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputKafka) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputKafka) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputKafka) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputKafka) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputKafka) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputKafka) GetBrokers() []string {
	if c == nil {
		return []string{}
	}
	return c.Brokers
}

func (c *CreateInputInputKafka) GetTopics() []string {
	if c == nil {
		return []string{}
	}
	return c.Topics
}

func (c *CreateInputInputKafka) GetGroupID() *string {
	if c == nil {
		return nil
	}
	return c.GroupID
}

func (c *CreateInputInputKafka) GetFromBeginning() *bool {
	if c == nil {
		return nil
	}
	return c.FromBeginning
}

func (c *CreateInputInputKafka) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if c == nil {
		return nil
	}
	return c.KafkaSchemaRegistry
}

func (c *CreateInputInputKafka) GetConnectionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ConnectionTimeout
}

func (c *CreateInputInputKafka) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputKafka) GetMaxRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRetries
}

func (c *CreateInputInputKafka) GetMaxBackOff() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBackOff
}

func (c *CreateInputInputKafka) GetInitialBackoff() *float64 {
	if c == nil {
		return nil
	}
	return c.InitialBackoff
}

func (c *CreateInputInputKafka) GetBackoffRate() *float64 {
	if c == nil {
		return nil
	}
	return c.BackoffRate
}

func (c *CreateInputInputKafka) GetAuthenticationTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.AuthenticationTimeout
}

func (c *CreateInputInputKafka) GetReauthenticationThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.ReauthenticationThreshold
}

func (c *CreateInputInputKafka) GetSasl() *components.AuthenticationType {
	if c == nil {
		return nil
	}
	return c.Sasl
}

func (c *CreateInputInputKafka) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputKafka) GetSessionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SessionTimeout
}

func (c *CreateInputInputKafka) GetRebalanceTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RebalanceTimeout
}

func (c *CreateInputInputKafka) GetHeartbeatInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.HeartbeatInterval
}

func (c *CreateInputInputKafka) GetAutoCommitInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitInterval
}

func (c *CreateInputInputKafka) GetAutoCommitThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitThreshold
}

func (c *CreateInputInputKafka) GetMaxBytesPerPartition() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytesPerPartition
}

func (c *CreateInputInputKafka) GetMaxBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytes
}

func (c *CreateInputInputKafka) GetMaxSocketErrors() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxSocketErrors
}

func (c *CreateInputInputKafka) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputKafka) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeCollection string

const (
	CreateInputTypeCollectionCollection CreateInputTypeCollection = "collection"
)

func (e CreateInputTypeCollection) ToPointer() *CreateInputTypeCollection {
	return &e
}
func (e *CreateInputTypeCollection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "collection":
		*e = CreateInputTypeCollection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeCollection: %v", v)
	}
}

type CreateInputInputCollection struct {
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     CreateInputTypeCollection `json:"type"`
	Disabled *bool                     `json:"disabled,omitempty"`
	// Pipeline to process results
	Pipeline *string `json:"pipeline,omitempty"`
	// Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64                   `json:"staleChannelFlushMs,omitempty"`
	Preprocess          *components.PreprocessType `json:"preprocess,omitempty"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `json:"throttleRatePerSec,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Destination to send results to
	Output *string `json:"output,omitempty"`
}

func (c CreateInputInputCollection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputCollection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputCollection) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputCollection) GetType() CreateInputTypeCollection {
	if c == nil {
		return CreateInputTypeCollection("")
	}
	return c.Type
}

func (c *CreateInputInputCollection) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputCollection) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputCollection) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputCollection) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputCollection) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputCollection) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputCollection) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputCollection) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputCollection) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputCollection) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputCollection) GetPreprocess() *components.PreprocessType {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputInputCollection) GetThrottleRatePerSec() *string {
	if c == nil {
		return nil
	}
	return c.ThrottleRatePerSec
}

func (c *CreateInputInputCollection) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputCollection) GetOutput() *string {
	if c == nil {
		return nil
	}
	return c.Output
}

type CreateInputRequestType string

const (
	CreateInputRequestTypeCollection           CreateInputRequestType = "collection"
	CreateInputRequestTypeKafka                CreateInputRequestType = "kafka"
	CreateInputRequestTypeMsk                  CreateInputRequestType = "msk"
	CreateInputRequestTypeHTTP                 CreateInputRequestType = "http"
	CreateInputRequestTypeSplunk               CreateInputRequestType = "splunk"
	CreateInputRequestTypeSplunkSearch         CreateInputRequestType = "splunk_search"
	CreateInputRequestTypeSplunkHec            CreateInputRequestType = "splunk_hec"
	CreateInputRequestTypeAzureBlob            CreateInputRequestType = "azure_blob"
	CreateInputRequestTypeElastic              CreateInputRequestType = "elastic"
	CreateInputRequestTypeConfluentCloud       CreateInputRequestType = "confluent_cloud"
	CreateInputRequestTypeGrafana              CreateInputRequestType = "grafana"
	CreateInputRequestTypeLoki                 CreateInputRequestType = "loki"
	CreateInputRequestTypePrometheusRw         CreateInputRequestType = "prometheus_rw"
	CreateInputRequestTypePrometheus           CreateInputRequestType = "prometheus"
	CreateInputRequestTypeEdgePrometheus       CreateInputRequestType = "edge_prometheus"
	CreateInputRequestTypeOffice365Mgmt        CreateInputRequestType = "office365_mgmt"
	CreateInputRequestTypeOffice365Service     CreateInputRequestType = "office365_service"
	CreateInputRequestTypeOffice365MsgTrace    CreateInputRequestType = "office365_msg_trace"
	CreateInputRequestTypeEventhub             CreateInputRequestType = "eventhub"
	CreateInputRequestTypeExec                 CreateInputRequestType = "exec"
	CreateInputRequestTypeFirehose             CreateInputRequestType = "firehose"
	CreateInputRequestTypeGooglePubsub         CreateInputRequestType = "google_pubsub"
	CreateInputRequestTypeCribl                CreateInputRequestType = "cribl"
	CreateInputRequestTypeCriblTCP             CreateInputRequestType = "cribl_tcp"
	CreateInputRequestTypeCriblHTTP            CreateInputRequestType = "cribl_http"
	CreateInputRequestTypeCriblLakeHTTP        CreateInputRequestType = "cribl_lake_http"
	CreateInputRequestTypeTcpjson              CreateInputRequestType = "tcpjson"
	CreateInputRequestTypeSystemMetrics        CreateInputRequestType = "system_metrics"
	CreateInputRequestTypeSystemState          CreateInputRequestType = "system_state"
	CreateInputRequestTypeKubeMetrics          CreateInputRequestType = "kube_metrics"
	CreateInputRequestTypeKubeLogs             CreateInputRequestType = "kube_logs"
	CreateInputRequestTypeKubeEvents           CreateInputRequestType = "kube_events"
	CreateInputRequestTypeWindowsMetrics       CreateInputRequestType = "windows_metrics"
	CreateInputRequestTypeCrowdstrike          CreateInputRequestType = "crowdstrike"
	CreateInputRequestTypeDatadogAgent         CreateInputRequestType = "datadog_agent"
	CreateInputRequestTypeDatagen              CreateInputRequestType = "datagen"
	CreateInputRequestTypeHTTPRaw              CreateInputRequestType = "http_raw"
	CreateInputRequestTypeKinesis              CreateInputRequestType = "kinesis"
	CreateInputRequestTypeCriblmetrics         CreateInputRequestType = "criblmetrics"
	CreateInputRequestTypeMetrics              CreateInputRequestType = "metrics"
	CreateInputRequestTypeS3                   CreateInputRequestType = "s3"
	CreateInputRequestTypeS3Inventory          CreateInputRequestType = "s3_inventory"
	CreateInputRequestTypeSnmp                 CreateInputRequestType = "snmp"
	CreateInputRequestTypeOpenTelemetry        CreateInputRequestType = "open_telemetry"
	CreateInputRequestTypeModelDrivenTelemetry CreateInputRequestType = "model_driven_telemetry"
	CreateInputRequestTypeSqs                  CreateInputRequestType = "sqs"
	CreateInputRequestTypeSyslog               CreateInputRequestType = "syslog"
	CreateInputRequestTypeFile                 CreateInputRequestType = "file"
	CreateInputRequestTypeTCP                  CreateInputRequestType = "tcp"
	CreateInputRequestTypeAppscope             CreateInputRequestType = "appscope"
	CreateInputRequestTypeWef                  CreateInputRequestType = "wef"
	CreateInputRequestTypeWinEventLogs         CreateInputRequestType = "win_event_logs"
	CreateInputRequestTypeRawUDP               CreateInputRequestType = "raw_udp"
	CreateInputRequestTypeJournalFiles         CreateInputRequestType = "journal_files"
	CreateInputRequestTypeWiz                  CreateInputRequestType = "wiz"
	CreateInputRequestTypeWizWebhook           CreateInputRequestType = "wiz_webhook"
	CreateInputRequestTypeNetflow              CreateInputRequestType = "netflow"
	CreateInputRequestTypeSecurityLake         CreateInputRequestType = "security_lake"
	CreateInputRequestTypeZscalerHec           CreateInputRequestType = "zscaler_hec"
	CreateInputRequestTypeCloudflareHec        CreateInputRequestType = "cloudflare_hec"
)

// CreateInputRequest - Input object
type CreateInputRequest struct {
	CreateInputInputCollection           *CreateInputInputCollection           `queryParam:"inline" union:"member"`
	CreateInputInputKafka                *CreateInputInputKafka                `queryParam:"inline" union:"member"`
	CreateInputInputMsk                  *CreateInputInputMsk                  `queryParam:"inline" union:"member"`
	CreateInputInputHTTP                 *CreateInputInputHTTP                 `queryParam:"inline" union:"member"`
	CreateInputInputSplunk               *CreateInputInputSplunk               `queryParam:"inline" union:"member"`
	CreateInputInputSplunkSearch         *CreateInputInputSplunkSearch         `queryParam:"inline" union:"member"`
	CreateInputInputSplunkHec            *CreateInputInputSplunkHec            `queryParam:"inline" union:"member"`
	CreateInputInputAzureBlob            *CreateInputInputAzureBlob            `queryParam:"inline" union:"member"`
	CreateInputInputElastic              *CreateInputInputElastic              `queryParam:"inline" union:"member"`
	CreateInputInputConfluentCloud       *CreateInputInputConfluentCloud       `queryParam:"inline" union:"member"`
	CreateInputInputGrafanaUnion         *CreateInputInputGrafanaUnion         `queryParam:"inline" union:"member"`
	CreateInputInputLoki                 *CreateInputInputLoki                 `queryParam:"inline" union:"member"`
	CreateInputInputPrometheusRw         *CreateInputInputPrometheusRw         `queryParam:"inline" union:"member"`
	CreateInputInputPrometheus           *CreateInputInputPrometheus           `queryParam:"inline" union:"member"`
	CreateInputInputEdgePrometheus       *CreateInputInputEdgePrometheus       `queryParam:"inline" union:"member"`
	CreateInputInputOffice365Mgmt        *CreateInputInputOffice365Mgmt        `queryParam:"inline" union:"member"`
	CreateInputInputOffice365Service     *CreateInputInputOffice365Service     `queryParam:"inline" union:"member"`
	CreateInputInputOffice365MsgTrace    *CreateInputInputOffice365MsgTrace    `queryParam:"inline" union:"member"`
	CreateInputInputEventhub             *CreateInputInputEventhub             `queryParam:"inline" union:"member"`
	CreateInputInputExec                 *CreateInputInputExec                 `queryParam:"inline" union:"member"`
	CreateInputInputFirehose             *CreateInputInputFirehose             `queryParam:"inline" union:"member"`
	CreateInputInputGooglePubsub         *CreateInputInputGooglePubsub         `queryParam:"inline" union:"member"`
	CreateInputInputCribl                *CreateInputInputCribl                `queryParam:"inline" union:"member"`
	CreateInputInputCriblTCP             *CreateInputInputCriblTCP             `queryParam:"inline" union:"member"`
	CreateInputInputCriblHTTP            *CreateInputInputCriblHTTP            `queryParam:"inline" union:"member"`
	CreateInputInputCriblLakeHTTP        *CreateInputInputCriblLakeHTTP        `queryParam:"inline" union:"member"`
	CreateInputInputTcpjson              *CreateInputInputTcpjson              `queryParam:"inline" union:"member"`
	CreateInputInputSystemMetrics        *CreateInputInputSystemMetrics        `queryParam:"inline" union:"member"`
	CreateInputInputSystemState          *CreateInputInputSystemState          `queryParam:"inline" union:"member"`
	CreateInputInputKubeMetrics          *CreateInputInputKubeMetrics          `queryParam:"inline" union:"member"`
	CreateInputInputKubeLogs             *CreateInputInputKubeLogs             `queryParam:"inline" union:"member"`
	CreateInputInputKubeEvents           *CreateInputInputKubeEvents           `queryParam:"inline" union:"member"`
	CreateInputInputWindowsMetrics       *CreateInputInputWindowsMetrics       `queryParam:"inline" union:"member"`
	CreateInputInputCrowdstrike          *CreateInputInputCrowdstrike          `queryParam:"inline" union:"member"`
	CreateInputInputDatadogAgent         *CreateInputInputDatadogAgent         `queryParam:"inline" union:"member"`
	CreateInputInputDatagen              *CreateInputInputDatagen              `queryParam:"inline" union:"member"`
	CreateInputInputHTTPRaw              *CreateInputInputHTTPRaw              `queryParam:"inline" union:"member"`
	CreateInputInputKinesis              *CreateInputInputKinesis              `queryParam:"inline" union:"member"`
	CreateInputInputCriblmetrics         *CreateInputInputCriblmetrics         `queryParam:"inline" union:"member"`
	CreateInputInputMetrics              *CreateInputInputMetrics              `queryParam:"inline" union:"member"`
	CreateInputInputS3                   *CreateInputInputS3                   `queryParam:"inline" union:"member"`
	CreateInputInputS3Inventory          *CreateInputInputS3Inventory          `queryParam:"inline" union:"member"`
	CreateInputInputSnmp                 *CreateInputInputSnmp                 `queryParam:"inline" union:"member"`
	CreateInputInputOpenTelemetry        *CreateInputInputOpenTelemetry        `queryParam:"inline" union:"member"`
	CreateInputInputModelDrivenTelemetry *CreateInputInputModelDrivenTelemetry `queryParam:"inline" union:"member"`
	CreateInputInputSqs                  *CreateInputInputSqs                  `queryParam:"inline" union:"member"`
	CreateInputInputSyslogUnion          *CreateInputInputSyslogUnion          `queryParam:"inline" union:"member"`
	CreateInputInputFile                 *CreateInputInputFile                 `queryParam:"inline" union:"member"`
	CreateInputInputTCP                  *CreateInputInputTCP                  `queryParam:"inline" union:"member"`
	CreateInputInputAppscope             *CreateInputInputAppscope             `queryParam:"inline" union:"member"`
	CreateInputInputWef                  *CreateInputInputWef                  `queryParam:"inline" union:"member"`
	CreateInputInputWinEventLogs         *CreateInputInputWinEventLogs         `queryParam:"inline" union:"member"`
	CreateInputInputRawUDP               *CreateInputInputRawUDP               `queryParam:"inline" union:"member"`
	CreateInputInputJournalFiles         *CreateInputInputJournalFiles         `queryParam:"inline" union:"member"`
	CreateInputInputWiz                  *CreateInputInputWiz                  `queryParam:"inline" union:"member"`
	CreateInputInputWizWebhook           *CreateInputInputWizWebhook           `queryParam:"inline" union:"member"`
	CreateInputInputNetflow              *CreateInputInputNetflow              `queryParam:"inline" union:"member"`
	CreateInputInputSecurityLake         *CreateInputInputSecurityLake         `queryParam:"inline" union:"member"`
	CreateInputInputZscalerHec           *CreateInputInputZscalerHec           `queryParam:"inline" union:"member"`
	CreateInputInputCloudflareHec        *CreateInputInputCloudflareHec        `queryParam:"inline" union:"member"`

	Type CreateInputRequestType
}

func CreateCreateInputRequestCollection(collection CreateInputInputCollection) CreateInputRequest {
	typ := CreateInputRequestTypeCollection

	typStr := CreateInputTypeCollection(typ)
	collection.Type = typStr

	return CreateInputRequest{
		CreateInputInputCollection: &collection,
		Type:                       typ,
	}
}

func CreateCreateInputRequestKafka(kafka CreateInputInputKafka) CreateInputRequest {
	typ := CreateInputRequestTypeKafka

	typStr := CreateInputTypeKafka(typ)
	kafka.Type = typStr

	return CreateInputRequest{
		CreateInputInputKafka: &kafka,
		Type:                  typ,
	}
}

func CreateCreateInputRequestMsk(msk CreateInputInputMsk) CreateInputRequest {
	typ := CreateInputRequestTypeMsk

	typStr := CreateInputTypeMsk(typ)
	msk.Type = typStr

	return CreateInputRequest{
		CreateInputInputMsk: &msk,
		Type:                typ,
	}
}

func CreateCreateInputRequestHTTP(http CreateInputInputHTTP) CreateInputRequest {
	typ := CreateInputRequestTypeHTTP

	typStr := CreateInputTypeHTTP(typ)
	http.Type = typStr

	return CreateInputRequest{
		CreateInputInputHTTP: &http,
		Type:                 typ,
	}
}

func CreateCreateInputRequestSplunk(splunk CreateInputInputSplunk) CreateInputRequest {
	typ := CreateInputRequestTypeSplunk

	typStr := CreateInputTypeSplunk(typ)
	splunk.Type = typStr

	return CreateInputRequest{
		CreateInputInputSplunk: &splunk,
		Type:                   typ,
	}
}

func CreateCreateInputRequestSplunkSearch(splunkSearch CreateInputInputSplunkSearch) CreateInputRequest {
	typ := CreateInputRequestTypeSplunkSearch

	typStr := CreateInputTypeSplunkSearch(typ)
	splunkSearch.Type = typStr

	return CreateInputRequest{
		CreateInputInputSplunkSearch: &splunkSearch,
		Type:                         typ,
	}
}

func CreateCreateInputRequestSplunkHec(splunkHec CreateInputInputSplunkHec) CreateInputRequest {
	typ := CreateInputRequestTypeSplunkHec

	typStr := CreateInputTypeSplunkHec(typ)
	splunkHec.Type = typStr

	return CreateInputRequest{
		CreateInputInputSplunkHec: &splunkHec,
		Type:                      typ,
	}
}

func CreateCreateInputRequestAzureBlob(azureBlob CreateInputInputAzureBlob) CreateInputRequest {
	typ := CreateInputRequestTypeAzureBlob

	typStr := CreateInputTypeAzureBlob(typ)
	azureBlob.Type = typStr

	return CreateInputRequest{
		CreateInputInputAzureBlob: &azureBlob,
		Type:                      typ,
	}
}

func CreateCreateInputRequestElastic(elastic CreateInputInputElastic) CreateInputRequest {
	typ := CreateInputRequestTypeElastic

	typStr := CreateInputTypeElastic(typ)
	elastic.Type = typStr

	return CreateInputRequest{
		CreateInputInputElastic: &elastic,
		Type:                    typ,
	}
}

func CreateCreateInputRequestConfluentCloud(confluentCloud CreateInputInputConfluentCloud) CreateInputRequest {
	typ := CreateInputRequestTypeConfluentCloud

	typStr := CreateInputTypeConfluentCloud(typ)
	confluentCloud.Type = typStr

	return CreateInputRequest{
		CreateInputInputConfluentCloud: &confluentCloud,
		Type:                           typ,
	}
}

func CreateCreateInputRequestGrafana(grafana CreateInputInputGrafanaUnion) CreateInputRequest {
	typ := CreateInputRequestTypeGrafana

	return CreateInputRequest{
		CreateInputInputGrafanaUnion: &grafana,
		Type:                         typ,
	}
}

func CreateCreateInputRequestLoki(loki CreateInputInputLoki) CreateInputRequest {
	typ := CreateInputRequestTypeLoki

	typStr := CreateInputTypeLoki(typ)
	loki.Type = typStr

	return CreateInputRequest{
		CreateInputInputLoki: &loki,
		Type:                 typ,
	}
}

func CreateCreateInputRequestPrometheusRw(prometheusRw CreateInputInputPrometheusRw) CreateInputRequest {
	typ := CreateInputRequestTypePrometheusRw

	typStr := CreateInputTypePrometheusRw(typ)
	prometheusRw.Type = typStr

	return CreateInputRequest{
		CreateInputInputPrometheusRw: &prometheusRw,
		Type:                         typ,
	}
}

func CreateCreateInputRequestPrometheus(prometheus CreateInputInputPrometheus) CreateInputRequest {
	typ := CreateInputRequestTypePrometheus

	typStr := CreateInputTypePrometheus(typ)
	prometheus.Type = typStr

	return CreateInputRequest{
		CreateInputInputPrometheus: &prometheus,
		Type:                       typ,
	}
}

func CreateCreateInputRequestEdgePrometheus(edgePrometheus CreateInputInputEdgePrometheus) CreateInputRequest {
	typ := CreateInputRequestTypeEdgePrometheus

	typStr := CreateInputTypeEdgePrometheus(typ)
	edgePrometheus.Type = typStr

	return CreateInputRequest{
		CreateInputInputEdgePrometheus: &edgePrometheus,
		Type:                           typ,
	}
}

func CreateCreateInputRequestOffice365Mgmt(office365Mgmt CreateInputInputOffice365Mgmt) CreateInputRequest {
	typ := CreateInputRequestTypeOffice365Mgmt

	typStr := CreateInputTypeOffice365Mgmt(typ)
	office365Mgmt.Type = typStr

	return CreateInputRequest{
		CreateInputInputOffice365Mgmt: &office365Mgmt,
		Type:                          typ,
	}
}

func CreateCreateInputRequestOffice365Service(office365Service CreateInputInputOffice365Service) CreateInputRequest {
	typ := CreateInputRequestTypeOffice365Service

	typStr := CreateInputTypeOffice365Service(typ)
	office365Service.Type = typStr

	return CreateInputRequest{
		CreateInputInputOffice365Service: &office365Service,
		Type:                             typ,
	}
}

func CreateCreateInputRequestOffice365MsgTrace(office365MsgTrace CreateInputInputOffice365MsgTrace) CreateInputRequest {
	typ := CreateInputRequestTypeOffice365MsgTrace

	typStr := CreateInputTypeOffice365MsgTrace(typ)
	office365MsgTrace.Type = typStr

	return CreateInputRequest{
		CreateInputInputOffice365MsgTrace: &office365MsgTrace,
		Type:                              typ,
	}
}

func CreateCreateInputRequestEventhub(eventhub CreateInputInputEventhub) CreateInputRequest {
	typ := CreateInputRequestTypeEventhub

	typStr := CreateInputTypeEventhub(typ)
	eventhub.Type = typStr

	return CreateInputRequest{
		CreateInputInputEventhub: &eventhub,
		Type:                     typ,
	}
}

func CreateCreateInputRequestExec(exec CreateInputInputExec) CreateInputRequest {
	typ := CreateInputRequestTypeExec

	typStr := CreateInputInputExecType(typ)
	exec.Type = typStr

	return CreateInputRequest{
		CreateInputInputExec: &exec,
		Type:                 typ,
	}
}

func CreateCreateInputRequestFirehose(firehose CreateInputInputFirehose) CreateInputRequest {
	typ := CreateInputRequestTypeFirehose

	typStr := CreateInputTypeFirehose(typ)
	firehose.Type = typStr

	return CreateInputRequest{
		CreateInputInputFirehose: &firehose,
		Type:                     typ,
	}
}

func CreateCreateInputRequestGooglePubsub(googlePubsub CreateInputInputGooglePubsub) CreateInputRequest {
	typ := CreateInputRequestTypeGooglePubsub

	typStr := CreateInputTypeGooglePubsub(typ)
	googlePubsub.Type = typStr

	return CreateInputRequest{
		CreateInputInputGooglePubsub: &googlePubsub,
		Type:                         typ,
	}
}

func CreateCreateInputRequestCribl(cribl CreateInputInputCribl) CreateInputRequest {
	typ := CreateInputRequestTypeCribl

	typStr := CreateInputTypeCribl(typ)
	cribl.Type = typStr

	return CreateInputRequest{
		CreateInputInputCribl: &cribl,
		Type:                  typ,
	}
}

func CreateCreateInputRequestCriblTCP(criblTCP CreateInputInputCriblTCP) CreateInputRequest {
	typ := CreateInputRequestTypeCriblTCP

	typStr := CreateInputTypeCriblTCP(typ)
	criblTCP.Type = typStr

	return CreateInputRequest{
		CreateInputInputCriblTCP: &criblTCP,
		Type:                     typ,
	}
}

func CreateCreateInputRequestCriblHTTP(criblHTTP CreateInputInputCriblHTTP) CreateInputRequest {
	typ := CreateInputRequestTypeCriblHTTP

	typStr := CreateInputTypeCriblHTTP(typ)
	criblHTTP.Type = typStr

	return CreateInputRequest{
		CreateInputInputCriblHTTP: &criblHTTP,
		Type:                      typ,
	}
}

func CreateCreateInputRequestCriblLakeHTTP(criblLakeHTTP CreateInputInputCriblLakeHTTP) CreateInputRequest {
	typ := CreateInputRequestTypeCriblLakeHTTP

	typStr := CreateInputTypeCriblLakeHTTP(typ)
	criblLakeHTTP.Type = typStr

	return CreateInputRequest{
		CreateInputInputCriblLakeHTTP: &criblLakeHTTP,
		Type:                          typ,
	}
}

func CreateCreateInputRequestTcpjson(tcpjson CreateInputInputTcpjson) CreateInputRequest {
	typ := CreateInputRequestTypeTcpjson

	typStr := CreateInputTypeTcpjson(typ)
	tcpjson.Type = typStr

	return CreateInputRequest{
		CreateInputInputTcpjson: &tcpjson,
		Type:                    typ,
	}
}

func CreateCreateInputRequestSystemMetrics(systemMetrics CreateInputInputSystemMetrics) CreateInputRequest {
	typ := CreateInputRequestTypeSystemMetrics

	typStr := CreateInputTypeSystemMetrics(typ)
	systemMetrics.Type = typStr

	return CreateInputRequest{
		CreateInputInputSystemMetrics: &systemMetrics,
		Type:                          typ,
	}
}

func CreateCreateInputRequestSystemState(systemState CreateInputInputSystemState) CreateInputRequest {
	typ := CreateInputRequestTypeSystemState

	typStr := CreateInputTypeSystemState(typ)
	systemState.Type = typStr

	return CreateInputRequest{
		CreateInputInputSystemState: &systemState,
		Type:                        typ,
	}
}

func CreateCreateInputRequestKubeMetrics(kubeMetrics CreateInputInputKubeMetrics) CreateInputRequest {
	typ := CreateInputRequestTypeKubeMetrics

	typStr := CreateInputTypeKubeMetrics(typ)
	kubeMetrics.Type = typStr

	return CreateInputRequest{
		CreateInputInputKubeMetrics: &kubeMetrics,
		Type:                        typ,
	}
}

func CreateCreateInputRequestKubeLogs(kubeLogs CreateInputInputKubeLogs) CreateInputRequest {
	typ := CreateInputRequestTypeKubeLogs

	typStr := CreateInputTypeKubeLogs(typ)
	kubeLogs.Type = typStr

	return CreateInputRequest{
		CreateInputInputKubeLogs: &kubeLogs,
		Type:                     typ,
	}
}

func CreateCreateInputRequestKubeEvents(kubeEvents CreateInputInputKubeEvents) CreateInputRequest {
	typ := CreateInputRequestTypeKubeEvents

	typStr := CreateInputTypeKubeEvents(typ)
	kubeEvents.Type = typStr

	return CreateInputRequest{
		CreateInputInputKubeEvents: &kubeEvents,
		Type:                       typ,
	}
}

func CreateCreateInputRequestWindowsMetrics(windowsMetrics CreateInputInputWindowsMetrics) CreateInputRequest {
	typ := CreateInputRequestTypeWindowsMetrics

	typStr := CreateInputTypeWindowsMetrics(typ)
	windowsMetrics.Type = typStr

	return CreateInputRequest{
		CreateInputInputWindowsMetrics: &windowsMetrics,
		Type:                           typ,
	}
}

func CreateCreateInputRequestCrowdstrike(crowdstrike CreateInputInputCrowdstrike) CreateInputRequest {
	typ := CreateInputRequestTypeCrowdstrike

	typStr := CreateInputTypeCrowdstrike(typ)
	crowdstrike.Type = typStr

	return CreateInputRequest{
		CreateInputInputCrowdstrike: &crowdstrike,
		Type:                        typ,
	}
}

func CreateCreateInputRequestDatadogAgent(datadogAgent CreateInputInputDatadogAgent) CreateInputRequest {
	typ := CreateInputRequestTypeDatadogAgent

	typStr := CreateInputTypeDatadogAgent(typ)
	datadogAgent.Type = typStr

	return CreateInputRequest{
		CreateInputInputDatadogAgent: &datadogAgent,
		Type:                         typ,
	}
}

func CreateCreateInputRequestDatagen(datagen CreateInputInputDatagen) CreateInputRequest {
	typ := CreateInputRequestTypeDatagen

	typStr := CreateInputTypeDatagen(typ)
	datagen.Type = typStr

	return CreateInputRequest{
		CreateInputInputDatagen: &datagen,
		Type:                    typ,
	}
}

func CreateCreateInputRequestHTTPRaw(httpRaw CreateInputInputHTTPRaw) CreateInputRequest {
	typ := CreateInputRequestTypeHTTPRaw

	typStr := CreateInputTypeHTTPRaw(typ)
	httpRaw.Type = typStr

	return CreateInputRequest{
		CreateInputInputHTTPRaw: &httpRaw,
		Type:                    typ,
	}
}

func CreateCreateInputRequestKinesis(kinesis CreateInputInputKinesis) CreateInputRequest {
	typ := CreateInputRequestTypeKinesis

	typStr := CreateInputTypeKinesis(typ)
	kinesis.Type = typStr

	return CreateInputRequest{
		CreateInputInputKinesis: &kinesis,
		Type:                    typ,
	}
}

func CreateCreateInputRequestCriblmetrics(criblmetrics CreateInputInputCriblmetrics) CreateInputRequest {
	typ := CreateInputRequestTypeCriblmetrics

	typStr := CreateInputTypeCriblmetrics(typ)
	criblmetrics.Type = typStr

	return CreateInputRequest{
		CreateInputInputCriblmetrics: &criblmetrics,
		Type:                         typ,
	}
}

func CreateCreateInputRequestMetrics(metrics CreateInputInputMetrics) CreateInputRequest {
	typ := CreateInputRequestTypeMetrics

	typStr := CreateInputTypeMetrics(typ)
	metrics.Type = typStr

	return CreateInputRequest{
		CreateInputInputMetrics: &metrics,
		Type:                    typ,
	}
}

func CreateCreateInputRequestS3(s3 CreateInputInputS3) CreateInputRequest {
	typ := CreateInputRequestTypeS3

	typStr := CreateInputTypeS3(typ)
	s3.Type = typStr

	return CreateInputRequest{
		CreateInputInputS3: &s3,
		Type:               typ,
	}
}

func CreateCreateInputRequestS3Inventory(s3Inventory CreateInputInputS3Inventory) CreateInputRequest {
	typ := CreateInputRequestTypeS3Inventory

	typStr := CreateInputTypeS3Inventory(typ)
	s3Inventory.Type = typStr

	return CreateInputRequest{
		CreateInputInputS3Inventory: &s3Inventory,
		Type:                        typ,
	}
}

func CreateCreateInputRequestSnmp(snmp CreateInputInputSnmp) CreateInputRequest {
	typ := CreateInputRequestTypeSnmp

	typStr := CreateInputTypeSnmp(typ)
	snmp.Type = typStr

	return CreateInputRequest{
		CreateInputInputSnmp: &snmp,
		Type:                 typ,
	}
}

func CreateCreateInputRequestOpenTelemetry(openTelemetry CreateInputInputOpenTelemetry) CreateInputRequest {
	typ := CreateInputRequestTypeOpenTelemetry

	typStr := CreateInputTypeOpenTelemetry(typ)
	openTelemetry.Type = typStr

	return CreateInputRequest{
		CreateInputInputOpenTelemetry: &openTelemetry,
		Type:                          typ,
	}
}

func CreateCreateInputRequestModelDrivenTelemetry(modelDrivenTelemetry CreateInputInputModelDrivenTelemetry) CreateInputRequest {
	typ := CreateInputRequestTypeModelDrivenTelemetry

	typStr := CreateInputTypeModelDrivenTelemetry(typ)
	modelDrivenTelemetry.Type = typStr

	return CreateInputRequest{
		CreateInputInputModelDrivenTelemetry: &modelDrivenTelemetry,
		Type:                                 typ,
	}
}

func CreateCreateInputRequestSqs(sqs CreateInputInputSqs) CreateInputRequest {
	typ := CreateInputRequestTypeSqs

	typStr := CreateInputTypeSqs(typ)
	sqs.Type = typStr

	return CreateInputRequest{
		CreateInputInputSqs: &sqs,
		Type:                typ,
	}
}

func CreateCreateInputRequestSyslog(syslog CreateInputInputSyslogUnion) CreateInputRequest {
	typ := CreateInputRequestTypeSyslog

	return CreateInputRequest{
		CreateInputInputSyslogUnion: &syslog,
		Type:                        typ,
	}
}

func CreateCreateInputRequestFile(file CreateInputInputFile) CreateInputRequest {
	typ := CreateInputRequestTypeFile

	typStr := CreateInputInputFileType(typ)
	file.Type = typStr

	return CreateInputRequest{
		CreateInputInputFile: &file,
		Type:                 typ,
	}
}

func CreateCreateInputRequestTCP(tcp CreateInputInputTCP) CreateInputRequest {
	typ := CreateInputRequestTypeTCP

	typStr := CreateInputTypeTCP(typ)
	tcp.Type = typStr

	return CreateInputRequest{
		CreateInputInputTCP: &tcp,
		Type:                typ,
	}
}

func CreateCreateInputRequestAppscope(appscope CreateInputInputAppscope) CreateInputRequest {
	typ := CreateInputRequestTypeAppscope

	typStr := CreateInputTypeAppscope(typ)
	appscope.Type = typStr

	return CreateInputRequest{
		CreateInputInputAppscope: &appscope,
		Type:                     typ,
	}
}

func CreateCreateInputRequestWef(wef CreateInputInputWef) CreateInputRequest {
	typ := CreateInputRequestTypeWef

	typStr := CreateInputTypeWef(typ)
	wef.Type = typStr

	return CreateInputRequest{
		CreateInputInputWef: &wef,
		Type:                typ,
	}
}

func CreateCreateInputRequestWinEventLogs(winEventLogs CreateInputInputWinEventLogs) CreateInputRequest {
	typ := CreateInputRequestTypeWinEventLogs

	typStr := CreateInputTypeWinEventLogs(typ)
	winEventLogs.Type = typStr

	return CreateInputRequest{
		CreateInputInputWinEventLogs: &winEventLogs,
		Type:                         typ,
	}
}

func CreateCreateInputRequestRawUDP(rawUDP CreateInputInputRawUDP) CreateInputRequest {
	typ := CreateInputRequestTypeRawUDP

	typStr := CreateInputTypeRawUDP(typ)
	rawUDP.Type = typStr

	return CreateInputRequest{
		CreateInputInputRawUDP: &rawUDP,
		Type:                   typ,
	}
}

func CreateCreateInputRequestJournalFiles(journalFiles CreateInputInputJournalFiles) CreateInputRequest {
	typ := CreateInputRequestTypeJournalFiles

	typStr := CreateInputInputJournalFilesType(typ)
	journalFiles.Type = typStr

	return CreateInputRequest{
		CreateInputInputJournalFiles: &journalFiles,
		Type:                         typ,
	}
}

func CreateCreateInputRequestWiz(wiz CreateInputInputWiz) CreateInputRequest {
	typ := CreateInputRequestTypeWiz

	typStr := CreateInputTypeWiz(typ)
	wiz.Type = typStr

	return CreateInputRequest{
		CreateInputInputWiz: &wiz,
		Type:                typ,
	}
}

func CreateCreateInputRequestWizWebhook(wizWebhook CreateInputInputWizWebhook) CreateInputRequest {
	typ := CreateInputRequestTypeWizWebhook

	typStr := CreateInputTypeWizWebhook(typ)
	wizWebhook.Type = typStr

	return CreateInputRequest{
		CreateInputInputWizWebhook: &wizWebhook,
		Type:                       typ,
	}
}

func CreateCreateInputRequestNetflow(netflow CreateInputInputNetflow) CreateInputRequest {
	typ := CreateInputRequestTypeNetflow

	typStr := CreateInputTypeNetflow(typ)
	netflow.Type = typStr

	return CreateInputRequest{
		CreateInputInputNetflow: &netflow,
		Type:                    typ,
	}
}

func CreateCreateInputRequestSecurityLake(securityLake CreateInputInputSecurityLake) CreateInputRequest {
	typ := CreateInputRequestTypeSecurityLake

	typStr := CreateInputTypeSecurityLake(typ)
	securityLake.Type = typStr

	return CreateInputRequest{
		CreateInputInputSecurityLake: &securityLake,
		Type:                         typ,
	}
}

func CreateCreateInputRequestZscalerHec(zscalerHec CreateInputInputZscalerHec) CreateInputRequest {
	typ := CreateInputRequestTypeZscalerHec

	typStr := CreateInputTypeZscalerHec(typ)
	zscalerHec.Type = typStr

	return CreateInputRequest{
		CreateInputInputZscalerHec: &zscalerHec,
		Type:                       typ,
	}
}

func CreateCreateInputRequestCloudflareHec(cloudflareHec CreateInputInputCloudflareHec) CreateInputRequest {
	typ := CreateInputRequestTypeCloudflareHec

	typStr := CreateInputTypeCloudflareHec(typ)
	cloudflareHec.Type = typStr

	return CreateInputRequest{
		CreateInputInputCloudflareHec: &cloudflareHec,
		Type:                          typ,
	}
}

func (u *CreateInputRequest) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "collection":
		createInputInputCollection := new(CreateInputInputCollection)
		if err := utils.UnmarshalJSON(data, &createInputInputCollection, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == collection) type CreateInputInputCollection within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputCollection = createInputInputCollection
		u.Type = CreateInputRequestTypeCollection
		return nil
	case "kafka":
		createInputInputKafka := new(CreateInputInputKafka)
		if err := utils.UnmarshalJSON(data, &createInputInputKafka, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kafka) type CreateInputInputKafka within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputKafka = createInputInputKafka
		u.Type = CreateInputRequestTypeKafka
		return nil
	case "msk":
		createInputInputMsk := new(CreateInputInputMsk)
		if err := utils.UnmarshalJSON(data, &createInputInputMsk, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == msk) type CreateInputInputMsk within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputMsk = createInputInputMsk
		u.Type = CreateInputRequestTypeMsk
		return nil
	case "http":
		createInputInputHTTP := new(CreateInputInputHTTP)
		if err := utils.UnmarshalJSON(data, &createInputInputHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http) type CreateInputInputHTTP within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputHTTP = createInputInputHTTP
		u.Type = CreateInputRequestTypeHTTP
		return nil
	case "splunk":
		createInputInputSplunk := new(CreateInputInputSplunk)
		if err := utils.UnmarshalJSON(data, &createInputInputSplunk, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk) type CreateInputInputSplunk within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSplunk = createInputInputSplunk
		u.Type = CreateInputRequestTypeSplunk
		return nil
	case "splunk_search":
		createInputInputSplunkSearch := new(CreateInputInputSplunkSearch)
		if err := utils.UnmarshalJSON(data, &createInputInputSplunkSearch, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk_search) type CreateInputInputSplunkSearch within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSplunkSearch = createInputInputSplunkSearch
		u.Type = CreateInputRequestTypeSplunkSearch
		return nil
	case "splunk_hec":
		createInputInputSplunkHec := new(CreateInputInputSplunkHec)
		if err := utils.UnmarshalJSON(data, &createInputInputSplunkHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk_hec) type CreateInputInputSplunkHec within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSplunkHec = createInputInputSplunkHec
		u.Type = CreateInputRequestTypeSplunkHec
		return nil
	case "azure_blob":
		createInputInputAzureBlob := new(CreateInputInputAzureBlob)
		if err := utils.UnmarshalJSON(data, &createInputInputAzureBlob, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == azure_blob) type CreateInputInputAzureBlob within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputAzureBlob = createInputInputAzureBlob
		u.Type = CreateInputRequestTypeAzureBlob
		return nil
	case "elastic":
		createInputInputElastic := new(CreateInputInputElastic)
		if err := utils.UnmarshalJSON(data, &createInputInputElastic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == elastic) type CreateInputInputElastic within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputElastic = createInputInputElastic
		u.Type = CreateInputRequestTypeElastic
		return nil
	case "confluent_cloud":
		createInputInputConfluentCloud := new(CreateInputInputConfluentCloud)
		if err := utils.UnmarshalJSON(data, &createInputInputConfluentCloud, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == confluent_cloud) type CreateInputInputConfluentCloud within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputConfluentCloud = createInputInputConfluentCloud
		u.Type = CreateInputRequestTypeConfluentCloud
		return nil
	case "grafana":
		createInputInputGrafanaUnion := new(CreateInputInputGrafanaUnion)
		if err := utils.UnmarshalJSON(data, &createInputInputGrafanaUnion, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == grafana) type CreateInputInputGrafanaUnion within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputGrafanaUnion = createInputInputGrafanaUnion
		u.Type = CreateInputRequestTypeGrafana
		return nil
	case "loki":
		createInputInputLoki := new(CreateInputInputLoki)
		if err := utils.UnmarshalJSON(data, &createInputInputLoki, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == loki) type CreateInputInputLoki within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputLoki = createInputInputLoki
		u.Type = CreateInputRequestTypeLoki
		return nil
	case "prometheus_rw":
		createInputInputPrometheusRw := new(CreateInputInputPrometheusRw)
		if err := utils.UnmarshalJSON(data, &createInputInputPrometheusRw, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == prometheus_rw) type CreateInputInputPrometheusRw within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputPrometheusRw = createInputInputPrometheusRw
		u.Type = CreateInputRequestTypePrometheusRw
		return nil
	case "prometheus":
		createInputInputPrometheus := new(CreateInputInputPrometheus)
		if err := utils.UnmarshalJSON(data, &createInputInputPrometheus, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == prometheus) type CreateInputInputPrometheus within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputPrometheus = createInputInputPrometheus
		u.Type = CreateInputRequestTypePrometheus
		return nil
	case "edge_prometheus":
		createInputInputEdgePrometheus := new(CreateInputInputEdgePrometheus)
		if err := utils.UnmarshalJSON(data, &createInputInputEdgePrometheus, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == edge_prometheus) type CreateInputInputEdgePrometheus within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputEdgePrometheus = createInputInputEdgePrometheus
		u.Type = CreateInputRequestTypeEdgePrometheus
		return nil
	case "office365_mgmt":
		createInputInputOffice365Mgmt := new(CreateInputInputOffice365Mgmt)
		if err := utils.UnmarshalJSON(data, &createInputInputOffice365Mgmt, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_mgmt) type CreateInputInputOffice365Mgmt within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputOffice365Mgmt = createInputInputOffice365Mgmt
		u.Type = CreateInputRequestTypeOffice365Mgmt
		return nil
	case "office365_service":
		createInputInputOffice365Service := new(CreateInputInputOffice365Service)
		if err := utils.UnmarshalJSON(data, &createInputInputOffice365Service, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_service) type CreateInputInputOffice365Service within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputOffice365Service = createInputInputOffice365Service
		u.Type = CreateInputRequestTypeOffice365Service
		return nil
	case "office365_msg_trace":
		createInputInputOffice365MsgTrace := new(CreateInputInputOffice365MsgTrace)
		if err := utils.UnmarshalJSON(data, &createInputInputOffice365MsgTrace, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_msg_trace) type CreateInputInputOffice365MsgTrace within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputOffice365MsgTrace = createInputInputOffice365MsgTrace
		u.Type = CreateInputRequestTypeOffice365MsgTrace
		return nil
	case "eventhub":
		createInputInputEventhub := new(CreateInputInputEventhub)
		if err := utils.UnmarshalJSON(data, &createInputInputEventhub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == eventhub) type CreateInputInputEventhub within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputEventhub = createInputInputEventhub
		u.Type = CreateInputRequestTypeEventhub
		return nil
	case "exec":
		createInputInputExec := new(CreateInputInputExec)
		if err := utils.UnmarshalJSON(data, &createInputInputExec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == exec) type CreateInputInputExec within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputExec = createInputInputExec
		u.Type = CreateInputRequestTypeExec
		return nil
	case "firehose":
		createInputInputFirehose := new(CreateInputInputFirehose)
		if err := utils.UnmarshalJSON(data, &createInputInputFirehose, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == firehose) type CreateInputInputFirehose within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputFirehose = createInputInputFirehose
		u.Type = CreateInputRequestTypeFirehose
		return nil
	case "google_pubsub":
		createInputInputGooglePubsub := new(CreateInputInputGooglePubsub)
		if err := utils.UnmarshalJSON(data, &createInputInputGooglePubsub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == google_pubsub) type CreateInputInputGooglePubsub within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputGooglePubsub = createInputInputGooglePubsub
		u.Type = CreateInputRequestTypeGooglePubsub
		return nil
	case "cribl":
		createInputInputCribl := new(CreateInputInputCribl)
		if err := utils.UnmarshalJSON(data, &createInputInputCribl, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl) type CreateInputInputCribl within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputCribl = createInputInputCribl
		u.Type = CreateInputRequestTypeCribl
		return nil
	case "cribl_tcp":
		createInputInputCriblTCP := new(CreateInputInputCriblTCP)
		if err := utils.UnmarshalJSON(data, &createInputInputCriblTCP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_tcp) type CreateInputInputCriblTCP within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputCriblTCP = createInputInputCriblTCP
		u.Type = CreateInputRequestTypeCriblTCP
		return nil
	case "cribl_http":
		createInputInputCriblHTTP := new(CreateInputInputCriblHTTP)
		if err := utils.UnmarshalJSON(data, &createInputInputCriblHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_http) type CreateInputInputCriblHTTP within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputCriblHTTP = createInputInputCriblHTTP
		u.Type = CreateInputRequestTypeCriblHTTP
		return nil
	case "cribl_lake_http":
		createInputInputCriblLakeHTTP := new(CreateInputInputCriblLakeHTTP)
		if err := utils.UnmarshalJSON(data, &createInputInputCriblLakeHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_lake_http) type CreateInputInputCriblLakeHTTP within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputCriblLakeHTTP = createInputInputCriblLakeHTTP
		u.Type = CreateInputRequestTypeCriblLakeHTTP
		return nil
	case "tcpjson":
		createInputInputTcpjson := new(CreateInputInputTcpjson)
		if err := utils.UnmarshalJSON(data, &createInputInputTcpjson, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == tcpjson) type CreateInputInputTcpjson within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputTcpjson = createInputInputTcpjson
		u.Type = CreateInputRequestTypeTcpjson
		return nil
	case "system_metrics":
		createInputInputSystemMetrics := new(CreateInputInputSystemMetrics)
		if err := utils.UnmarshalJSON(data, &createInputInputSystemMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == system_metrics) type CreateInputInputSystemMetrics within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSystemMetrics = createInputInputSystemMetrics
		u.Type = CreateInputRequestTypeSystemMetrics
		return nil
	case "system_state":
		createInputInputSystemState := new(CreateInputInputSystemState)
		if err := utils.UnmarshalJSON(data, &createInputInputSystemState, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == system_state) type CreateInputInputSystemState within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSystemState = createInputInputSystemState
		u.Type = CreateInputRequestTypeSystemState
		return nil
	case "kube_metrics":
		createInputInputKubeMetrics := new(CreateInputInputKubeMetrics)
		if err := utils.UnmarshalJSON(data, &createInputInputKubeMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_metrics) type CreateInputInputKubeMetrics within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputKubeMetrics = createInputInputKubeMetrics
		u.Type = CreateInputRequestTypeKubeMetrics
		return nil
	case "kube_logs":
		createInputInputKubeLogs := new(CreateInputInputKubeLogs)
		if err := utils.UnmarshalJSON(data, &createInputInputKubeLogs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_logs) type CreateInputInputKubeLogs within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputKubeLogs = createInputInputKubeLogs
		u.Type = CreateInputRequestTypeKubeLogs
		return nil
	case "kube_events":
		createInputInputKubeEvents := new(CreateInputInputKubeEvents)
		if err := utils.UnmarshalJSON(data, &createInputInputKubeEvents, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_events) type CreateInputInputKubeEvents within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputKubeEvents = createInputInputKubeEvents
		u.Type = CreateInputRequestTypeKubeEvents
		return nil
	case "windows_metrics":
		createInputInputWindowsMetrics := new(CreateInputInputWindowsMetrics)
		if err := utils.UnmarshalJSON(data, &createInputInputWindowsMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == windows_metrics) type CreateInputInputWindowsMetrics within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputWindowsMetrics = createInputInputWindowsMetrics
		u.Type = CreateInputRequestTypeWindowsMetrics
		return nil
	case "crowdstrike":
		createInputInputCrowdstrike := new(CreateInputInputCrowdstrike)
		if err := utils.UnmarshalJSON(data, &createInputInputCrowdstrike, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == crowdstrike) type CreateInputInputCrowdstrike within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputCrowdstrike = createInputInputCrowdstrike
		u.Type = CreateInputRequestTypeCrowdstrike
		return nil
	case "datadog_agent":
		createInputInputDatadogAgent := new(CreateInputInputDatadogAgent)
		if err := utils.UnmarshalJSON(data, &createInputInputDatadogAgent, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == datadog_agent) type CreateInputInputDatadogAgent within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputDatadogAgent = createInputInputDatadogAgent
		u.Type = CreateInputRequestTypeDatadogAgent
		return nil
	case "datagen":
		createInputInputDatagen := new(CreateInputInputDatagen)
		if err := utils.UnmarshalJSON(data, &createInputInputDatagen, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == datagen) type CreateInputInputDatagen within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputDatagen = createInputInputDatagen
		u.Type = CreateInputRequestTypeDatagen
		return nil
	case "http_raw":
		createInputInputHTTPRaw := new(CreateInputInputHTTPRaw)
		if err := utils.UnmarshalJSON(data, &createInputInputHTTPRaw, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http_raw) type CreateInputInputHTTPRaw within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputHTTPRaw = createInputInputHTTPRaw
		u.Type = CreateInputRequestTypeHTTPRaw
		return nil
	case "kinesis":
		createInputInputKinesis := new(CreateInputInputKinesis)
		if err := utils.UnmarshalJSON(data, &createInputInputKinesis, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kinesis) type CreateInputInputKinesis within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputKinesis = createInputInputKinesis
		u.Type = CreateInputRequestTypeKinesis
		return nil
	case "criblmetrics":
		createInputInputCriblmetrics := new(CreateInputInputCriblmetrics)
		if err := utils.UnmarshalJSON(data, &createInputInputCriblmetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == criblmetrics) type CreateInputInputCriblmetrics within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputCriblmetrics = createInputInputCriblmetrics
		u.Type = CreateInputRequestTypeCriblmetrics
		return nil
	case "metrics":
		createInputInputMetrics := new(CreateInputInputMetrics)
		if err := utils.UnmarshalJSON(data, &createInputInputMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == metrics) type CreateInputInputMetrics within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputMetrics = createInputInputMetrics
		u.Type = CreateInputRequestTypeMetrics
		return nil
	case "s3":
		createInputInputS3 := new(CreateInputInputS3)
		if err := utils.UnmarshalJSON(data, &createInputInputS3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == s3) type CreateInputInputS3 within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputS3 = createInputInputS3
		u.Type = CreateInputRequestTypeS3
		return nil
	case "s3_inventory":
		createInputInputS3Inventory := new(CreateInputInputS3Inventory)
		if err := utils.UnmarshalJSON(data, &createInputInputS3Inventory, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == s3_inventory) type CreateInputInputS3Inventory within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputS3Inventory = createInputInputS3Inventory
		u.Type = CreateInputRequestTypeS3Inventory
		return nil
	case "snmp":
		createInputInputSnmp := new(CreateInputInputSnmp)
		if err := utils.UnmarshalJSON(data, &createInputInputSnmp, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == snmp) type CreateInputInputSnmp within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSnmp = createInputInputSnmp
		u.Type = CreateInputRequestTypeSnmp
		return nil
	case "open_telemetry":
		createInputInputOpenTelemetry := new(CreateInputInputOpenTelemetry)
		if err := utils.UnmarshalJSON(data, &createInputInputOpenTelemetry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == open_telemetry) type CreateInputInputOpenTelemetry within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputOpenTelemetry = createInputInputOpenTelemetry
		u.Type = CreateInputRequestTypeOpenTelemetry
		return nil
	case "model_driven_telemetry":
		createInputInputModelDrivenTelemetry := new(CreateInputInputModelDrivenTelemetry)
		if err := utils.UnmarshalJSON(data, &createInputInputModelDrivenTelemetry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == model_driven_telemetry) type CreateInputInputModelDrivenTelemetry within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputModelDrivenTelemetry = createInputInputModelDrivenTelemetry
		u.Type = CreateInputRequestTypeModelDrivenTelemetry
		return nil
	case "sqs":
		createInputInputSqs := new(CreateInputInputSqs)
		if err := utils.UnmarshalJSON(data, &createInputInputSqs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == sqs) type CreateInputInputSqs within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSqs = createInputInputSqs
		u.Type = CreateInputRequestTypeSqs
		return nil
	case "syslog":
		createInputInputSyslogUnion := new(CreateInputInputSyslogUnion)
		if err := utils.UnmarshalJSON(data, &createInputInputSyslogUnion, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == syslog) type CreateInputInputSyslogUnion within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSyslogUnion = createInputInputSyslogUnion
		u.Type = CreateInputRequestTypeSyslog
		return nil
	case "file":
		createInputInputFile := new(CreateInputInputFile)
		if err := utils.UnmarshalJSON(data, &createInputInputFile, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == file) type CreateInputInputFile within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputFile = createInputInputFile
		u.Type = CreateInputRequestTypeFile
		return nil
	case "tcp":
		createInputInputTCP := new(CreateInputInputTCP)
		if err := utils.UnmarshalJSON(data, &createInputInputTCP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == tcp) type CreateInputInputTCP within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputTCP = createInputInputTCP
		u.Type = CreateInputRequestTypeTCP
		return nil
	case "appscope":
		createInputInputAppscope := new(CreateInputInputAppscope)
		if err := utils.UnmarshalJSON(data, &createInputInputAppscope, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == appscope) type CreateInputInputAppscope within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputAppscope = createInputInputAppscope
		u.Type = CreateInputRequestTypeAppscope
		return nil
	case "wef":
		createInputInputWef := new(CreateInputInputWef)
		if err := utils.UnmarshalJSON(data, &createInputInputWef, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wef) type CreateInputInputWef within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputWef = createInputInputWef
		u.Type = CreateInputRequestTypeWef
		return nil
	case "win_event_logs":
		createInputInputWinEventLogs := new(CreateInputInputWinEventLogs)
		if err := utils.UnmarshalJSON(data, &createInputInputWinEventLogs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == win_event_logs) type CreateInputInputWinEventLogs within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputWinEventLogs = createInputInputWinEventLogs
		u.Type = CreateInputRequestTypeWinEventLogs
		return nil
	case "raw_udp":
		createInputInputRawUDP := new(CreateInputInputRawUDP)
		if err := utils.UnmarshalJSON(data, &createInputInputRawUDP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == raw_udp) type CreateInputInputRawUDP within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputRawUDP = createInputInputRawUDP
		u.Type = CreateInputRequestTypeRawUDP
		return nil
	case "journal_files":
		createInputInputJournalFiles := new(CreateInputInputJournalFiles)
		if err := utils.UnmarshalJSON(data, &createInputInputJournalFiles, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == journal_files) type CreateInputInputJournalFiles within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputJournalFiles = createInputInputJournalFiles
		u.Type = CreateInputRequestTypeJournalFiles
		return nil
	case "wiz":
		createInputInputWiz := new(CreateInputInputWiz)
		if err := utils.UnmarshalJSON(data, &createInputInputWiz, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wiz) type CreateInputInputWiz within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputWiz = createInputInputWiz
		u.Type = CreateInputRequestTypeWiz
		return nil
	case "wiz_webhook":
		createInputInputWizWebhook := new(CreateInputInputWizWebhook)
		if err := utils.UnmarshalJSON(data, &createInputInputWizWebhook, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wiz_webhook) type CreateInputInputWizWebhook within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputWizWebhook = createInputInputWizWebhook
		u.Type = CreateInputRequestTypeWizWebhook
		return nil
	case "netflow":
		createInputInputNetflow := new(CreateInputInputNetflow)
		if err := utils.UnmarshalJSON(data, &createInputInputNetflow, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == netflow) type CreateInputInputNetflow within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputNetflow = createInputInputNetflow
		u.Type = CreateInputRequestTypeNetflow
		return nil
	case "security_lake":
		createInputInputSecurityLake := new(CreateInputInputSecurityLake)
		if err := utils.UnmarshalJSON(data, &createInputInputSecurityLake, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == security_lake) type CreateInputInputSecurityLake within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputSecurityLake = createInputInputSecurityLake
		u.Type = CreateInputRequestTypeSecurityLake
		return nil
	case "zscaler_hec":
		createInputInputZscalerHec := new(CreateInputInputZscalerHec)
		if err := utils.UnmarshalJSON(data, &createInputInputZscalerHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == zscaler_hec) type CreateInputInputZscalerHec within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputZscalerHec = createInputInputZscalerHec
		u.Type = CreateInputRequestTypeZscalerHec
		return nil
	case "cloudflare_hec":
		createInputInputCloudflareHec := new(CreateInputInputCloudflareHec)
		if err := utils.UnmarshalJSON(data, &createInputInputCloudflareHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cloudflare_hec) type CreateInputInputCloudflareHec within CreateInputRequest: %w", string(data), err)
		}

		u.CreateInputInputCloudflareHec = createInputInputCloudflareHec
		u.Type = CreateInputRequestTypeCloudflareHec
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputRequest", string(data))
}

func (u CreateInputRequest) MarshalJSON() ([]byte, error) {
	if u.CreateInputInputCollection != nil {
		return utils.MarshalJSON(u.CreateInputInputCollection, "", true)
	}

	if u.CreateInputInputKafka != nil {
		return utils.MarshalJSON(u.CreateInputInputKafka, "", true)
	}

	if u.CreateInputInputMsk != nil {
		return utils.MarshalJSON(u.CreateInputInputMsk, "", true)
	}

	if u.CreateInputInputHTTP != nil {
		return utils.MarshalJSON(u.CreateInputInputHTTP, "", true)
	}

	if u.CreateInputInputSplunk != nil {
		return utils.MarshalJSON(u.CreateInputInputSplunk, "", true)
	}

	if u.CreateInputInputSplunkSearch != nil {
		return utils.MarshalJSON(u.CreateInputInputSplunkSearch, "", true)
	}

	if u.CreateInputInputSplunkHec != nil {
		return utils.MarshalJSON(u.CreateInputInputSplunkHec, "", true)
	}

	if u.CreateInputInputAzureBlob != nil {
		return utils.MarshalJSON(u.CreateInputInputAzureBlob, "", true)
	}

	if u.CreateInputInputElastic != nil {
		return utils.MarshalJSON(u.CreateInputInputElastic, "", true)
	}

	if u.CreateInputInputConfluentCloud != nil {
		return utils.MarshalJSON(u.CreateInputInputConfluentCloud, "", true)
	}

	if u.CreateInputInputGrafanaUnion != nil {
		return utils.MarshalJSON(u.CreateInputInputGrafanaUnion, "", true)
	}

	if u.CreateInputInputLoki != nil {
		return utils.MarshalJSON(u.CreateInputInputLoki, "", true)
	}

	if u.CreateInputInputPrometheusRw != nil {
		return utils.MarshalJSON(u.CreateInputInputPrometheusRw, "", true)
	}

	if u.CreateInputInputPrometheus != nil {
		return utils.MarshalJSON(u.CreateInputInputPrometheus, "", true)
	}

	if u.CreateInputInputEdgePrometheus != nil {
		return utils.MarshalJSON(u.CreateInputInputEdgePrometheus, "", true)
	}

	if u.CreateInputInputOffice365Mgmt != nil {
		return utils.MarshalJSON(u.CreateInputInputOffice365Mgmt, "", true)
	}

	if u.CreateInputInputOffice365Service != nil {
		return utils.MarshalJSON(u.CreateInputInputOffice365Service, "", true)
	}

	if u.CreateInputInputOffice365MsgTrace != nil {
		return utils.MarshalJSON(u.CreateInputInputOffice365MsgTrace, "", true)
	}

	if u.CreateInputInputEventhub != nil {
		return utils.MarshalJSON(u.CreateInputInputEventhub, "", true)
	}

	if u.CreateInputInputExec != nil {
		return utils.MarshalJSON(u.CreateInputInputExec, "", true)
	}

	if u.CreateInputInputFirehose != nil {
		return utils.MarshalJSON(u.CreateInputInputFirehose, "", true)
	}

	if u.CreateInputInputGooglePubsub != nil {
		return utils.MarshalJSON(u.CreateInputInputGooglePubsub, "", true)
	}

	if u.CreateInputInputCribl != nil {
		return utils.MarshalJSON(u.CreateInputInputCribl, "", true)
	}

	if u.CreateInputInputCriblTCP != nil {
		return utils.MarshalJSON(u.CreateInputInputCriblTCP, "", true)
	}

	if u.CreateInputInputCriblHTTP != nil {
		return utils.MarshalJSON(u.CreateInputInputCriblHTTP, "", true)
	}

	if u.CreateInputInputCriblLakeHTTP != nil {
		return utils.MarshalJSON(u.CreateInputInputCriblLakeHTTP, "", true)
	}

	if u.CreateInputInputTcpjson != nil {
		return utils.MarshalJSON(u.CreateInputInputTcpjson, "", true)
	}

	if u.CreateInputInputSystemMetrics != nil {
		return utils.MarshalJSON(u.CreateInputInputSystemMetrics, "", true)
	}

	if u.CreateInputInputSystemState != nil {
		return utils.MarshalJSON(u.CreateInputInputSystemState, "", true)
	}

	if u.CreateInputInputKubeMetrics != nil {
		return utils.MarshalJSON(u.CreateInputInputKubeMetrics, "", true)
	}

	if u.CreateInputInputKubeLogs != nil {
		return utils.MarshalJSON(u.CreateInputInputKubeLogs, "", true)
	}

	if u.CreateInputInputKubeEvents != nil {
		return utils.MarshalJSON(u.CreateInputInputKubeEvents, "", true)
	}

	if u.CreateInputInputWindowsMetrics != nil {
		return utils.MarshalJSON(u.CreateInputInputWindowsMetrics, "", true)
	}

	if u.CreateInputInputCrowdstrike != nil {
		return utils.MarshalJSON(u.CreateInputInputCrowdstrike, "", true)
	}

	if u.CreateInputInputDatadogAgent != nil {
		return utils.MarshalJSON(u.CreateInputInputDatadogAgent, "", true)
	}

	if u.CreateInputInputDatagen != nil {
		return utils.MarshalJSON(u.CreateInputInputDatagen, "", true)
	}

	if u.CreateInputInputHTTPRaw != nil {
		return utils.MarshalJSON(u.CreateInputInputHTTPRaw, "", true)
	}

	if u.CreateInputInputKinesis != nil {
		return utils.MarshalJSON(u.CreateInputInputKinesis, "", true)
	}

	if u.CreateInputInputCriblmetrics != nil {
		return utils.MarshalJSON(u.CreateInputInputCriblmetrics, "", true)
	}

	if u.CreateInputInputMetrics != nil {
		return utils.MarshalJSON(u.CreateInputInputMetrics, "", true)
	}

	if u.CreateInputInputS3 != nil {
		return utils.MarshalJSON(u.CreateInputInputS3, "", true)
	}

	if u.CreateInputInputS3Inventory != nil {
		return utils.MarshalJSON(u.CreateInputInputS3Inventory, "", true)
	}

	if u.CreateInputInputSnmp != nil {
		return utils.MarshalJSON(u.CreateInputInputSnmp, "", true)
	}

	if u.CreateInputInputOpenTelemetry != nil {
		return utils.MarshalJSON(u.CreateInputInputOpenTelemetry, "", true)
	}

	if u.CreateInputInputModelDrivenTelemetry != nil {
		return utils.MarshalJSON(u.CreateInputInputModelDrivenTelemetry, "", true)
	}

	if u.CreateInputInputSqs != nil {
		return utils.MarshalJSON(u.CreateInputInputSqs, "", true)
	}

	if u.CreateInputInputSyslogUnion != nil {
		return utils.MarshalJSON(u.CreateInputInputSyslogUnion, "", true)
	}

	if u.CreateInputInputFile != nil {
		return utils.MarshalJSON(u.CreateInputInputFile, "", true)
	}

	if u.CreateInputInputTCP != nil {
		return utils.MarshalJSON(u.CreateInputInputTCP, "", true)
	}

	if u.CreateInputInputAppscope != nil {
		return utils.MarshalJSON(u.CreateInputInputAppscope, "", true)
	}

	if u.CreateInputInputWef != nil {
		return utils.MarshalJSON(u.CreateInputInputWef, "", true)
	}

	if u.CreateInputInputWinEventLogs != nil {
		return utils.MarshalJSON(u.CreateInputInputWinEventLogs, "", true)
	}

	if u.CreateInputInputRawUDP != nil {
		return utils.MarshalJSON(u.CreateInputInputRawUDP, "", true)
	}

	if u.CreateInputInputJournalFiles != nil {
		return utils.MarshalJSON(u.CreateInputInputJournalFiles, "", true)
	}

	if u.CreateInputInputWiz != nil {
		return utils.MarshalJSON(u.CreateInputInputWiz, "", true)
	}

	if u.CreateInputInputWizWebhook != nil {
		return utils.MarshalJSON(u.CreateInputInputWizWebhook, "", true)
	}

	if u.CreateInputInputNetflow != nil {
		return utils.MarshalJSON(u.CreateInputInputNetflow, "", true)
	}

	if u.CreateInputInputSecurityLake != nil {
		return utils.MarshalJSON(u.CreateInputInputSecurityLake, "", true)
	}

	if u.CreateInputInputZscalerHec != nil {
		return utils.MarshalJSON(u.CreateInputInputZscalerHec, "", true)
	}

	if u.CreateInputInputCloudflareHec != nil {
		return utils.MarshalJSON(u.CreateInputInputCloudflareHec, "", true)
	}

	return nil, errors.New("could not marshal union type CreateInputRequest: all fields are null")
}

type CreateInputResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// a list of Source objects
	CountedInput *components.CountedInput
}

func (c *CreateInputResponse) GetHTTPMeta() components.HTTPMetadata {
	if c == nil {
		return components.HTTPMetadata{}
	}
	return c.HTTPMeta
}

func (c *CreateInputResponse) GetCountedInput() *components.CountedInput {
	if c == nil {
		return nil
	}
	return c.CountedInput
}
