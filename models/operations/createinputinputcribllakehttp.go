// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
	"github.com/criblio/cribl-control-plane-sdk-go/models/components"
)

type CreateInputTypeCloudflareHec string

const (
	CreateInputTypeCloudflareHecCloudflareHec CreateInputTypeCloudflareHec = "cloudflare_hec"
)

func (e CreateInputTypeCloudflareHec) ToPointer() *CreateInputTypeCloudflareHec {
	return &e
}
func (e *CreateInputTypeCloudflareHec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cloudflare_hec":
		*e = CreateInputTypeCloudflareHec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeCloudflareHec: %v", v)
	}
}

// CreateInputAuthTokenAuthenticationMethod - Select Secret to use a text secret to authenticate
type CreateInputAuthTokenAuthenticationMethod string

const (
	CreateInputAuthTokenAuthenticationMethodSecret CreateInputAuthTokenAuthenticationMethod = "secret"
)

func (e CreateInputAuthTokenAuthenticationMethod) ToPointer() *CreateInputAuthTokenAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputAuthTokenAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "secret":
			return true
		}
	}
	return false
}

type CreateInputAuthTokenCloudflareHec struct {
	// Select Secret to use a text secret to authenticate
	AuthType *CreateInputAuthTokenAuthenticationMethod `json:"authType,omitempty"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	Token       any     `json:"token,omitempty"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
}

func (c CreateInputAuthTokenCloudflareHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputAuthTokenCloudflareHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputAuthTokenCloudflareHec) GetAuthType() *CreateInputAuthTokenAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputAuthTokenCloudflareHec) GetTokenSecret() *string {
	if c == nil {
		return nil
	}
	return c.TokenSecret
}

func (c *CreateInputAuthTokenCloudflareHec) GetToken() any {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputAuthTokenCloudflareHec) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputAuthTokenCloudflareHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputAuthTokenCloudflareHec) GetAllowedIndexesAtToken() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexesAtToken
}

func (c *CreateInputAuthTokenCloudflareHec) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

type CreateInputTLSSettingsServerSide struct {
	// Enable or disable TLS. Defaults to enabled for Cloudflare sources.
	Disabled *bool `json:"disabled,omitempty"`
	// Require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
	// Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Regex matching allowable common names in peer certificates' subject attribute
	CommonNameRegex *string `json:"commonNameRegex,omitempty"`
	// The name of the predefined certificate
	CertificateName *string `json:"certificateName,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS. Defaults to the built-in Cribl private key when TLS is enabled.
	PrivKeyPath *string `json:"privKeyPath,omitempty"`
	// Passphrase to use to decrypt private key
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS. Defaults to the built-in Cribl certificate when TLS is enabled.
	CertPath *string `json:"certPath,omitempty"`
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath     *string                                                    `json:"caPath,omitempty"`
	MinVersion *components.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS `json:"minVersion,omitempty"`
	MaxVersion *components.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS `json:"maxVersion,omitempty"`
}

func (c CreateInputTLSSettingsServerSide) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputTLSSettingsServerSide) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputTLSSettingsServerSide) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputTLSSettingsServerSide) GetRequestCert() *bool {
	if c == nil {
		return nil
	}
	return c.RequestCert
}

func (c *CreateInputTLSSettingsServerSide) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputTLSSettingsServerSide) GetCommonNameRegex() *string {
	if c == nil {
		return nil
	}
	return c.CommonNameRegex
}

func (c *CreateInputTLSSettingsServerSide) GetCertificateName() *string {
	if c == nil {
		return nil
	}
	return c.CertificateName
}

func (c *CreateInputTLSSettingsServerSide) GetPrivKeyPath() *string {
	if c == nil {
		return nil
	}
	return c.PrivKeyPath
}

func (c *CreateInputTLSSettingsServerSide) GetPassphrase() *string {
	if c == nil {
		return nil
	}
	return c.Passphrase
}

func (c *CreateInputTLSSettingsServerSide) GetCertPath() *string {
	if c == nil {
		return nil
	}
	return c.CertPath
}

func (c *CreateInputTLSSettingsServerSide) GetCaPath() *string {
	if c == nil {
		return nil
	}
	return c.CaPath
}

func (c *CreateInputTLSSettingsServerSide) GetMinVersion() *components.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS {
	if c == nil {
		return nil
	}
	return c.MinVersion
}

func (c *CreateInputTLSSettingsServerSide) GetMaxVersion() *components.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS {
	if c == nil {
		return nil
	}
	return c.MaxVersion
}

type CreateInputInputCloudflareHec struct {
	// Unique ID for this input
	ID       string                       `json:"id"`
	Type     CreateInputTypeCloudflareHec `json:"type"`
	Disabled *bool                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []CreateInputAuthTokenCloudflareHec `json:"authTokens,omitempty"`
	TLS        *CreateInputTLSSettingsServerSide   `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `json:"keepAliveTimeout,omitempty"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `json:"emitTokenMetrics,omitempty"`
	Description      *string `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputCloudflareHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputCloudflareHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputCloudflareHec) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputCloudflareHec) GetType() CreateInputTypeCloudflareHec {
	if c == nil {
		return CreateInputTypeCloudflareHec("")
	}
	return c.Type
}

func (c *CreateInputInputCloudflareHec) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputCloudflareHec) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputCloudflareHec) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputCloudflareHec) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputCloudflareHec) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputCloudflareHec) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputCloudflareHec) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputCloudflareHec) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputCloudflareHec) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputCloudflareHec) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputCloudflareHec) GetAuthTokens() []CreateInputAuthTokenCloudflareHec {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputCloudflareHec) GetTLS() *CreateInputTLSSettingsServerSide {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputCloudflareHec) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputCloudflareHec) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputCloudflareHec) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputCloudflareHec) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputCloudflareHec) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputCloudflareHec) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputCloudflareHec) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputCloudflareHec) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputCloudflareHec) GetEnableHealthCheck() any {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputCloudflareHec) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputCloudflareHec) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputCloudflareHec) GetHecAPI() string {
	if c == nil {
		return ""
	}
	return c.HecAPI
}

func (c *CreateInputInputCloudflareHec) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputCloudflareHec) GetAllowedIndexes() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexes
}

func (c *CreateInputInputCloudflareHec) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputCloudflareHec) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputCloudflareHec) GetAccessControlAllowOrigin() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowOrigin
}

func (c *CreateInputInputCloudflareHec) GetAccessControlAllowHeaders() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowHeaders
}

func (c *CreateInputInputCloudflareHec) GetEmitTokenMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.EmitTokenMetrics
}

func (c *CreateInputInputCloudflareHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputCloudflareHec) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputCloudflareHec) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeZscalerHec string

const (
	CreateInputTypeZscalerHecZscalerHec CreateInputTypeZscalerHec = "zscaler_hec"
)

func (e CreateInputTypeZscalerHec) ToPointer() *CreateInputTypeZscalerHec {
	return &e
}
func (e *CreateInputTypeZscalerHec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zscaler_hec":
		*e = CreateInputTypeZscalerHec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeZscalerHec: %v", v)
	}
}

type CreateInputAuthTokenZscalerHec struct {
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	// Shared secret to be provided by any client (Authorization: <token>)
	Token       string  `json:"token"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
}

func (c CreateInputAuthTokenZscalerHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputAuthTokenZscalerHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputAuthTokenZscalerHec) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputAuthTokenZscalerHec) GetTokenSecret() *string {
	if c == nil {
		return nil
	}
	return c.TokenSecret
}

func (c *CreateInputAuthTokenZscalerHec) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CreateInputAuthTokenZscalerHec) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputAuthTokenZscalerHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputAuthTokenZscalerHec) GetAllowedIndexesAtToken() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexesAtToken
}

func (c *CreateInputAuthTokenZscalerHec) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

type CreateInputInputZscalerHec struct {
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     CreateInputTypeZscalerHec `json:"type"`
	Disabled *bool                     `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []CreateInputAuthTokenZscalerHec      `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `json:"keepAliveTimeout,omitempty"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Whether to enable Zscaler HEC acknowledgements
	HecAcks *bool `json:"hecAcks,omitempty"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `json:"emitTokenMetrics,omitempty"`
	Description      *string `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'hecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'hecAPI' at runtime.
	TemplateHecAPI *string `json:"__template_hecAPI,omitempty"`
}

func (c CreateInputInputZscalerHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputZscalerHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputZscalerHec) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputZscalerHec) GetType() CreateInputTypeZscalerHec {
	if c == nil {
		return CreateInputTypeZscalerHec("")
	}
	return c.Type
}

func (c *CreateInputInputZscalerHec) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputZscalerHec) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputZscalerHec) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputZscalerHec) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputZscalerHec) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputZscalerHec) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputZscalerHec) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputZscalerHec) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputZscalerHec) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputZscalerHec) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputZscalerHec) GetAuthTokens() []CreateInputAuthTokenZscalerHec {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputZscalerHec) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputZscalerHec) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputZscalerHec) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputZscalerHec) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputZscalerHec) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputZscalerHec) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputZscalerHec) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputZscalerHec) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputZscalerHec) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputZscalerHec) GetEnableHealthCheck() any {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputZscalerHec) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputZscalerHec) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputZscalerHec) GetHecAPI() string {
	if c == nil {
		return ""
	}
	return c.HecAPI
}

func (c *CreateInputInputZscalerHec) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputZscalerHec) GetAllowedIndexes() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexes
}

func (c *CreateInputInputZscalerHec) GetHecAcks() *bool {
	if c == nil {
		return nil
	}
	return c.HecAcks
}

func (c *CreateInputInputZscalerHec) GetAccessControlAllowOrigin() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowOrigin
}

func (c *CreateInputInputZscalerHec) GetAccessControlAllowHeaders() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowHeaders
}

func (c *CreateInputInputZscalerHec) GetEmitTokenMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.EmitTokenMetrics
}

func (c *CreateInputInputZscalerHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputZscalerHec) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputZscalerHec) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputInputZscalerHec) GetTemplateHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHecAPI
}

type CreateInputTypeSecurityLake string

const (
	CreateInputTypeSecurityLakeSecurityLake CreateInputTypeSecurityLake = "security_lake"
)

func (e CreateInputTypeSecurityLake) ToPointer() *CreateInputTypeSecurityLake {
	return &e
}
func (e *CreateInputTypeSecurityLake) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "security_lake":
		*e = CreateInputTypeSecurityLake(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeSecurityLake: %v", v)
	}
}

type CreateInputInputSecurityLake struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputTypeSecurityLake `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `json:"includeSqsMetadata,omitempty"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                      `json:"enableSQSAssumeRole,omitempty"`
	Preprocess          *components.PreprocessType `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `json:"parquetChunkDownloadTimeout,omitempty"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputInputSecurityLake) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSecurityLake) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSecurityLake) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSecurityLake) GetType() CreateInputTypeSecurityLake {
	if c == nil {
		return CreateInputTypeSecurityLake("")
	}
	return c.Type
}

func (c *CreateInputInputSecurityLake) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSecurityLake) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSecurityLake) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSecurityLake) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSecurityLake) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSecurityLake) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSecurityLake) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSecurityLake) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSecurityLake) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputInputSecurityLake) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputInputSecurityLake) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputInputSecurityLake) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputSecurityLake) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputSecurityLake) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputInputSecurityLake) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputSecurityLake) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputSecurityLake) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputSecurityLake) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputSecurityLake) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputSecurityLake) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputSecurityLake) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputInputSecurityLake) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputInputSecurityLake) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputInputSecurityLake) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputSecurityLake) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputInputSecurityLake) GetIncludeSqsMetadata() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeSqsMetadata
}

func (c *CreateInputInputSecurityLake) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputSecurityLake) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputSecurityLake) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputSecurityLake) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputSecurityLake) GetEnableSQSAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableSQSAssumeRole
}

func (c *CreateInputInputSecurityLake) GetPreprocess() *components.PreprocessType {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputInputSecurityLake) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSecurityLake) GetParquetChunkSizeMB() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkSizeMB
}

func (c *CreateInputInputSecurityLake) GetParquetChunkDownloadTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkDownloadTimeout
}

func (c *CreateInputInputSecurityLake) GetCheckpointing() *components.CheckpointingType {
	if c == nil {
		return nil
	}
	return c.Checkpointing
}

func (c *CreateInputInputSecurityLake) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputInputSecurityLake) GetEncoding() *string {
	if c == nil {
		return nil
	}
	return c.Encoding
}

func (c *CreateInputInputSecurityLake) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputSecurityLake) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputSecurityLake) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputSecurityLake) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if c == nil {
		return nil
	}
	return c.TagAfterProcessing
}

func (c *CreateInputInputSecurityLake) GetProcessedTagKey() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagKey
}

func (c *CreateInputInputSecurityLake) GetProcessedTagValue() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagValue
}

func (c *CreateInputInputSecurityLake) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputInputSecurityLake) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputInputSecurityLake) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputSecurityLake) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputSecurityLake) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputSecurityLake) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputInputSecurityLake) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputTypeNetflow string

const (
	CreateInputTypeNetflowNetflow CreateInputTypeNetflow = "netflow"
)

func (e CreateInputTypeNetflow) ToPointer() *CreateInputTypeNetflow {
	return &e
}
func (e *CreateInputTypeNetflow) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "netflow":
		*e = CreateInputTypeNetflow(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeNetflow: %v", v)
	}
}

type CreateInputInputNetflow struct {
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     CreateInputTypeNetflow `json:"type"`
	Disabled *bool                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
	EnablePassThrough *bool `json:"enablePassThrough,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
	TemplateCacheMinutes *float64 `json:"templateCacheMinutes,omitempty"`
	// Accept messages in Netflow V5 format.
	V5Enabled *bool `json:"v5Enabled,omitempty"`
	// Accept messages in Netflow V9 format.
	V9Enabled *bool `json:"v9Enabled,omitempty"`
	// Accept messages in IPFIX format.
	IpfixEnabled *bool `json:"ipfixEnabled,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputNetflow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputNetflow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputNetflow) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputNetflow) GetType() CreateInputTypeNetflow {
	if c == nil {
		return CreateInputTypeNetflow("")
	}
	return c.Type
}

func (c *CreateInputInputNetflow) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputNetflow) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputNetflow) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputNetflow) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputNetflow) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputNetflow) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputNetflow) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputNetflow) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputNetflow) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputNetflow) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputNetflow) GetEnablePassThrough() *bool {
	if c == nil {
		return nil
	}
	return c.EnablePassThrough
}

func (c *CreateInputInputNetflow) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputNetflow) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputNetflow) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputInputNetflow) GetTemplateCacheMinutes() *float64 {
	if c == nil {
		return nil
	}
	return c.TemplateCacheMinutes
}

func (c *CreateInputInputNetflow) GetV5Enabled() *bool {
	if c == nil {
		return nil
	}
	return c.V5Enabled
}

func (c *CreateInputInputNetflow) GetV9Enabled() *bool {
	if c == nil {
		return nil
	}
	return c.V9Enabled
}

func (c *CreateInputInputNetflow) GetIpfixEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.IpfixEnabled
}

func (c *CreateInputInputNetflow) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputNetflow) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputNetflow) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputNetflow) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeWizWebhook string

const (
	CreateInputTypeWizWebhookWizWebhook CreateInputTypeWizWebhook = "wiz_webhook"
)

func (e CreateInputTypeWizWebhook) ToPointer() *CreateInputTypeWizWebhook {
	return &e
}
func (e *CreateInputTypeWizWebhook) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wiz_webhook":
		*e = CreateInputTypeWizWebhook(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeWizWebhook: %v", v)
	}
}

type CreateInputInputWizWebhook struct {
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     CreateInputTypeWizWebhook `json:"type"`
	Disabled *bool                     `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input. Wildcards are supported (such as /api/v*/hook). Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputWizWebhook) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputWizWebhook) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputWizWebhook) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputWizWebhook) GetType() CreateInputTypeWizWebhook {
	if c == nil {
		return CreateInputTypeWizWebhook("")
	}
	return c.Type
}

func (c *CreateInputInputWizWebhook) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputWizWebhook) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputWizWebhook) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputWizWebhook) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputWizWebhook) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputWizWebhook) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputWizWebhook) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputWizWebhook) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputWizWebhook) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputWizWebhook) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputWizWebhook) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputWizWebhook) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputWizWebhook) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputWizWebhook) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputWizWebhook) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputWizWebhook) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputWizWebhook) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputWizWebhook) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputWizWebhook) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputWizWebhook) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputWizWebhook) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputWizWebhook) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputWizWebhook) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputWizWebhook) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputWizWebhook) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputWizWebhook) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputWizWebhook) GetAllowedPaths() []string {
	if c == nil {
		return nil
	}
	return c.AllowedPaths
}

func (c *CreateInputInputWizWebhook) GetAllowedMethods() []string {
	if c == nil {
		return nil
	}
	return c.AllowedMethods
}

func (c *CreateInputInputWizWebhook) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if c == nil {
		return nil
	}
	return c.AuthTokensExt
}

func (c *CreateInputInputWizWebhook) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputWizWebhook) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputWizWebhook) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeWiz string

const (
	CreateInputTypeWizWiz CreateInputTypeWiz = "wiz"
)

func (e CreateInputTypeWiz) ToPointer() *CreateInputTypeWiz {
	return &e
}
func (e *CreateInputTypeWiz) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wiz":
		*e = CreateInputTypeWiz(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeWiz: %v", v)
	}
}

type CreateInputManageState struct {
}

func (c CreateInputManageState) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputManageState) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

// CreateInputContentConfigLogLevel - Collector runtime log level
type CreateInputContentConfigLogLevel string

const (
	CreateInputContentConfigLogLevelError CreateInputContentConfigLogLevel = "error"
	CreateInputContentConfigLogLevelWarn  CreateInputContentConfigLogLevel = "warn"
	CreateInputContentConfigLogLevelInfo  CreateInputContentConfigLogLevel = "info"
	CreateInputContentConfigLogLevelDebug CreateInputContentConfigLogLevel = "debug"
	CreateInputContentConfigLogLevelSilly CreateInputContentConfigLogLevel = "silly"
)

func (e CreateInputContentConfigLogLevel) ToPointer() *CreateInputContentConfigLogLevel {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputContentConfigLogLevel) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug", "silly":
			return true
		}
	}
	return false
}

type CreateInputContentConfigWiz struct {
	// The name of the Wiz query
	ContentType        string  `json:"contentType"`
	ContentDescription *string `json:"contentDescription,omitempty"`
	Enabled            *bool   `json:"enabled,omitempty"`
	// Track collection progress between consecutive scheduled executions
	StateTracking *bool `json:"stateTracking,omitempty"`
	// JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information.
	StateUpdateExpression *string `json:"stateUpdateExpression,omitempty"`
	// JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep.
	StateMergeExpression *string                 `json:"stateMergeExpression,omitempty"`
	ManageState          *CreateInputManageState `json:"manageState,omitempty"`
	// Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`.
	ContentQuery string `json:"contentQuery"`
	// A cron schedule on which to run this job
	CronSchedule string `json:"cronSchedule"`
	// Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
	Earliest string `json:"earliest"`
	// Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
	Latest string `json:"latest"`
	// Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// Collector runtime log level
	LogLevel *CreateInputContentConfigLogLevel `json:"logLevel,omitempty"`
	// Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages.
	MaxPages *float64 `json:"maxPages,omitempty"`
}

func (c CreateInputContentConfigWiz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputContentConfigWiz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputContentConfigWiz) GetContentType() string {
	if c == nil {
		return ""
	}
	return c.ContentType
}

func (c *CreateInputContentConfigWiz) GetContentDescription() *string {
	if c == nil {
		return nil
	}
	return c.ContentDescription
}

func (c *CreateInputContentConfigWiz) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputContentConfigWiz) GetStateTracking() *bool {
	if c == nil {
		return nil
	}
	return c.StateTracking
}

func (c *CreateInputContentConfigWiz) GetStateUpdateExpression() *string {
	if c == nil {
		return nil
	}
	return c.StateUpdateExpression
}

func (c *CreateInputContentConfigWiz) GetStateMergeExpression() *string {
	if c == nil {
		return nil
	}
	return c.StateMergeExpression
}

func (c *CreateInputContentConfigWiz) GetManageState() *CreateInputManageState {
	if c == nil {
		return nil
	}
	return c.ManageState
}

func (c *CreateInputContentConfigWiz) GetContentQuery() string {
	if c == nil {
		return ""
	}
	return c.ContentQuery
}

func (c *CreateInputContentConfigWiz) GetCronSchedule() string {
	if c == nil {
		return ""
	}
	return c.CronSchedule
}

func (c *CreateInputContentConfigWiz) GetEarliest() string {
	if c == nil {
		return ""
	}
	return c.Earliest
}

func (c *CreateInputContentConfigWiz) GetLatest() string {
	if c == nil {
		return ""
	}
	return c.Latest
}

func (c *CreateInputContentConfigWiz) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputContentConfigWiz) GetLogLevel() *CreateInputContentConfigLogLevel {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputContentConfigWiz) GetMaxPages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxPages
}

type CreateInputInputWiz struct {
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     CreateInputTypeWiz `json:"type"`
	Disabled *bool              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
	Endpoint string `json:"endpoint"`
	// The authentication URL to generate an OAuth token
	AuthURL string `json:"authUrl"`
	// The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
	AuthAudienceOverride *string `json:"authAudienceOverride,omitempty"`
	// The client ID of the Wiz application
	ClientID      string                        `json:"clientId"`
	ContentConfig []CreateInputContentConfigWiz `json:"contentConfig"`
	// HTTP request inactivity timeout. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType     `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `json:"authType,omitempty"`
	Description *string                                  `json:"description,omitempty"`
	// The client secret of the Wiz application
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'endpoint' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'endpoint' at runtime.
	TemplateEndpoint *string `json:"__template_endpoint,omitempty"`
	// Binds 'authUrl' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'authUrl' at runtime.
	TemplateAuthURL *string `json:"__template_authUrl,omitempty"`
	// Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime.
	TemplateClientID *string `json:"__template_clientId,omitempty"`
}

func (c CreateInputInputWiz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputWiz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputWiz) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputWiz) GetType() CreateInputTypeWiz {
	if c == nil {
		return CreateInputTypeWiz("")
	}
	return c.Type
}

func (c *CreateInputInputWiz) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputWiz) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputWiz) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputWiz) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputWiz) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputWiz) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputWiz) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputWiz) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputWiz) GetEndpoint() string {
	if c == nil {
		return ""
	}
	return c.Endpoint
}

func (c *CreateInputInputWiz) GetAuthURL() string {
	if c == nil {
		return ""
	}
	return c.AuthURL
}

func (c *CreateInputInputWiz) GetAuthAudienceOverride() *string {
	if c == nil {
		return nil
	}
	return c.AuthAudienceOverride
}

func (c *CreateInputInputWiz) GetClientID() string {
	if c == nil {
		return ""
	}
	return c.ClientID
}

func (c *CreateInputInputWiz) GetContentConfig() []CreateInputContentConfigWiz {
	if c == nil {
		return []CreateInputContentConfigWiz{}
	}
	return c.ContentConfig
}

func (c *CreateInputInputWiz) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputWiz) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputInputWiz) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputInputWiz) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputInputWiz) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputInputWiz) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputWiz) GetRetryRules() *components.RetryRulesType {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputInputWiz) GetAuthType() *components.AuthenticationMethodOptions1 {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputWiz) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputWiz) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateInputInputWiz) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputWiz) GetTemplateEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.TemplateEndpoint
}

func (c *CreateInputInputWiz) GetTemplateAuthURL() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAuthURL
}

func (c *CreateInputInputWiz) GetTemplateClientID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientID
}

type CreateInputInputJournalFilesType string

const (
	CreateInputInputJournalFilesTypeJournalFiles CreateInputInputJournalFilesType = "journal_files"
)

func (e CreateInputInputJournalFilesType) ToPointer() *CreateInputInputJournalFilesType {
	return &e
}
func (e *CreateInputInputJournalFilesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "journal_files":
		*e = CreateInputInputJournalFilesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputInputJournalFilesType: %v", v)
	}
}

type CreateInputInputJournalFilesRule struct {
	// JavaScript expression applied to Journal objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (c CreateInputInputJournalFilesRule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputJournalFilesRule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputJournalFilesRule) GetFilter() string {
	if c == nil {
		return ""
	}
	return c.Filter
}

func (c *CreateInputInputJournalFilesRule) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputInputJournalFiles struct {
	// Unique ID for this input
	ID       string                           `json:"id"`
	Type     CreateInputInputJournalFilesType `json:"type"`
	Disabled *bool                            `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
	Path string `json:"path"`
	// Time, in seconds, between scanning for journals.
	Interval *float64 `json:"interval,omitempty"`
	// The full path of discovered journals are matched against this wildcard list.
	Journals []string `json:"journals"`
	// Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
	Rules []CreateInputInputJournalFilesRule `json:"rules,omitempty"`
	// Skip log messages that are not part of the current boot session.
	CurrentBoot *bool `json:"currentBoot,omitempty"`
	// The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
}

func (c CreateInputInputJournalFiles) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputJournalFiles) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputJournalFiles) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputJournalFiles) GetType() CreateInputInputJournalFilesType {
	if c == nil {
		return CreateInputInputJournalFilesType("")
	}
	return c.Type
}

func (c *CreateInputInputJournalFiles) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputJournalFiles) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputJournalFiles) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputJournalFiles) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputJournalFiles) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputJournalFiles) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputJournalFiles) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputJournalFiles) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputJournalFiles) GetPath() string {
	if c == nil {
		return ""
	}
	return c.Path
}

func (c *CreateInputInputJournalFiles) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputJournalFiles) GetJournals() []string {
	if c == nil {
		return []string{}
	}
	return c.Journals
}

func (c *CreateInputInputJournalFiles) GetRules() []CreateInputInputJournalFilesRule {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *CreateInputInputJournalFiles) GetCurrentBoot() *bool {
	if c == nil {
		return nil
	}
	return c.CurrentBoot
}

func (c *CreateInputInputJournalFiles) GetMaxAgeDur() *string {
	if c == nil {
		return nil
	}
	return c.MaxAgeDur
}

func (c *CreateInputInputJournalFiles) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputJournalFiles) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeRawUDP string

const (
	CreateInputTypeRawUDPRawUDP CreateInputTypeRawUDP = "raw_udp"
)

func (e CreateInputTypeRawUDP) ToPointer() *CreateInputTypeRawUDP {
	return &e
}
func (e *CreateInputTypeRawUDP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "raw_udp":
		*e = CreateInputTypeRawUDP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeRawUDP: %v", v)
	}
}

type CreateInputInputRawUDP struct {
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     CreateInputTypeRawUDP `json:"type"`
	Disabled *bool                 `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
	IngestRawBytes *bool `json:"ingestRawBytes,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputRawUDP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputRawUDP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputRawUDP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputRawUDP) GetType() CreateInputTypeRawUDP {
	if c == nil {
		return CreateInputTypeRawUDP("")
	}
	return c.Type
}

func (c *CreateInputInputRawUDP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputRawUDP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputRawUDP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputRawUDP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputRawUDP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputRawUDP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputRawUDP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputRawUDP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputRawUDP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputRawUDP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputRawUDP) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputInputRawUDP) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputRawUDP) GetSingleMsgUDPPackets() *bool {
	if c == nil {
		return nil
	}
	return c.SingleMsgUDPPackets
}

func (c *CreateInputInputRawUDP) GetIngestRawBytes() *bool {
	if c == nil {
		return nil
	}
	return c.IngestRawBytes
}

func (c *CreateInputInputRawUDP) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputInputRawUDP) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputRawUDP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputRawUDP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputRawUDP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeWinEventLogs string

const (
	CreateInputTypeWinEventLogsWinEventLogs CreateInputTypeWinEventLogs = "win_event_logs"
)

func (e CreateInputTypeWinEventLogs) ToPointer() *CreateInputTypeWinEventLogs {
	return &e
}
func (e *CreateInputTypeWinEventLogs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "win_event_logs":
		*e = CreateInputTypeWinEventLogs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeWinEventLogs: %v", v)
	}
}

// CreateInputReadMode - Read all stored and future event logs, or only future events
type CreateInputReadMode string

const (
	// CreateInputReadModeOldest Entire log
	CreateInputReadModeOldest CreateInputReadMode = "oldest"
	// CreateInputReadModeNewest From last entry
	CreateInputReadModeNewest CreateInputReadMode = "newest"
)

func (e CreateInputReadMode) ToPointer() *CreateInputReadMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputReadMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "oldest", "newest":
			return true
		}
	}
	return false
}

// CreateInputEventFormat - Format of individual events
type CreateInputEventFormat string

const (
	// CreateInputEventFormatJSON JSON
	CreateInputEventFormatJSON CreateInputEventFormat = "json"
	// CreateInputEventFormatXML XML
	CreateInputEventFormatXML CreateInputEventFormat = "xml"
)

func (e CreateInputEventFormat) ToPointer() *CreateInputEventFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputEventFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "json", "xml":
			return true
		}
	}
	return false
}

type CreateInputInputWinEventLogs struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputTypeWinEventLogs `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
	LogNames []string `json:"logNames"`
	// Read all stored and future event logs, or only future events
	ReadMode *CreateInputReadMode `json:"readMode,omitempty"`
	// Format of individual events
	EventFormat *CreateInputEventFormat `json:"eventFormat,omitempty"`
	// Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
	DisableNativeModule *bool `json:"disableNativeModule,omitempty"`
	// Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
	Interval *float64 `json:"interval,omitempty"`
	// The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
	BatchSize *float64 `json:"batchSize,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// The maximum number of bytes in an event before it is flushed to the pipelines
	MaxEventBytes *float64 `json:"maxEventBytes,omitempty"`
	Description   *string  `json:"description,omitempty"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableJSONRendering *bool `json:"disableJsonRendering,omitempty"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableXMLRendering *bool `json:"disableXmlRendering,omitempty"`
}

func (c CreateInputInputWinEventLogs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputWinEventLogs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputWinEventLogs) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputWinEventLogs) GetType() CreateInputTypeWinEventLogs {
	if c == nil {
		return CreateInputTypeWinEventLogs("")
	}
	return c.Type
}

func (c *CreateInputInputWinEventLogs) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputWinEventLogs) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputWinEventLogs) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputWinEventLogs) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputWinEventLogs) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputWinEventLogs) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputWinEventLogs) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputWinEventLogs) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputWinEventLogs) GetLogNames() []string {
	if c == nil {
		return []string{}
	}
	return c.LogNames
}

func (c *CreateInputInputWinEventLogs) GetReadMode() *CreateInputReadMode {
	if c == nil {
		return nil
	}
	return c.ReadMode
}

func (c *CreateInputInputWinEventLogs) GetEventFormat() *CreateInputEventFormat {
	if c == nil {
		return nil
	}
	return c.EventFormat
}

func (c *CreateInputInputWinEventLogs) GetDisableNativeModule() *bool {
	if c == nil {
		return nil
	}
	return c.DisableNativeModule
}

func (c *CreateInputInputWinEventLogs) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputWinEventLogs) GetBatchSize() *float64 {
	if c == nil {
		return nil
	}
	return c.BatchSize
}

func (c *CreateInputInputWinEventLogs) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputWinEventLogs) GetMaxEventBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxEventBytes
}

func (c *CreateInputInputWinEventLogs) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputWinEventLogs) GetDisableJSONRendering() *bool {
	if c == nil {
		return nil
	}
	return c.DisableJSONRendering
}

func (c *CreateInputInputWinEventLogs) GetDisableXMLRendering() *bool {
	if c == nil {
		return nil
	}
	return c.DisableXMLRendering
}

type CreateInputTypeWef string

const (
	CreateInputTypeWefWef CreateInputTypeWef = "wef"
)

func (e CreateInputTypeWef) ToPointer() *CreateInputTypeWef {
	return &e
}
func (e *CreateInputTypeWef) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wef":
		*e = CreateInputTypeWef(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeWef: %v", v)
	}
}

// CreateInputAuthMethodAuthenticationMethod - How to authenticate incoming client connections
type CreateInputAuthMethodAuthenticationMethod string

const (
	// CreateInputAuthMethodAuthenticationMethodClientCert Client certificate
	CreateInputAuthMethodAuthenticationMethodClientCert CreateInputAuthMethodAuthenticationMethod = "clientCert"
	// CreateInputAuthMethodAuthenticationMethodKerberos Kerberos
	CreateInputAuthMethodAuthenticationMethodKerberos CreateInputAuthMethodAuthenticationMethod = "kerberos"
)

func (e CreateInputAuthMethodAuthenticationMethod) ToPointer() *CreateInputAuthMethodAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputAuthMethodAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "clientCert", "kerberos":
			return true
		}
	}
	return false
}

type CreateInputMTLSSettings struct {
	// Enable TLS
	Disabled *bool `json:"disabled,omitempty"`
	// Required for WEF certificate authentication
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Required for WEF certificate authentication
	RequestCert *bool `json:"requestCert,omitempty"`
	// Name of the predefined certificate
	CertificateName *string `json:"certificateName,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath string `json:"privKeyPath"`
	// Passphrase to use to decrypt private key
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath string `json:"certPath"`
	// Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
	CaPath string `json:"caPath"`
	// Regex matching allowable common names in peer certificates' subject attribute
	CommonNameRegex *string                                                    `json:"commonNameRegex,omitempty"`
	MinVersion      *components.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS `json:"minVersion,omitempty"`
	MaxVersion      *components.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS `json:"maxVersion,omitempty"`
	// Enable OCSP check of certificate
	OcspCheck *bool `json:"ocspCheck,omitempty"`
	Keytab    any   `json:"keytab,omitempty"`
	Principal any   `json:"principal,omitempty"`
	// If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors.
	OcspCheckFailClose *bool `json:"ocspCheckFailClose,omitempty"`
}

func (c CreateInputMTLSSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputMTLSSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputMTLSSettings) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputMTLSSettings) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputMTLSSettings) GetRequestCert() *bool {
	if c == nil {
		return nil
	}
	return c.RequestCert
}

func (c *CreateInputMTLSSettings) GetCertificateName() *string {
	if c == nil {
		return nil
	}
	return c.CertificateName
}

func (c *CreateInputMTLSSettings) GetPrivKeyPath() string {
	if c == nil {
		return ""
	}
	return c.PrivKeyPath
}

func (c *CreateInputMTLSSettings) GetPassphrase() *string {
	if c == nil {
		return nil
	}
	return c.Passphrase
}

func (c *CreateInputMTLSSettings) GetCertPath() string {
	if c == nil {
		return ""
	}
	return c.CertPath
}

func (c *CreateInputMTLSSettings) GetCaPath() string {
	if c == nil {
		return ""
	}
	return c.CaPath
}

func (c *CreateInputMTLSSettings) GetCommonNameRegex() *string {
	if c == nil {
		return nil
	}
	return c.CommonNameRegex
}

func (c *CreateInputMTLSSettings) GetMinVersion() *components.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS {
	if c == nil {
		return nil
	}
	return c.MinVersion
}

func (c *CreateInputMTLSSettings) GetMaxVersion() *components.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS {
	if c == nil {
		return nil
	}
	return c.MaxVersion
}

func (c *CreateInputMTLSSettings) GetOcspCheck() *bool {
	if c == nil {
		return nil
	}
	return c.OcspCheck
}

func (c *CreateInputMTLSSettings) GetKeytab() any {
	if c == nil {
		return nil
	}
	return c.Keytab
}

func (c *CreateInputMTLSSettings) GetPrincipal() any {
	if c == nil {
		return nil
	}
	return c.Principal
}

func (c *CreateInputMTLSSettings) GetOcspCheckFailClose() *bool {
	if c == nil {
		return nil
	}
	return c.OcspCheckFailClose
}

// CreateInputFormat - Content format in which the endpoint should deliver events
type CreateInputFormat string

const (
	CreateInputFormatRaw          CreateInputFormat = "Raw"
	CreateInputFormatRenderedText CreateInputFormat = "RenderedText"
)

func (e CreateInputFormat) ToPointer() *CreateInputFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "Raw", "RenderedText":
			return true
		}
	}
	return false
}

type CreateInputQueryBuilderMode string

const (
	CreateInputQueryBuilderModeSimple CreateInputQueryBuilderMode = "simple"
	CreateInputQueryBuilderModeXML    CreateInputQueryBuilderMode = "xml"
)

func (e CreateInputQueryBuilderMode) ToPointer() *CreateInputQueryBuilderMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputQueryBuilderMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "simple", "xml":
			return true
		}
	}
	return false
}

type CreateInputQuery struct {
	// The Path attribute from the relevant XML Select element
	Path string `json:"path"`
	// The XPath query inside the relevant XML Select element
	QueryExpression string `json:"queryExpression"`
}

func (c CreateInputQuery) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputQuery) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputQuery) GetPath() string {
	if c == nil {
		return ""
	}
	return c.Path
}

func (c *CreateInputQuery) GetQueryExpression() string {
	if c == nil {
		return ""
	}
	return c.QueryExpression
}

type CreateInputSubscription struct {
	SubscriptionName string `json:"subscriptionName"`
	// Version UUID for this subscription. If any subscription parameters are modified, this value will change.
	Version *string `json:"version,omitempty"`
	// Content format in which the endpoint should deliver events
	ContentFormat CreateInputFormat `json:"contentFormat"`
	// Maximum time (in seconds) between endpoint checkins before considering it unavailable
	HeartbeatInterval float64 `json:"heartbeatInterval"`
	// Interval (in seconds) over which the endpoint should collect events before sending them to Stream
	BatchTimeout float64 `json:"batchTimeout"`
	// Newly subscribed endpoints will send previously existing events. Disable to receive new events only.
	ReadExistingEvents *bool `json:"readExistingEvents,omitempty"`
	// Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details.
	SendBookmarks *bool `json:"sendBookmarks,omitempty"`
	// Receive compressed events from the source
	Compress *bool `json:"compress,omitempty"`
	// The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com
	Targets []string `json:"targets"`
	// The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US".
	Locale        *string                      `json:"locale,omitempty"`
	QuerySelector *CreateInputQueryBuilderMode `json:"querySelector,omitempty"`
	// Fields to add to events ingested under this subscription
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Queries  []CreateInputQuery             `json:"queries,omitempty"`
	// The XPath query to use for selecting events
	XMLQuery *string `json:"xmlQuery,omitempty"`
}

func (c CreateInputSubscription) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSubscription) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSubscription) GetSubscriptionName() string {
	if c == nil {
		return ""
	}
	return c.SubscriptionName
}

func (c *CreateInputSubscription) GetVersion() *string {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CreateInputSubscription) GetContentFormat() CreateInputFormat {
	if c == nil {
		return CreateInputFormat("")
	}
	return c.ContentFormat
}

func (c *CreateInputSubscription) GetHeartbeatInterval() float64 {
	if c == nil {
		return 0.0
	}
	return c.HeartbeatInterval
}

func (c *CreateInputSubscription) GetBatchTimeout() float64 {
	if c == nil {
		return 0.0
	}
	return c.BatchTimeout
}

func (c *CreateInputSubscription) GetReadExistingEvents() *bool {
	if c == nil {
		return nil
	}
	return c.ReadExistingEvents
}

func (c *CreateInputSubscription) GetSendBookmarks() *bool {
	if c == nil {
		return nil
	}
	return c.SendBookmarks
}

func (c *CreateInputSubscription) GetCompress() *bool {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputSubscription) GetTargets() []string {
	if c == nil {
		return []string{}
	}
	return c.Targets
}

func (c *CreateInputSubscription) GetLocale() *string {
	if c == nil {
		return nil
	}
	return c.Locale
}

func (c *CreateInputSubscription) GetQuerySelector() *CreateInputQueryBuilderMode {
	if c == nil {
		return nil
	}
	return c.QuerySelector
}

func (c *CreateInputSubscription) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSubscription) GetQueries() []CreateInputQuery {
	if c == nil {
		return nil
	}
	return c.Queries
}

func (c *CreateInputSubscription) GetXMLQuery() *string {
	if c == nil {
		return nil
	}
	return c.XMLQuery
}

type CreateInputInputWef struct {
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     CreateInputTypeWef `json:"type"`
	Disabled *bool              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// How to authenticate incoming client connections
	AuthMethod *CreateInputAuthMethodAuthenticationMethod `json:"authMethod,omitempty"`
	TLS        *CreateInputMTLSSettings                   `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
	CaFingerprint *string `json:"caFingerprint,omitempty"`
	// Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
	Keytab *string `json:"keytab,omitempty"`
	// Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
	Principal *string `json:"principal,omitempty"`
	// Allow events to be ingested even if their MachineID does not match the client certificate CN
	AllowMachineIDMismatch *bool `json:"allowMachineIdMismatch,omitempty"`
	// Subscriptions to events on forwarding endpoints
	Subscriptions []CreateInputSubscription `json:"subscriptions"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	// Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
	LogFingerprintMismatch *bool `json:"logFingerprintMismatch,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputWef) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputWef) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputWef) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputWef) GetType() CreateInputTypeWef {
	if c == nil {
		return CreateInputTypeWef("")
	}
	return c.Type
}

func (c *CreateInputInputWef) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputWef) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputWef) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputWef) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputWef) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputWef) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputWef) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputWef) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputWef) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputWef) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputWef) GetAuthMethod() *CreateInputAuthMethodAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.AuthMethod
}

func (c *CreateInputInputWef) GetTLS() *CreateInputMTLSSettings {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputWef) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputWef) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputWef) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputWef) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputWef) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputWef) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputWef) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputWef) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputWef) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputWef) GetCaFingerprint() *string {
	if c == nil {
		return nil
	}
	return c.CaFingerprint
}

func (c *CreateInputInputWef) GetKeytab() *string {
	if c == nil {
		return nil
	}
	return c.Keytab
}

func (c *CreateInputInputWef) GetPrincipal() *string {
	if c == nil {
		return nil
	}
	return c.Principal
}

func (c *CreateInputInputWef) GetAllowMachineIDMismatch() *bool {
	if c == nil {
		return nil
	}
	return c.AllowMachineIDMismatch
}

func (c *CreateInputInputWef) GetSubscriptions() []CreateInputSubscription {
	if c == nil {
		return []CreateInputSubscription{}
	}
	return c.Subscriptions
}

func (c *CreateInputInputWef) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputWef) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputWef) GetLogFingerprintMismatch() *bool {
	if c == nil {
		return nil
	}
	return c.LogFingerprintMismatch
}

func (c *CreateInputInputWef) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputWef) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeAppscope string

const (
	CreateInputTypeAppscopeAppscope CreateInputTypeAppscope = "appscope"
)

func (e CreateInputTypeAppscope) ToPointer() *CreateInputTypeAppscope {
	return &e
}
func (e *CreateInputTypeAppscope) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "appscope":
		*e = CreateInputTypeAppscope(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeAppscope: %v", v)
	}
}

type CreateInputAllow struct {
	// Specify the name of a process or family of processes.
	Procname string `json:"procname"`
	// Specify a string to substring-match against process command-line.
	Arg *string `json:"arg,omitempty"`
	// Choose a config to apply to processes that match the process name and/or argument.
	Config string `json:"config"`
}

func (c CreateInputAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputAllow) GetProcname() string {
	if c == nil {
		return ""
	}
	return c.Procname
}

func (c *CreateInputAllow) GetArg() *string {
	if c == nil {
		return nil
	}
	return c.Arg
}

func (c *CreateInputAllow) GetConfig() string {
	if c == nil {
		return ""
	}
	return c.Config
}

type CreateInputFilterAppscope struct {
	// Specify processes that AppScope should be loaded into, and the config to use.
	Allow []CreateInputAllow `json:"allow,omitempty"`
	// To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
	TransportURL *string `json:"transportURL,omitempty"`
}

func (c CreateInputFilterAppscope) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputFilterAppscope) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputFilterAppscope) GetAllow() []CreateInputAllow {
	if c == nil {
		return nil
	}
	return c.Allow
}

func (c *CreateInputFilterAppscope) GetTransportURL() *string {
	if c == nil {
		return nil
	}
	return c.TransportURL
}

type CreateInputPersistenceAppscope struct {
	// Spool events and metrics on disk for Cribl Edge and Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputPersistenceAppscope) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputPersistenceAppscope) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputPersistenceAppscope) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputPersistenceAppscope) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputPersistenceAppscope) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputPersistenceAppscope) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputPersistenceAppscope) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputPersistenceAppscope) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputInputAppscope struct {
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     CreateInputTypeAppscope `json:"type"`
	Disabled *bool                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
	EnableUnixPath *bool                           `json:"enableUnixPath,omitempty"`
	Filter         *CreateInputFilterAppscope      `json:"filter,omitempty"`
	Persistence    *CreateInputPersistenceAppscope `json:"persistence,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	Description *string                                                `json:"description,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `json:"host,omitempty"`
	// Port to listen on
	Port *float64                              `json:"port,omitempty"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Path to the UNIX domain socket to listen on.
	UnixSocketPath *string `json:"unixSocketPath,omitempty"`
	// Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
	UnixSocketPerms *string `json:"unixSocketPerms,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `json:"authToken,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputAppscope) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputAppscope) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputAppscope) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputAppscope) GetType() CreateInputTypeAppscope {
	if c == nil {
		return CreateInputTypeAppscope("")
	}
	return c.Type
}

func (c *CreateInputInputAppscope) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputAppscope) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputAppscope) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputAppscope) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputAppscope) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputAppscope) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputAppscope) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputAppscope) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputAppscope) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputAppscope) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputAppscope) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputInputAppscope) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputInputAppscope) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputInputAppscope) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputAppscope) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputAppscope) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputAppscope) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputAppscope) GetEnableUnixPath() *bool {
	if c == nil {
		return nil
	}
	return c.EnableUnixPath
}

func (c *CreateInputInputAppscope) GetFilter() *CreateInputFilterAppscope {
	if c == nil {
		return nil
	}
	return c.Filter
}

func (c *CreateInputInputAppscope) GetPersistence() *CreateInputPersistenceAppscope {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputInputAppscope) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputAppscope) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputAppscope) GetHost() *string {
	if c == nil {
		return nil
	}
	return c.Host
}

func (c *CreateInputInputAppscope) GetPort() *float64 {
	if c == nil {
		return nil
	}
	return c.Port
}

func (c *CreateInputInputAppscope) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputAppscope) GetUnixSocketPath() *string {
	if c == nil {
		return nil
	}
	return c.UnixSocketPath
}

func (c *CreateInputInputAppscope) GetUnixSocketPerms() *string {
	if c == nil {
		return nil
	}
	return c.UnixSocketPerms
}

func (c *CreateInputInputAppscope) GetAuthToken() *string {
	if c == nil {
		return nil
	}
	return c.AuthToken
}

func (c *CreateInputInputAppscope) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputAppscope) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputAppscope) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeTCP string

const (
	CreateInputTypeTCPTCP CreateInputTypeTCP = "tcp"
)

func (e CreateInputTypeTCP) ToPointer() *CreateInputTypeTCP {
	return &e
}
func (e *CreateInputTypeTCP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		*e = CreateInputTypeTCP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeTCP: %v", v)
	}
}

type CreateInputInputTCP struct {
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     CreateInputTypeTCP `json:"type"`
	Disabled *bool              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
	EnableHeader *bool                      `json:"enableHeader,omitempty"`
	Preprocess   *components.PreprocessType `json:"preprocess,omitempty"`
	Description  *string                    `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `json:"authToken,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputTCP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputTCP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputTCP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputTCP) GetType() CreateInputTypeTCP {
	if c == nil {
		return CreateInputTypeTCP("")
	}
	return c.Type
}

func (c *CreateInputInputTCP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputTCP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputTCP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputTCP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputTCP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputTCP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputTCP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputTCP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputTCP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputTCP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputTCP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputTCP) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputTCP) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputTCP) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputInputTCP) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputInputTCP) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputInputTCP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputTCP) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputTCP) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputTCP) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputTCP) GetEnableHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHeader
}

func (c *CreateInputInputTCP) GetPreprocess() *components.PreprocessType {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputInputTCP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputTCP) GetAuthToken() *string {
	if c == nil {
		return nil
	}
	return c.AuthToken
}

func (c *CreateInputInputTCP) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputTCP) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputTCP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputTCP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputInputFileType string

const (
	CreateInputInputFileTypeFile CreateInputInputFileType = "file"
)

func (e CreateInputInputFileType) ToPointer() *CreateInputInputFileType {
	return &e
}
func (e *CreateInputInputFileType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = CreateInputInputFileType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputInputFileType: %v", v)
	}
}

// CreateInputInputFileMode - Choose how to discover files to monitor
type CreateInputInputFileMode string

const (
	// CreateInputInputFileModeManual Manual
	CreateInputInputFileModeManual CreateInputInputFileMode = "manual"
	// CreateInputInputFileModeAuto Auto
	CreateInputInputFileModeAuto CreateInputInputFileMode = "auto"
)

func (e CreateInputInputFileMode) ToPointer() *CreateInputInputFileMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputInputFileMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "auto":
			return true
		}
	}
	return false
}

type CreateInputInputFile struct {
	// Unique ID for this input
	ID       string                   `json:"id"`
	Type     CreateInputInputFileType `json:"type"`
	Disabled *bool                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Choose how to discover files to monitor
	Mode *CreateInputInputFileMode `json:"mode,omitempty"`
	// Time, in seconds, between scanning for files
	Interval *float64 `json:"interval,omitempty"`
	// The full path of discovered files are matched against this wildcard list
	Filenames []string `json:"filenames,omitempty"`
	// Apply filename allowlist to file entries in archive file types, like tar or zip.
	FilterArchivedFiles *bool `json:"filterArchivedFiles,omitempty"`
	// Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
	TailOnly *bool `json:"tailOnly,omitempty"`
	// Time, in seconds, before an idle file is closed
	IdleTimeout *float64 `json:"idleTimeout,omitempty"`
	// The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
	MinAgeDur *string `json:"minAgeDur,omitempty"`
	// The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Skip files with modification times earlier than the maximum age duration
	CheckFileModTime *bool `json:"checkFileModTime,omitempty"`
	// Forces files containing binary data to be streamed as text
	ForceText *bool `json:"forceText,omitempty"`
	// Length of file header bytes to use in hash for unique file identification
	HashLen *float64 `json:"hashLen,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	Description         *string  `json:"description,omitempty"`
	// Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
	Path *string `json:"path,omitempty"`
	// Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
	Depth                     *float64 `json:"depth,omitempty"`
	SuppressMissingPathErrors *bool    `json:"suppressMissingPathErrors,omitempty"`
	// Delete files after they have been collected
	DeleteFiles *bool `json:"deleteFiles,omitempty"`
	// Salt the file hash with the Source file path. Ensures that all files with the same header hash, such as CSV files, are ingested. Moving or renaming the file, or toggling this after starting the Source will cause re-ingestion.
	SaltHash *bool `json:"saltHash,omitempty"`
	// Stream binary files as Base64-encoded chunks.
	IncludeUnidentifiableBinary *bool `json:"includeUnidentifiableBinary,omitempty"`
}

func (c CreateInputInputFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputFile) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputFile) GetType() CreateInputInputFileType {
	if c == nil {
		return CreateInputInputFileType("")
	}
	return c.Type
}

func (c *CreateInputInputFile) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputFile) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputFile) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputFile) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputFile) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputFile) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputFile) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputFile) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputFile) GetMode() *CreateInputInputFileMode {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputInputFile) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputFile) GetFilenames() []string {
	if c == nil {
		return nil
	}
	return c.Filenames
}

func (c *CreateInputInputFile) GetFilterArchivedFiles() *bool {
	if c == nil {
		return nil
	}
	return c.FilterArchivedFiles
}

func (c *CreateInputInputFile) GetTailOnly() *bool {
	if c == nil {
		return nil
	}
	return c.TailOnly
}

func (c *CreateInputInputFile) GetIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.IdleTimeout
}

func (c *CreateInputInputFile) GetMinAgeDur() *string {
	if c == nil {
		return nil
	}
	return c.MinAgeDur
}

func (c *CreateInputInputFile) GetMaxAgeDur() *string {
	if c == nil {
		return nil
	}
	return c.MaxAgeDur
}

func (c *CreateInputInputFile) GetCheckFileModTime() *bool {
	if c == nil {
		return nil
	}
	return c.CheckFileModTime
}

func (c *CreateInputInputFile) GetForceText() *bool {
	if c == nil {
		return nil
	}
	return c.ForceText
}

func (c *CreateInputInputFile) GetHashLen() *float64 {
	if c == nil {
		return nil
	}
	return c.HashLen
}

func (c *CreateInputInputFile) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputFile) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputFile) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputFile) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputFile) GetPath() *string {
	if c == nil {
		return nil
	}
	return c.Path
}

func (c *CreateInputInputFile) GetDepth() *float64 {
	if c == nil {
		return nil
	}
	return c.Depth
}

func (c *CreateInputInputFile) GetSuppressMissingPathErrors() *bool {
	if c == nil {
		return nil
	}
	return c.SuppressMissingPathErrors
}

func (c *CreateInputInputFile) GetDeleteFiles() *bool {
	if c == nil {
		return nil
	}
	return c.DeleteFiles
}

func (c *CreateInputInputFile) GetSaltHash() *bool {
	if c == nil {
		return nil
	}
	return c.SaltHash
}

func (c *CreateInputInputFile) GetIncludeUnidentifiableBinary() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeUnidentifiableBinary
}

type CreateInputInputSyslogType2 string

const (
	CreateInputInputSyslogType2Syslog CreateInputInputSyslogType2 = "syslog"
)

func (e CreateInputInputSyslogType2) ToPointer() *CreateInputInputSyslogType2 {
	return &e
}
func (e *CreateInputInputSyslogType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = CreateInputInputSyslogType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputInputSyslogType2: %v", v)
	}
}

type CreateInputInputSyslogSyslog2 struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputInputSyslogType2 `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort float64 `json:"tcpPort"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Timezone to assign to timestamps without timezone info
	TimestampTimezone *string `json:"timestampTimezone,omitempty"`
	// Treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Wildcard list of fields to keep from source data; * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting *bool `json:"octetCounting,omitempty"`
	// Enable if we should infer the syslog framing of the incoming messages.
	InferFraming *bool `json:"inferFraming,omitempty"`
	// Enable if we should infer octet counting only if the messages comply with RFC 5424.
	StrictlyInferOctetCounting *bool `json:"strictlyInferOctetCounting,omitempty"`
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`
	// Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64                              `json:"socketMaxLifespan,omitempty"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `json:"enableLoadBalancing,omitempty"`
	Description         *string `json:"description,omitempty"`
	// When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
	EnableEnhancedProxyHeaderParsing *bool `json:"enableEnhancedProxyHeaderParsing,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime.
	TemplateUDPPort *string `json:"__template_udpPort,omitempty"`
	// Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime.
	TemplateTCPPort *string `json:"__template_tcpPort,omitempty"`
}

func (c CreateInputInputSyslogSyslog2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSyslogSyslog2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSyslogSyslog2) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSyslogSyslog2) GetType() CreateInputInputSyslogType2 {
	if c == nil {
		return CreateInputInputSyslogType2("")
	}
	return c.Type
}

func (c *CreateInputInputSyslogSyslog2) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSyslogSyslog2) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSyslogSyslog2) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSyslogSyslog2) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSyslogSyslog2) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSyslogSyslog2) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSyslogSyslog2) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSyslogSyslog2) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSyslogSyslog2) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputSyslogSyslog2) GetUDPPort() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPPort
}

func (c *CreateInputInputSyslogSyslog2) GetTCPPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.TCPPort
}

func (c *CreateInputInputSyslogSyslog2) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputInputSyslogSyslog2) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputSyslogSyslog2) GetTimestampTimezone() *string {
	if c == nil {
		return nil
	}
	return c.TimestampTimezone
}

func (c *CreateInputInputSyslogSyslog2) GetSingleMsgUDPPackets() *bool {
	if c == nil {
		return nil
	}
	return c.SingleMsgUDPPackets
}

func (c *CreateInputInputSyslogSyslog2) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputSyslogSyslog2) GetKeepFieldsList() []string {
	if c == nil {
		return nil
	}
	return c.KeepFieldsList
}

func (c *CreateInputInputSyslogSyslog2) GetOctetCounting() *bool {
	if c == nil {
		return nil
	}
	return c.OctetCounting
}

func (c *CreateInputInputSyslogSyslog2) GetInferFraming() *bool {
	if c == nil {
		return nil
	}
	return c.InferFraming
}

func (c *CreateInputInputSyslogSyslog2) GetStrictlyInferOctetCounting() *bool {
	if c == nil {
		return nil
	}
	return c.StrictlyInferOctetCounting
}

func (c *CreateInputInputSyslogSyslog2) GetAllowNonStandardAppName() *bool {
	if c == nil {
		return nil
	}
	return c.AllowNonStandardAppName
}

func (c *CreateInputInputSyslogSyslog2) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputSyslogSyslog2) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputInputSyslogSyslog2) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputInputSyslogSyslog2) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputInputSyslogSyslog2) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputSyslogSyslog2) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSyslogSyslog2) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputInputSyslogSyslog2) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputInputSyslogSyslog2) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputSyslogSyslog2) GetEnableEnhancedProxyHeaderParsing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableEnhancedProxyHeaderParsing
}

func (c *CreateInputInputSyslogSyslog2) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputSyslogSyslog2) GetTemplateUDPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateUDPPort
}

func (c *CreateInputInputSyslogSyslog2) GetTemplateTCPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTCPPort
}

type CreateInputInputSyslogType1 string

const (
	CreateInputInputSyslogType1Syslog CreateInputInputSyslogType1 = "syslog"
)

func (e CreateInputInputSyslogType1) ToPointer() *CreateInputInputSyslogType1 {
	return &e
}
func (e *CreateInputInputSyslogType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = CreateInputInputSyslogType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputInputSyslogType1: %v", v)
	}
}

type CreateInputInputSyslogSyslog1 struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputInputSyslogType1 `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort float64 `json:"udpPort"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Timezone to assign to timestamps without timezone info
	TimestampTimezone *string `json:"timestampTimezone,omitempty"`
	// Treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Wildcard list of fields to keep from source data; * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting *bool `json:"octetCounting,omitempty"`
	// Enable if we should infer the syslog framing of the incoming messages.
	InferFraming *bool `json:"inferFraming,omitempty"`
	// Enable if we should infer octet counting only if the messages comply with RFC 5424.
	StrictlyInferOctetCounting *bool `json:"strictlyInferOctetCounting,omitempty"`
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`
	// Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64                              `json:"socketMaxLifespan,omitempty"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `json:"enableLoadBalancing,omitempty"`
	Description         *string `json:"description,omitempty"`
	// When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
	EnableEnhancedProxyHeaderParsing *bool `json:"enableEnhancedProxyHeaderParsing,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime.
	TemplateUDPPort *string `json:"__template_udpPort,omitempty"`
	// Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime.
	TemplateTCPPort *string `json:"__template_tcpPort,omitempty"`
}

func (c CreateInputInputSyslogSyslog1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSyslogSyslog1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSyslogSyslog1) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSyslogSyslog1) GetType() CreateInputInputSyslogType1 {
	if c == nil {
		return CreateInputInputSyslogType1("")
	}
	return c.Type
}

func (c *CreateInputInputSyslogSyslog1) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSyslogSyslog1) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSyslogSyslog1) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSyslogSyslog1) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSyslogSyslog1) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSyslogSyslog1) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSyslogSyslog1) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSyslogSyslog1) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSyslogSyslog1) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputSyslogSyslog1) GetUDPPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.UDPPort
}

func (c *CreateInputInputSyslogSyslog1) GetTCPPort() *float64 {
	if c == nil {
		return nil
	}
	return c.TCPPort
}

func (c *CreateInputInputSyslogSyslog1) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputInputSyslogSyslog1) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputSyslogSyslog1) GetTimestampTimezone() *string {
	if c == nil {
		return nil
	}
	return c.TimestampTimezone
}

func (c *CreateInputInputSyslogSyslog1) GetSingleMsgUDPPackets() *bool {
	if c == nil {
		return nil
	}
	return c.SingleMsgUDPPackets
}

func (c *CreateInputInputSyslogSyslog1) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputSyslogSyslog1) GetKeepFieldsList() []string {
	if c == nil {
		return nil
	}
	return c.KeepFieldsList
}

func (c *CreateInputInputSyslogSyslog1) GetOctetCounting() *bool {
	if c == nil {
		return nil
	}
	return c.OctetCounting
}

func (c *CreateInputInputSyslogSyslog1) GetInferFraming() *bool {
	if c == nil {
		return nil
	}
	return c.InferFraming
}

func (c *CreateInputInputSyslogSyslog1) GetStrictlyInferOctetCounting() *bool {
	if c == nil {
		return nil
	}
	return c.StrictlyInferOctetCounting
}

func (c *CreateInputInputSyslogSyslog1) GetAllowNonStandardAppName() *bool {
	if c == nil {
		return nil
	}
	return c.AllowNonStandardAppName
}

func (c *CreateInputInputSyslogSyslog1) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputSyslogSyslog1) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputInputSyslogSyslog1) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputInputSyslogSyslog1) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputInputSyslogSyslog1) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputSyslogSyslog1) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSyslogSyslog1) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputInputSyslogSyslog1) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputInputSyslogSyslog1) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputSyslogSyslog1) GetEnableEnhancedProxyHeaderParsing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableEnhancedProxyHeaderParsing
}

func (c *CreateInputInputSyslogSyslog1) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputSyslogSyslog1) GetTemplateUDPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateUDPPort
}

func (c *CreateInputInputSyslogSyslog1) GetTemplateTCPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTCPPort
}

type CreateInputInputSyslogUnionType string

const (
	CreateInputInputSyslogUnionTypeCreateInputInputSyslogSyslog1 CreateInputInputSyslogUnionType = "createInput_InputSyslog_Syslog_1"
	CreateInputInputSyslogUnionTypeCreateInputInputSyslogSyslog2 CreateInputInputSyslogUnionType = "createInput_InputSyslog_Syslog_2"
)

type CreateInputInputSyslogUnion struct {
	CreateInputInputSyslogSyslog1 *CreateInputInputSyslogSyslog1 `queryParam:"inline" union:"member"`
	CreateInputInputSyslogSyslog2 *CreateInputInputSyslogSyslog2 `queryParam:"inline" union:"member"`

	Type CreateInputInputSyslogUnionType
}

func CreateCreateInputInputSyslogUnionCreateInputInputSyslogSyslog1(createInputInputSyslogSyslog1 CreateInputInputSyslogSyslog1) CreateInputInputSyslogUnion {
	typ := CreateInputInputSyslogUnionTypeCreateInputInputSyslogSyslog1

	return CreateInputInputSyslogUnion{
		CreateInputInputSyslogSyslog1: &createInputInputSyslogSyslog1,
		Type:                          typ,
	}
}

func CreateCreateInputInputSyslogUnionCreateInputInputSyslogSyslog2(createInputInputSyslogSyslog2 CreateInputInputSyslogSyslog2) CreateInputInputSyslogUnion {
	typ := CreateInputInputSyslogUnionTypeCreateInputInputSyslogSyslog2

	return CreateInputInputSyslogUnion{
		CreateInputInputSyslogSyslog2: &createInputInputSyslogSyslog2,
		Type:                          typ,
	}
}

func (u *CreateInputInputSyslogUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var createInputInputSyslogSyslog1 CreateInputInputSyslogSyslog1 = CreateInputInputSyslogSyslog1{}
	if err := utils.UnmarshalJSON(data, &createInputInputSyslogSyslog1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CreateInputInputSyslogUnionTypeCreateInputInputSyslogSyslog1,
			Value: &createInputInputSyslogSyslog1,
		})
	}

	var createInputInputSyslogSyslog2 CreateInputInputSyslogSyslog2 = CreateInputInputSyslogSyslog2{}
	if err := utils.UnmarshalJSON(data, &createInputInputSyslogSyslog2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CreateInputInputSyslogUnionTypeCreateInputInputSyslogSyslog2,
			Value: &createInputInputSyslogSyslog2,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputInputSyslogUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputInputSyslogUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(CreateInputInputSyslogUnionType)
	switch best.Type {
	case CreateInputInputSyslogUnionTypeCreateInputInputSyslogSyslog1:
		u.CreateInputInputSyslogSyslog1 = best.Value.(*CreateInputInputSyslogSyslog1)
		return nil
	case CreateInputInputSyslogUnionTypeCreateInputInputSyslogSyslog2:
		u.CreateInputInputSyslogSyslog2 = best.Value.(*CreateInputInputSyslogSyslog2)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputInputSyslogUnion", string(data))
}

func (u CreateInputInputSyslogUnion) MarshalJSON() ([]byte, error) {
	if u.CreateInputInputSyslogSyslog1 != nil {
		return utils.MarshalJSON(u.CreateInputInputSyslogSyslog1, "", true)
	}

	if u.CreateInputInputSyslogSyslog2 != nil {
		return utils.MarshalJSON(u.CreateInputInputSyslogSyslog2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateInputInputSyslogUnion: all fields are null")
}

type CreateInputTypeSqs string

const (
	CreateInputTypeSqsSqs CreateInputTypeSqs = "sqs"
)

func (e CreateInputTypeSqs) ToPointer() *CreateInputTypeSqs {
	return &e
}
func (e *CreateInputTypeSqs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sqs":
		*e = CreateInputTypeSqs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeSqs: %v", v)
	}
}

// CreateInputQueueType - The queue type used (or created)
type CreateInputQueueType string

const (
	// CreateInputQueueTypeStandard Standard
	CreateInputQueueTypeStandard CreateInputQueueType = "standard"
	// CreateInputQueueTypeFifo FIFO
	CreateInputQueueTypeFifo CreateInputQueueType = "fifo"
)

func (e CreateInputQueueType) ToPointer() *CreateInputQueueType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputQueueType) IsExact() bool {
	if e != nil {
		switch *e {
		case "standard", "fifo":
			return true
		}
	}
	return false
}

type CreateInputInputSqs struct {
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     CreateInputTypeSqs `json:"type"`
	Disabled *bool              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// The queue type used (or created)
	QueueType CreateInputQueueType `json:"queueType"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// Create queue if it does not exist
	CreateQueue *bool `json:"createQueue,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing SQS requests
	SignatureVersion *components.SignatureVersionOptions3 `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Use Assume Role credentials to access SQS
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	Description *string  `json:"description,omitempty"`
	AwsAPIKey   *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputInputSqs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSqs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSqs) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSqs) GetType() CreateInputTypeSqs {
	if c == nil {
		return CreateInputTypeSqs("")
	}
	return c.Type
}

func (c *CreateInputInputSqs) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSqs) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSqs) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSqs) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSqs) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSqs) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSqs) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSqs) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSqs) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputInputSqs) GetQueueType() CreateInputQueueType {
	if c == nil {
		return CreateInputQueueType("")
	}
	return c.QueueType
}

func (c *CreateInputInputSqs) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputInputSqs) GetCreateQueue() *bool {
	if c == nil {
		return nil
	}
	return c.CreateQueue
}

func (c *CreateInputInputSqs) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputSqs) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputSqs) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputInputSqs) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputSqs) GetSignatureVersion() *components.SignatureVersionOptions3 {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputSqs) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputSqs) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputSqs) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputSqs) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputSqs) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputSqs) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputSqs) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputInputSqs) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputInputSqs) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSqs) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputInputSqs) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputSqs) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputSqs) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputSqs) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputInputSqs) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputInputSqs) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputInputSqs) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputSqs) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputSqs) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputSqs) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputInputSqs) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputTypeModelDrivenTelemetry string

const (
	CreateInputTypeModelDrivenTelemetryModelDrivenTelemetry CreateInputTypeModelDrivenTelemetry = "model_driven_telemetry"
)

func (e CreateInputTypeModelDrivenTelemetry) ToPointer() *CreateInputTypeModelDrivenTelemetry {
	return &e
}
func (e *CreateInputTypeModelDrivenTelemetry) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "model_driven_telemetry":
		*e = CreateInputTypeModelDrivenTelemetry(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeModelDrivenTelemetry: %v", v)
	}
}

type CreateInputInputModelDrivenTelemetry struct {
	// Unique ID for this input
	ID       string                              `json:"id"`
	Type     CreateInputTypeModelDrivenTelemetry `json:"type"`
	Disabled *bool                               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
	ShutdownTimeoutMs *float64 `json:"shutdownTimeoutMs,omitempty"`
	Description       *string  `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputModelDrivenTelemetry) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputModelDrivenTelemetry) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputModelDrivenTelemetry) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputModelDrivenTelemetry) GetType() CreateInputTypeModelDrivenTelemetry {
	if c == nil {
		return CreateInputTypeModelDrivenTelemetry("")
	}
	return c.Type
}

func (c *CreateInputInputModelDrivenTelemetry) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputModelDrivenTelemetry) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputModelDrivenTelemetry) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputModelDrivenTelemetry) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputModelDrivenTelemetry) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputModelDrivenTelemetry) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputModelDrivenTelemetry) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputModelDrivenTelemetry) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputModelDrivenTelemetry) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputModelDrivenTelemetry) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputModelDrivenTelemetry) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputModelDrivenTelemetry) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputModelDrivenTelemetry) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputModelDrivenTelemetry) GetShutdownTimeoutMs() *float64 {
	if c == nil {
		return nil
	}
	return c.ShutdownTimeoutMs
}

func (c *CreateInputInputModelDrivenTelemetry) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputModelDrivenTelemetry) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputModelDrivenTelemetry) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeOpenTelemetry string

const (
	CreateInputTypeOpenTelemetryOpenTelemetry CreateInputTypeOpenTelemetry = "open_telemetry"
)

func (e CreateInputTypeOpenTelemetry) ToPointer() *CreateInputTypeOpenTelemetry {
	return &e
}
func (e *CreateInputTypeOpenTelemetry) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "open_telemetry":
		*e = CreateInputTypeOpenTelemetry(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeOpenTelemetry: %v", v)
	}
}

// CreateInputProtocol - Select whether to leverage gRPC or HTTP for OpenTelemetry
type CreateInputProtocol string

const (
	// CreateInputProtocolGrpc gRPC
	CreateInputProtocolGrpc CreateInputProtocol = "grpc"
	// CreateInputProtocolHTTP HTTP
	CreateInputProtocolHTTP CreateInputProtocol = "http"
)

func (e CreateInputProtocol) ToPointer() *CreateInputProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "grpc", "http":
			return true
		}
	}
	return false
}

// CreateInputOTLPVersion - The version of OTLP Protobuf definitions to use when interpreting received data
type CreateInputOTLPVersion string

const (
	// CreateInputOTLPVersionZeroDot10Dot0 0.10.0
	CreateInputOTLPVersionZeroDot10Dot0 CreateInputOTLPVersion = "0.10.0"
	// CreateInputOTLPVersionOneDot3Dot1 1.3.1
	CreateInputOTLPVersionOneDot3Dot1 CreateInputOTLPVersion = "1.3.1"
)

func (e CreateInputOTLPVersion) ToPointer() *CreateInputOTLPVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputOTLPVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "0.10.0", "1.3.1":
			return true
		}
	}
	return false
}

type CreateInputInputOpenTelemetry struct {
	// Unique ID for this input
	ID       string                       `json:"id"`
	Type     CreateInputTypeOpenTelemetry `json:"type"`
	Disabled *bool                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket  *int64 `json:"maxRequestsPerSocket,omitempty"`
	EnableProxyHeader     any    `json:"enableProxyHeader,omitempty"`
	CaptureHeaders        any    `json:"captureHeaders,omitempty"`
	ActivityLogSampleRate any    `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Select whether to leverage gRPC or HTTP for OpenTelemetry
	Protocol *CreateInputProtocol `json:"protocol,omitempty"`
	// Enable to extract each incoming span to a separate event
	ExtractSpans *bool `json:"extractSpans,omitempty"`
	// Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`
	// The version of OTLP Protobuf definitions to use when interpreting received data
	OtlpVersion *CreateInputOTLPVersion `json:"otlpVersion,omitempty"`
	// OpenTelemetry authentication type
	AuthType *components.AuthenticationTypeOptions `json:"authType,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Username     *string  `json:"username,omitempty"`
	Password     *string  `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Enable to extract each incoming log record to a separate event
	ExtractLogs *bool `json:"extractLogs,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputOpenTelemetry) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputOpenTelemetry) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputOpenTelemetry) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputOpenTelemetry) GetType() CreateInputTypeOpenTelemetry {
	if c == nil {
		return CreateInputTypeOpenTelemetry("")
	}
	return c.Type
}

func (c *CreateInputInputOpenTelemetry) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputOpenTelemetry) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputOpenTelemetry) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputOpenTelemetry) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputOpenTelemetry) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputOpenTelemetry) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputOpenTelemetry) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputOpenTelemetry) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputOpenTelemetry) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputOpenTelemetry) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputOpenTelemetry) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputOpenTelemetry) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputOpenTelemetry) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputOpenTelemetry) GetEnableProxyHeader() any {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputOpenTelemetry) GetCaptureHeaders() any {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputOpenTelemetry) GetActivityLogSampleRate() any {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputOpenTelemetry) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputOpenTelemetry) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputOpenTelemetry) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputOpenTelemetry) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputOpenTelemetry) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputOpenTelemetry) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputOpenTelemetry) GetProtocol() *CreateInputProtocol {
	if c == nil {
		return nil
	}
	return c.Protocol
}

func (c *CreateInputInputOpenTelemetry) GetExtractSpans() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractSpans
}

func (c *CreateInputInputOpenTelemetry) GetExtractMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractMetrics
}

func (c *CreateInputInputOpenTelemetry) GetOtlpVersion() *CreateInputOTLPVersion {
	if c == nil {
		return nil
	}
	return c.OtlpVersion
}

func (c *CreateInputInputOpenTelemetry) GetAuthType() *components.AuthenticationTypeOptions {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputOpenTelemetry) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputOpenTelemetry) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputOpenTelemetry) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputOpenTelemetry) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputInputOpenTelemetry) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputInputOpenTelemetry) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputInputOpenTelemetry) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputInputOpenTelemetry) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputOpenTelemetry) GetExtractLogs() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractLogs
}

func (c *CreateInputInputOpenTelemetry) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputOpenTelemetry) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeSnmp string

const (
	CreateInputTypeSnmpSnmp CreateInputTypeSnmp = "snmp"
)

func (e CreateInputTypeSnmp) ToPointer() *CreateInputTypeSnmp {
	return &e
}
func (e *CreateInputTypeSnmp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snmp":
		*e = CreateInputTypeSnmp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeSnmp: %v", v)
	}
}

type CreateInputV3User struct {
	Name         string                                                                       `json:"name"`
	AuthProtocol *components.AuthenticationProtocolOptionsV3User                              `json:"authProtocol,omitempty"`
	AuthKey      *string                                                                      `json:"authKey,omitempty"`
	PrivProtocol *components.PrivacyProtocolOptionsSnmpTrapSerializeV3UserAuthProtocolNotNone `json:"privProtocol,omitempty"`
	PrivKey      *string                                                                      `json:"privKey,omitempty"`
}

func (c CreateInputV3User) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputV3User) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputV3User) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateInputV3User) GetAuthProtocol() *components.AuthenticationProtocolOptionsV3User {
	if c == nil {
		return nil
	}
	return c.AuthProtocol
}

func (c *CreateInputV3User) GetAuthKey() *string {
	if c == nil {
		return nil
	}
	return c.AuthKey
}

func (c *CreateInputV3User) GetPrivProtocol() *components.PrivacyProtocolOptionsSnmpTrapSerializeV3UserAuthProtocolNotNone {
	if c == nil {
		return nil
	}
	return c.PrivProtocol
}

func (c *CreateInputV3User) GetPrivKey() *string {
	if c == nil {
		return nil
	}
	return c.PrivKey
}

// CreateInputSNMPv3Authentication - Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
type CreateInputSNMPv3Authentication struct {
	V3AuthEnabled bool `json:"v3AuthEnabled"`
	// Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps.
	AllowUnmatchedTrap *bool `json:"allowUnmatchedTrap,omitempty"`
	// User credentials for receiving v3 traps
	V3Users []CreateInputV3User `json:"v3Users,omitempty"`
}

func (c CreateInputSNMPv3Authentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSNMPv3Authentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSNMPv3Authentication) GetV3AuthEnabled() bool {
	if c == nil {
		return false
	}
	return c.V3AuthEnabled
}

func (c *CreateInputSNMPv3Authentication) GetAllowUnmatchedTrap() *bool {
	if c == nil {
		return nil
	}
	return c.AllowUnmatchedTrap
}

func (c *CreateInputSNMPv3Authentication) GetV3Users() []CreateInputV3User {
	if c == nil {
		return nil
	}
	return c.V3Users
}

type CreateInputInputSnmp struct {
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     CreateInputTypeSnmp `json:"type"`
	Disabled *bool               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// UDP port to receive SNMP traps on. Defaults to 162.
	Port float64 `json:"port"`
	// Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
	SnmpV3Auth *CreateInputSNMPv3Authentication `json:"snmpV3Auth,omitempty"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// If enabled, parses varbinds as an array of objects that include OID, value, and type
	VarbindsWithTypes *bool `json:"varbindsWithTypes,omitempty"`
	// If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
	BestEffortParsing *bool   `json:"bestEffortParsing,omitempty"`
	Description       *string `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputSnmp) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSnmp) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSnmp) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSnmp) GetType() CreateInputTypeSnmp {
	if c == nil {
		return CreateInputTypeSnmp("")
	}
	return c.Type
}

func (c *CreateInputInputSnmp) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSnmp) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSnmp) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSnmp) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSnmp) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSnmp) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSnmp) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSnmp) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSnmp) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputSnmp) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputSnmp) GetSnmpV3Auth() *CreateInputSNMPv3Authentication {
	if c == nil {
		return nil
	}
	return c.SnmpV3Auth
}

func (c *CreateInputInputSnmp) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputInputSnmp) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputSnmp) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSnmp) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputInputSnmp) GetVarbindsWithTypes() *bool {
	if c == nil {
		return nil
	}
	return c.VarbindsWithTypes
}

func (c *CreateInputInputSnmp) GetBestEffortParsing() *bool {
	if c == nil {
		return nil
	}
	return c.BestEffortParsing
}

func (c *CreateInputInputSnmp) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputSnmp) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputSnmp) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeS3Inventory string

const (
	CreateInputTypeS3InventoryS3Inventory CreateInputTypeS3Inventory = "s3_inventory"
)

func (e CreateInputTypeS3Inventory) ToPointer() *CreateInputTypeS3Inventory {
	return &e
}
func (e *CreateInputTypeS3Inventory) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3_inventory":
		*e = CreateInputTypeS3Inventory(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeS3Inventory: %v", v)
	}
}

type CreateInputInputS3Inventory struct {
	// Unique ID for this input
	ID       string                     `json:"id"`
	Type     CreateInputTypeS3Inventory `json:"type"`
	Disabled *bool                      `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `json:"includeSqsMetadata,omitempty"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                      `json:"enableSQSAssumeRole,omitempty"`
	Preprocess          *components.PreprocessType `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `json:"parquetChunkDownloadTimeout,omitempty"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	// Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
	ChecksumSuffix *string `json:"checksumSuffix,omitempty"`
	// Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
	MaxManifestSizeKB *int64 `json:"maxManifestSizeKB,omitempty"`
	// If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
	ValidateInventoryFiles *bool   `json:"validateInventoryFiles,omitempty"`
	Description            *string `json:"description,omitempty"`
	AwsAPIKey              *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputInputS3Inventory) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputS3Inventory) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputS3Inventory) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputS3Inventory) GetType() CreateInputTypeS3Inventory {
	if c == nil {
		return CreateInputTypeS3Inventory("")
	}
	return c.Type
}

func (c *CreateInputInputS3Inventory) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputS3Inventory) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputS3Inventory) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputS3Inventory) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputS3Inventory) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputS3Inventory) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputS3Inventory) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputS3Inventory) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputS3Inventory) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputInputS3Inventory) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputInputS3Inventory) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputInputS3Inventory) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputS3Inventory) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputS3Inventory) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputInputS3Inventory) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputS3Inventory) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputS3Inventory) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputS3Inventory) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputS3Inventory) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputS3Inventory) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputS3Inventory) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputInputS3Inventory) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputInputS3Inventory) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputInputS3Inventory) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputS3Inventory) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputInputS3Inventory) GetIncludeSqsMetadata() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeSqsMetadata
}

func (c *CreateInputInputS3Inventory) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputS3Inventory) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputS3Inventory) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputS3Inventory) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputS3Inventory) GetEnableSQSAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableSQSAssumeRole
}

func (c *CreateInputInputS3Inventory) GetPreprocess() *components.PreprocessType {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputInputS3Inventory) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputS3Inventory) GetParquetChunkSizeMB() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkSizeMB
}

func (c *CreateInputInputS3Inventory) GetParquetChunkDownloadTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkDownloadTimeout
}

func (c *CreateInputInputS3Inventory) GetCheckpointing() *components.CheckpointingType {
	if c == nil {
		return nil
	}
	return c.Checkpointing
}

func (c *CreateInputInputS3Inventory) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputInputS3Inventory) GetChecksumSuffix() *string {
	if c == nil {
		return nil
	}
	return c.ChecksumSuffix
}

func (c *CreateInputInputS3Inventory) GetMaxManifestSizeKB() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxManifestSizeKB
}

func (c *CreateInputInputS3Inventory) GetValidateInventoryFiles() *bool {
	if c == nil {
		return nil
	}
	return c.ValidateInventoryFiles
}

func (c *CreateInputInputS3Inventory) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputS3Inventory) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputS3Inventory) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputS3Inventory) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if c == nil {
		return nil
	}
	return c.TagAfterProcessing
}

func (c *CreateInputInputS3Inventory) GetProcessedTagKey() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagKey
}

func (c *CreateInputInputS3Inventory) GetProcessedTagValue() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagValue
}

func (c *CreateInputInputS3Inventory) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputInputS3Inventory) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputInputS3Inventory) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputS3Inventory) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputS3Inventory) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputS3Inventory) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputInputS3Inventory) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputTypeS3 string

const (
	CreateInputTypeS3S3 CreateInputTypeS3 = "s3"
)

func (e CreateInputTypeS3) ToPointer() *CreateInputTypeS3 {
	return &e
}
func (e *CreateInputTypeS3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3":
		*e = CreateInputTypeS3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeS3: %v", v)
	}
}

type CreateInputInputS3 struct {
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     CreateInputTypeS3 `json:"type"`
	Disabled *bool             `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `json:"includeSqsMetadata,omitempty"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                      `json:"enableSQSAssumeRole,omitempty"`
	Preprocess          *components.PreprocessType `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `json:"parquetChunkDownloadTimeout,omitempty"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
	TagAfterProcessing *bool   `json:"tagAfterProcessing,omitempty"`
	Description        *string `json:"description,omitempty"`
	AwsAPIKey          *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputInputS3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputS3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputS3) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputS3) GetType() CreateInputTypeS3 {
	if c == nil {
		return CreateInputTypeS3("")
	}
	return c.Type
}

func (c *CreateInputInputS3) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputS3) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputS3) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputS3) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputS3) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputS3) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputS3) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputS3) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputS3) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputInputS3) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputInputS3) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputInputS3) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputS3) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputS3) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputInputS3) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputS3) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputS3) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputS3) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputS3) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputS3) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputS3) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputInputS3) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputInputS3) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputInputS3) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputS3) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputInputS3) GetIncludeSqsMetadata() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeSqsMetadata
}

func (c *CreateInputInputS3) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputS3) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputS3) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputS3) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputS3) GetEnableSQSAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableSQSAssumeRole
}

func (c *CreateInputInputS3) GetPreprocess() *components.PreprocessType {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputInputS3) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputS3) GetParquetChunkSizeMB() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkSizeMB
}

func (c *CreateInputInputS3) GetParquetChunkDownloadTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkDownloadTimeout
}

func (c *CreateInputInputS3) GetCheckpointing() *components.CheckpointingType {
	if c == nil {
		return nil
	}
	return c.Checkpointing
}

func (c *CreateInputInputS3) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputInputS3) GetEncoding() *string {
	if c == nil {
		return nil
	}
	return c.Encoding
}

func (c *CreateInputInputS3) GetTagAfterProcessing() *bool {
	if c == nil {
		return nil
	}
	return c.TagAfterProcessing
}

func (c *CreateInputInputS3) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputS3) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputS3) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputS3) GetProcessedTagKey() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagKey
}

func (c *CreateInputInputS3) GetProcessedTagValue() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagValue
}

func (c *CreateInputInputS3) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputInputS3) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputInputS3) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputS3) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputS3) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputS3) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputInputS3) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputTypeMetrics string

const (
	CreateInputTypeMetricsMetrics CreateInputTypeMetrics = "metrics"
)

func (e CreateInputTypeMetrics) ToPointer() *CreateInputTypeMetrics {
	return &e
}
func (e *CreateInputTypeMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "metrics":
		*e = CreateInputTypeMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeMetrics: %v", v)
	}
}

type CreateInputInputMetrics struct {
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     CreateInputTypeMetrics `json:"type"`
	Disabled *bool                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool                                 `json:"enableProxyHeader,omitempty"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	Description        *string  `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime.
	TemplateUDPPort *string `json:"__template_udpPort,omitempty"`
	// Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime.
	TemplateTCPPort *string `json:"__template_tcpPort,omitempty"`
}

func (c CreateInputInputMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputMetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputMetrics) GetType() CreateInputTypeMetrics {
	if c == nil {
		return CreateInputTypeMetrics("")
	}
	return c.Type
}

func (c *CreateInputInputMetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputMetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputMetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputMetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputMetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputMetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputMetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputMetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputMetrics) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputMetrics) GetUDPPort() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPPort
}

func (c *CreateInputInputMetrics) GetTCPPort() *float64 {
	if c == nil {
		return nil
	}
	return c.TCPPort
}

func (c *CreateInputInputMetrics) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputInputMetrics) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputMetrics) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputMetrics) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputMetrics) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputMetrics) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputInputMetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputMetrics) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputMetrics) GetTemplateUDPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateUDPPort
}

func (c *CreateInputInputMetrics) GetTemplateTCPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTCPPort
}

type CreateInputTypeCriblmetrics string

const (
	CreateInputTypeCriblmetricsCriblmetrics CreateInputTypeCriblmetrics = "criblmetrics"
)

func (e CreateInputTypeCriblmetrics) ToPointer() *CreateInputTypeCriblmetrics {
	return &e
}
func (e *CreateInputTypeCriblmetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "criblmetrics":
		*e = CreateInputTypeCriblmetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeCriblmetrics: %v", v)
	}
}

type CreateInputInputCriblmetrics struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputTypeCriblmetrics `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// A prefix that is applied to the metrics provided by Cribl Stream
	Prefix *string `json:"prefix,omitempty"`
	// Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
	FullFidelity *bool `json:"fullFidelity,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
}

func (c CreateInputInputCriblmetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputCriblmetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputCriblmetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputCriblmetrics) GetType() CreateInputTypeCriblmetrics {
	if c == nil {
		return CreateInputTypeCriblmetrics("")
	}
	return c.Type
}

func (c *CreateInputInputCriblmetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputCriblmetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputCriblmetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputCriblmetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputCriblmetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputCriblmetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputCriblmetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputCriblmetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputCriblmetrics) GetPrefix() *string {
	if c == nil {
		return nil
	}
	return c.Prefix
}

func (c *CreateInputInputCriblmetrics) GetFullFidelity() *bool {
	if c == nil {
		return nil
	}
	return c.FullFidelity
}

func (c *CreateInputInputCriblmetrics) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputCriblmetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeKinesis string

const (
	CreateInputTypeKinesisKinesis CreateInputTypeKinesis = "kinesis"
)

func (e CreateInputTypeKinesis) ToPointer() *CreateInputTypeKinesis {
	return &e
}
func (e *CreateInputTypeKinesis) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kinesis":
		*e = CreateInputTypeKinesis(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeKinesis: %v", v)
	}
}

// CreateInputShardIteratorStart - Location at which to start reading a shard for the first time
type CreateInputShardIteratorStart string

const (
	// CreateInputShardIteratorStartTrimHorizon Earliest record
	CreateInputShardIteratorStartTrimHorizon CreateInputShardIteratorStart = "TRIM_HORIZON"
	// CreateInputShardIteratorStartLatest Latest record
	CreateInputShardIteratorStartLatest CreateInputShardIteratorStart = "LATEST"
)

func (e CreateInputShardIteratorStart) ToPointer() *CreateInputShardIteratorStart {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputShardIteratorStart) IsExact() bool {
	if e != nil {
		switch *e {
		case "TRIM_HORIZON", "LATEST":
			return true
		}
	}
	return false
}

// CreateInputRecordDataFormat - Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
type CreateInputRecordDataFormat string

const (
	// CreateInputRecordDataFormatCribl Cribl
	CreateInputRecordDataFormatCribl CreateInputRecordDataFormat = "cribl"
	// CreateInputRecordDataFormatNdjson Newline JSON
	CreateInputRecordDataFormatNdjson CreateInputRecordDataFormat = "ndjson"
	// CreateInputRecordDataFormatCloudwatch Cloudwatch Logs
	CreateInputRecordDataFormatCloudwatch CreateInputRecordDataFormat = "cloudwatch"
	// CreateInputRecordDataFormatLine Event per line
	CreateInputRecordDataFormatLine CreateInputRecordDataFormat = "line"
)

func (e CreateInputRecordDataFormat) ToPointer() *CreateInputRecordDataFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputRecordDataFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "cribl", "ndjson", "cloudwatch", "line":
			return true
		}
	}
	return false
}

// CreateInputShardLoadBalancing - The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
type CreateInputShardLoadBalancing string

const (
	// CreateInputShardLoadBalancingConsistentHashing Consistent Hashing
	CreateInputShardLoadBalancingConsistentHashing CreateInputShardLoadBalancing = "ConsistentHashing"
	// CreateInputShardLoadBalancingRoundRobin Round Robin
	CreateInputShardLoadBalancingRoundRobin CreateInputShardLoadBalancing = "RoundRobin"
)

func (e CreateInputShardLoadBalancing) ToPointer() *CreateInputShardLoadBalancing {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputShardLoadBalancing) IsExact() bool {
	if e != nil {
		switch *e {
		case "ConsistentHashing", "RoundRobin":
			return true
		}
	}
	return false
}

type CreateInputInputKinesis struct {
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     CreateInputTypeKinesis `json:"type"`
	Disabled *bool                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `json:"serviceInterval,omitempty"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `json:"shardExpr,omitempty"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *CreateInputShardIteratorStart `json:"shardIteratorType,omitempty"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *CreateInputRecordDataFormat `json:"payloadFormat,omitempty"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `json:"getRecordsLimit,omitempty"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `json:"getRecordsLimitTotal,omitempty"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *CreateInputShardLoadBalancing `json:"loadBalancingAlgorithm,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *components.SignatureVersionOptions2 `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `json:"verifyKPLCheckSums,omitempty"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `json:"avoidDuplicates,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
	AwsAPIKey   *string                        `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Binds 'streamName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'streamName' at runtime.
	TemplateStreamName *string `json:"__template_streamName,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputInputKinesis) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputKinesis) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputKinesis) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputKinesis) GetType() CreateInputTypeKinesis {
	if c == nil {
		return CreateInputTypeKinesis("")
	}
	return c.Type
}

func (c *CreateInputInputKinesis) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputKinesis) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputKinesis) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputKinesis) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputKinesis) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputKinesis) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputKinesis) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputKinesis) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputKinesis) GetStreamName() string {
	if c == nil {
		return ""
	}
	return c.StreamName
}

func (c *CreateInputInputKinesis) GetServiceInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.ServiceInterval
}

func (c *CreateInputInputKinesis) GetShardExpr() *string {
	if c == nil {
		return nil
	}
	return c.ShardExpr
}

func (c *CreateInputInputKinesis) GetShardIteratorType() *CreateInputShardIteratorStart {
	if c == nil {
		return nil
	}
	return c.ShardIteratorType
}

func (c *CreateInputInputKinesis) GetPayloadFormat() *CreateInputRecordDataFormat {
	if c == nil {
		return nil
	}
	return c.PayloadFormat
}

func (c *CreateInputInputKinesis) GetGetRecordsLimit() *float64 {
	if c == nil {
		return nil
	}
	return c.GetRecordsLimit
}

func (c *CreateInputInputKinesis) GetGetRecordsLimitTotal() *float64 {
	if c == nil {
		return nil
	}
	return c.GetRecordsLimitTotal
}

func (c *CreateInputInputKinesis) GetLoadBalancingAlgorithm() *CreateInputShardLoadBalancing {
	if c == nil {
		return nil
	}
	return c.LoadBalancingAlgorithm
}

func (c *CreateInputInputKinesis) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputKinesis) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputKinesis) GetRegion() string {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateInputInputKinesis) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputKinesis) GetSignatureVersion() *components.SignatureVersionOptions2 {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputKinesis) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputKinesis) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputKinesis) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputKinesis) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputKinesis) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputKinesis) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputKinesis) GetVerifyKPLCheckSums() *bool {
	if c == nil {
		return nil
	}
	return c.VerifyKPLCheckSums
}

func (c *CreateInputInputKinesis) GetAvoidDuplicates() *bool {
	if c == nil {
		return nil
	}
	return c.AvoidDuplicates
}

func (c *CreateInputInputKinesis) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputKinesis) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputKinesis) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputKinesis) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputKinesis) GetTemplateStreamName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateStreamName
}

func (c *CreateInputInputKinesis) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputKinesis) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputKinesis) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputKinesis) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputInputKinesis) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputTypeHTTPRaw string

const (
	CreateInputTypeHTTPRawHTTPRaw CreateInputTypeHTTPRaw = "http_raw"
)

func (e CreateInputTypeHTTPRaw) ToPointer() *CreateInputTypeHTTPRaw {
	return &e
}
func (e *CreateInputTypeHTTPRaw) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http_raw":
		*e = CreateInputTypeHTTPRaw(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeHTTPRaw: %v", v)
	}
}

type CreateInputInputHTTPRaw struct {
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     CreateInputTypeHTTPRaw `json:"type"`
	Disabled *bool                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputHTTPRaw) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputHTTPRaw) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputHTTPRaw) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputHTTPRaw) GetType() CreateInputTypeHTTPRaw {
	if c == nil {
		return CreateInputTypeHTTPRaw("")
	}
	return c.Type
}

func (c *CreateInputInputHTTPRaw) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputHTTPRaw) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputHTTPRaw) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputHTTPRaw) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputHTTPRaw) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputHTTPRaw) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputHTTPRaw) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputHTTPRaw) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputHTTPRaw) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputHTTPRaw) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputHTTPRaw) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputHTTPRaw) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputHTTPRaw) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputHTTPRaw) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputHTTPRaw) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputHTTPRaw) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputHTTPRaw) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputHTTPRaw) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputHTTPRaw) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputHTTPRaw) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputHTTPRaw) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputHTTPRaw) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputHTTPRaw) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputHTTPRaw) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputHTTPRaw) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputHTTPRaw) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputHTTPRaw) GetAllowedPaths() []string {
	if c == nil {
		return nil
	}
	return c.AllowedPaths
}

func (c *CreateInputInputHTTPRaw) GetAllowedMethods() []string {
	if c == nil {
		return nil
	}
	return c.AllowedMethods
}

func (c *CreateInputInputHTTPRaw) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if c == nil {
		return nil
	}
	return c.AuthTokensExt
}

func (c *CreateInputInputHTTPRaw) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputHTTPRaw) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputHTTPRaw) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeDatagen string

const (
	CreateInputTypeDatagenDatagen CreateInputTypeDatagen = "datagen"
)

func (e CreateInputTypeDatagen) ToPointer() *CreateInputTypeDatagen {
	return &e
}
func (e *CreateInputTypeDatagen) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "datagen":
		*e = CreateInputTypeDatagen(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeDatagen: %v", v)
	}
}

type CreateInputSample struct {
	Sample string `json:"sample"`
	// Maximum number of events to generate per second per Worker Node. Defaults to 10.
	EventsPerSec float64 `json:"eventsPerSec"`
}

func (c CreateInputSample) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSample) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSample) GetSample() string {
	if c == nil {
		return ""
	}
	return c.Sample
}

func (c *CreateInputSample) GetEventsPerSec() float64 {
	if c == nil {
		return 0.0
	}
	return c.EventsPerSec
}

type CreateInputInputDatagen struct {
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     CreateInputTypeDatagen `json:"type"`
	Disabled *bool                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	Samples     []CreateInputSample                       `json:"samples"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
}

func (c CreateInputInputDatagen) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputDatagen) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputDatagen) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputDatagen) GetType() CreateInputTypeDatagen {
	if c == nil {
		return CreateInputTypeDatagen("")
	}
	return c.Type
}

func (c *CreateInputInputDatagen) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputDatagen) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputDatagen) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputDatagen) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputDatagen) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputDatagen) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputDatagen) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputDatagen) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputDatagen) GetSamples() []CreateInputSample {
	if c == nil {
		return []CreateInputSample{}
	}
	return c.Samples
}

func (c *CreateInputInputDatagen) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputDatagen) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeDatadogAgent string

const (
	CreateInputTypeDatadogAgentDatadogAgent CreateInputTypeDatadogAgent = "datadog_agent"
)

func (e CreateInputTypeDatadogAgent) ToPointer() *CreateInputTypeDatadogAgent {
	return &e
}
func (e *CreateInputTypeDatadogAgent) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "datadog_agent":
		*e = CreateInputTypeDatadogAgent(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeDatadogAgent: %v", v)
	}
}

type CreateInputProxyModeDatadogAgent struct {
	// Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid.
	Enabled bool `json:"enabled"`
	// Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
}

func (c CreateInputProxyModeDatadogAgent) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputProxyModeDatadogAgent) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputProxyModeDatadogAgent) GetEnabled() bool {
	if c == nil {
		return false
	}
	return c.Enabled
}

func (c *CreateInputProxyModeDatadogAgent) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

type CreateInputInputDatadogAgent struct {
	// Unique ID for this input
	ID       string                      `json:"id"`
	Type     CreateInputTypeDatadogAgent `json:"type"`
	Disabled *bool                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata    `json:"metadata,omitempty"`
	ProxyMode   *CreateInputProxyModeDatadogAgent `json:"proxyMode,omitempty"`
	Description *string                           `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputDatadogAgent) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputDatadogAgent) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputDatadogAgent) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputDatadogAgent) GetType() CreateInputTypeDatadogAgent {
	if c == nil {
		return CreateInputTypeDatadogAgent("")
	}
	return c.Type
}

func (c *CreateInputInputDatadogAgent) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputDatadogAgent) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputDatadogAgent) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputDatadogAgent) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputDatadogAgent) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputDatadogAgent) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputDatadogAgent) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputDatadogAgent) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputDatadogAgent) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputDatadogAgent) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputDatadogAgent) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputDatadogAgent) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputDatadogAgent) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputDatadogAgent) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputDatadogAgent) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputDatadogAgent) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputDatadogAgent) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputDatadogAgent) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputDatadogAgent) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputDatadogAgent) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputDatadogAgent) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputDatadogAgent) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputDatadogAgent) GetExtractMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractMetrics
}

func (c *CreateInputInputDatadogAgent) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputDatadogAgent) GetProxyMode() *CreateInputProxyModeDatadogAgent {
	if c == nil {
		return nil
	}
	return c.ProxyMode
}

func (c *CreateInputInputDatadogAgent) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputDatadogAgent) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputDatadogAgent) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeCrowdstrike string

const (
	CreateInputTypeCrowdstrikeCrowdstrike CreateInputTypeCrowdstrike = "crowdstrike"
)

func (e CreateInputTypeCrowdstrike) ToPointer() *CreateInputTypeCrowdstrike {
	return &e
}
func (e *CreateInputTypeCrowdstrike) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "crowdstrike":
		*e = CreateInputTypeCrowdstrike(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeCrowdstrike: %v", v)
	}
}

type CreateInputInputCrowdstrike struct {
	// Unique ID for this input
	ID       string                     `json:"id"`
	Type     CreateInputTypeCrowdstrike `json:"type"`
	Disabled *bool                      `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `json:"includeSqsMetadata,omitempty"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                      `json:"enableSQSAssumeRole,omitempty"`
	Preprocess          *components.PreprocessType `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Checkpointing *components.CheckpointingType  `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputInputCrowdstrike) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputCrowdstrike) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputCrowdstrike) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputCrowdstrike) GetType() CreateInputTypeCrowdstrike {
	if c == nil {
		return CreateInputTypeCrowdstrike("")
	}
	return c.Type
}

func (c *CreateInputInputCrowdstrike) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputCrowdstrike) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputCrowdstrike) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputCrowdstrike) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputCrowdstrike) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputCrowdstrike) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputCrowdstrike) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputCrowdstrike) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputCrowdstrike) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputInputCrowdstrike) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputInputCrowdstrike) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputInputCrowdstrike) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputInputCrowdstrike) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputInputCrowdstrike) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputInputCrowdstrike) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputInputCrowdstrike) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputInputCrowdstrike) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputInputCrowdstrike) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputInputCrowdstrike) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputCrowdstrike) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputCrowdstrike) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputInputCrowdstrike) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputInputCrowdstrike) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputInputCrowdstrike) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputCrowdstrike) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputInputCrowdstrike) GetIncludeSqsMetadata() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeSqsMetadata
}

func (c *CreateInputInputCrowdstrike) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputInputCrowdstrike) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputInputCrowdstrike) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputInputCrowdstrike) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputInputCrowdstrike) GetEnableSQSAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableSQSAssumeRole
}

func (c *CreateInputInputCrowdstrike) GetPreprocess() *components.PreprocessType {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputInputCrowdstrike) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputCrowdstrike) GetCheckpointing() *components.CheckpointingType {
	if c == nil {
		return nil
	}
	return c.Checkpointing
}

func (c *CreateInputInputCrowdstrike) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputInputCrowdstrike) GetEncoding() *string {
	if c == nil {
		return nil
	}
	return c.Encoding
}

func (c *CreateInputInputCrowdstrike) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputCrowdstrike) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputInputCrowdstrike) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputInputCrowdstrike) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if c == nil {
		return nil
	}
	return c.TagAfterProcessing
}

func (c *CreateInputInputCrowdstrike) GetProcessedTagKey() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagKey
}

func (c *CreateInputInputCrowdstrike) GetProcessedTagValue() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagValue
}

func (c *CreateInputInputCrowdstrike) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputInputCrowdstrike) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputInputCrowdstrike) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputInputCrowdstrike) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputInputCrowdstrike) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputInputCrowdstrike) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputInputCrowdstrike) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputTypeWindowsMetrics string

const (
	CreateInputTypeWindowsMetricsWindowsMetrics CreateInputTypeWindowsMetrics = "windows_metrics"
)

func (e CreateInputTypeWindowsMetrics) ToPointer() *CreateInputTypeWindowsMetrics {
	return &e
}
func (e *CreateInputTypeWindowsMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "windows_metrics":
		*e = CreateInputTypeWindowsMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeWindowsMetrics: %v", v)
	}
}

// CreateInputSystemModeWindowsMetrics - Select the level of details for system metrics
type CreateInputSystemModeWindowsMetrics string

const (
	// CreateInputSystemModeWindowsMetricsBasic Basic
	CreateInputSystemModeWindowsMetricsBasic CreateInputSystemModeWindowsMetrics = "basic"
	// CreateInputSystemModeWindowsMetricsAll All
	CreateInputSystemModeWindowsMetricsAll CreateInputSystemModeWindowsMetrics = "all"
	// CreateInputSystemModeWindowsMetricsCustom Custom
	CreateInputSystemModeWindowsMetricsCustom CreateInputSystemModeWindowsMetrics = "custom"
	// CreateInputSystemModeWindowsMetricsDisabled Disabled
	CreateInputSystemModeWindowsMetricsDisabled CreateInputSystemModeWindowsMetrics = "disabled"
)

func (e CreateInputSystemModeWindowsMetrics) ToPointer() *CreateInputSystemModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemWindowsMetrics struct {
	// Select the level of details for system metrics
	Mode *CreateInputSystemModeWindowsMetrics `json:"mode,omitempty"`
	// Generate metrics for all system information
	Detail *bool `json:"detail,omitempty"`
}

func (c CreateInputSystemWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemWindowsMetrics) GetMode() *CreateInputSystemModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

// CreateInputCPUModeWindowsMetrics - Select the level of details for CPU metrics
type CreateInputCPUModeWindowsMetrics string

const (
	// CreateInputCPUModeWindowsMetricsBasic Basic
	CreateInputCPUModeWindowsMetricsBasic CreateInputCPUModeWindowsMetrics = "basic"
	// CreateInputCPUModeWindowsMetricsAll All
	CreateInputCPUModeWindowsMetricsAll CreateInputCPUModeWindowsMetrics = "all"
	// CreateInputCPUModeWindowsMetricsCustom Custom
	CreateInputCPUModeWindowsMetricsCustom CreateInputCPUModeWindowsMetrics = "custom"
	// CreateInputCPUModeWindowsMetricsDisabled Disabled
	CreateInputCPUModeWindowsMetricsDisabled CreateInputCPUModeWindowsMetrics = "disabled"
)

func (e CreateInputCPUModeWindowsMetrics) ToPointer() *CreateInputCPUModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputCPUModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputCPUWindowsMetrics struct {
	// Select the level of details for CPU metrics
	Mode *CreateInputCPUModeWindowsMetrics `json:"mode,omitempty"`
	// Generate metrics for each CPU
	PerCPU *bool `json:"perCpu,omitempty"`
	// Generate metrics for all CPU states
	Detail *bool `json:"detail,omitempty"`
	// Generate raw, monotonic CPU time counters
	Time *bool `json:"time,omitempty"`
}

func (c CreateInputCPUWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputCPUWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputCPUWindowsMetrics) GetMode() *CreateInputCPUModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputCPUWindowsMetrics) GetPerCPU() *bool {
	if c == nil {
		return nil
	}
	return c.PerCPU
}

func (c *CreateInputCPUWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputCPUWindowsMetrics) GetTime() *bool {
	if c == nil {
		return nil
	}
	return c.Time
}

// CreateInputMemoryModeWindowsMetrics - Select the level of details for memory metrics
type CreateInputMemoryModeWindowsMetrics string

const (
	// CreateInputMemoryModeWindowsMetricsBasic Basic
	CreateInputMemoryModeWindowsMetricsBasic CreateInputMemoryModeWindowsMetrics = "basic"
	// CreateInputMemoryModeWindowsMetricsAll All
	CreateInputMemoryModeWindowsMetricsAll CreateInputMemoryModeWindowsMetrics = "all"
	// CreateInputMemoryModeWindowsMetricsCustom Custom
	CreateInputMemoryModeWindowsMetricsCustom CreateInputMemoryModeWindowsMetrics = "custom"
	// CreateInputMemoryModeWindowsMetricsDisabled Disabled
	CreateInputMemoryModeWindowsMetricsDisabled CreateInputMemoryModeWindowsMetrics = "disabled"
)

func (e CreateInputMemoryModeWindowsMetrics) ToPointer() *CreateInputMemoryModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputMemoryModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputMemoryWindowsMetrics struct {
	// Select the level of details for memory metrics
	Mode *CreateInputMemoryModeWindowsMetrics `json:"mode,omitempty"`
	// Generate metrics for all memory states
	Detail *bool `json:"detail,omitempty"`
}

func (c CreateInputMemoryWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputMemoryWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputMemoryWindowsMetrics) GetMode() *CreateInputMemoryModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputMemoryWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

// CreateInputNetworkModeWindowsMetrics - Select the level of details for network metrics
type CreateInputNetworkModeWindowsMetrics string

const (
	// CreateInputNetworkModeWindowsMetricsBasic Basic
	CreateInputNetworkModeWindowsMetricsBasic CreateInputNetworkModeWindowsMetrics = "basic"
	// CreateInputNetworkModeWindowsMetricsAll All
	CreateInputNetworkModeWindowsMetricsAll CreateInputNetworkModeWindowsMetrics = "all"
	// CreateInputNetworkModeWindowsMetricsCustom Custom
	CreateInputNetworkModeWindowsMetricsCustom CreateInputNetworkModeWindowsMetrics = "custom"
	// CreateInputNetworkModeWindowsMetricsDisabled Disabled
	CreateInputNetworkModeWindowsMetricsDisabled CreateInputNetworkModeWindowsMetrics = "disabled"
)

func (e CreateInputNetworkModeWindowsMetrics) ToPointer() *CreateInputNetworkModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputNetworkModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputNetworkWindowsMetrics struct {
	// Select the level of details for network metrics
	Mode *CreateInputNetworkModeWindowsMetrics `json:"mode,omitempty"`
	// Generate full network metrics
	Detail *bool `json:"detail,omitempty"`
	// Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
	Protocols *bool `json:"protocols,omitempty"`
	// Network interfaces to include/exclude. All interfaces are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Generate separate metrics for each interface
	PerInterface *bool `json:"perInterface,omitempty"`
}

func (c CreateInputNetworkWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputNetworkWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputNetworkWindowsMetrics) GetMode() *CreateInputNetworkModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputNetworkWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputNetworkWindowsMetrics) GetProtocols() *bool {
	if c == nil {
		return nil
	}
	return c.Protocols
}

func (c *CreateInputNetworkWindowsMetrics) GetDevices() []string {
	if c == nil {
		return nil
	}
	return c.Devices
}

func (c *CreateInputNetworkWindowsMetrics) GetPerInterface() *bool {
	if c == nil {
		return nil
	}
	return c.PerInterface
}

// CreateInputDiskModeWindowsMetrics - Select the level of details for disk metrics
type CreateInputDiskModeWindowsMetrics string

const (
	// CreateInputDiskModeWindowsMetricsBasic Basic
	CreateInputDiskModeWindowsMetricsBasic CreateInputDiskModeWindowsMetrics = "basic"
	// CreateInputDiskModeWindowsMetricsAll All
	CreateInputDiskModeWindowsMetricsAll CreateInputDiskModeWindowsMetrics = "all"
	// CreateInputDiskModeWindowsMetricsCustom Custom
	CreateInputDiskModeWindowsMetricsCustom CreateInputDiskModeWindowsMetrics = "custom"
	// CreateInputDiskModeWindowsMetricsDisabled Disabled
	CreateInputDiskModeWindowsMetricsDisabled CreateInputDiskModeWindowsMetrics = "disabled"
)

func (e CreateInputDiskModeWindowsMetrics) ToPointer() *CreateInputDiskModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputDiskModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputDiskWindowsMetrics struct {
	// Select the level of details for disk metrics
	Mode *CreateInputDiskModeWindowsMetrics `json:"mode,omitempty"`
	// Generate separate metrics for each volume
	PerVolume *bool `json:"perVolume,omitempty"`
	// Generate full disk metrics
	Detail *bool `json:"detail,omitempty"`
	// Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
	Volumes []string `json:"volumes,omitempty"`
}

func (c CreateInputDiskWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputDiskWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputDiskWindowsMetrics) GetMode() *CreateInputDiskModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputDiskWindowsMetrics) GetPerVolume() *bool {
	if c == nil {
		return nil
	}
	return c.PerVolume
}

func (c *CreateInputDiskWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputDiskWindowsMetrics) GetVolumes() []string {
	if c == nil {
		return nil
	}
	return c.Volumes
}

type CreateInputCustomWindowsMetrics struct {
	System  *CreateInputSystemWindowsMetrics  `json:"system,omitempty"`
	CPU     *CreateInputCPUWindowsMetrics     `json:"cpu,omitempty"`
	Memory  *CreateInputMemoryWindowsMetrics  `json:"memory,omitempty"`
	Network *CreateInputNetworkWindowsMetrics `json:"network,omitempty"`
	Disk    *CreateInputDiskWindowsMetrics    `json:"disk,omitempty"`
}

func (c CreateInputCustomWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputCustomWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputCustomWindowsMetrics) GetSystem() *CreateInputSystemWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.System
}

func (c *CreateInputCustomWindowsMetrics) GetCPU() *CreateInputCPUWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.CPU
}

func (c *CreateInputCustomWindowsMetrics) GetMemory() *CreateInputMemoryWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Memory
}

func (c *CreateInputCustomWindowsMetrics) GetNetwork() *CreateInputNetworkWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Network
}

func (c *CreateInputCustomWindowsMetrics) GetDisk() *CreateInputDiskWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Disk
}

type CreateInputHostWindowsMetrics struct {
	// Select level of detail for host metrics
	Mode   *components.ModeOptionsHost      `json:"mode,omitempty"`
	Custom *CreateInputCustomWindowsMetrics `json:"custom,omitempty"`
}

func (c CreateInputHostWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputHostWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputHostWindowsMetrics) GetMode() *components.ModeOptionsHost {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputHostWindowsMetrics) GetCustom() *CreateInputCustomWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Custom
}

type CreateInputPersistenceWindowsMetrics struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputPersistenceWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputPersistenceWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputPersistenceWindowsMetrics) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputPersistenceWindowsMetrics) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputPersistenceWindowsMetrics) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputPersistenceWindowsMetrics) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputPersistenceWindowsMetrics) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputPersistenceWindowsMetrics) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputInputWindowsMetrics struct {
	// Unique ID for this input
	ID       string                        `json:"id"`
	Type     CreateInputTypeWindowsMetrics `json:"type"`
	Disabled *bool                         `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                       `json:"interval,omitempty"`
	Host     *CreateInputHostWindowsMetrics `json:"host,omitempty"`
	Process  *components.ProcessType        `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata        `json:"metadata,omitempty"`
	Persistence *CreateInputPersistenceWindowsMetrics `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `json:"disableNativeModule,omitempty"`
	Description         *string `json:"description,omitempty"`
}

func (c CreateInputInputWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputWindowsMetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputWindowsMetrics) GetType() CreateInputTypeWindowsMetrics {
	if c == nil {
		return CreateInputTypeWindowsMetrics("")
	}
	return c.Type
}

func (c *CreateInputInputWindowsMetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputWindowsMetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputWindowsMetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputWindowsMetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputWindowsMetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputWindowsMetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputWindowsMetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputWindowsMetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputWindowsMetrics) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputWindowsMetrics) GetHost() *CreateInputHostWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Host
}

func (c *CreateInputInputWindowsMetrics) GetProcess() *components.ProcessType {
	if c == nil {
		return nil
	}
	return c.Process
}

func (c *CreateInputInputWindowsMetrics) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputWindowsMetrics) GetPersistence() *CreateInputPersistenceWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputInputWindowsMetrics) GetDisableNativeModule() *bool {
	if c == nil {
		return nil
	}
	return c.DisableNativeModule
}

func (c *CreateInputInputWindowsMetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeKubeEvents string

const (
	CreateInputTypeKubeEventsKubeEvents CreateInputTypeKubeEvents = "kube_events"
)

func (e CreateInputTypeKubeEvents) ToPointer() *CreateInputTypeKubeEvents {
	return &e
}
func (e *CreateInputTypeKubeEvents) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_events":
		*e = CreateInputTypeKubeEvents(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeKubeEvents: %v", v)
	}
}

type CreateInputInputKubeEvents struct {
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     CreateInputTypeKubeEvents `json:"type"`
	Disabled *bool                     `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Filtering on event fields
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Description *string                        `json:"description,omitempty"`
}

func (c CreateInputInputKubeEvents) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputKubeEvents) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputKubeEvents) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputKubeEvents) GetType() CreateInputTypeKubeEvents {
	if c == nil {
		return CreateInputTypeKubeEvents("")
	}
	return c.Type
}

func (c *CreateInputInputKubeEvents) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputKubeEvents) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputKubeEvents) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputKubeEvents) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputKubeEvents) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputKubeEvents) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputKubeEvents) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputKubeEvents) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputKubeEvents) GetRules() []components.ItemsTypeRules {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *CreateInputInputKubeEvents) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputKubeEvents) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeKubeLogs string

const (
	CreateInputTypeKubeLogsKubeLogs CreateInputTypeKubeLogs = "kube_logs"
)

func (e CreateInputTypeKubeLogs) ToPointer() *CreateInputTypeKubeLogs {
	return &e
}
func (e *CreateInputTypeKubeLogs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_logs":
		*e = CreateInputTypeKubeLogs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeKubeLogs: %v", v)
	}
}

type CreateInputRuleKubeLogs struct {
	// JavaScript expression applied to Pod objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (c CreateInputRuleKubeLogs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputRuleKubeLogs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputRuleKubeLogs) GetFilter() string {
	if c == nil {
		return ""
	}
	return c.Filter
}

func (c *CreateInputRuleKubeLogs) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputInputKubeLogs struct {
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     CreateInputTypeKubeLogs `json:"type"`
	Disabled *bool                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between checks for new containers. Default is 15 secs.
	Interval *float64 `json:"interval,omitempty"`
	// Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
	Rules []CreateInputRuleKubeLogs `json:"rules,omitempty"`
	// For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
	Timestamps *bool `json:"timestamps,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	Persistence *components.DiskSpoolingType   `json:"persistence,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `json:"enableLoadBalancing,omitempty"`
	Description         *string `json:"description,omitempty"`
}

func (c CreateInputInputKubeLogs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputKubeLogs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputKubeLogs) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputKubeLogs) GetType() CreateInputTypeKubeLogs {
	if c == nil {
		return CreateInputTypeKubeLogs("")
	}
	return c.Type
}

func (c *CreateInputInputKubeLogs) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputKubeLogs) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputKubeLogs) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputKubeLogs) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputKubeLogs) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputKubeLogs) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputKubeLogs) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputKubeLogs) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputKubeLogs) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputKubeLogs) GetRules() []CreateInputRuleKubeLogs {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *CreateInputInputKubeLogs) GetTimestamps() *bool {
	if c == nil {
		return nil
	}
	return c.Timestamps
}

func (c *CreateInputInputKubeLogs) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputKubeLogs) GetPersistence() *components.DiskSpoolingType {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputInputKubeLogs) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputInputKubeLogs) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputInputKubeLogs) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputInputKubeLogs) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeKubeMetrics string

const (
	CreateInputTypeKubeMetricsKubeMetrics CreateInputTypeKubeMetrics = "kube_metrics"
)

func (e CreateInputTypeKubeMetrics) ToPointer() *CreateInputTypeKubeMetrics {
	return &e
}
func (e *CreateInputTypeKubeMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_metrics":
		*e = CreateInputTypeKubeMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeKubeMetrics: %v", v)
	}
}

type CreateInputPersistenceKubeMetrics struct {
	// Spool metrics on disk for Cribl Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputPersistenceKubeMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputPersistenceKubeMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputPersistenceKubeMetrics) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputPersistenceKubeMetrics) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputPersistenceKubeMetrics) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputPersistenceKubeMetrics) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputPersistenceKubeMetrics) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputPersistenceKubeMetrics) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputInputKubeMetrics struct {
	// Unique ID for this input
	ID       string                     `json:"id"`
	Type     CreateInputTypeKubeMetrics `json:"type"`
	Disabled *bool                      `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metrics collections. Default is 15 secs.
	Interval *float64 `json:"interval,omitempty"`
	// Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata     `json:"metadata,omitempty"`
	Persistence *CreateInputPersistenceKubeMetrics `json:"persistence,omitempty"`
	Description *string                            `json:"description,omitempty"`
}

func (c CreateInputInputKubeMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputKubeMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputKubeMetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputKubeMetrics) GetType() CreateInputTypeKubeMetrics {
	if c == nil {
		return CreateInputTypeKubeMetrics("")
	}
	return c.Type
}

func (c *CreateInputInputKubeMetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputKubeMetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputKubeMetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputKubeMetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputKubeMetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputKubeMetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputKubeMetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputKubeMetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputKubeMetrics) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputKubeMetrics) GetRules() []components.ItemsTypeRules {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *CreateInputInputKubeMetrics) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputKubeMetrics) GetPersistence() *CreateInputPersistenceKubeMetrics {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputInputKubeMetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeSystemState string

const (
	CreateInputTypeSystemStateSystemState CreateInputTypeSystemState = "system_state"
)

func (e CreateInputTypeSystemState) ToPointer() *CreateInputTypeSystemState {
	return &e
}
func (e *CreateInputTypeSystemState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system_state":
		*e = CreateInputTypeSystemState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeSystemState: %v", v)
	}
}

// CreateInputHostsFile - Creates events based on entries collected from the hosts file
type CreateInputHostsFile struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputHostsFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputHostsFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputHostsFile) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputInterfaces - Creates events for each of the hosts network interfaces
type CreateInputInterfaces struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputInterfaces) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInterfaces) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInterfaces) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputDisksAndFileSystems - Creates events for physical disks, partitions, and file systems
type CreateInputDisksAndFileSystems struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputDisksAndFileSystems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputDisksAndFileSystems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputDisksAndFileSystems) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputHostInfo - Creates events based on the host systems current state
type CreateInputHostInfo struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputHostInfo) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputHostInfo) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputHostInfo) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputRoutes - Creates events based on entries collected from the hosts network routes
type CreateInputRoutes struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputRoutes) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputRoutes) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputRoutes) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputDNS - Creates events for DNS resolvers and search entries
type CreateInputDNS struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputDNS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputDNS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputDNS) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputUsersAndGroups - Creates events for local users and groups
type CreateInputUsersAndGroups struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputUsersAndGroups) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputUsersAndGroups) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputUsersAndGroups) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputFirewall - Creates events for Firewall rules entries
type CreateInputFirewall struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputFirewall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputFirewall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputFirewall) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputServices - Creates events from the list of services
type CreateInputServices struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputServices) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputServices) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputServices) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputListeningPorts - Creates events from list of listening ports
type CreateInputListeningPorts struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputListeningPorts) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputListeningPorts) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputListeningPorts) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputLoggedInUsers - Creates events from list of logged-in users
type CreateInputLoggedInUsers struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputLoggedInUsers) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputLoggedInUsers) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputLoggedInUsers) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

type CreateInputCollectors struct {
	// Creates events based on entries collected from the hosts file
	Hostsfile *CreateInputHostsFile `json:"hostsfile,omitempty"`
	// Creates events for each of the hosts network interfaces
	Interfaces *CreateInputInterfaces `json:"interfaces,omitempty"`
	// Creates events for physical disks, partitions, and file systems
	Disk *CreateInputDisksAndFileSystems `json:"disk,omitempty"`
	// Creates events based on the host systems current state
	Metadata *CreateInputHostInfo `json:"metadata,omitempty"`
	// Creates events based on entries collected from the hosts network routes
	Routes *CreateInputRoutes `json:"routes,omitempty"`
	// Creates events for DNS resolvers and search entries
	DNS *CreateInputDNS `json:"dns,omitempty"`
	// Creates events for local users and groups
	User *CreateInputUsersAndGroups `json:"user,omitempty"`
	// Creates events for Firewall rules entries
	Firewall *CreateInputFirewall `json:"firewall,omitempty"`
	// Creates events from the list of services
	Services *CreateInputServices `json:"services,omitempty"`
	// Creates events from list of listening ports
	Ports *CreateInputListeningPorts `json:"ports,omitempty"`
	// Creates events from list of logged-in users
	LoginUsers *CreateInputLoggedInUsers `json:"loginUsers,omitempty"`
}

func (c CreateInputCollectors) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputCollectors) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputCollectors) GetHostsfile() *CreateInputHostsFile {
	if c == nil {
		return nil
	}
	return c.Hostsfile
}

func (c *CreateInputCollectors) GetInterfaces() *CreateInputInterfaces {
	if c == nil {
		return nil
	}
	return c.Interfaces
}

func (c *CreateInputCollectors) GetDisk() *CreateInputDisksAndFileSystems {
	if c == nil {
		return nil
	}
	return c.Disk
}

func (c *CreateInputCollectors) GetMetadata() *CreateInputHostInfo {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputCollectors) GetRoutes() *CreateInputRoutes {
	if c == nil {
		return nil
	}
	return c.Routes
}

func (c *CreateInputCollectors) GetDNS() *CreateInputDNS {
	if c == nil {
		return nil
	}
	return c.DNS
}

func (c *CreateInputCollectors) GetUser() *CreateInputUsersAndGroups {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *CreateInputCollectors) GetFirewall() *CreateInputFirewall {
	if c == nil {
		return nil
	}
	return c.Firewall
}

func (c *CreateInputCollectors) GetServices() *CreateInputServices {
	if c == nil {
		return nil
	}
	return c.Services
}

func (c *CreateInputCollectors) GetPorts() *CreateInputListeningPorts {
	if c == nil {
		return nil
	}
	return c.Ports
}

func (c *CreateInputCollectors) GetLoginUsers() *CreateInputLoggedInUsers {
	if c == nil {
		return nil
	}
	return c.LoginUsers
}

type CreateInputPersistenceSystemState struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputPersistenceSystemState) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputPersistenceSystemState) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputPersistenceSystemState) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputPersistenceSystemState) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputPersistenceSystemState) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputPersistenceSystemState) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputPersistenceSystemState) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputPersistenceSystemState) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputInputSystemState struct {
	// Unique ID for this input
	ID       string                     `json:"id"`
	Type     CreateInputTypeSystemState `json:"type"`
	Disabled *bool                      `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
	Interval *float64 `json:"interval,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata     `json:"metadata,omitempty"`
	Collectors  *CreateInputCollectors             `json:"collectors,omitempty"`
	Persistence *CreateInputPersistenceSystemState `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
	DisableNativeModule *bool `json:"disableNativeModule,omitempty"`
	// Enable only to collect LastLog data via legacy implementation. This option will be removed in a future release. Please contact Support before enabling. [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
	DisableNativeLastLogModule *bool   `json:"disableNativeLastLogModule,omitempty"`
	Description                *string `json:"description,omitempty"`
}

func (c CreateInputInputSystemState) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSystemState) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSystemState) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSystemState) GetType() CreateInputTypeSystemState {
	if c == nil {
		return CreateInputTypeSystemState("")
	}
	return c.Type
}

func (c *CreateInputInputSystemState) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSystemState) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSystemState) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSystemState) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSystemState) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSystemState) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSystemState) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSystemState) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSystemState) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputSystemState) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSystemState) GetCollectors() *CreateInputCollectors {
	if c == nil {
		return nil
	}
	return c.Collectors
}

func (c *CreateInputInputSystemState) GetPersistence() *CreateInputPersistenceSystemState {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputInputSystemState) GetDisableNativeModule() *bool {
	if c == nil {
		return nil
	}
	return c.DisableNativeModule
}

func (c *CreateInputInputSystemState) GetDisableNativeLastLogModule() *bool {
	if c == nil {
		return nil
	}
	return c.DisableNativeLastLogModule
}

func (c *CreateInputInputSystemState) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeSystemMetrics string

const (
	CreateInputTypeSystemMetricsSystemMetrics CreateInputTypeSystemMetrics = "system_metrics"
)

func (e CreateInputTypeSystemMetrics) ToPointer() *CreateInputTypeSystemMetrics {
	return &e
}
func (e *CreateInputTypeSystemMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system_metrics":
		*e = CreateInputTypeSystemMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeSystemMetrics: %v", v)
	}
}

// CreateInputSystemModeSystemMetrics - Select the level of detail for system metrics
type CreateInputSystemModeSystemMetrics string

const (
	// CreateInputSystemModeSystemMetricsBasic Basic
	CreateInputSystemModeSystemMetricsBasic CreateInputSystemModeSystemMetrics = "basic"
	// CreateInputSystemModeSystemMetricsAll All
	CreateInputSystemModeSystemMetricsAll CreateInputSystemModeSystemMetrics = "all"
	// CreateInputSystemModeSystemMetricsCustom Custom
	CreateInputSystemModeSystemMetricsCustom CreateInputSystemModeSystemMetrics = "custom"
	// CreateInputSystemModeSystemMetricsDisabled Disabled
	CreateInputSystemModeSystemMetricsDisabled CreateInputSystemModeSystemMetrics = "disabled"
)

func (e CreateInputSystemModeSystemMetrics) ToPointer() *CreateInputSystemModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemSystemMetrics struct {
	// Select the level of detail for system metrics
	Mode *CreateInputSystemModeSystemMetrics `json:"mode,omitempty"`
	// Generate metrics for the numbers of processes in various states
	Processes *bool `json:"processes,omitempty"`
}

func (c CreateInputSystemSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemSystemMetrics) GetMode() *CreateInputSystemModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemSystemMetrics) GetProcesses() *bool {
	if c == nil {
		return nil
	}
	return c.Processes
}

// CreateInputCPUModeSystemMetrics - Select the level of detail for CPU metrics
type CreateInputCPUModeSystemMetrics string

const (
	// CreateInputCPUModeSystemMetricsBasic Basic
	CreateInputCPUModeSystemMetricsBasic CreateInputCPUModeSystemMetrics = "basic"
	// CreateInputCPUModeSystemMetricsAll All
	CreateInputCPUModeSystemMetricsAll CreateInputCPUModeSystemMetrics = "all"
	// CreateInputCPUModeSystemMetricsCustom Custom
	CreateInputCPUModeSystemMetricsCustom CreateInputCPUModeSystemMetrics = "custom"
	// CreateInputCPUModeSystemMetricsDisabled Disabled
	CreateInputCPUModeSystemMetricsDisabled CreateInputCPUModeSystemMetrics = "disabled"
)

func (e CreateInputCPUModeSystemMetrics) ToPointer() *CreateInputCPUModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputCPUModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputCPUSystemMetrics struct {
	// Select the level of detail for CPU metrics
	Mode *CreateInputCPUModeSystemMetrics `json:"mode,omitempty"`
	// Generate metrics for each CPU
	PerCPU *bool `json:"perCpu,omitempty"`
	// Generate metrics for all CPU states
	Detail *bool `json:"detail,omitempty"`
	// Generate raw, monotonic CPU time counters
	Time *bool `json:"time,omitempty"`
}

func (c CreateInputCPUSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputCPUSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputCPUSystemMetrics) GetMode() *CreateInputCPUModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputCPUSystemMetrics) GetPerCPU() *bool {
	if c == nil {
		return nil
	}
	return c.PerCPU
}

func (c *CreateInputCPUSystemMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputCPUSystemMetrics) GetTime() *bool {
	if c == nil {
		return nil
	}
	return c.Time
}

// CreateInputMemoryModeSystemMetrics - Select the level of detail for memory metrics
type CreateInputMemoryModeSystemMetrics string

const (
	// CreateInputMemoryModeSystemMetricsBasic Basic
	CreateInputMemoryModeSystemMetricsBasic CreateInputMemoryModeSystemMetrics = "basic"
	// CreateInputMemoryModeSystemMetricsAll All
	CreateInputMemoryModeSystemMetricsAll CreateInputMemoryModeSystemMetrics = "all"
	// CreateInputMemoryModeSystemMetricsCustom Custom
	CreateInputMemoryModeSystemMetricsCustom CreateInputMemoryModeSystemMetrics = "custom"
	// CreateInputMemoryModeSystemMetricsDisabled Disabled
	CreateInputMemoryModeSystemMetricsDisabled CreateInputMemoryModeSystemMetrics = "disabled"
)

func (e CreateInputMemoryModeSystemMetrics) ToPointer() *CreateInputMemoryModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputMemoryModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputMemorySystemMetrics struct {
	// Select the level of detail for memory metrics
	Mode *CreateInputMemoryModeSystemMetrics `json:"mode,omitempty"`
	// Generate metrics for all memory states
	Detail *bool `json:"detail,omitempty"`
}

func (c CreateInputMemorySystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputMemorySystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputMemorySystemMetrics) GetMode() *CreateInputMemoryModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputMemorySystemMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

// CreateInputNetworkModeSystemMetrics - Select the level of detail for network metrics
type CreateInputNetworkModeSystemMetrics string

const (
	// CreateInputNetworkModeSystemMetricsBasic Basic
	CreateInputNetworkModeSystemMetricsBasic CreateInputNetworkModeSystemMetrics = "basic"
	// CreateInputNetworkModeSystemMetricsAll All
	CreateInputNetworkModeSystemMetricsAll CreateInputNetworkModeSystemMetrics = "all"
	// CreateInputNetworkModeSystemMetricsCustom Custom
	CreateInputNetworkModeSystemMetricsCustom CreateInputNetworkModeSystemMetrics = "custom"
	// CreateInputNetworkModeSystemMetricsDisabled Disabled
	CreateInputNetworkModeSystemMetricsDisabled CreateInputNetworkModeSystemMetrics = "disabled"
)

func (e CreateInputNetworkModeSystemMetrics) ToPointer() *CreateInputNetworkModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputNetworkModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputNetworkSystemMetrics struct {
	// Select the level of detail for network metrics
	Mode *CreateInputNetworkModeSystemMetrics `json:"mode,omitempty"`
	// Generate full network metrics
	Detail *bool `json:"detail,omitempty"`
	// Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
	Protocols *bool `json:"protocols,omitempty"`
	// Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Generate separate metrics for each interface
	PerInterface *bool `json:"perInterface,omitempty"`
}

func (c CreateInputNetworkSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputNetworkSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputNetworkSystemMetrics) GetMode() *CreateInputNetworkModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputNetworkSystemMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputNetworkSystemMetrics) GetProtocols() *bool {
	if c == nil {
		return nil
	}
	return c.Protocols
}

func (c *CreateInputNetworkSystemMetrics) GetDevices() []string {
	if c == nil {
		return nil
	}
	return c.Devices
}

func (c *CreateInputNetworkSystemMetrics) GetPerInterface() *bool {
	if c == nil {
		return nil
	}
	return c.PerInterface
}

// CreateInputDiskModeSystemMetrics - Select the level of detail for disk metrics
type CreateInputDiskModeSystemMetrics string

const (
	// CreateInputDiskModeSystemMetricsBasic Basic
	CreateInputDiskModeSystemMetricsBasic CreateInputDiskModeSystemMetrics = "basic"
	// CreateInputDiskModeSystemMetricsAll All
	CreateInputDiskModeSystemMetricsAll CreateInputDiskModeSystemMetrics = "all"
	// CreateInputDiskModeSystemMetricsCustom Custom
	CreateInputDiskModeSystemMetricsCustom CreateInputDiskModeSystemMetrics = "custom"
	// CreateInputDiskModeSystemMetricsDisabled Disabled
	CreateInputDiskModeSystemMetricsDisabled CreateInputDiskModeSystemMetrics = "disabled"
)

func (e CreateInputDiskModeSystemMetrics) ToPointer() *CreateInputDiskModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputDiskModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputDiskSystemMetrics struct {
	// Select the level of detail for disk metrics
	Mode *CreateInputDiskModeSystemMetrics `json:"mode,omitempty"`
	// Generate full disk metrics
	Detail *bool `json:"detail,omitempty"`
	// Generate filesystem inode metrics
	Inodes *bool `json:"inodes,omitempty"`
	// Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty.
	Mountpoints []string `json:"mountpoints,omitempty"`
	// Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty.
	Fstypes []string `json:"fstypes,omitempty"`
	// Generate separate metrics for each device
	PerDevice *bool `json:"perDevice,omitempty"`
}

func (c CreateInputDiskSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputDiskSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputDiskSystemMetrics) GetMode() *CreateInputDiskModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputDiskSystemMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputDiskSystemMetrics) GetInodes() *bool {
	if c == nil {
		return nil
	}
	return c.Inodes
}

func (c *CreateInputDiskSystemMetrics) GetDevices() []string {
	if c == nil {
		return nil
	}
	return c.Devices
}

func (c *CreateInputDiskSystemMetrics) GetMountpoints() []string {
	if c == nil {
		return nil
	}
	return c.Mountpoints
}

func (c *CreateInputDiskSystemMetrics) GetFstypes() []string {
	if c == nil {
		return nil
	}
	return c.Fstypes
}

func (c *CreateInputDiskSystemMetrics) GetPerDevice() *bool {
	if c == nil {
		return nil
	}
	return c.PerDevice
}

type CreateInputCustomSystemMetrics struct {
	System  *CreateInputSystemSystemMetrics  `json:"system,omitempty"`
	CPU     *CreateInputCPUSystemMetrics     `json:"cpu,omitempty"`
	Memory  *CreateInputMemorySystemMetrics  `json:"memory,omitempty"`
	Network *CreateInputNetworkSystemMetrics `json:"network,omitempty"`
	Disk    *CreateInputDiskSystemMetrics    `json:"disk,omitempty"`
}

func (c CreateInputCustomSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputCustomSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputCustomSystemMetrics) GetSystem() *CreateInputSystemSystemMetrics {
	if c == nil {
		return nil
	}
	return c.System
}

func (c *CreateInputCustomSystemMetrics) GetCPU() *CreateInputCPUSystemMetrics {
	if c == nil {
		return nil
	}
	return c.CPU
}

func (c *CreateInputCustomSystemMetrics) GetMemory() *CreateInputMemorySystemMetrics {
	if c == nil {
		return nil
	}
	return c.Memory
}

func (c *CreateInputCustomSystemMetrics) GetNetwork() *CreateInputNetworkSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Network
}

func (c *CreateInputCustomSystemMetrics) GetDisk() *CreateInputDiskSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Disk
}

type CreateInputHostSystemMetrics struct {
	// Select level of detail for host metrics
	Mode   *components.ModeOptionsHost     `json:"mode,omitempty"`
	Custom *CreateInputCustomSystemMetrics `json:"custom,omitempty"`
}

func (c CreateInputHostSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputHostSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputHostSystemMetrics) GetMode() *components.ModeOptionsHost {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputHostSystemMetrics) GetCustom() *CreateInputCustomSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Custom
}

// CreateInputContainerMode - Select the level of detail for container metrics
type CreateInputContainerMode string

const (
	// CreateInputContainerModeBasic Basic
	CreateInputContainerModeBasic CreateInputContainerMode = "basic"
	// CreateInputContainerModeAll All
	CreateInputContainerModeAll CreateInputContainerMode = "all"
	// CreateInputContainerModeCustom Custom
	CreateInputContainerModeCustom CreateInputContainerMode = "custom"
	// CreateInputContainerModeDisabled Disabled
	CreateInputContainerModeDisabled CreateInputContainerMode = "disabled"
)

func (e CreateInputContainerMode) ToPointer() *CreateInputContainerMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputContainerMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputContainerFilter struct {
	Expr string `json:"expr"`
}

func (c CreateInputContainerFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputContainerFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputContainerFilter) GetExpr() string {
	if c == nil {
		return ""
	}
	return c.Expr
}

type CreateInputContainer struct {
	// Select the level of detail for container metrics
	Mode *CreateInputContainerMode `json:"mode,omitempty"`
	// Full paths for Docker's UNIX-domain socket
	DockerSocket []string `json:"dockerSocket,omitempty"`
	// Timeout, in seconds, for the Docker API
	DockerTimeout *float64 `json:"dockerTimeout,omitempty"`
	// Containers matching any of these will be included. All are included if no filters are added.
	Filters []CreateInputContainerFilter `json:"filters,omitempty"`
	// Include stopped and paused containers
	AllContainers *bool `json:"allContainers,omitempty"`
	// Generate separate metrics for each device
	PerDevice *bool `json:"perDevice,omitempty"`
	// Generate full container metrics
	Detail *bool `json:"detail,omitempty"`
}

func (c CreateInputContainer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputContainer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputContainer) GetMode() *CreateInputContainerMode {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputContainer) GetDockerSocket() []string {
	if c == nil {
		return nil
	}
	return c.DockerSocket
}

func (c *CreateInputContainer) GetDockerTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.DockerTimeout
}

func (c *CreateInputContainer) GetFilters() []CreateInputContainerFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateInputContainer) GetAllContainers() *bool {
	if c == nil {
		return nil
	}
	return c.AllContainers
}

func (c *CreateInputContainer) GetPerDevice() *bool {
	if c == nil {
		return nil
	}
	return c.PerDevice
}

func (c *CreateInputContainer) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

type CreateInputPersistenceSystemMetrics struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputPersistenceSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputPersistenceSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputPersistenceSystemMetrics) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputPersistenceSystemMetrics) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputPersistenceSystemMetrics) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputPersistenceSystemMetrics) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputPersistenceSystemMetrics) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputPersistenceSystemMetrics) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputInputSystemMetrics struct {
	// Unique ID for this input
	ID       string                       `json:"id"`
	Type     CreateInputTypeSystemMetrics `json:"type"`
	Disabled *bool                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval  *float64                      `json:"interval,omitempty"`
	Host      *CreateInputHostSystemMetrics `json:"host,omitempty"`
	Process   *components.ProcessType       `json:"process,omitempty"`
	Container *CreateInputContainer         `json:"container,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeMetadata       `json:"metadata,omitempty"`
	Persistence *CreateInputPersistenceSystemMetrics `json:"persistence,omitempty"`
	Description *string                              `json:"description,omitempty"`
}

func (c CreateInputInputSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputSystemMetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputSystemMetrics) GetType() CreateInputTypeSystemMetrics {
	if c == nil {
		return CreateInputTypeSystemMetrics("")
	}
	return c.Type
}

func (c *CreateInputInputSystemMetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputSystemMetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputSystemMetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputSystemMetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputSystemMetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputSystemMetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputSystemMetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputSystemMetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputSystemMetrics) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputInputSystemMetrics) GetHost() *CreateInputHostSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Host
}

func (c *CreateInputInputSystemMetrics) GetProcess() *components.ProcessType {
	if c == nil {
		return nil
	}
	return c.Process
}

func (c *CreateInputInputSystemMetrics) GetContainer() *CreateInputContainer {
	if c == nil {
		return nil
	}
	return c.Container
}

func (c *CreateInputInputSystemMetrics) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputSystemMetrics) GetPersistence() *CreateInputPersistenceSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputInputSystemMetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputTypeTcpjson string

const (
	CreateInputTypeTcpjsonTcpjson CreateInputTypeTcpjson = "tcpjson"
)

func (e CreateInputTypeTcpjson) ToPointer() *CreateInputTypeTcpjson {
	return &e
}
func (e *CreateInputTypeTcpjson) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcpjson":
		*e = CreateInputTypeTcpjson(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeTcpjson: %v", v)
	}
}

type CreateInputInputTcpjson struct {
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     CreateInputTypeTcpjson `json:"type"`
	Disabled *bool                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `json:"enableLoadBalancing,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	Description *string                                                `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `json:"authToken,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputInputTcpjson) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputTcpjson) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputTcpjson) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputTcpjson) GetType() CreateInputTypeTcpjson {
	if c == nil {
		return CreateInputTypeTcpjson("")
	}
	return c.Type
}

func (c *CreateInputInputTcpjson) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputTcpjson) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputTcpjson) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputTcpjson) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputTcpjson) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputTcpjson) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputTcpjson) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputTcpjson) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputTcpjson) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputTcpjson) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputTcpjson) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputTcpjson) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputInputTcpjson) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputInputTcpjson) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputInputTcpjson) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputInputTcpjson) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputInputTcpjson) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputTcpjson) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputTcpjson) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputInputTcpjson) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputInputTcpjson) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputTcpjson) GetAuthToken() *string {
	if c == nil {
		return nil
	}
	return c.AuthToken
}

func (c *CreateInputInputTcpjson) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputInputTcpjson) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputTcpjson) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputTypeCriblLakeHTTP string

const (
	CreateInputTypeCriblLakeHTTPCriblLakeHTTP CreateInputTypeCriblLakeHTTP = "cribl_lake_http"
)

func (e CreateInputTypeCriblLakeHTTP) ToPointer() *CreateInputTypeCriblLakeHTTP {
	return &e
}
func (e *CreateInputTypeCriblLakeHTTP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_lake_http":
		*e = CreateInputTypeCriblLakeHTTP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputTypeCriblLakeHTTP: %v", v)
	}
}

type CreateInputSplunkHecMetadata struct {
	Enabled               *bool    `json:"enabled,omitempty"`
	DefaultDataset        *string  `json:"defaultDataset,omitempty"`
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
}

func (c CreateInputSplunkHecMetadata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSplunkHecMetadata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSplunkHecMetadata) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputSplunkHecMetadata) GetDefaultDataset() *string {
	if c == nil {
		return nil
	}
	return c.DefaultDataset
}

func (c *CreateInputSplunkHecMetadata) GetAllowedIndexesAtToken() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexesAtToken
}

type CreateInputElasticsearchMetadata struct {
	Enabled        *bool   `json:"enabled,omitempty"`
	DefaultDataset *string `json:"defaultDataset,omitempty"`
}

func (c CreateInputElasticsearchMetadata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputElasticsearchMetadata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputElasticsearchMetadata) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputElasticsearchMetadata) GetDefaultDataset() *string {
	if c == nil {
		return nil
	}
	return c.DefaultDataset
}

type CreateInputAuthTokensExt struct {
	Token       string  `json:"token"`
	Description *string `json:"description,omitempty"`
	// Fields to add to events referencing this token
	Metadata              []components.ItemsTypeMetadata    `json:"metadata,omitempty"`
	SplunkHecMetadata     *CreateInputSplunkHecMetadata     `json:"splunkHecMetadata,omitempty"`
	ElasticsearchMetadata *CreateInputElasticsearchMetadata `json:"elasticsearchMetadata,omitempty"`
}

func (c CreateInputAuthTokensExt) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputAuthTokensExt) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputAuthTokensExt) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CreateInputAuthTokensExt) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputAuthTokensExt) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputAuthTokensExt) GetSplunkHecMetadata() *CreateInputSplunkHecMetadata {
	if c == nil {
		return nil
	}
	return c.SplunkHecMetadata
}

func (c *CreateInputAuthTokensExt) GetElasticsearchMetadata() *CreateInputElasticsearchMetadata {
	if c == nil {
		return nil
	}
	return c.ElasticsearchMetadata
}

type CreateInputInputCriblLakeHTTP struct {
	// Unique ID for this input
	ID       string                       `json:"id"`
	Type     CreateInputTypeCriblLakeHTTP `json:"type"`
	Disabled *bool                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `json:"criblAPI,omitempty"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `json:"elasticAPI,omitempty"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `json:"splunkHecAPI,omitempty"`
	SplunkHecAcks *bool   `json:"splunkHecAcks,omitempty"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeMetadata `json:"metadata,omitempty"`
	AuthTokensExt []CreateInputAuthTokensExt     `json:"authTokensExt,omitempty"`
	Description   *string                        `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime.
	TemplateSplunkHecAPI *string `json:"__template_splunkHecAPI,omitempty"`
}

func (c CreateInputInputCriblLakeHTTP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputInputCriblLakeHTTP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputInputCriblLakeHTTP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputInputCriblLakeHTTP) GetType() CreateInputTypeCriblLakeHTTP {
	if c == nil {
		return CreateInputTypeCriblLakeHTTP("")
	}
	return c.Type
}

func (c *CreateInputInputCriblLakeHTTP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputInputCriblLakeHTTP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputInputCriblLakeHTTP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputInputCriblLakeHTTP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputInputCriblLakeHTTP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputInputCriblLakeHTTP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputInputCriblLakeHTTP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputInputCriblLakeHTTP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputInputCriblLakeHTTP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputInputCriblLakeHTTP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputInputCriblLakeHTTP) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputInputCriblLakeHTTP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputInputCriblLakeHTTP) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputInputCriblLakeHTTP) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputInputCriblLakeHTTP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputInputCriblLakeHTTP) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputInputCriblLakeHTTP) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputInputCriblLakeHTTP) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputInputCriblLakeHTTP) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputInputCriblLakeHTTP) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputInputCriblLakeHTTP) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputInputCriblLakeHTTP) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputInputCriblLakeHTTP) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputInputCriblLakeHTTP) GetCriblAPI() *string {
	if c == nil {
		return nil
	}
	return c.CriblAPI
}

func (c *CreateInputInputCriblLakeHTTP) GetElasticAPI() *string {
	if c == nil {
		return nil
	}
	return c.ElasticAPI
}

func (c *CreateInputInputCriblLakeHTTP) GetSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.SplunkHecAPI
}

func (c *CreateInputInputCriblLakeHTTP) GetSplunkHecAcks() *bool {
	if c == nil {
		return nil
	}
	return c.SplunkHecAcks
}

func (c *CreateInputInputCriblLakeHTTP) GetMetadata() []components.ItemsTypeMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputInputCriblLakeHTTP) GetAuthTokensExt() []CreateInputAuthTokensExt {
	if c == nil {
		return nil
	}
	return c.AuthTokensExt
}

func (c *CreateInputInputCriblLakeHTTP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputInputCriblLakeHTTP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputInputCriblLakeHTTP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputInputCriblLakeHTTP) GetTemplateSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplateSplunkHecAPI
}
