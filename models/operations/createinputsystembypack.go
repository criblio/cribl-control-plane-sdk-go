// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
	"github.com/criblio/cribl-control-plane-sdk-go/models/components"
)

type CreateInputSystemByPackTypeCloudflareHec string

const (
	CreateInputSystemByPackTypeCloudflareHecCloudflareHec CreateInputSystemByPackTypeCloudflareHec = "cloudflare_hec"
)

func (e CreateInputSystemByPackTypeCloudflareHec) ToPointer() *CreateInputSystemByPackTypeCloudflareHec {
	return &e
}
func (e *CreateInputSystemByPackTypeCloudflareHec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cloudflare_hec":
		*e = CreateInputSystemByPackTypeCloudflareHec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeCloudflareHec: %v", v)
	}
}

// CreateInputSystemByPackAuthTokenAuthenticationMethod - Select Secret to use a text secret to authenticate
type CreateInputSystemByPackAuthTokenAuthenticationMethod string

const (
	CreateInputSystemByPackAuthTokenAuthenticationMethodSecret CreateInputSystemByPackAuthTokenAuthenticationMethod = "secret"
)

func (e CreateInputSystemByPackAuthTokenAuthenticationMethod) ToPointer() *CreateInputSystemByPackAuthTokenAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackAuthTokenAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "secret":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackAuthTokenCloudflareHec struct {
	// Select Secret to use a text secret to authenticate
	AuthType *CreateInputSystemByPackAuthTokenAuthenticationMethod `json:"authType,omitempty"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	Token       any     `json:"token,omitempty"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
}

func (c CreateInputSystemByPackAuthTokenCloudflareHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackAuthTokenCloudflareHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackAuthTokenCloudflareHec) GetAuthType() *CreateInputSystemByPackAuthTokenAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackAuthTokenCloudflareHec) GetTokenSecret() *string {
	if c == nil {
		return nil
	}
	return c.TokenSecret
}

func (c *CreateInputSystemByPackAuthTokenCloudflareHec) GetToken() any {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackAuthTokenCloudflareHec) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputSystemByPackAuthTokenCloudflareHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackAuthTokenCloudflareHec) GetAllowedIndexesAtToken() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexesAtToken
}

func (c *CreateInputSystemByPackAuthTokenCloudflareHec) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

type CreateInputSystemByPackInputCloudflareHec struct {
	// Unique ID for this input
	ID       string                                   `json:"id"`
	Type     CreateInputSystemByPackTypeCloudflareHec `json:"type"`
	Disabled *bool                                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []CreateInputSystemByPackAuthTokenCloudflareHec `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType           `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `json:"keepAliveTimeout,omitempty"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `json:"emitTokenMetrics,omitempty"`
	Description      *string `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputCloudflareHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputCloudflareHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "hecAPI"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetType() CreateInputSystemByPackTypeCloudflareHec {
	if c == nil {
		return CreateInputSystemByPackTypeCloudflareHec("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetAuthTokens() []CreateInputSystemByPackAuthTokenCloudflareHec {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetEnableHealthCheck() any {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetHecAPI() string {
	if c == nil {
		return ""
	}
	return c.HecAPI
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetAllowedIndexes() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexes
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetAccessControlAllowOrigin() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowOrigin
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetAccessControlAllowHeaders() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowHeaders
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetEmitTokenMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.EmitTokenMetrics
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputCloudflareHec) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeZscalerHec string

const (
	CreateInputSystemByPackTypeZscalerHecZscalerHec CreateInputSystemByPackTypeZscalerHec = "zscaler_hec"
)

func (e CreateInputSystemByPackTypeZscalerHec) ToPointer() *CreateInputSystemByPackTypeZscalerHec {
	return &e
}
func (e *CreateInputSystemByPackTypeZscalerHec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zscaler_hec":
		*e = CreateInputSystemByPackTypeZscalerHec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeZscalerHec: %v", v)
	}
}

type CreateInputSystemByPackAuthTokenZscalerHec struct {
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	// Shared secret to be provided by any client (Authorization: <token>)
	Token       string  `json:"token"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
}

func (c CreateInputSystemByPackAuthTokenZscalerHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackAuthTokenZscalerHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"token"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackAuthTokenZscalerHec) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackAuthTokenZscalerHec) GetTokenSecret() *string {
	if c == nil {
		return nil
	}
	return c.TokenSecret
}

func (c *CreateInputSystemByPackAuthTokenZscalerHec) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CreateInputSystemByPackAuthTokenZscalerHec) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputSystemByPackAuthTokenZscalerHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackAuthTokenZscalerHec) GetAllowedIndexesAtToken() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexesAtToken
}

func (c *CreateInputSystemByPackAuthTokenZscalerHec) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

type CreateInputSystemByPackInputZscalerHec struct {
	// Unique ID for this input
	ID       string                                `json:"id"`
	Type     CreateInputSystemByPackTypeZscalerHec `json:"type"`
	Disabled *bool                                 `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []CreateInputSystemByPackAuthTokenZscalerHec `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType        `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `json:"keepAliveTimeout,omitempty"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Whether to enable Zscaler HEC acknowledgements
	HecAcks *bool `json:"hecAcks,omitempty"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `json:"emitTokenMetrics,omitempty"`
	Description      *string `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'hecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'hecAPI' at runtime.
	TemplateHecAPI *string `json:"__template_hecAPI,omitempty"`
}

func (c CreateInputSystemByPackInputZscalerHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputZscalerHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "hecAPI"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputZscalerHec) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputZscalerHec) GetType() CreateInputSystemByPackTypeZscalerHec {
	if c == nil {
		return CreateInputSystemByPackTypeZscalerHec("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputZscalerHec) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputZscalerHec) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputZscalerHec) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputZscalerHec) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputZscalerHec) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputZscalerHec) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputZscalerHec) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputZscalerHec) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputZscalerHec) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputZscalerHec) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputZscalerHec) GetAuthTokens() []CreateInputSystemByPackAuthTokenZscalerHec {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputZscalerHec) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputZscalerHec) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputZscalerHec) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputZscalerHec) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputZscalerHec) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputZscalerHec) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputZscalerHec) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputZscalerHec) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputZscalerHec) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputZscalerHec) GetEnableHealthCheck() any {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputZscalerHec) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputZscalerHec) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputZscalerHec) GetHecAPI() string {
	if c == nil {
		return ""
	}
	return c.HecAPI
}

func (c *CreateInputSystemByPackInputZscalerHec) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputZscalerHec) GetAllowedIndexes() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexes
}

func (c *CreateInputSystemByPackInputZscalerHec) GetHecAcks() *bool {
	if c == nil {
		return nil
	}
	return c.HecAcks
}

func (c *CreateInputSystemByPackInputZscalerHec) GetAccessControlAllowOrigin() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowOrigin
}

func (c *CreateInputSystemByPackInputZscalerHec) GetAccessControlAllowHeaders() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowHeaders
}

func (c *CreateInputSystemByPackInputZscalerHec) GetEmitTokenMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.EmitTokenMetrics
}

func (c *CreateInputSystemByPackInputZscalerHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputZscalerHec) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputZscalerHec) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputSystemByPackInputZscalerHec) GetTemplateHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHecAPI
}

type CreateInputSystemByPackTypeSecurityLake string

const (
	CreateInputSystemByPackTypeSecurityLakeSecurityLake CreateInputSystemByPackTypeSecurityLake = "security_lake"
)

func (e CreateInputSystemByPackTypeSecurityLake) ToPointer() *CreateInputSystemByPackTypeSecurityLake {
	return &e
}
func (e *CreateInputSystemByPackTypeSecurityLake) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "security_lake":
		*e = CreateInputSystemByPackTypeSecurityLake(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeSecurityLake: %v", v)
	}
}

type CreateInputSystemByPackInputSecurityLake struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackTypeSecurityLake `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `json:"includeSqsMetadata,omitempty"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `json:"enableSQSAssumeRole,omitempty"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `json:"parquetChunkDownloadTimeout,omitempty"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputSystemByPackInputSecurityLake) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSecurityLake) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSecurityLake) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSecurityLake) GetType() CreateInputSystemByPackTypeSecurityLake {
	if c == nil {
		return CreateInputSystemByPackTypeSecurityLake("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSecurityLake) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSecurityLake) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSecurityLake) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSecurityLake) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSecurityLake) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSecurityLake) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSecurityLake) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSecurityLake) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSecurityLake) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputSystemByPackInputSecurityLake) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputSystemByPackInputSecurityLake) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputSystemByPackInputSecurityLake) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputSecurityLake) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputSecurityLake) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputSecurityLake) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputSecurityLake) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputSecurityLake) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputSecurityLake) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputSecurityLake) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputSecurityLake) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputSecurityLake) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputSystemByPackInputSecurityLake) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputSystemByPackInputSecurityLake) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputSystemByPackInputSecurityLake) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputSecurityLake) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputSystemByPackInputSecurityLake) GetIncludeSqsMetadata() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeSqsMetadata
}

func (c *CreateInputSystemByPackInputSecurityLake) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputSecurityLake) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputSecurityLake) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputSecurityLake) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputSecurityLake) GetEnableSQSAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableSQSAssumeRole
}

func (c *CreateInputSystemByPackInputSecurityLake) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputSystemByPackInputSecurityLake) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSecurityLake) GetParquetChunkSizeMB() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkSizeMB
}

func (c *CreateInputSystemByPackInputSecurityLake) GetParquetChunkDownloadTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkDownloadTimeout
}

func (c *CreateInputSystemByPackInputSecurityLake) GetCheckpointing() *components.CheckpointingType {
	if c == nil {
		return nil
	}
	return c.Checkpointing
}

func (c *CreateInputSystemByPackInputSecurityLake) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputSystemByPackInputSecurityLake) GetEncoding() *string {
	if c == nil {
		return nil
	}
	return c.Encoding
}

func (c *CreateInputSystemByPackInputSecurityLake) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputSecurityLake) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputSecurityLake) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputSecurityLake) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if c == nil {
		return nil
	}
	return c.TagAfterProcessing
}

func (c *CreateInputSystemByPackInputSecurityLake) GetProcessedTagKey() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagKey
}

func (c *CreateInputSystemByPackInputSecurityLake) GetProcessedTagValue() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagValue
}

func (c *CreateInputSystemByPackInputSecurityLake) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputSystemByPackInputSecurityLake) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputSystemByPackInputSecurityLake) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputSecurityLake) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputSecurityLake) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputSecurityLake) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputSecurityLake) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputSystemByPackTypeNetflow string

const (
	CreateInputSystemByPackTypeNetflowNetflow CreateInputSystemByPackTypeNetflow = "netflow"
)

func (e CreateInputSystemByPackTypeNetflow) ToPointer() *CreateInputSystemByPackTypeNetflow {
	return &e
}
func (e *CreateInputSystemByPackTypeNetflow) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "netflow":
		*e = CreateInputSystemByPackTypeNetflow(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeNetflow: %v", v)
	}
}

type CreateInputSystemByPackInputNetflow struct {
	// Unique ID for this input
	ID       string                             `json:"id"`
	Type     CreateInputSystemByPackTypeNetflow `json:"type"`
	Disabled *bool                              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
	EnablePassThrough *bool `json:"enablePassThrough,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
	TemplateCacheMinutes *float64 `json:"templateCacheMinutes,omitempty"`
	// Accept messages in Netflow V5 format.
	V5Enabled *bool `json:"v5Enabled,omitempty"`
	// Accept messages in Netflow V9 format.
	V9Enabled *bool `json:"v9Enabled,omitempty"`
	// Accept messages in IPFIX format.
	IpfixEnabled *bool `json:"ipfixEnabled,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputNetflow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputNetflow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputNetflow) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputNetflow) GetType() CreateInputSystemByPackTypeNetflow {
	if c == nil {
		return CreateInputSystemByPackTypeNetflow("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputNetflow) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputNetflow) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputNetflow) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputNetflow) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputNetflow) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputNetflow) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputNetflow) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputNetflow) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputNetflow) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputNetflow) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputNetflow) GetEnablePassThrough() *bool {
	if c == nil {
		return nil
	}
	return c.EnablePassThrough
}

func (c *CreateInputSystemByPackInputNetflow) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputNetflow) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputNetflow) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputSystemByPackInputNetflow) GetTemplateCacheMinutes() *float64 {
	if c == nil {
		return nil
	}
	return c.TemplateCacheMinutes
}

func (c *CreateInputSystemByPackInputNetflow) GetV5Enabled() *bool {
	if c == nil {
		return nil
	}
	return c.V5Enabled
}

func (c *CreateInputSystemByPackInputNetflow) GetV9Enabled() *bool {
	if c == nil {
		return nil
	}
	return c.V9Enabled
}

func (c *CreateInputSystemByPackInputNetflow) GetIpfixEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.IpfixEnabled
}

func (c *CreateInputSystemByPackInputNetflow) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputNetflow) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputNetflow) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputNetflow) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeWizWebhook string

const (
	CreateInputSystemByPackTypeWizWebhookWizWebhook CreateInputSystemByPackTypeWizWebhook = "wiz_webhook"
)

func (e CreateInputSystemByPackTypeWizWebhook) ToPointer() *CreateInputSystemByPackTypeWizWebhook {
	return &e
}
func (e *CreateInputSystemByPackTypeWizWebhook) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wiz_webhook":
		*e = CreateInputSystemByPackTypeWizWebhook(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeWizWebhook: %v", v)
	}
}

type CreateInputSystemByPackInputWizWebhook struct {
	// Unique ID for this input
	ID       string                                `json:"id"`
	Type     CreateInputSystemByPackTypeWizWebhook `json:"type"`
	Disabled *bool                                 `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input. Wildcards are supported (such as /api/v*/hook). Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputWizWebhook) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputWizWebhook) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputWizWebhook) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputWizWebhook) GetType() CreateInputSystemByPackTypeWizWebhook {
	if c == nil {
		return CreateInputSystemByPackTypeWizWebhook("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputWizWebhook) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputWizWebhook) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputWizWebhook) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputWizWebhook) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputWizWebhook) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputWizWebhook) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputWizWebhook) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputWizWebhook) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputWizWebhook) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputWizWebhook) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputWizWebhook) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputWizWebhook) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputWizWebhook) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputWizWebhook) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputWizWebhook) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputWizWebhook) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputWizWebhook) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputWizWebhook) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputWizWebhook) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputWizWebhook) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputWizWebhook) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputWizWebhook) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputWizWebhook) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputWizWebhook) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputWizWebhook) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputWizWebhook) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputWizWebhook) GetAllowedPaths() []string {
	if c == nil {
		return nil
	}
	return c.AllowedPaths
}

func (c *CreateInputSystemByPackInputWizWebhook) GetAllowedMethods() []string {
	if c == nil {
		return nil
	}
	return c.AllowedMethods
}

func (c *CreateInputSystemByPackInputWizWebhook) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if c == nil {
		return nil
	}
	return c.AuthTokensExt
}

func (c *CreateInputSystemByPackInputWizWebhook) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputWizWebhook) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputWizWebhook) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeWiz string

const (
	CreateInputSystemByPackTypeWizWiz CreateInputSystemByPackTypeWiz = "wiz"
)

func (e CreateInputSystemByPackTypeWiz) ToPointer() *CreateInputSystemByPackTypeWiz {
	return &e
}
func (e *CreateInputSystemByPackTypeWiz) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wiz":
		*e = CreateInputSystemByPackTypeWiz(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeWiz: %v", v)
	}
}

type CreateInputSystemByPackManageState struct {
}

func (c CreateInputSystemByPackManageState) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackManageState) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

// CreateInputSystemByPackContentConfigLogLevel - Collector runtime log level
type CreateInputSystemByPackContentConfigLogLevel string

const (
	CreateInputSystemByPackContentConfigLogLevelError CreateInputSystemByPackContentConfigLogLevel = "error"
	CreateInputSystemByPackContentConfigLogLevelWarn  CreateInputSystemByPackContentConfigLogLevel = "warn"
	CreateInputSystemByPackContentConfigLogLevelInfo  CreateInputSystemByPackContentConfigLogLevel = "info"
	CreateInputSystemByPackContentConfigLogLevelDebug CreateInputSystemByPackContentConfigLogLevel = "debug"
	CreateInputSystemByPackContentConfigLogLevelSilly CreateInputSystemByPackContentConfigLogLevel = "silly"
)

func (e CreateInputSystemByPackContentConfigLogLevel) ToPointer() *CreateInputSystemByPackContentConfigLogLevel {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackContentConfigLogLevel) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug", "silly":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackContentConfigWiz struct {
	// The name of the Wiz query
	ContentType        string  `json:"contentType"`
	ContentDescription *string `json:"contentDescription,omitempty"`
	Enabled            *bool   `json:"enabled,omitempty"`
	// Track collection progress between consecutive scheduled executions
	StateTracking *bool `json:"stateTracking,omitempty"`
	// JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information.
	StateUpdateExpression *string `json:"stateUpdateExpression,omitempty"`
	// JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep.
	StateMergeExpression *string                             `json:"stateMergeExpression,omitempty"`
	ManageState          *CreateInputSystemByPackManageState `json:"manageState,omitempty"`
	// Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`.
	ContentQuery string `json:"contentQuery"`
	// A cron schedule on which to run this job
	CronSchedule string `json:"cronSchedule"`
	// Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
	Earliest string `json:"earliest"`
	// Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
	Latest string `json:"latest"`
	// Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// Collector runtime log level
	LogLevel *CreateInputSystemByPackContentConfigLogLevel `json:"logLevel,omitempty"`
	// Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages.
	MaxPages *float64 `json:"maxPages,omitempty"`
}

func (c CreateInputSystemByPackContentConfigWiz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackContentConfigWiz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"contentType", "contentQuery", "cronSchedule", "earliest", "latest"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackContentConfigWiz) GetContentType() string {
	if c == nil {
		return ""
	}
	return c.ContentType
}

func (c *CreateInputSystemByPackContentConfigWiz) GetContentDescription() *string {
	if c == nil {
		return nil
	}
	return c.ContentDescription
}

func (c *CreateInputSystemByPackContentConfigWiz) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputSystemByPackContentConfigWiz) GetStateTracking() *bool {
	if c == nil {
		return nil
	}
	return c.StateTracking
}

func (c *CreateInputSystemByPackContentConfigWiz) GetStateUpdateExpression() *string {
	if c == nil {
		return nil
	}
	return c.StateUpdateExpression
}

func (c *CreateInputSystemByPackContentConfigWiz) GetStateMergeExpression() *string {
	if c == nil {
		return nil
	}
	return c.StateMergeExpression
}

func (c *CreateInputSystemByPackContentConfigWiz) GetManageState() *CreateInputSystemByPackManageState {
	if c == nil {
		return nil
	}
	return c.ManageState
}

func (c *CreateInputSystemByPackContentConfigWiz) GetContentQuery() string {
	if c == nil {
		return ""
	}
	return c.ContentQuery
}

func (c *CreateInputSystemByPackContentConfigWiz) GetCronSchedule() string {
	if c == nil {
		return ""
	}
	return c.CronSchedule
}

func (c *CreateInputSystemByPackContentConfigWiz) GetEarliest() string {
	if c == nil {
		return ""
	}
	return c.Earliest
}

func (c *CreateInputSystemByPackContentConfigWiz) GetLatest() string {
	if c == nil {
		return ""
	}
	return c.Latest
}

func (c *CreateInputSystemByPackContentConfigWiz) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputSystemByPackContentConfigWiz) GetLogLevel() *CreateInputSystemByPackContentConfigLogLevel {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputSystemByPackContentConfigWiz) GetMaxPages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxPages
}

type CreateInputSystemByPackInputWiz struct {
	// Unique ID for this input
	ID       string                         `json:"id"`
	Type     CreateInputSystemByPackTypeWiz `json:"type"`
	Disabled *bool                          `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
	Endpoint string `json:"endpoint"`
	// The authentication URL to generate an OAuth token
	AuthURL string `json:"authUrl"`
	// The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
	AuthAudienceOverride *string `json:"authAudienceOverride,omitempty"`
	// The client ID of the Wiz application
	ClientID      string                                    `json:"clientId"`
	ContentConfig []CreateInputSystemByPackContentConfigWiz `json:"contentConfig"`
	// HTTP request inactivity timeout. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `json:"authType,omitempty"`
	Description *string                                  `json:"description,omitempty"`
	// The client secret of the Wiz application
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'endpoint' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'endpoint' at runtime.
	TemplateEndpoint *string `json:"__template_endpoint,omitempty"`
	// Binds 'authUrl' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'authUrl' at runtime.
	TemplateAuthURL *string `json:"__template_authUrl,omitempty"`
	// Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime.
	TemplateClientID *string `json:"__template_clientId,omitempty"`
}

func (c CreateInputSystemByPackInputWiz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputWiz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "endpoint", "authUrl", "clientId", "contentConfig"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputWiz) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputWiz) GetType() CreateInputSystemByPackTypeWiz {
	if c == nil {
		return CreateInputSystemByPackTypeWiz("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputWiz) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputWiz) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputWiz) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputWiz) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputWiz) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputWiz) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputWiz) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputWiz) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputWiz) GetEndpoint() string {
	if c == nil {
		return ""
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputWiz) GetAuthURL() string {
	if c == nil {
		return ""
	}
	return c.AuthURL
}

func (c *CreateInputSystemByPackInputWiz) GetAuthAudienceOverride() *string {
	if c == nil {
		return nil
	}
	return c.AuthAudienceOverride
}

func (c *CreateInputSystemByPackInputWiz) GetClientID() string {
	if c == nil {
		return ""
	}
	return c.ClientID
}

func (c *CreateInputSystemByPackInputWiz) GetContentConfig() []CreateInputSystemByPackContentConfigWiz {
	if c == nil {
		return []CreateInputSystemByPackContentConfigWiz{}
	}
	return c.ContentConfig
}

func (c *CreateInputSystemByPackInputWiz) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputWiz) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputSystemByPackInputWiz) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputSystemByPackInputWiz) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputSystemByPackInputWiz) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputSystemByPackInputWiz) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputWiz) GetRetryRules() *components.RetryRulesType {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputSystemByPackInputWiz) GetAuthType() *components.AuthenticationMethodOptions1 {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputWiz) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputWiz) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateInputSystemByPackInputWiz) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputWiz) GetTemplateEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.TemplateEndpoint
}

func (c *CreateInputSystemByPackInputWiz) GetTemplateAuthURL() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAuthURL
}

func (c *CreateInputSystemByPackInputWiz) GetTemplateClientID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientID
}

type CreateInputSystemByPackInputJournalFilesType string

const (
	CreateInputSystemByPackInputJournalFilesTypeJournalFiles CreateInputSystemByPackInputJournalFilesType = "journal_files"
)

func (e CreateInputSystemByPackInputJournalFilesType) ToPointer() *CreateInputSystemByPackInputJournalFilesType {
	return &e
}
func (e *CreateInputSystemByPackInputJournalFilesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "journal_files":
		*e = CreateInputSystemByPackInputJournalFilesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackInputJournalFilesType: %v", v)
	}
}

type CreateInputSystemByPackInputJournalFilesRule struct {
	// JavaScript expression applied to Journal objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputJournalFilesRule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputJournalFilesRule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputJournalFilesRule) GetFilter() string {
	if c == nil {
		return ""
	}
	return c.Filter
}

func (c *CreateInputSystemByPackInputJournalFilesRule) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackInputJournalFiles struct {
	// Unique ID for this input
	ID       string                                       `json:"id"`
	Type     CreateInputSystemByPackInputJournalFilesType `json:"type"`
	Disabled *bool                                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
	Path string `json:"path"`
	// Time, in seconds, between scanning for journals.
	Interval *float64 `json:"interval,omitempty"`
	// The full path of discovered journals are matched against this wildcard list.
	Journals []string `json:"journals"`
	// Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
	Rules []CreateInputSystemByPackInputJournalFilesRule `json:"rules,omitempty"`
	// Skip log messages that are not part of the current boot session.
	CurrentBoot *bool `json:"currentBoot,omitempty"`
	// The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputJournalFiles) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputJournalFiles) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "path", "journals"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputJournalFiles) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputJournalFiles) GetType() CreateInputSystemByPackInputJournalFilesType {
	if c == nil {
		return CreateInputSystemByPackInputJournalFilesType("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputJournalFiles) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputJournalFiles) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputJournalFiles) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputJournalFiles) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputJournalFiles) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputJournalFiles) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputJournalFiles) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputJournalFiles) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputJournalFiles) GetPath() string {
	if c == nil {
		return ""
	}
	return c.Path
}

func (c *CreateInputSystemByPackInputJournalFiles) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputJournalFiles) GetJournals() []string {
	if c == nil {
		return []string{}
	}
	return c.Journals
}

func (c *CreateInputSystemByPackInputJournalFiles) GetRules() []CreateInputSystemByPackInputJournalFilesRule {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *CreateInputSystemByPackInputJournalFiles) GetCurrentBoot() *bool {
	if c == nil {
		return nil
	}
	return c.CurrentBoot
}

func (c *CreateInputSystemByPackInputJournalFiles) GetMaxAgeDur() *string {
	if c == nil {
		return nil
	}
	return c.MaxAgeDur
}

func (c *CreateInputSystemByPackInputJournalFiles) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputJournalFiles) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeRawUDP string

const (
	CreateInputSystemByPackTypeRawUDPRawUDP CreateInputSystemByPackTypeRawUDP = "raw_udp"
)

func (e CreateInputSystemByPackTypeRawUDP) ToPointer() *CreateInputSystemByPackTypeRawUDP {
	return &e
}
func (e *CreateInputSystemByPackTypeRawUDP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "raw_udp":
		*e = CreateInputSystemByPackTypeRawUDP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeRawUDP: %v", v)
	}
}

type CreateInputSystemByPackInputRawUDP struct {
	// Unique ID for this input
	ID       string                            `json:"id"`
	Type     CreateInputSystemByPackTypeRawUDP `json:"type"`
	Disabled *bool                             `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
	IngestRawBytes *bool `json:"ingestRawBytes,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputRawUDP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputRawUDP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputRawUDP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputRawUDP) GetType() CreateInputSystemByPackTypeRawUDP {
	if c == nil {
		return CreateInputSystemByPackTypeRawUDP("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputRawUDP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputRawUDP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputRawUDP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputRawUDP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputRawUDP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputRawUDP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputRawUDP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputRawUDP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputRawUDP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputRawUDP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputRawUDP) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputSystemByPackInputRawUDP) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputRawUDP) GetSingleMsgUDPPackets() *bool {
	if c == nil {
		return nil
	}
	return c.SingleMsgUDPPackets
}

func (c *CreateInputSystemByPackInputRawUDP) GetIngestRawBytes() *bool {
	if c == nil {
		return nil
	}
	return c.IngestRawBytes
}

func (c *CreateInputSystemByPackInputRawUDP) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputSystemByPackInputRawUDP) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputRawUDP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputRawUDP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputRawUDP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeWinEventLogs string

const (
	CreateInputSystemByPackTypeWinEventLogsWinEventLogs CreateInputSystemByPackTypeWinEventLogs = "win_event_logs"
)

func (e CreateInputSystemByPackTypeWinEventLogs) ToPointer() *CreateInputSystemByPackTypeWinEventLogs {
	return &e
}
func (e *CreateInputSystemByPackTypeWinEventLogs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "win_event_logs":
		*e = CreateInputSystemByPackTypeWinEventLogs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeWinEventLogs: %v", v)
	}
}

// CreateInputSystemByPackReadMode - Read all stored and future event logs, or only future events
type CreateInputSystemByPackReadMode string

const (
	// CreateInputSystemByPackReadModeOldest Entire log
	CreateInputSystemByPackReadModeOldest CreateInputSystemByPackReadMode = "oldest"
	// CreateInputSystemByPackReadModeNewest From last entry
	CreateInputSystemByPackReadModeNewest CreateInputSystemByPackReadMode = "newest"
)

func (e CreateInputSystemByPackReadMode) ToPointer() *CreateInputSystemByPackReadMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackReadMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "oldest", "newest":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackEventFormat - Format of individual events
type CreateInputSystemByPackEventFormat string

const (
	// CreateInputSystemByPackEventFormatJSON JSON
	CreateInputSystemByPackEventFormatJSON CreateInputSystemByPackEventFormat = "json"
	// CreateInputSystemByPackEventFormatXML XML
	CreateInputSystemByPackEventFormatXML CreateInputSystemByPackEventFormat = "xml"
)

func (e CreateInputSystemByPackEventFormat) ToPointer() *CreateInputSystemByPackEventFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackEventFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "json", "xml":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputWinEventLogs struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackTypeWinEventLogs `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
	LogNames []string `json:"logNames"`
	// Read all stored and future event logs, or only future events
	ReadMode *CreateInputSystemByPackReadMode `json:"readMode,omitempty"`
	// Format of individual events
	EventFormat *CreateInputSystemByPackEventFormat `json:"eventFormat,omitempty"`
	// Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
	DisableNativeModule *bool `json:"disableNativeModule,omitempty"`
	// Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
	Interval *float64 `json:"interval,omitempty"`
	// The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
	BatchSize *float64 `json:"batchSize,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// The maximum number of bytes in an event before it is flushed to the pipelines
	MaxEventBytes *float64 `json:"maxEventBytes,omitempty"`
	Description   *string  `json:"description,omitempty"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableJSONRendering *bool `json:"disableJsonRendering,omitempty"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableXMLRendering *bool `json:"disableXmlRendering,omitempty"`
}

func (c CreateInputSystemByPackInputWinEventLogs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputWinEventLogs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "logNames"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetType() CreateInputSystemByPackTypeWinEventLogs {
	if c == nil {
		return CreateInputSystemByPackTypeWinEventLogs("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetLogNames() []string {
	if c == nil {
		return []string{}
	}
	return c.LogNames
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetReadMode() *CreateInputSystemByPackReadMode {
	if c == nil {
		return nil
	}
	return c.ReadMode
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetEventFormat() *CreateInputSystemByPackEventFormat {
	if c == nil {
		return nil
	}
	return c.EventFormat
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetDisableNativeModule() *bool {
	if c == nil {
		return nil
	}
	return c.DisableNativeModule
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetBatchSize() *float64 {
	if c == nil {
		return nil
	}
	return c.BatchSize
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetMaxEventBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxEventBytes
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetDisableJSONRendering() *bool {
	if c == nil {
		return nil
	}
	return c.DisableJSONRendering
}

func (c *CreateInputSystemByPackInputWinEventLogs) GetDisableXMLRendering() *bool {
	if c == nil {
		return nil
	}
	return c.DisableXMLRendering
}

type CreateInputSystemByPackTypeWef string

const (
	CreateInputSystemByPackTypeWefWef CreateInputSystemByPackTypeWef = "wef"
)

func (e CreateInputSystemByPackTypeWef) ToPointer() *CreateInputSystemByPackTypeWef {
	return &e
}
func (e *CreateInputSystemByPackTypeWef) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wef":
		*e = CreateInputSystemByPackTypeWef(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeWef: %v", v)
	}
}

// CreateInputSystemByPackAuthMethodAuthenticationMethod - How to authenticate incoming client connections
type CreateInputSystemByPackAuthMethodAuthenticationMethod string

const (
	// CreateInputSystemByPackAuthMethodAuthenticationMethodClientCert Client certificate
	CreateInputSystemByPackAuthMethodAuthenticationMethodClientCert CreateInputSystemByPackAuthMethodAuthenticationMethod = "clientCert"
	// CreateInputSystemByPackAuthMethodAuthenticationMethodKerberos Kerberos
	CreateInputSystemByPackAuthMethodAuthenticationMethodKerberos CreateInputSystemByPackAuthMethodAuthenticationMethod = "kerberos"
)

func (e CreateInputSystemByPackAuthMethodAuthenticationMethod) ToPointer() *CreateInputSystemByPackAuthMethodAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackAuthMethodAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "clientCert", "kerberos":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackMTLSSettings struct {
	// Enable TLS
	Disabled *bool `json:"disabled,omitempty"`
	// Required for WEF certificate authentication
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Required for WEF certificate authentication
	RequestCert *bool `json:"requestCert,omitempty"`
	// Name of the predefined certificate
	CertificateName *string `json:"certificateName,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath string `json:"privKeyPath"`
	// Passphrase to use to decrypt private key
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath string `json:"certPath"`
	// Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
	CaPath string `json:"caPath"`
	// Regex matching allowable common names in peer certificates' subject attribute
	CommonNameRegex *string                                                    `json:"commonNameRegex,omitempty"`
	MinVersion      *components.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS `json:"minVersion,omitempty"`
	MaxVersion      *components.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS `json:"maxVersion,omitempty"`
	// Enable OCSP check of certificate
	OcspCheck *bool `json:"ocspCheck,omitempty"`
	Keytab    any   `json:"keytab,omitempty"`
	Principal any   `json:"principal,omitempty"`
	// If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors.
	OcspCheckFailClose *bool `json:"ocspCheckFailClose,omitempty"`
}

func (c CreateInputSystemByPackMTLSSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackMTLSSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"privKeyPath", "certPath", "caPath"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackMTLSSettings) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackMTLSSettings) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackMTLSSettings) GetRequestCert() *bool {
	if c == nil {
		return nil
	}
	return c.RequestCert
}

func (c *CreateInputSystemByPackMTLSSettings) GetCertificateName() *string {
	if c == nil {
		return nil
	}
	return c.CertificateName
}

func (c *CreateInputSystemByPackMTLSSettings) GetPrivKeyPath() string {
	if c == nil {
		return ""
	}
	return c.PrivKeyPath
}

func (c *CreateInputSystemByPackMTLSSettings) GetPassphrase() *string {
	if c == nil {
		return nil
	}
	return c.Passphrase
}

func (c *CreateInputSystemByPackMTLSSettings) GetCertPath() string {
	if c == nil {
		return ""
	}
	return c.CertPath
}

func (c *CreateInputSystemByPackMTLSSettings) GetCaPath() string {
	if c == nil {
		return ""
	}
	return c.CaPath
}

func (c *CreateInputSystemByPackMTLSSettings) GetCommonNameRegex() *string {
	if c == nil {
		return nil
	}
	return c.CommonNameRegex
}

func (c *CreateInputSystemByPackMTLSSettings) GetMinVersion() *components.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS {
	if c == nil {
		return nil
	}
	return c.MinVersion
}

func (c *CreateInputSystemByPackMTLSSettings) GetMaxVersion() *components.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS {
	if c == nil {
		return nil
	}
	return c.MaxVersion
}

func (c *CreateInputSystemByPackMTLSSettings) GetOcspCheck() *bool {
	if c == nil {
		return nil
	}
	return c.OcspCheck
}

func (c *CreateInputSystemByPackMTLSSettings) GetKeytab() any {
	if c == nil {
		return nil
	}
	return c.Keytab
}

func (c *CreateInputSystemByPackMTLSSettings) GetPrincipal() any {
	if c == nil {
		return nil
	}
	return c.Principal
}

func (c *CreateInputSystemByPackMTLSSettings) GetOcspCheckFailClose() *bool {
	if c == nil {
		return nil
	}
	return c.OcspCheckFailClose
}

// CreateInputSystemByPackFormat - Content format in which the endpoint should deliver events
type CreateInputSystemByPackFormat string

const (
	CreateInputSystemByPackFormatRaw          CreateInputSystemByPackFormat = "Raw"
	CreateInputSystemByPackFormatRenderedText CreateInputSystemByPackFormat = "RenderedText"
)

func (e CreateInputSystemByPackFormat) ToPointer() *CreateInputSystemByPackFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "Raw", "RenderedText":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackQueryBuilderMode string

const (
	CreateInputSystemByPackQueryBuilderModeSimple CreateInputSystemByPackQueryBuilderMode = "simple"
	CreateInputSystemByPackQueryBuilderModeXML    CreateInputSystemByPackQueryBuilderMode = "xml"
)

func (e CreateInputSystemByPackQueryBuilderMode) ToPointer() *CreateInputSystemByPackQueryBuilderMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackQueryBuilderMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "simple", "xml":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackQuery struct {
	// The Path attribute from the relevant XML Select element
	Path string `json:"path"`
	// The XPath query inside the relevant XML Select element
	QueryExpression string `json:"queryExpression"`
}

func (c CreateInputSystemByPackQuery) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackQuery) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"path", "queryExpression"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackQuery) GetPath() string {
	if c == nil {
		return ""
	}
	return c.Path
}

func (c *CreateInputSystemByPackQuery) GetQueryExpression() string {
	if c == nil {
		return ""
	}
	return c.QueryExpression
}

type CreateInputSystemByPackSubscription struct {
	SubscriptionName string `json:"subscriptionName"`
	// Version UUID for this subscription. If any subscription parameters are modified, this value will change.
	Version *string `json:"version,omitempty"`
	// Content format in which the endpoint should deliver events
	ContentFormat CreateInputSystemByPackFormat `json:"contentFormat"`
	// Maximum time (in seconds) between endpoint checkins before considering it unavailable
	HeartbeatInterval float64 `json:"heartbeatInterval"`
	// Interval (in seconds) over which the endpoint should collect events before sending them to Stream
	BatchTimeout float64 `json:"batchTimeout"`
	// Newly subscribed endpoints will send previously existing events. Disable to receive new events only.
	ReadExistingEvents *bool `json:"readExistingEvents,omitempty"`
	// Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details.
	SendBookmarks *bool `json:"sendBookmarks,omitempty"`
	// Receive compressed events from the source
	Compress *bool `json:"compress,omitempty"`
	// The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com
	Targets []string `json:"targets"`
	// The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US".
	Locale        *string                                  `json:"locale,omitempty"`
	QuerySelector *CreateInputSystemByPackQueryBuilderMode `json:"querySelector,omitempty"`
	// Fields to add to events ingested under this subscription
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Queries  []CreateInputSystemByPackQuery             `json:"queries,omitempty"`
	// The XPath query to use for selecting events
	XMLQuery *string `json:"xmlQuery,omitempty"`
}

func (c CreateInputSystemByPackSubscription) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackSubscription) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"subscriptionName", "contentFormat", "heartbeatInterval", "batchTimeout", "targets"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackSubscription) GetSubscriptionName() string {
	if c == nil {
		return ""
	}
	return c.SubscriptionName
}

func (c *CreateInputSystemByPackSubscription) GetVersion() *string {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CreateInputSystemByPackSubscription) GetContentFormat() CreateInputSystemByPackFormat {
	if c == nil {
		return CreateInputSystemByPackFormat("")
	}
	return c.ContentFormat
}

func (c *CreateInputSystemByPackSubscription) GetHeartbeatInterval() float64 {
	if c == nil {
		return 0.0
	}
	return c.HeartbeatInterval
}

func (c *CreateInputSystemByPackSubscription) GetBatchTimeout() float64 {
	if c == nil {
		return 0.0
	}
	return c.BatchTimeout
}

func (c *CreateInputSystemByPackSubscription) GetReadExistingEvents() *bool {
	if c == nil {
		return nil
	}
	return c.ReadExistingEvents
}

func (c *CreateInputSystemByPackSubscription) GetSendBookmarks() *bool {
	if c == nil {
		return nil
	}
	return c.SendBookmarks
}

func (c *CreateInputSystemByPackSubscription) GetCompress() *bool {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputSystemByPackSubscription) GetTargets() []string {
	if c == nil {
		return []string{}
	}
	return c.Targets
}

func (c *CreateInputSystemByPackSubscription) GetLocale() *string {
	if c == nil {
		return nil
	}
	return c.Locale
}

func (c *CreateInputSystemByPackSubscription) GetQuerySelector() *CreateInputSystemByPackQueryBuilderMode {
	if c == nil {
		return nil
	}
	return c.QuerySelector
}

func (c *CreateInputSystemByPackSubscription) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackSubscription) GetQueries() []CreateInputSystemByPackQuery {
	if c == nil {
		return nil
	}
	return c.Queries
}

func (c *CreateInputSystemByPackSubscription) GetXMLQuery() *string {
	if c == nil {
		return nil
	}
	return c.XMLQuery
}

type CreateInputSystemByPackInputWef struct {
	// Unique ID for this input
	ID       string                         `json:"id"`
	Type     CreateInputSystemByPackTypeWef `json:"type"`
	Disabled *bool                          `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// How to authenticate incoming client connections
	AuthMethod *CreateInputSystemByPackAuthMethodAuthenticationMethod `json:"authMethod,omitempty"`
	TLS        *CreateInputSystemByPackMTLSSettings                   `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
	CaFingerprint *string `json:"caFingerprint,omitempty"`
	// Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
	Keytab *string `json:"keytab,omitempty"`
	// Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
	Principal *string `json:"principal,omitempty"`
	// Allow events to be ingested even if their MachineID does not match the client certificate CN
	AllowMachineIDMismatch *bool `json:"allowMachineIdMismatch,omitempty"`
	// Subscriptions to events on forwarding endpoints
	Subscriptions []CreateInputSystemByPackSubscription `json:"subscriptions"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
	LogFingerprintMismatch *bool `json:"logFingerprintMismatch,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputWef) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputWef) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "subscriptions"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputWef) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputWef) GetType() CreateInputSystemByPackTypeWef {
	if c == nil {
		return CreateInputSystemByPackTypeWef("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputWef) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputWef) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputWef) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputWef) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputWef) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputWef) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputWef) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputWef) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputWef) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputWef) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputWef) GetAuthMethod() *CreateInputSystemByPackAuthMethodAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.AuthMethod
}

func (c *CreateInputSystemByPackInputWef) GetTLS() *CreateInputSystemByPackMTLSSettings {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputWef) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputWef) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputWef) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputWef) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputWef) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputWef) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputWef) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputWef) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputWef) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputWef) GetCaFingerprint() *string {
	if c == nil {
		return nil
	}
	return c.CaFingerprint
}

func (c *CreateInputSystemByPackInputWef) GetKeytab() *string {
	if c == nil {
		return nil
	}
	return c.Keytab
}

func (c *CreateInputSystemByPackInputWef) GetPrincipal() *string {
	if c == nil {
		return nil
	}
	return c.Principal
}

func (c *CreateInputSystemByPackInputWef) GetAllowMachineIDMismatch() *bool {
	if c == nil {
		return nil
	}
	return c.AllowMachineIDMismatch
}

func (c *CreateInputSystemByPackInputWef) GetSubscriptions() []CreateInputSystemByPackSubscription {
	if c == nil {
		return []CreateInputSystemByPackSubscription{}
	}
	return c.Subscriptions
}

func (c *CreateInputSystemByPackInputWef) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputWef) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputWef) GetLogFingerprintMismatch() *bool {
	if c == nil {
		return nil
	}
	return c.LogFingerprintMismatch
}

func (c *CreateInputSystemByPackInputWef) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputWef) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeAppscope string

const (
	CreateInputSystemByPackTypeAppscopeAppscope CreateInputSystemByPackTypeAppscope = "appscope"
)

func (e CreateInputSystemByPackTypeAppscope) ToPointer() *CreateInputSystemByPackTypeAppscope {
	return &e
}
func (e *CreateInputSystemByPackTypeAppscope) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "appscope":
		*e = CreateInputSystemByPackTypeAppscope(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeAppscope: %v", v)
	}
}

type CreateInputSystemByPackAllow struct {
	// Specify the name of a process or family of processes.
	Procname string `json:"procname"`
	// Specify a string to substring-match against process command-line.
	Arg *string `json:"arg,omitempty"`
	// Choose a config to apply to processes that match the process name and/or argument.
	Config string `json:"config"`
}

func (c CreateInputSystemByPackAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"procname", "config"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackAllow) GetProcname() string {
	if c == nil {
		return ""
	}
	return c.Procname
}

func (c *CreateInputSystemByPackAllow) GetArg() *string {
	if c == nil {
		return nil
	}
	return c.Arg
}

func (c *CreateInputSystemByPackAllow) GetConfig() string {
	if c == nil {
		return ""
	}
	return c.Config
}

type CreateInputSystemByPackFilterAppscope struct {
	// Specify processes that AppScope should be loaded into, and the config to use.
	Allow []CreateInputSystemByPackAllow `json:"allow,omitempty"`
	// To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
	TransportURL *string `json:"transportURL,omitempty"`
}

func (c CreateInputSystemByPackFilterAppscope) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackFilterAppscope) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackFilterAppscope) GetAllow() []CreateInputSystemByPackAllow {
	if c == nil {
		return nil
	}
	return c.Allow
}

func (c *CreateInputSystemByPackFilterAppscope) GetTransportURL() *string {
	if c == nil {
		return nil
	}
	return c.TransportURL
}

type CreateInputSystemByPackPersistenceAppscope struct {
	// Spool events and metrics on disk for Cribl Edge and Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputSystemByPackPersistenceAppscope) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackPersistenceAppscope) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackPersistenceAppscope) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputSystemByPackPersistenceAppscope) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputSystemByPackPersistenceAppscope) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputSystemByPackPersistenceAppscope) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputSystemByPackPersistenceAppscope) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputSystemByPackPersistenceAppscope) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputSystemByPackInputAppscope struct {
	// Unique ID for this input
	ID       string                              `json:"id"`
	Type     CreateInputSystemByPackTypeAppscope `json:"type"`
	Disabled *bool                               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
	EnableUnixPath *bool                                       `json:"enableUnixPath,omitempty"`
	Filter         *CreateInputSystemByPackFilterAppscope      `json:"filter,omitempty"`
	Persistence    *CreateInputSystemByPackPersistenceAppscope `json:"persistence,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	Description *string                                                `json:"description,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `json:"host,omitempty"`
	// Port to listen on
	Port *float64                              `json:"port,omitempty"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Path to the UNIX domain socket to listen on.
	UnixSocketPath *string `json:"unixSocketPath,omitempty"`
	// Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
	UnixSocketPerms *string `json:"unixSocketPerms,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `json:"authToken,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputAppscope) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputAppscope) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputAppscope) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputAppscope) GetType() CreateInputSystemByPackTypeAppscope {
	if c == nil {
		return CreateInputSystemByPackTypeAppscope("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputAppscope) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputAppscope) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputAppscope) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputAppscope) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputAppscope) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputAppscope) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputAppscope) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputAppscope) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputAppscope) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputAppscope) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputAppscope) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputSystemByPackInputAppscope) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputSystemByPackInputAppscope) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputSystemByPackInputAppscope) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputAppscope) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputAppscope) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputAppscope) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputAppscope) GetEnableUnixPath() *bool {
	if c == nil {
		return nil
	}
	return c.EnableUnixPath
}

func (c *CreateInputSystemByPackInputAppscope) GetFilter() *CreateInputSystemByPackFilterAppscope {
	if c == nil {
		return nil
	}
	return c.Filter
}

func (c *CreateInputSystemByPackInputAppscope) GetPersistence() *CreateInputSystemByPackPersistenceAppscope {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputSystemByPackInputAppscope) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputAppscope) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputAppscope) GetHost() *string {
	if c == nil {
		return nil
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputAppscope) GetPort() *float64 {
	if c == nil {
		return nil
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputAppscope) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputAppscope) GetUnixSocketPath() *string {
	if c == nil {
		return nil
	}
	return c.UnixSocketPath
}

func (c *CreateInputSystemByPackInputAppscope) GetUnixSocketPerms() *string {
	if c == nil {
		return nil
	}
	return c.UnixSocketPerms
}

func (c *CreateInputSystemByPackInputAppscope) GetAuthToken() *string {
	if c == nil {
		return nil
	}
	return c.AuthToken
}

func (c *CreateInputSystemByPackInputAppscope) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputAppscope) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputAppscope) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeTCP string

const (
	CreateInputSystemByPackTypeTCPTCP CreateInputSystemByPackTypeTCP = "tcp"
)

func (e CreateInputSystemByPackTypeTCP) ToPointer() *CreateInputSystemByPackTypeTCP {
	return &e
}
func (e *CreateInputSystemByPackTypeTCP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		*e = CreateInputSystemByPackTypeTCP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeTCP: %v", v)
	}
}

type CreateInputSystemByPackInputTCP struct {
	// Unique ID for this input
	ID       string                         `json:"id"`
	Type     CreateInputSystemByPackTypeTCP `json:"type"`
	Disabled *bool                          `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
	EnableHeader *bool                                             `json:"enableHeader,omitempty"`
	Preprocess   *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	Description  *string                                           `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `json:"authToken,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputTCP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputTCP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputTCP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputTCP) GetType() CreateInputSystemByPackTypeTCP {
	if c == nil {
		return CreateInputSystemByPackTypeTCP("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputTCP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputTCP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputTCP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputTCP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputTCP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputTCP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputTCP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputTCP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputTCP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputTCP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputTCP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputTCP) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputTCP) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputTCP) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputSystemByPackInputTCP) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputSystemByPackInputTCP) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputSystemByPackInputTCP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputTCP) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputTCP) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputTCP) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputTCP) GetEnableHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHeader
}

func (c *CreateInputSystemByPackInputTCP) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputSystemByPackInputTCP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputTCP) GetAuthToken() *string {
	if c == nil {
		return nil
	}
	return c.AuthToken
}

func (c *CreateInputSystemByPackInputTCP) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputTCP) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputTCP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputTCP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackInputFileType string

const (
	CreateInputSystemByPackInputFileTypeFile CreateInputSystemByPackInputFileType = "file"
)

func (e CreateInputSystemByPackInputFileType) ToPointer() *CreateInputSystemByPackInputFileType {
	return &e
}
func (e *CreateInputSystemByPackInputFileType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = CreateInputSystemByPackInputFileType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackInputFileType: %v", v)
	}
}

// CreateInputSystemByPackInputFileMode - Choose how to discover files to monitor
type CreateInputSystemByPackInputFileMode string

const (
	// CreateInputSystemByPackInputFileModeManual Manual
	CreateInputSystemByPackInputFileModeManual CreateInputSystemByPackInputFileMode = "manual"
	// CreateInputSystemByPackInputFileModeAuto Auto
	CreateInputSystemByPackInputFileModeAuto CreateInputSystemByPackInputFileMode = "auto"
)

func (e CreateInputSystemByPackInputFileMode) ToPointer() *CreateInputSystemByPackInputFileMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackInputFileMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "auto":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputFile struct {
	// Unique ID for this input
	ID       string                               `json:"id"`
	Type     CreateInputSystemByPackInputFileType `json:"type"`
	Disabled *bool                                `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Choose how to discover files to monitor
	Mode *CreateInputSystemByPackInputFileMode `json:"mode,omitempty"`
	// Time, in seconds, between scanning for files
	Interval *float64 `json:"interval,omitempty"`
	// The full path of discovered files are matched against this wildcard list
	Filenames []string `json:"filenames,omitempty"`
	// Apply filename allowlist to file entries in archive file types, like tar or zip.
	FilterArchivedFiles *bool `json:"filterArchivedFiles,omitempty"`
	// Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
	TailOnly *bool `json:"tailOnly,omitempty"`
	// Time, in seconds, before an idle file is closed
	IdleTimeout *float64 `json:"idleTimeout,omitempty"`
	// The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
	MinAgeDur *string `json:"minAgeDur,omitempty"`
	// The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Skip files with modification times earlier than the maximum age duration
	CheckFileModTime *bool `json:"checkFileModTime,omitempty"`
	// Forces files containing binary data to be streamed as text
	ForceText *bool `json:"forceText,omitempty"`
	// Length of file header bytes to use in hash for unique file identification
	HashLen *float64 `json:"hashLen,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	Description         *string  `json:"description,omitempty"`
	// Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
	Path *string `json:"path,omitempty"`
	// Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
	Depth                     *float64 `json:"depth,omitempty"`
	SuppressMissingPathErrors *bool    `json:"suppressMissingPathErrors,omitempty"`
	// Delete files after they have been collected
	DeleteFiles *bool `json:"deleteFiles,omitempty"`
	// Salt the file hash with the Source file path. Ensures that all files with the same header hash, such as CSV files, are ingested. Moving or renaming the file, or toggling this after starting the Source will cause re-ingestion.
	SaltHash *bool `json:"saltHash,omitempty"`
	// Stream binary files as Base64-encoded chunks.
	IncludeUnidentifiableBinary *bool `json:"includeUnidentifiableBinary,omitempty"`
}

func (c CreateInputSystemByPackInputFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputFile) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputFile) GetType() CreateInputSystemByPackInputFileType {
	if c == nil {
		return CreateInputSystemByPackInputFileType("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputFile) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputFile) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputFile) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputFile) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputFile) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputFile) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputFile) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputFile) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputFile) GetMode() *CreateInputSystemByPackInputFileMode {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackInputFile) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputFile) GetFilenames() []string {
	if c == nil {
		return nil
	}
	return c.Filenames
}

func (c *CreateInputSystemByPackInputFile) GetFilterArchivedFiles() *bool {
	if c == nil {
		return nil
	}
	return c.FilterArchivedFiles
}

func (c *CreateInputSystemByPackInputFile) GetTailOnly() *bool {
	if c == nil {
		return nil
	}
	return c.TailOnly
}

func (c *CreateInputSystemByPackInputFile) GetIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.IdleTimeout
}

func (c *CreateInputSystemByPackInputFile) GetMinAgeDur() *string {
	if c == nil {
		return nil
	}
	return c.MinAgeDur
}

func (c *CreateInputSystemByPackInputFile) GetMaxAgeDur() *string {
	if c == nil {
		return nil
	}
	return c.MaxAgeDur
}

func (c *CreateInputSystemByPackInputFile) GetCheckFileModTime() *bool {
	if c == nil {
		return nil
	}
	return c.CheckFileModTime
}

func (c *CreateInputSystemByPackInputFile) GetForceText() *bool {
	if c == nil {
		return nil
	}
	return c.ForceText
}

func (c *CreateInputSystemByPackInputFile) GetHashLen() *float64 {
	if c == nil {
		return nil
	}
	return c.HashLen
}

func (c *CreateInputSystemByPackInputFile) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputFile) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputFile) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputFile) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputFile) GetPath() *string {
	if c == nil {
		return nil
	}
	return c.Path
}

func (c *CreateInputSystemByPackInputFile) GetDepth() *float64 {
	if c == nil {
		return nil
	}
	return c.Depth
}

func (c *CreateInputSystemByPackInputFile) GetSuppressMissingPathErrors() *bool {
	if c == nil {
		return nil
	}
	return c.SuppressMissingPathErrors
}

func (c *CreateInputSystemByPackInputFile) GetDeleteFiles() *bool {
	if c == nil {
		return nil
	}
	return c.DeleteFiles
}

func (c *CreateInputSystemByPackInputFile) GetSaltHash() *bool {
	if c == nil {
		return nil
	}
	return c.SaltHash
}

func (c *CreateInputSystemByPackInputFile) GetIncludeUnidentifiableBinary() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeUnidentifiableBinary
}

type CreateInputSystemByPackInputSyslogType2 string

const (
	CreateInputSystemByPackInputSyslogType2Syslog CreateInputSystemByPackInputSyslogType2 = "syslog"
)

func (e CreateInputSystemByPackInputSyslogType2) ToPointer() *CreateInputSystemByPackInputSyslogType2 {
	return &e
}
func (e *CreateInputSystemByPackInputSyslogType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = CreateInputSystemByPackInputSyslogType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackInputSyslogType2: %v", v)
	}
}

type CreateInputSystemByPackInputSyslogSyslog2 struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackInputSyslogType2 `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort float64 `json:"tcpPort"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Timezone to assign to timestamps without timezone info
	TimestampTimezone *string `json:"timestampTimezone,omitempty"`
	// Treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Wildcard list of fields to keep from source data; * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting *bool `json:"octetCounting,omitempty"`
	// Enable if we should infer the syslog framing of the incoming messages.
	InferFraming *bool `json:"inferFraming,omitempty"`
	// Enable if we should infer octet counting only if the messages comply with RFC 5424.
	StrictlyInferOctetCounting *bool `json:"strictlyInferOctetCounting,omitempty"`
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`
	// Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64                              `json:"socketMaxLifespan,omitempty"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `json:"enableLoadBalancing,omitempty"`
	Description         *string `json:"description,omitempty"`
	// When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
	EnableEnhancedProxyHeaderParsing *bool `json:"enableEnhancedProxyHeaderParsing,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime.
	TemplateUDPPort *string `json:"__template_udpPort,omitempty"`
	// Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime.
	TemplateTCPPort *string `json:"__template_tcpPort,omitempty"`
}

func (c CreateInputSystemByPackInputSyslogSyslog2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "tcpPort"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetType() CreateInputSystemByPackInputSyslogType2 {
	if c == nil {
		return CreateInputSystemByPackInputSyslogType2("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetUDPPort() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPPort
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetTCPPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.TCPPort
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetTimestampTimezone() *string {
	if c == nil {
		return nil
	}
	return c.TimestampTimezone
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetSingleMsgUDPPackets() *bool {
	if c == nil {
		return nil
	}
	return c.SingleMsgUDPPackets
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetKeepFieldsList() []string {
	if c == nil {
		return nil
	}
	return c.KeepFieldsList
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetOctetCounting() *bool {
	if c == nil {
		return nil
	}
	return c.OctetCounting
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetInferFraming() *bool {
	if c == nil {
		return nil
	}
	return c.InferFraming
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetStrictlyInferOctetCounting() *bool {
	if c == nil {
		return nil
	}
	return c.StrictlyInferOctetCounting
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetAllowNonStandardAppName() *bool {
	if c == nil {
		return nil
	}
	return c.AllowNonStandardAppName
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetEnableEnhancedProxyHeaderParsing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableEnhancedProxyHeaderParsing
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetTemplateUDPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateUDPPort
}

func (c *CreateInputSystemByPackInputSyslogSyslog2) GetTemplateTCPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTCPPort
}

type CreateInputSystemByPackInputSyslogType1 string

const (
	CreateInputSystemByPackInputSyslogType1Syslog CreateInputSystemByPackInputSyslogType1 = "syslog"
)

func (e CreateInputSystemByPackInputSyslogType1) ToPointer() *CreateInputSystemByPackInputSyslogType1 {
	return &e
}
func (e *CreateInputSystemByPackInputSyslogType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = CreateInputSystemByPackInputSyslogType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackInputSyslogType1: %v", v)
	}
}

type CreateInputSystemByPackInputSyslogSyslog1 struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackInputSyslogType1 `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort float64 `json:"udpPort"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Timezone to assign to timestamps without timezone info
	TimestampTimezone *string `json:"timestampTimezone,omitempty"`
	// Treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Wildcard list of fields to keep from source data; * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting *bool `json:"octetCounting,omitempty"`
	// Enable if we should infer the syslog framing of the incoming messages.
	InferFraming *bool `json:"inferFraming,omitempty"`
	// Enable if we should infer octet counting only if the messages comply with RFC 5424.
	StrictlyInferOctetCounting *bool `json:"strictlyInferOctetCounting,omitempty"`
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`
	// Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64                              `json:"socketMaxLifespan,omitempty"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `json:"enableLoadBalancing,omitempty"`
	Description         *string `json:"description,omitempty"`
	// When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
	EnableEnhancedProxyHeaderParsing *bool `json:"enableEnhancedProxyHeaderParsing,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime.
	TemplateUDPPort *string `json:"__template_udpPort,omitempty"`
	// Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime.
	TemplateTCPPort *string `json:"__template_tcpPort,omitempty"`
}

func (c CreateInputSystemByPackInputSyslogSyslog1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "udpPort"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetType() CreateInputSystemByPackInputSyslogType1 {
	if c == nil {
		return CreateInputSystemByPackInputSyslogType1("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetUDPPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.UDPPort
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetTCPPort() *float64 {
	if c == nil {
		return nil
	}
	return c.TCPPort
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetTimestampTimezone() *string {
	if c == nil {
		return nil
	}
	return c.TimestampTimezone
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetSingleMsgUDPPackets() *bool {
	if c == nil {
		return nil
	}
	return c.SingleMsgUDPPackets
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetKeepFieldsList() []string {
	if c == nil {
		return nil
	}
	return c.KeepFieldsList
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetOctetCounting() *bool {
	if c == nil {
		return nil
	}
	return c.OctetCounting
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetInferFraming() *bool {
	if c == nil {
		return nil
	}
	return c.InferFraming
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetStrictlyInferOctetCounting() *bool {
	if c == nil {
		return nil
	}
	return c.StrictlyInferOctetCounting
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetAllowNonStandardAppName() *bool {
	if c == nil {
		return nil
	}
	return c.AllowNonStandardAppName
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetEnableEnhancedProxyHeaderParsing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableEnhancedProxyHeaderParsing
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetTemplateUDPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateUDPPort
}

func (c *CreateInputSystemByPackInputSyslogSyslog1) GetTemplateTCPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTCPPort
}

type CreateInputSystemByPackInputSyslogUnionType string

const (
	CreateInputSystemByPackInputSyslogUnionTypeCreateInputSystemByPackInputSyslogSyslog1 CreateInputSystemByPackInputSyslogUnionType = "createInputSystemByPack_InputSyslog_Syslog_1"
	CreateInputSystemByPackInputSyslogUnionTypeCreateInputSystemByPackInputSyslogSyslog2 CreateInputSystemByPackInputSyslogUnionType = "createInputSystemByPack_InputSyslog_Syslog_2"
)

type CreateInputSystemByPackInputSyslogUnion struct {
	CreateInputSystemByPackInputSyslogSyslog1 *CreateInputSystemByPackInputSyslogSyslog1 `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSyslogSyslog2 *CreateInputSystemByPackInputSyslogSyslog2 `queryParam:"inline" union:"member"`

	Type CreateInputSystemByPackInputSyslogUnionType
}

func CreateCreateInputSystemByPackInputSyslogUnionCreateInputSystemByPackInputSyslogSyslog1(createInputSystemByPackInputSyslogSyslog1 CreateInputSystemByPackInputSyslogSyslog1) CreateInputSystemByPackInputSyslogUnion {
	typ := CreateInputSystemByPackInputSyslogUnionTypeCreateInputSystemByPackInputSyslogSyslog1

	return CreateInputSystemByPackInputSyslogUnion{
		CreateInputSystemByPackInputSyslogSyslog1: &createInputSystemByPackInputSyslogSyslog1,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackInputSyslogUnionCreateInputSystemByPackInputSyslogSyslog2(createInputSystemByPackInputSyslogSyslog2 CreateInputSystemByPackInputSyslogSyslog2) CreateInputSystemByPackInputSyslogUnion {
	typ := CreateInputSystemByPackInputSyslogUnionTypeCreateInputSystemByPackInputSyslogSyslog2

	return CreateInputSystemByPackInputSyslogUnion{
		CreateInputSystemByPackInputSyslogSyslog2: &createInputSystemByPackInputSyslogSyslog2,
		Type: typ,
	}
}

func (u *CreateInputSystemByPackInputSyslogUnion) UnmarshalJSON(data []byte) error {

	var createInputSystemByPackInputSyslogSyslog1 CreateInputSystemByPackInputSyslogSyslog1 = CreateInputSystemByPackInputSyslogSyslog1{}
	if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSyslogSyslog1, "", true, nil); err == nil {
		u.CreateInputSystemByPackInputSyslogSyslog1 = &createInputSystemByPackInputSyslogSyslog1
		u.Type = CreateInputSystemByPackInputSyslogUnionTypeCreateInputSystemByPackInputSyslogSyslog1
		return nil
	}

	var createInputSystemByPackInputSyslogSyslog2 CreateInputSystemByPackInputSyslogSyslog2 = CreateInputSystemByPackInputSyslogSyslog2{}
	if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSyslogSyslog2, "", true, nil); err == nil {
		u.CreateInputSystemByPackInputSyslogSyslog2 = &createInputSystemByPackInputSyslogSyslog2
		u.Type = CreateInputSystemByPackInputSyslogUnionTypeCreateInputSystemByPackInputSyslogSyslog2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputSystemByPackInputSyslogUnion", string(data))
}

func (u CreateInputSystemByPackInputSyslogUnion) MarshalJSON() ([]byte, error) {
	if u.CreateInputSystemByPackInputSyslogSyslog1 != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSyslogSyslog1, "", true)
	}

	if u.CreateInputSystemByPackInputSyslogSyslog2 != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSyslogSyslog2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateInputSystemByPackInputSyslogUnion: all fields are null")
}

type CreateInputSystemByPackTypeSqs string

const (
	CreateInputSystemByPackTypeSqsSqs CreateInputSystemByPackTypeSqs = "sqs"
)

func (e CreateInputSystemByPackTypeSqs) ToPointer() *CreateInputSystemByPackTypeSqs {
	return &e
}
func (e *CreateInputSystemByPackTypeSqs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sqs":
		*e = CreateInputSystemByPackTypeSqs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeSqs: %v", v)
	}
}

// CreateInputSystemByPackQueueType - The queue type used (or created)
type CreateInputSystemByPackQueueType string

const (
	// CreateInputSystemByPackQueueTypeStandard Standard
	CreateInputSystemByPackQueueTypeStandard CreateInputSystemByPackQueueType = "standard"
	// CreateInputSystemByPackQueueTypeFifo FIFO
	CreateInputSystemByPackQueueTypeFifo CreateInputSystemByPackQueueType = "fifo"
)

func (e CreateInputSystemByPackQueueType) ToPointer() *CreateInputSystemByPackQueueType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackQueueType) IsExact() bool {
	if e != nil {
		switch *e {
		case "standard", "fifo":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputSqs struct {
	// Unique ID for this input
	ID       string                         `json:"id"`
	Type     CreateInputSystemByPackTypeSqs `json:"type"`
	Disabled *bool                          `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// The queue type used (or created)
	QueueType CreateInputSystemByPackQueueType `json:"queueType"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// Create queue if it does not exist
	CreateQueue *bool `json:"createQueue,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing SQS requests
	SignatureVersion *components.SignatureVersionOptions3 `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Use Assume Role credentials to access SQS
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	Description *string  `json:"description,omitempty"`
	AwsAPIKey   *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputSystemByPackInputSqs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSqs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "queueName", "queueType"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSqs) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSqs) GetType() CreateInputSystemByPackTypeSqs {
	if c == nil {
		return CreateInputSystemByPackTypeSqs("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSqs) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSqs) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSqs) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSqs) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSqs) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSqs) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSqs) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSqs) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSqs) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputSystemByPackInputSqs) GetQueueType() CreateInputSystemByPackQueueType {
	if c == nil {
		return CreateInputSystemByPackQueueType("")
	}
	return c.QueueType
}

func (c *CreateInputSystemByPackInputSqs) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputSystemByPackInputSqs) GetCreateQueue() *bool {
	if c == nil {
		return nil
	}
	return c.CreateQueue
}

func (c *CreateInputSystemByPackInputSqs) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputSqs) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputSqs) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputSqs) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputSqs) GetSignatureVersion() *components.SignatureVersionOptions3 {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputSqs) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputSqs) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputSqs) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputSqs) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputSqs) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputSqs) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputSqs) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputSystemByPackInputSqs) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputSystemByPackInputSqs) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSqs) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputSystemByPackInputSqs) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputSqs) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputSqs) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputSqs) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputSystemByPackInputSqs) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputSystemByPackInputSqs) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputSystemByPackInputSqs) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputSqs) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputSqs) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputSqs) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputSqs) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputSystemByPackTypeModelDrivenTelemetry string

const (
	CreateInputSystemByPackTypeModelDrivenTelemetryModelDrivenTelemetry CreateInputSystemByPackTypeModelDrivenTelemetry = "model_driven_telemetry"
)

func (e CreateInputSystemByPackTypeModelDrivenTelemetry) ToPointer() *CreateInputSystemByPackTypeModelDrivenTelemetry {
	return &e
}
func (e *CreateInputSystemByPackTypeModelDrivenTelemetry) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "model_driven_telemetry":
		*e = CreateInputSystemByPackTypeModelDrivenTelemetry(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeModelDrivenTelemetry: %v", v)
	}
}

type CreateInputSystemByPackInputModelDrivenTelemetry struct {
	// Unique ID for this input
	ID       string                                          `json:"id"`
	Type     CreateInputSystemByPackTypeModelDrivenTelemetry `json:"type"`
	Disabled *bool                                           `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
	ShutdownTimeoutMs *float64 `json:"shutdownTimeoutMs,omitempty"`
	Description       *string  `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputModelDrivenTelemetry) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetType() CreateInputSystemByPackTypeModelDrivenTelemetry {
	if c == nil {
		return CreateInputSystemByPackTypeModelDrivenTelemetry("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetShutdownTimeoutMs() *float64 {
	if c == nil {
		return nil
	}
	return c.ShutdownTimeoutMs
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputModelDrivenTelemetry) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeOpenTelemetry string

const (
	CreateInputSystemByPackTypeOpenTelemetryOpenTelemetry CreateInputSystemByPackTypeOpenTelemetry = "open_telemetry"
)

func (e CreateInputSystemByPackTypeOpenTelemetry) ToPointer() *CreateInputSystemByPackTypeOpenTelemetry {
	return &e
}
func (e *CreateInputSystemByPackTypeOpenTelemetry) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "open_telemetry":
		*e = CreateInputSystemByPackTypeOpenTelemetry(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeOpenTelemetry: %v", v)
	}
}

// CreateInputSystemByPackProtocol - Select whether to leverage gRPC or HTTP for OpenTelemetry
type CreateInputSystemByPackProtocol string

const (
	// CreateInputSystemByPackProtocolGrpc gRPC
	CreateInputSystemByPackProtocolGrpc CreateInputSystemByPackProtocol = "grpc"
	// CreateInputSystemByPackProtocolHTTP HTTP
	CreateInputSystemByPackProtocolHTTP CreateInputSystemByPackProtocol = "http"
)

func (e CreateInputSystemByPackProtocol) ToPointer() *CreateInputSystemByPackProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "grpc", "http":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackOTLPVersion - The version of OTLP Protobuf definitions to use when interpreting received data
type CreateInputSystemByPackOTLPVersion string

const (
	// CreateInputSystemByPackOTLPVersionZeroDot10Dot0 0.10.0
	CreateInputSystemByPackOTLPVersionZeroDot10Dot0 CreateInputSystemByPackOTLPVersion = "0.10.0"
	// CreateInputSystemByPackOTLPVersionOneDot3Dot1 1.3.1
	CreateInputSystemByPackOTLPVersionOneDot3Dot1 CreateInputSystemByPackOTLPVersion = "1.3.1"
)

func (e CreateInputSystemByPackOTLPVersion) ToPointer() *CreateInputSystemByPackOTLPVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackOTLPVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "0.10.0", "1.3.1":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputOpenTelemetry struct {
	// Unique ID for this input
	ID       string                                   `json:"id"`
	Type     CreateInputSystemByPackTypeOpenTelemetry `json:"type"`
	Disabled *bool                                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket  *int64 `json:"maxRequestsPerSocket,omitempty"`
	EnableProxyHeader     any    `json:"enableProxyHeader,omitempty"`
	CaptureHeaders        any    `json:"captureHeaders,omitempty"`
	ActivityLogSampleRate any    `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Select whether to leverage gRPC or HTTP for OpenTelemetry
	Protocol *CreateInputSystemByPackProtocol `json:"protocol,omitempty"`
	// Enable to extract each incoming span to a separate event
	ExtractSpans *bool `json:"extractSpans,omitempty"`
	// Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`
	// The version of OTLP Protobuf definitions to use when interpreting received data
	OtlpVersion *CreateInputSystemByPackOTLPVersion `json:"otlpVersion,omitempty"`
	// OpenTelemetry authentication type
	AuthType *components.AuthenticationTypeOptions `json:"authType,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Username     *string  `json:"username,omitempty"`
	Password     *string  `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Enable to extract each incoming log record to a separate event
	ExtractLogs *bool `json:"extractLogs,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputOpenTelemetry) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputOpenTelemetry) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetType() CreateInputSystemByPackTypeOpenTelemetry {
	if c == nil {
		return CreateInputSystemByPackTypeOpenTelemetry("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetEnableProxyHeader() any {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetCaptureHeaders() any {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetActivityLogSampleRate() any {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetProtocol() *CreateInputSystemByPackProtocol {
	if c == nil {
		return nil
	}
	return c.Protocol
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetExtractSpans() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractSpans
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetExtractMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractMetrics
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetOtlpVersion() *CreateInputSystemByPackOTLPVersion {
	if c == nil {
		return nil
	}
	return c.OtlpVersion
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetAuthType() *components.AuthenticationTypeOptions {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetExtractLogs() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractLogs
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputOpenTelemetry) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeSnmp string

const (
	CreateInputSystemByPackTypeSnmpSnmp CreateInputSystemByPackTypeSnmp = "snmp"
)

func (e CreateInputSystemByPackTypeSnmp) ToPointer() *CreateInputSystemByPackTypeSnmp {
	return &e
}
func (e *CreateInputSystemByPackTypeSnmp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snmp":
		*e = CreateInputSystemByPackTypeSnmp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeSnmp: %v", v)
	}
}

type CreateInputSystemByPackPrivacyProtocol string

const (
	// CreateInputSystemByPackPrivacyProtocolNone None
	CreateInputSystemByPackPrivacyProtocolNone CreateInputSystemByPackPrivacyProtocol = "none"
	// CreateInputSystemByPackPrivacyProtocolDes DES
	CreateInputSystemByPackPrivacyProtocolDes CreateInputSystemByPackPrivacyProtocol = "des"
	// CreateInputSystemByPackPrivacyProtocolAes AES128
	CreateInputSystemByPackPrivacyProtocolAes CreateInputSystemByPackPrivacyProtocol = "aes"
	// CreateInputSystemByPackPrivacyProtocolAes256b AES256b (Blumenthal)
	CreateInputSystemByPackPrivacyProtocolAes256b CreateInputSystemByPackPrivacyProtocol = "aes256b"
	// CreateInputSystemByPackPrivacyProtocolAes256r AES256r (Reeder)
	CreateInputSystemByPackPrivacyProtocolAes256r CreateInputSystemByPackPrivacyProtocol = "aes256r"
)

func (e CreateInputSystemByPackPrivacyProtocol) ToPointer() *CreateInputSystemByPackPrivacyProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackPrivacyProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "des", "aes", "aes256b", "aes256r":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackV3User struct {
	Name         string                                          `json:"name"`
	AuthProtocol *components.AuthenticationProtocolOptionsV3User `json:"authProtocol,omitempty"`
	AuthKey      *string                                         `json:"authKey,omitempty"`
	PrivProtocol *CreateInputSystemByPackPrivacyProtocol         `json:"privProtocol,omitempty"`
	PrivKey      *string                                         `json:"privKey,omitempty"`
}

func (c CreateInputSystemByPackV3User) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackV3User) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"name"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackV3User) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateInputSystemByPackV3User) GetAuthProtocol() *components.AuthenticationProtocolOptionsV3User {
	if c == nil {
		return nil
	}
	return c.AuthProtocol
}

func (c *CreateInputSystemByPackV3User) GetAuthKey() *string {
	if c == nil {
		return nil
	}
	return c.AuthKey
}

func (c *CreateInputSystemByPackV3User) GetPrivProtocol() *CreateInputSystemByPackPrivacyProtocol {
	if c == nil {
		return nil
	}
	return c.PrivProtocol
}

func (c *CreateInputSystemByPackV3User) GetPrivKey() *string {
	if c == nil {
		return nil
	}
	return c.PrivKey
}

// CreateInputSystemByPackSNMPv3Authentication - Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
type CreateInputSystemByPackSNMPv3Authentication struct {
	V3AuthEnabled bool `json:"v3AuthEnabled"`
	// Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps.
	AllowUnmatchedTrap *bool `json:"allowUnmatchedTrap,omitempty"`
	// User credentials for receiving v3 traps
	V3Users []CreateInputSystemByPackV3User `json:"v3Users,omitempty"`
}

func (c CreateInputSystemByPackSNMPv3Authentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackSNMPv3Authentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"v3AuthEnabled"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackSNMPv3Authentication) GetV3AuthEnabled() bool {
	if c == nil {
		return false
	}
	return c.V3AuthEnabled
}

func (c *CreateInputSystemByPackSNMPv3Authentication) GetAllowUnmatchedTrap() *bool {
	if c == nil {
		return nil
	}
	return c.AllowUnmatchedTrap
}

func (c *CreateInputSystemByPackSNMPv3Authentication) GetV3Users() []CreateInputSystemByPackV3User {
	if c == nil {
		return nil
	}
	return c.V3Users
}

type CreateInputSystemByPackInputSnmp struct {
	// Unique ID for this input
	ID       string                          `json:"id"`
	Type     CreateInputSystemByPackTypeSnmp `json:"type"`
	Disabled *bool                           `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// UDP port to receive SNMP traps on. Defaults to 162.
	Port float64 `json:"port"`
	// Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
	SnmpV3Auth *CreateInputSystemByPackSNMPv3Authentication `json:"snmpV3Auth,omitempty"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// If enabled, parses varbinds as an array of objects that include OID, value, and type
	VarbindsWithTypes *bool `json:"varbindsWithTypes,omitempty"`
	// If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
	BestEffortParsing *bool   `json:"bestEffortParsing,omitempty"`
	Description       *string `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputSnmp) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSnmp) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSnmp) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSnmp) GetType() CreateInputSystemByPackTypeSnmp {
	if c == nil {
		return CreateInputSystemByPackTypeSnmp("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSnmp) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSnmp) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSnmp) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSnmp) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSnmp) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSnmp) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSnmp) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSnmp) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSnmp) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputSnmp) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputSnmp) GetSnmpV3Auth() *CreateInputSystemByPackSNMPv3Authentication {
	if c == nil {
		return nil
	}
	return c.SnmpV3Auth
}

func (c *CreateInputSystemByPackInputSnmp) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputSystemByPackInputSnmp) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputSnmp) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSnmp) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputSystemByPackInputSnmp) GetVarbindsWithTypes() *bool {
	if c == nil {
		return nil
	}
	return c.VarbindsWithTypes
}

func (c *CreateInputSystemByPackInputSnmp) GetBestEffortParsing() *bool {
	if c == nil {
		return nil
	}
	return c.BestEffortParsing
}

func (c *CreateInputSystemByPackInputSnmp) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputSnmp) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputSnmp) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeS3Inventory string

const (
	CreateInputSystemByPackTypeS3InventoryS3Inventory CreateInputSystemByPackTypeS3Inventory = "s3_inventory"
)

func (e CreateInputSystemByPackTypeS3Inventory) ToPointer() *CreateInputSystemByPackTypeS3Inventory {
	return &e
}
func (e *CreateInputSystemByPackTypeS3Inventory) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3_inventory":
		*e = CreateInputSystemByPackTypeS3Inventory(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeS3Inventory: %v", v)
	}
}

type CreateInputSystemByPackInputS3Inventory struct {
	// Unique ID for this input
	ID       string                                 `json:"id"`
	Type     CreateInputSystemByPackTypeS3Inventory `json:"type"`
	Disabled *bool                                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `json:"includeSqsMetadata,omitempty"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `json:"enableSQSAssumeRole,omitempty"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `json:"parquetChunkDownloadTimeout,omitempty"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	// Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
	ChecksumSuffix *string `json:"checksumSuffix,omitempty"`
	// Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
	MaxManifestSizeKB *int64 `json:"maxManifestSizeKB,omitempty"`
	// If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
	ValidateInventoryFiles *bool   `json:"validateInventoryFiles,omitempty"`
	Description            *string `json:"description,omitempty"`
	AwsAPIKey              *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputSystemByPackInputS3Inventory) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputS3Inventory) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputS3Inventory) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputS3Inventory) GetType() CreateInputSystemByPackTypeS3Inventory {
	if c == nil {
		return CreateInputSystemByPackTypeS3Inventory("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputS3Inventory) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputS3Inventory) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputS3Inventory) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputS3Inventory) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputS3Inventory) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputS3Inventory) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputS3Inventory) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputS3Inventory) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputS3Inventory) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputSystemByPackInputS3Inventory) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputSystemByPackInputS3Inventory) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputSystemByPackInputS3Inventory) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputS3Inventory) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputS3Inventory) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputS3Inventory) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputS3Inventory) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputS3Inventory) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputS3Inventory) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputS3Inventory) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputS3Inventory) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputS3Inventory) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputSystemByPackInputS3Inventory) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputSystemByPackInputS3Inventory) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputSystemByPackInputS3Inventory) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputS3Inventory) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputSystemByPackInputS3Inventory) GetIncludeSqsMetadata() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeSqsMetadata
}

func (c *CreateInputSystemByPackInputS3Inventory) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputS3Inventory) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputS3Inventory) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputS3Inventory) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputS3Inventory) GetEnableSQSAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableSQSAssumeRole
}

func (c *CreateInputSystemByPackInputS3Inventory) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputSystemByPackInputS3Inventory) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputS3Inventory) GetParquetChunkSizeMB() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkSizeMB
}

func (c *CreateInputSystemByPackInputS3Inventory) GetParquetChunkDownloadTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkDownloadTimeout
}

func (c *CreateInputSystemByPackInputS3Inventory) GetCheckpointing() *components.CheckpointingType {
	if c == nil {
		return nil
	}
	return c.Checkpointing
}

func (c *CreateInputSystemByPackInputS3Inventory) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputSystemByPackInputS3Inventory) GetChecksumSuffix() *string {
	if c == nil {
		return nil
	}
	return c.ChecksumSuffix
}

func (c *CreateInputSystemByPackInputS3Inventory) GetMaxManifestSizeKB() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxManifestSizeKB
}

func (c *CreateInputSystemByPackInputS3Inventory) GetValidateInventoryFiles() *bool {
	if c == nil {
		return nil
	}
	return c.ValidateInventoryFiles
}

func (c *CreateInputSystemByPackInputS3Inventory) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputS3Inventory) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputS3Inventory) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputS3Inventory) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if c == nil {
		return nil
	}
	return c.TagAfterProcessing
}

func (c *CreateInputSystemByPackInputS3Inventory) GetProcessedTagKey() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagKey
}

func (c *CreateInputSystemByPackInputS3Inventory) GetProcessedTagValue() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagValue
}

func (c *CreateInputSystemByPackInputS3Inventory) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputSystemByPackInputS3Inventory) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputSystemByPackInputS3Inventory) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputS3Inventory) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputS3Inventory) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputS3Inventory) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputS3Inventory) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputSystemByPackTypeS3 string

const (
	CreateInputSystemByPackTypeS3S3 CreateInputSystemByPackTypeS3 = "s3"
)

func (e CreateInputSystemByPackTypeS3) ToPointer() *CreateInputSystemByPackTypeS3 {
	return &e
}
func (e *CreateInputSystemByPackTypeS3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3":
		*e = CreateInputSystemByPackTypeS3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeS3: %v", v)
	}
}

type CreateInputSystemByPackInputS3 struct {
	// Unique ID for this input
	ID       string                        `json:"id"`
	Type     CreateInputSystemByPackTypeS3 `json:"type"`
	Disabled *bool                         `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `json:"includeSqsMetadata,omitempty"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `json:"enableSQSAssumeRole,omitempty"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `json:"parquetChunkDownloadTimeout,omitempty"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
	TagAfterProcessing *bool   `json:"tagAfterProcessing,omitempty"`
	Description        *string `json:"description,omitempty"`
	AwsAPIKey          *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputSystemByPackInputS3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputS3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputS3) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputS3) GetType() CreateInputSystemByPackTypeS3 {
	if c == nil {
		return CreateInputSystemByPackTypeS3("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputS3) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputS3) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputS3) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputS3) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputS3) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputS3) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputS3) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputS3) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputS3) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputSystemByPackInputS3) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputSystemByPackInputS3) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputSystemByPackInputS3) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputS3) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputS3) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputS3) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputS3) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputS3) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputS3) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputS3) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputS3) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputS3) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputSystemByPackInputS3) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputSystemByPackInputS3) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputSystemByPackInputS3) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputS3) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputSystemByPackInputS3) GetIncludeSqsMetadata() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeSqsMetadata
}

func (c *CreateInputSystemByPackInputS3) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputS3) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputS3) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputS3) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputS3) GetEnableSQSAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableSQSAssumeRole
}

func (c *CreateInputSystemByPackInputS3) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputSystemByPackInputS3) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputS3) GetParquetChunkSizeMB() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkSizeMB
}

func (c *CreateInputSystemByPackInputS3) GetParquetChunkDownloadTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkDownloadTimeout
}

func (c *CreateInputSystemByPackInputS3) GetCheckpointing() *components.CheckpointingType {
	if c == nil {
		return nil
	}
	return c.Checkpointing
}

func (c *CreateInputSystemByPackInputS3) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputSystemByPackInputS3) GetEncoding() *string {
	if c == nil {
		return nil
	}
	return c.Encoding
}

func (c *CreateInputSystemByPackInputS3) GetTagAfterProcessing() *bool {
	if c == nil {
		return nil
	}
	return c.TagAfterProcessing
}

func (c *CreateInputSystemByPackInputS3) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputS3) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputS3) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputS3) GetProcessedTagKey() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagKey
}

func (c *CreateInputSystemByPackInputS3) GetProcessedTagValue() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagValue
}

func (c *CreateInputSystemByPackInputS3) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputSystemByPackInputS3) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputSystemByPackInputS3) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputS3) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputS3) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputS3) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputS3) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputSystemByPackTypeMetrics string

const (
	CreateInputSystemByPackTypeMetricsMetrics CreateInputSystemByPackTypeMetrics = "metrics"
)

func (e CreateInputSystemByPackTypeMetrics) ToPointer() *CreateInputSystemByPackTypeMetrics {
	return &e
}
func (e *CreateInputSystemByPackTypeMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "metrics":
		*e = CreateInputSystemByPackTypeMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeMetrics: %v", v)
	}
}

type CreateInputSystemByPackInputMetrics struct {
	// Unique ID for this input
	ID       string                             `json:"id"`
	Type     CreateInputSystemByPackTypeMetrics `json:"type"`
	Disabled *bool                              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `json:"maxBufferSize,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool                                 `json:"enableProxyHeader,omitempty"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	Description        *string  `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime.
	TemplateUDPPort *string `json:"__template_udpPort,omitempty"`
	// Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime.
	TemplateTCPPort *string `json:"__template_tcpPort,omitempty"`
}

func (c CreateInputSystemByPackInputMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputMetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputMetrics) GetType() CreateInputSystemByPackTypeMetrics {
	if c == nil {
		return CreateInputSystemByPackTypeMetrics("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputMetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputMetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputMetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputMetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputMetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputMetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputMetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputMetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputMetrics) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputMetrics) GetUDPPort() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPPort
}

func (c *CreateInputSystemByPackInputMetrics) GetTCPPort() *float64 {
	if c == nil {
		return nil
	}
	return c.TCPPort
}

func (c *CreateInputSystemByPackInputMetrics) GetMaxBufferSize() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBufferSize
}

func (c *CreateInputSystemByPackInputMetrics) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputMetrics) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputMetrics) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputMetrics) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputMetrics) GetUDPSocketRxBufSize() *float64 {
	if c == nil {
		return nil
	}
	return c.UDPSocketRxBufSize
}

func (c *CreateInputSystemByPackInputMetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputMetrics) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputMetrics) GetTemplateUDPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateUDPPort
}

func (c *CreateInputSystemByPackInputMetrics) GetTemplateTCPPort() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTCPPort
}

type CreateInputSystemByPackTypeCriblmetrics string

const (
	CreateInputSystemByPackTypeCriblmetricsCriblmetrics CreateInputSystemByPackTypeCriblmetrics = "criblmetrics"
)

func (e CreateInputSystemByPackTypeCriblmetrics) ToPointer() *CreateInputSystemByPackTypeCriblmetrics {
	return &e
}
func (e *CreateInputSystemByPackTypeCriblmetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "criblmetrics":
		*e = CreateInputSystemByPackTypeCriblmetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeCriblmetrics: %v", v)
	}
}

type CreateInputSystemByPackInputCriblmetrics struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackTypeCriblmetrics `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// A prefix that is applied to the metrics provided by Cribl Stream
	Prefix *string `json:"prefix,omitempty"`
	// Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
	FullFidelity *bool `json:"fullFidelity,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputCriblmetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputCriblmetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetType() CreateInputSystemByPackTypeCriblmetrics {
	if c == nil {
		return CreateInputSystemByPackTypeCriblmetrics("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetPrefix() *string {
	if c == nil {
		return nil
	}
	return c.Prefix
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetFullFidelity() *bool {
	if c == nil {
		return nil
	}
	return c.FullFidelity
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputCriblmetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeKinesis string

const (
	CreateInputSystemByPackTypeKinesisKinesis CreateInputSystemByPackTypeKinesis = "kinesis"
)

func (e CreateInputSystemByPackTypeKinesis) ToPointer() *CreateInputSystemByPackTypeKinesis {
	return &e
}
func (e *CreateInputSystemByPackTypeKinesis) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kinesis":
		*e = CreateInputSystemByPackTypeKinesis(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeKinesis: %v", v)
	}
}

// CreateInputSystemByPackShardIteratorStart - Location at which to start reading a shard for the first time
type CreateInputSystemByPackShardIteratorStart string

const (
	// CreateInputSystemByPackShardIteratorStartTrimHorizon Earliest record
	CreateInputSystemByPackShardIteratorStartTrimHorizon CreateInputSystemByPackShardIteratorStart = "TRIM_HORIZON"
	// CreateInputSystemByPackShardIteratorStartLatest Latest record
	CreateInputSystemByPackShardIteratorStartLatest CreateInputSystemByPackShardIteratorStart = "LATEST"
)

func (e CreateInputSystemByPackShardIteratorStart) ToPointer() *CreateInputSystemByPackShardIteratorStart {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackShardIteratorStart) IsExact() bool {
	if e != nil {
		switch *e {
		case "TRIM_HORIZON", "LATEST":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackRecordDataFormat - Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
type CreateInputSystemByPackRecordDataFormat string

const (
	// CreateInputSystemByPackRecordDataFormatCribl Cribl
	CreateInputSystemByPackRecordDataFormatCribl CreateInputSystemByPackRecordDataFormat = "cribl"
	// CreateInputSystemByPackRecordDataFormatNdjson Newline JSON
	CreateInputSystemByPackRecordDataFormatNdjson CreateInputSystemByPackRecordDataFormat = "ndjson"
	// CreateInputSystemByPackRecordDataFormatCloudwatch Cloudwatch Logs
	CreateInputSystemByPackRecordDataFormatCloudwatch CreateInputSystemByPackRecordDataFormat = "cloudwatch"
	// CreateInputSystemByPackRecordDataFormatLine Event per line
	CreateInputSystemByPackRecordDataFormatLine CreateInputSystemByPackRecordDataFormat = "line"
)

func (e CreateInputSystemByPackRecordDataFormat) ToPointer() *CreateInputSystemByPackRecordDataFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackRecordDataFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "cribl", "ndjson", "cloudwatch", "line":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackShardLoadBalancing - The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
type CreateInputSystemByPackShardLoadBalancing string

const (
	// CreateInputSystemByPackShardLoadBalancingConsistentHashing Consistent Hashing
	CreateInputSystemByPackShardLoadBalancingConsistentHashing CreateInputSystemByPackShardLoadBalancing = "ConsistentHashing"
	// CreateInputSystemByPackShardLoadBalancingRoundRobin Round Robin
	CreateInputSystemByPackShardLoadBalancingRoundRobin CreateInputSystemByPackShardLoadBalancing = "RoundRobin"
)

func (e CreateInputSystemByPackShardLoadBalancing) ToPointer() *CreateInputSystemByPackShardLoadBalancing {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackShardLoadBalancing) IsExact() bool {
	if e != nil {
		switch *e {
		case "ConsistentHashing", "RoundRobin":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputKinesis struct {
	// Unique ID for this input
	ID       string                             `json:"id"`
	Type     CreateInputSystemByPackTypeKinesis `json:"type"`
	Disabled *bool                              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `json:"serviceInterval,omitempty"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `json:"shardExpr,omitempty"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *CreateInputSystemByPackShardIteratorStart `json:"shardIteratorType,omitempty"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *CreateInputSystemByPackRecordDataFormat `json:"payloadFormat,omitempty"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `json:"getRecordsLimit,omitempty"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `json:"getRecordsLimitTotal,omitempty"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *CreateInputSystemByPackShardLoadBalancing `json:"loadBalancingAlgorithm,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *components.SignatureVersionOptions2 `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `json:"verifyKPLCheckSums,omitempty"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `json:"avoidDuplicates,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	AwsAPIKey   *string                                    `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Binds 'streamName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'streamName' at runtime.
	TemplateStreamName *string `json:"__template_streamName,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputSystemByPackInputKinesis) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputKinesis) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputKinesis) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputKinesis) GetType() CreateInputSystemByPackTypeKinesis {
	if c == nil {
		return CreateInputSystemByPackTypeKinesis("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputKinesis) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputKinesis) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputKinesis) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputKinesis) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputKinesis) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputKinesis) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputKinesis) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputKinesis) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputKinesis) GetStreamName() string {
	if c == nil {
		return ""
	}
	return c.StreamName
}

func (c *CreateInputSystemByPackInputKinesis) GetServiceInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.ServiceInterval
}

func (c *CreateInputSystemByPackInputKinesis) GetShardExpr() *string {
	if c == nil {
		return nil
	}
	return c.ShardExpr
}

func (c *CreateInputSystemByPackInputKinesis) GetShardIteratorType() *CreateInputSystemByPackShardIteratorStart {
	if c == nil {
		return nil
	}
	return c.ShardIteratorType
}

func (c *CreateInputSystemByPackInputKinesis) GetPayloadFormat() *CreateInputSystemByPackRecordDataFormat {
	if c == nil {
		return nil
	}
	return c.PayloadFormat
}

func (c *CreateInputSystemByPackInputKinesis) GetGetRecordsLimit() *float64 {
	if c == nil {
		return nil
	}
	return c.GetRecordsLimit
}

func (c *CreateInputSystemByPackInputKinesis) GetGetRecordsLimitTotal() *float64 {
	if c == nil {
		return nil
	}
	return c.GetRecordsLimitTotal
}

func (c *CreateInputSystemByPackInputKinesis) GetLoadBalancingAlgorithm() *CreateInputSystemByPackShardLoadBalancing {
	if c == nil {
		return nil
	}
	return c.LoadBalancingAlgorithm
}

func (c *CreateInputSystemByPackInputKinesis) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputKinesis) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputKinesis) GetRegion() string {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputKinesis) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputKinesis) GetSignatureVersion() *components.SignatureVersionOptions2 {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputKinesis) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputKinesis) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputKinesis) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputKinesis) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputKinesis) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputKinesis) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputKinesis) GetVerifyKPLCheckSums() *bool {
	if c == nil {
		return nil
	}
	return c.VerifyKPLCheckSums
}

func (c *CreateInputSystemByPackInputKinesis) GetAvoidDuplicates() *bool {
	if c == nil {
		return nil
	}
	return c.AvoidDuplicates
}

func (c *CreateInputSystemByPackInputKinesis) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputKinesis) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputKinesis) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputKinesis) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputKinesis) GetTemplateStreamName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateStreamName
}

func (c *CreateInputSystemByPackInputKinesis) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputKinesis) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputKinesis) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputKinesis) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputKinesis) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputSystemByPackTypeHTTPRaw string

const (
	CreateInputSystemByPackTypeHTTPRawHTTPRaw CreateInputSystemByPackTypeHTTPRaw = "http_raw"
)

func (e CreateInputSystemByPackTypeHTTPRaw) ToPointer() *CreateInputSystemByPackTypeHTTPRaw {
	return &e
}
func (e *CreateInputSystemByPackTypeHTTPRaw) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http_raw":
		*e = CreateInputSystemByPackTypeHTTPRaw(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeHTTPRaw: %v", v)
	}
}

type CreateInputSystemByPackInputHTTPRaw struct {
	// Unique ID for this input
	ID       string                             `json:"id"`
	Type     CreateInputSystemByPackTypeHTTPRaw `json:"type"`
	Disabled *bool                              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputHTTPRaw) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputHTTPRaw) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetType() CreateInputSystemByPackTypeHTTPRaw {
	if c == nil {
		return CreateInputSystemByPackTypeHTTPRaw("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetAllowedPaths() []string {
	if c == nil {
		return nil
	}
	return c.AllowedPaths
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetAllowedMethods() []string {
	if c == nil {
		return nil
	}
	return c.AllowedMethods
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if c == nil {
		return nil
	}
	return c.AuthTokensExt
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputHTTPRaw) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeDatagen string

const (
	CreateInputSystemByPackTypeDatagenDatagen CreateInputSystemByPackTypeDatagen = "datagen"
)

func (e CreateInputSystemByPackTypeDatagen) ToPointer() *CreateInputSystemByPackTypeDatagen {
	return &e
}
func (e *CreateInputSystemByPackTypeDatagen) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "datagen":
		*e = CreateInputSystemByPackTypeDatagen(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeDatagen: %v", v)
	}
}

type CreateInputSystemByPackSample struct {
	Sample string `json:"sample"`
	// Maximum number of events to generate per second per Worker Node. Defaults to 10.
	EventsPerSec float64 `json:"eventsPerSec"`
}

func (c CreateInputSystemByPackSample) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackSample) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"sample", "eventsPerSec"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackSample) GetSample() string {
	if c == nil {
		return ""
	}
	return c.Sample
}

func (c *CreateInputSystemByPackSample) GetEventsPerSec() float64 {
	if c == nil {
		return 0.0
	}
	return c.EventsPerSec
}

type CreateInputSystemByPackInputDatagen struct {
	// Unique ID for this input
	ID       string                             `json:"id"`
	Type     CreateInputSystemByPackTypeDatagen `json:"type"`
	Disabled *bool                              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	Samples     []CreateInputSystemByPackSample           `json:"samples"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputDatagen) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputDatagen) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "samples"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputDatagen) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputDatagen) GetType() CreateInputSystemByPackTypeDatagen {
	if c == nil {
		return CreateInputSystemByPackTypeDatagen("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputDatagen) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputDatagen) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputDatagen) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputDatagen) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputDatagen) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputDatagen) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputDatagen) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputDatagen) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputDatagen) GetSamples() []CreateInputSystemByPackSample {
	if c == nil {
		return []CreateInputSystemByPackSample{}
	}
	return c.Samples
}

func (c *CreateInputSystemByPackInputDatagen) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputDatagen) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeDatadogAgent string

const (
	CreateInputSystemByPackTypeDatadogAgentDatadogAgent CreateInputSystemByPackTypeDatadogAgent = "datadog_agent"
)

func (e CreateInputSystemByPackTypeDatadogAgent) ToPointer() *CreateInputSystemByPackTypeDatadogAgent {
	return &e
}
func (e *CreateInputSystemByPackTypeDatadogAgent) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "datadog_agent":
		*e = CreateInputSystemByPackTypeDatadogAgent(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeDatadogAgent: %v", v)
	}
}

type CreateInputSystemByPackProxyModeDatadogAgent struct {
	// Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid.
	Enabled bool `json:"enabled"`
	// Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
}

func (c CreateInputSystemByPackProxyModeDatadogAgent) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackProxyModeDatadogAgent) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"enabled"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackProxyModeDatadogAgent) GetEnabled() bool {
	if c == nil {
		return false
	}
	return c.Enabled
}

func (c *CreateInputSystemByPackProxyModeDatadogAgent) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

type CreateInputSystemByPackInputDatadogAgent struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackTypeDatadogAgent `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata    `json:"metadata,omitempty"`
	ProxyMode   *CreateInputSystemByPackProxyModeDatadogAgent `json:"proxyMode,omitempty"`
	Description *string                                       `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputDatadogAgent) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputDatadogAgent) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetType() CreateInputSystemByPackTypeDatadogAgent {
	if c == nil {
		return CreateInputSystemByPackTypeDatadogAgent("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetExtractMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractMetrics
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetProxyMode() *CreateInputSystemByPackProxyModeDatadogAgent {
	if c == nil {
		return nil
	}
	return c.ProxyMode
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputDatadogAgent) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeCrowdstrike string

const (
	CreateInputSystemByPackTypeCrowdstrikeCrowdstrike CreateInputSystemByPackTypeCrowdstrike = "crowdstrike"
)

func (e CreateInputSystemByPackTypeCrowdstrike) ToPointer() *CreateInputSystemByPackTypeCrowdstrike {
	return &e
}
func (e *CreateInputSystemByPackTypeCrowdstrike) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "crowdstrike":
		*e = CreateInputSystemByPackTypeCrowdstrike(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeCrowdstrike: %v", v)
	}
}

type CreateInputSystemByPackInputCrowdstrike struct {
	// Unique ID for this input
	ID       string                                 `json:"id"`
	Type     CreateInputSystemByPackTypeCrowdstrike `json:"type"`
	Disabled *bool                                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `json:"includeSqsMetadata,omitempty"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `json:"enableSQSAssumeRole,omitempty"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Checkpointing *components.CheckpointingType              `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `json:"pollTimeout,omitempty"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime.
	TemplateAwsAccountID *string `json:"__template_awsAccountId,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputSystemByPackInputCrowdstrike) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputCrowdstrike) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetType() CreateInputSystemByPackTypeCrowdstrike {
	if c == nil {
		return CreateInputSystemByPackTypeCrowdstrike("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.AwsAccountID
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetIncludeSqsMetadata() *bool {
	if c == nil {
		return nil
	}
	return c.IncludeSqsMetadata
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetEnableSQSAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableSQSAssumeRole
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetCheckpointing() *components.CheckpointingType {
	if c == nil {
		return nil
	}
	return c.Checkpointing
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetPollTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.PollTimeout
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetEncoding() *string {
	if c == nil {
		return nil
	}
	return c.Encoding
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if c == nil {
		return nil
	}
	return c.TagAfterProcessing
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetProcessedTagKey() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagKey
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetProcessedTagValue() *string {
	if c == nil {
		return nil
	}
	return c.ProcessedTagValue
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetTemplateAwsAccountID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAccountID
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputCrowdstrike) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputSystemByPackTypeWindowsMetrics string

const (
	CreateInputSystemByPackTypeWindowsMetricsWindowsMetrics CreateInputSystemByPackTypeWindowsMetrics = "windows_metrics"
)

func (e CreateInputSystemByPackTypeWindowsMetrics) ToPointer() *CreateInputSystemByPackTypeWindowsMetrics {
	return &e
}
func (e *CreateInputSystemByPackTypeWindowsMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "windows_metrics":
		*e = CreateInputSystemByPackTypeWindowsMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeWindowsMetrics: %v", v)
	}
}

// CreateInputSystemByPackSystemModeWindowsMetrics - Select the level of details for system metrics
type CreateInputSystemByPackSystemModeWindowsMetrics string

const (
	// CreateInputSystemByPackSystemModeWindowsMetricsBasic Basic
	CreateInputSystemByPackSystemModeWindowsMetricsBasic CreateInputSystemByPackSystemModeWindowsMetrics = "basic"
	// CreateInputSystemByPackSystemModeWindowsMetricsAll All
	CreateInputSystemByPackSystemModeWindowsMetricsAll CreateInputSystemByPackSystemModeWindowsMetrics = "all"
	// CreateInputSystemByPackSystemModeWindowsMetricsCustom Custom
	CreateInputSystemByPackSystemModeWindowsMetricsCustom CreateInputSystemByPackSystemModeWindowsMetrics = "custom"
	// CreateInputSystemByPackSystemModeWindowsMetricsDisabled Disabled
	CreateInputSystemByPackSystemModeWindowsMetricsDisabled CreateInputSystemByPackSystemModeWindowsMetrics = "disabled"
)

func (e CreateInputSystemByPackSystemModeWindowsMetrics) ToPointer() *CreateInputSystemByPackSystemModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackSystemModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackSystemWindowsMetrics struct {
	// Select the level of details for system metrics
	Mode *CreateInputSystemByPackSystemModeWindowsMetrics `json:"mode,omitempty"`
	// Generate metrics for all system information
	Detail *bool `json:"detail,omitempty"`
}

func (c CreateInputSystemByPackSystemWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackSystemWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackSystemWindowsMetrics) GetMode() *CreateInputSystemByPackSystemModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackSystemWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

// CreateInputSystemByPackCPUModeWindowsMetrics - Select the level of details for CPU metrics
type CreateInputSystemByPackCPUModeWindowsMetrics string

const (
	// CreateInputSystemByPackCPUModeWindowsMetricsBasic Basic
	CreateInputSystemByPackCPUModeWindowsMetricsBasic CreateInputSystemByPackCPUModeWindowsMetrics = "basic"
	// CreateInputSystemByPackCPUModeWindowsMetricsAll All
	CreateInputSystemByPackCPUModeWindowsMetricsAll CreateInputSystemByPackCPUModeWindowsMetrics = "all"
	// CreateInputSystemByPackCPUModeWindowsMetricsCustom Custom
	CreateInputSystemByPackCPUModeWindowsMetricsCustom CreateInputSystemByPackCPUModeWindowsMetrics = "custom"
	// CreateInputSystemByPackCPUModeWindowsMetricsDisabled Disabled
	CreateInputSystemByPackCPUModeWindowsMetricsDisabled CreateInputSystemByPackCPUModeWindowsMetrics = "disabled"
)

func (e CreateInputSystemByPackCPUModeWindowsMetrics) ToPointer() *CreateInputSystemByPackCPUModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackCPUModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackCPUWindowsMetrics struct {
	// Select the level of details for CPU metrics
	Mode *CreateInputSystemByPackCPUModeWindowsMetrics `json:"mode,omitempty"`
	// Generate metrics for each CPU
	PerCPU *bool `json:"perCpu,omitempty"`
	// Generate metrics for all CPU states
	Detail *bool `json:"detail,omitempty"`
	// Generate raw, monotonic CPU time counters
	Time *bool `json:"time,omitempty"`
}

func (c CreateInputSystemByPackCPUWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackCPUWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackCPUWindowsMetrics) GetMode() *CreateInputSystemByPackCPUModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackCPUWindowsMetrics) GetPerCPU() *bool {
	if c == nil {
		return nil
	}
	return c.PerCPU
}

func (c *CreateInputSystemByPackCPUWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputSystemByPackCPUWindowsMetrics) GetTime() *bool {
	if c == nil {
		return nil
	}
	return c.Time
}

// CreateInputSystemByPackMemoryModeWindowsMetrics - Select the level of details for memory metrics
type CreateInputSystemByPackMemoryModeWindowsMetrics string

const (
	// CreateInputSystemByPackMemoryModeWindowsMetricsBasic Basic
	CreateInputSystemByPackMemoryModeWindowsMetricsBasic CreateInputSystemByPackMemoryModeWindowsMetrics = "basic"
	// CreateInputSystemByPackMemoryModeWindowsMetricsAll All
	CreateInputSystemByPackMemoryModeWindowsMetricsAll CreateInputSystemByPackMemoryModeWindowsMetrics = "all"
	// CreateInputSystemByPackMemoryModeWindowsMetricsCustom Custom
	CreateInputSystemByPackMemoryModeWindowsMetricsCustom CreateInputSystemByPackMemoryModeWindowsMetrics = "custom"
	// CreateInputSystemByPackMemoryModeWindowsMetricsDisabled Disabled
	CreateInputSystemByPackMemoryModeWindowsMetricsDisabled CreateInputSystemByPackMemoryModeWindowsMetrics = "disabled"
)

func (e CreateInputSystemByPackMemoryModeWindowsMetrics) ToPointer() *CreateInputSystemByPackMemoryModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackMemoryModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackMemoryWindowsMetrics struct {
	// Select the level of details for memory metrics
	Mode *CreateInputSystemByPackMemoryModeWindowsMetrics `json:"mode,omitempty"`
	// Generate metrics for all memory states
	Detail *bool `json:"detail,omitempty"`
}

func (c CreateInputSystemByPackMemoryWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackMemoryWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackMemoryWindowsMetrics) GetMode() *CreateInputSystemByPackMemoryModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackMemoryWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

// CreateInputSystemByPackNetworkModeWindowsMetrics - Select the level of details for network metrics
type CreateInputSystemByPackNetworkModeWindowsMetrics string

const (
	// CreateInputSystemByPackNetworkModeWindowsMetricsBasic Basic
	CreateInputSystemByPackNetworkModeWindowsMetricsBasic CreateInputSystemByPackNetworkModeWindowsMetrics = "basic"
	// CreateInputSystemByPackNetworkModeWindowsMetricsAll All
	CreateInputSystemByPackNetworkModeWindowsMetricsAll CreateInputSystemByPackNetworkModeWindowsMetrics = "all"
	// CreateInputSystemByPackNetworkModeWindowsMetricsCustom Custom
	CreateInputSystemByPackNetworkModeWindowsMetricsCustom CreateInputSystemByPackNetworkModeWindowsMetrics = "custom"
	// CreateInputSystemByPackNetworkModeWindowsMetricsDisabled Disabled
	CreateInputSystemByPackNetworkModeWindowsMetricsDisabled CreateInputSystemByPackNetworkModeWindowsMetrics = "disabled"
)

func (e CreateInputSystemByPackNetworkModeWindowsMetrics) ToPointer() *CreateInputSystemByPackNetworkModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackNetworkModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackNetworkWindowsMetrics struct {
	// Select the level of details for network metrics
	Mode *CreateInputSystemByPackNetworkModeWindowsMetrics `json:"mode,omitempty"`
	// Generate full network metrics
	Detail *bool `json:"detail,omitempty"`
	// Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
	Protocols *bool `json:"protocols,omitempty"`
	// Network interfaces to include/exclude. All interfaces are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Generate separate metrics for each interface
	PerInterface *bool `json:"perInterface,omitempty"`
}

func (c CreateInputSystemByPackNetworkWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackNetworkWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackNetworkWindowsMetrics) GetMode() *CreateInputSystemByPackNetworkModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackNetworkWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputSystemByPackNetworkWindowsMetrics) GetProtocols() *bool {
	if c == nil {
		return nil
	}
	return c.Protocols
}

func (c *CreateInputSystemByPackNetworkWindowsMetrics) GetDevices() []string {
	if c == nil {
		return nil
	}
	return c.Devices
}

func (c *CreateInputSystemByPackNetworkWindowsMetrics) GetPerInterface() *bool {
	if c == nil {
		return nil
	}
	return c.PerInterface
}

// CreateInputSystemByPackDiskModeWindowsMetrics - Select the level of details for disk metrics
type CreateInputSystemByPackDiskModeWindowsMetrics string

const (
	// CreateInputSystemByPackDiskModeWindowsMetricsBasic Basic
	CreateInputSystemByPackDiskModeWindowsMetricsBasic CreateInputSystemByPackDiskModeWindowsMetrics = "basic"
	// CreateInputSystemByPackDiskModeWindowsMetricsAll All
	CreateInputSystemByPackDiskModeWindowsMetricsAll CreateInputSystemByPackDiskModeWindowsMetrics = "all"
	// CreateInputSystemByPackDiskModeWindowsMetricsCustom Custom
	CreateInputSystemByPackDiskModeWindowsMetricsCustom CreateInputSystemByPackDiskModeWindowsMetrics = "custom"
	// CreateInputSystemByPackDiskModeWindowsMetricsDisabled Disabled
	CreateInputSystemByPackDiskModeWindowsMetricsDisabled CreateInputSystemByPackDiskModeWindowsMetrics = "disabled"
)

func (e CreateInputSystemByPackDiskModeWindowsMetrics) ToPointer() *CreateInputSystemByPackDiskModeWindowsMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackDiskModeWindowsMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackDiskWindowsMetrics struct {
	// Select the level of details for disk metrics
	Mode *CreateInputSystemByPackDiskModeWindowsMetrics `json:"mode,omitempty"`
	// Generate separate metrics for each volume
	PerVolume *bool `json:"perVolume,omitempty"`
	// Generate full disk metrics
	Detail *bool `json:"detail,omitempty"`
	// Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
	Volumes []string `json:"volumes,omitempty"`
}

func (c CreateInputSystemByPackDiskWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackDiskWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackDiskWindowsMetrics) GetMode() *CreateInputSystemByPackDiskModeWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackDiskWindowsMetrics) GetPerVolume() *bool {
	if c == nil {
		return nil
	}
	return c.PerVolume
}

func (c *CreateInputSystemByPackDiskWindowsMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputSystemByPackDiskWindowsMetrics) GetVolumes() []string {
	if c == nil {
		return nil
	}
	return c.Volumes
}

type CreateInputSystemByPackCustomWindowsMetrics struct {
	System  *CreateInputSystemByPackSystemWindowsMetrics  `json:"system,omitempty"`
	CPU     *CreateInputSystemByPackCPUWindowsMetrics     `json:"cpu,omitempty"`
	Memory  *CreateInputSystemByPackMemoryWindowsMetrics  `json:"memory,omitempty"`
	Network *CreateInputSystemByPackNetworkWindowsMetrics `json:"network,omitempty"`
	Disk    *CreateInputSystemByPackDiskWindowsMetrics    `json:"disk,omitempty"`
}

func (c CreateInputSystemByPackCustomWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackCustomWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackCustomWindowsMetrics) GetSystem() *CreateInputSystemByPackSystemWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.System
}

func (c *CreateInputSystemByPackCustomWindowsMetrics) GetCPU() *CreateInputSystemByPackCPUWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.CPU
}

func (c *CreateInputSystemByPackCustomWindowsMetrics) GetMemory() *CreateInputSystemByPackMemoryWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Memory
}

func (c *CreateInputSystemByPackCustomWindowsMetrics) GetNetwork() *CreateInputSystemByPackNetworkWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Network
}

func (c *CreateInputSystemByPackCustomWindowsMetrics) GetDisk() *CreateInputSystemByPackDiskWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Disk
}

type CreateInputSystemByPackHostWindowsMetrics struct {
	// Select level of detail for host metrics
	Mode   *components.ModeOptionsHost                  `json:"mode,omitempty"`
	Custom *CreateInputSystemByPackCustomWindowsMetrics `json:"custom,omitempty"`
}

func (c CreateInputSystemByPackHostWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackHostWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackHostWindowsMetrics) GetMode() *components.ModeOptionsHost {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackHostWindowsMetrics) GetCustom() *CreateInputSystemByPackCustomWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Custom
}

type CreateInputSystemByPackPersistenceWindowsMetrics struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputSystemByPackPersistenceWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackPersistenceWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackPersistenceWindowsMetrics) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputSystemByPackPersistenceWindowsMetrics) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputSystemByPackPersistenceWindowsMetrics) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputSystemByPackPersistenceWindowsMetrics) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputSystemByPackPersistenceWindowsMetrics) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputSystemByPackPersistenceWindowsMetrics) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputSystemByPackInputWindowsMetrics struct {
	// Unique ID for this input
	ID       string                                    `json:"id"`
	Type     CreateInputSystemByPackTypeWindowsMetrics `json:"type"`
	Disabled *bool                                     `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                                   `json:"interval,omitempty"`
	Host     *CreateInputSystemByPackHostWindowsMetrics `json:"host,omitempty"`
	Process  *components.ProcessType                    `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata        `json:"metadata,omitempty"`
	Persistence *CreateInputSystemByPackPersistenceWindowsMetrics `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `json:"disableNativeModule,omitempty"`
	Description         *string `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputWindowsMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputWindowsMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetType() CreateInputSystemByPackTypeWindowsMetrics {
	if c == nil {
		return CreateInputSystemByPackTypeWindowsMetrics("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetHost() *CreateInputSystemByPackHostWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetProcess() *components.ProcessType {
	if c == nil {
		return nil
	}
	return c.Process
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetPersistence() *CreateInputSystemByPackPersistenceWindowsMetrics {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetDisableNativeModule() *bool {
	if c == nil {
		return nil
	}
	return c.DisableNativeModule
}

func (c *CreateInputSystemByPackInputWindowsMetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeKubeEvents string

const (
	CreateInputSystemByPackTypeKubeEventsKubeEvents CreateInputSystemByPackTypeKubeEvents = "kube_events"
)

func (e CreateInputSystemByPackTypeKubeEvents) ToPointer() *CreateInputSystemByPackTypeKubeEvents {
	return &e
}
func (e *CreateInputSystemByPackTypeKubeEvents) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_events":
		*e = CreateInputSystemByPackTypeKubeEvents(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeKubeEvents: %v", v)
	}
}

type CreateInputSystemByPackInputKubeEvents struct {
	// Unique ID for this input
	ID       string                                `json:"id"`
	Type     CreateInputSystemByPackTypeKubeEvents `json:"type"`
	Disabled *bool                                 `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Filtering on event fields
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputKubeEvents) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputKubeEvents) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputKubeEvents) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputKubeEvents) GetType() CreateInputSystemByPackTypeKubeEvents {
	if c == nil {
		return CreateInputSystemByPackTypeKubeEvents("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputKubeEvents) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputKubeEvents) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputKubeEvents) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputKubeEvents) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputKubeEvents) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputKubeEvents) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputKubeEvents) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputKubeEvents) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputKubeEvents) GetRules() []components.ItemsTypeRules {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *CreateInputSystemByPackInputKubeEvents) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputKubeEvents) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeKubeLogs string

const (
	CreateInputSystemByPackTypeKubeLogsKubeLogs CreateInputSystemByPackTypeKubeLogs = "kube_logs"
)

func (e CreateInputSystemByPackTypeKubeLogs) ToPointer() *CreateInputSystemByPackTypeKubeLogs {
	return &e
}
func (e *CreateInputSystemByPackTypeKubeLogs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_logs":
		*e = CreateInputSystemByPackTypeKubeLogs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeKubeLogs: %v", v)
	}
}

type CreateInputSystemByPackRuleKubeLogs struct {
	// JavaScript expression applied to Pod objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (c CreateInputSystemByPackRuleKubeLogs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackRuleKubeLogs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackRuleKubeLogs) GetFilter() string {
	if c == nil {
		return ""
	}
	return c.Filter
}

func (c *CreateInputSystemByPackRuleKubeLogs) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackInputKubeLogs struct {
	// Unique ID for this input
	ID       string                              `json:"id"`
	Type     CreateInputSystemByPackTypeKubeLogs `json:"type"`
	Disabled *bool                               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between checks for new containers. Default is 15 secs.
	Interval *float64 `json:"interval,omitempty"`
	// Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
	Rules []CreateInputSystemByPackRuleKubeLogs `json:"rules,omitempty"`
	// For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
	Timestamps *bool `json:"timestamps,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *components.DiskSpoolingType               `json:"persistence,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `json:"enableLoadBalancing,omitempty"`
	Description         *string `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputKubeLogs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputKubeLogs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputKubeLogs) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputKubeLogs) GetType() CreateInputSystemByPackTypeKubeLogs {
	if c == nil {
		return CreateInputSystemByPackTypeKubeLogs("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputKubeLogs) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputKubeLogs) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputKubeLogs) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputKubeLogs) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputKubeLogs) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputKubeLogs) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputKubeLogs) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputKubeLogs) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputKubeLogs) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputKubeLogs) GetRules() []CreateInputSystemByPackRuleKubeLogs {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *CreateInputSystemByPackInputKubeLogs) GetTimestamps() *bool {
	if c == nil {
		return nil
	}
	return c.Timestamps
}

func (c *CreateInputSystemByPackInputKubeLogs) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputKubeLogs) GetPersistence() *components.DiskSpoolingType {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputSystemByPackInputKubeLogs) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputKubeLogs) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputKubeLogs) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputSystemByPackInputKubeLogs) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeKubeMetrics string

const (
	CreateInputSystemByPackTypeKubeMetricsKubeMetrics CreateInputSystemByPackTypeKubeMetrics = "kube_metrics"
)

func (e CreateInputSystemByPackTypeKubeMetrics) ToPointer() *CreateInputSystemByPackTypeKubeMetrics {
	return &e
}
func (e *CreateInputSystemByPackTypeKubeMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_metrics":
		*e = CreateInputSystemByPackTypeKubeMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeKubeMetrics: %v", v)
	}
}

type CreateInputSystemByPackPersistenceKubeMetrics struct {
	// Spool metrics on disk for Cribl Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputSystemByPackPersistenceKubeMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackPersistenceKubeMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackPersistenceKubeMetrics) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputSystemByPackPersistenceKubeMetrics) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputSystemByPackPersistenceKubeMetrics) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputSystemByPackPersistenceKubeMetrics) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputSystemByPackPersistenceKubeMetrics) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputSystemByPackPersistenceKubeMetrics) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputSystemByPackInputKubeMetrics struct {
	// Unique ID for this input
	ID       string                                 `json:"id"`
	Type     CreateInputSystemByPackTypeKubeMetrics `json:"type"`
	Disabled *bool                                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metrics collections. Default is 15 secs.
	Interval *float64 `json:"interval,omitempty"`
	// Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata     `json:"metadata,omitempty"`
	Persistence *CreateInputSystemByPackPersistenceKubeMetrics `json:"persistence,omitempty"`
	Description *string                                        `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputKubeMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputKubeMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetType() CreateInputSystemByPackTypeKubeMetrics {
	if c == nil {
		return CreateInputSystemByPackTypeKubeMetrics("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetRules() []components.ItemsTypeRules {
	if c == nil {
		return nil
	}
	return c.Rules
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetPersistence() *CreateInputSystemByPackPersistenceKubeMetrics {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputSystemByPackInputKubeMetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeSystemState string

const (
	CreateInputSystemByPackTypeSystemStateSystemState CreateInputSystemByPackTypeSystemState = "system_state"
)

func (e CreateInputSystemByPackTypeSystemState) ToPointer() *CreateInputSystemByPackTypeSystemState {
	return &e
}
func (e *CreateInputSystemByPackTypeSystemState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system_state":
		*e = CreateInputSystemByPackTypeSystemState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeSystemState: %v", v)
	}
}

// CreateInputSystemByPackHostsFile - Creates events based on entries collected from the hosts file
type CreateInputSystemByPackHostsFile struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackHostsFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackHostsFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackHostsFile) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackInterfaces - Creates events for each of the hosts network interfaces
type CreateInputSystemByPackInterfaces struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackInterfaces) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInterfaces) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInterfaces) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackDisksAndFileSystems - Creates events for physical disks, partitions, and file systems
type CreateInputSystemByPackDisksAndFileSystems struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackDisksAndFileSystems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackDisksAndFileSystems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackDisksAndFileSystems) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackHostInfo - Creates events based on the host systems current state
type CreateInputSystemByPackHostInfo struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackHostInfo) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackHostInfo) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackHostInfo) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackRoutes - Creates events based on entries collected from the hosts network routes
type CreateInputSystemByPackRoutes struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackRoutes) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackRoutes) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackRoutes) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackDNS - Creates events for DNS resolvers and search entries
type CreateInputSystemByPackDNS struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackDNS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackDNS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackDNS) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackUsersAndGroups - Creates events for local users and groups
type CreateInputSystemByPackUsersAndGroups struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackUsersAndGroups) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackUsersAndGroups) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackUsersAndGroups) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackFirewall - Creates events for Firewall rules entries
type CreateInputSystemByPackFirewall struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackFirewall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackFirewall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackFirewall) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackServices - Creates events from the list of services
type CreateInputSystemByPackServices struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackServices) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackServices) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackServices) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackListeningPorts - Creates events from list of listening ports
type CreateInputSystemByPackListeningPorts struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackListeningPorts) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackListeningPorts) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackListeningPorts) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

// CreateInputSystemByPackLoggedInUsers - Creates events from list of logged-in users
type CreateInputSystemByPackLoggedInUsers struct {
	Enable *bool `json:"enable,omitempty"`
}

func (c CreateInputSystemByPackLoggedInUsers) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackLoggedInUsers) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackLoggedInUsers) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

type CreateInputSystemByPackCollectors struct {
	// Creates events based on entries collected from the hosts file
	Hostsfile *CreateInputSystemByPackHostsFile `json:"hostsfile,omitempty"`
	// Creates events for each of the hosts network interfaces
	Interfaces *CreateInputSystemByPackInterfaces `json:"interfaces,omitempty"`
	// Creates events for physical disks, partitions, and file systems
	Disk *CreateInputSystemByPackDisksAndFileSystems `json:"disk,omitempty"`
	// Creates events based on the host systems current state
	Metadata *CreateInputSystemByPackHostInfo `json:"metadata,omitempty"`
	// Creates events based on entries collected from the hosts network routes
	Routes *CreateInputSystemByPackRoutes `json:"routes,omitempty"`
	// Creates events for DNS resolvers and search entries
	DNS *CreateInputSystemByPackDNS `json:"dns,omitempty"`
	// Creates events for local users and groups
	User *CreateInputSystemByPackUsersAndGroups `json:"user,omitempty"`
	// Creates events for Firewall rules entries
	Firewall *CreateInputSystemByPackFirewall `json:"firewall,omitempty"`
	// Creates events from the list of services
	Services *CreateInputSystemByPackServices `json:"services,omitempty"`
	// Creates events from list of listening ports
	Ports *CreateInputSystemByPackListeningPorts `json:"ports,omitempty"`
	// Creates events from list of logged-in users
	LoginUsers *CreateInputSystemByPackLoggedInUsers `json:"loginUsers,omitempty"`
}

func (c CreateInputSystemByPackCollectors) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackCollectors) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackCollectors) GetHostsfile() *CreateInputSystemByPackHostsFile {
	if c == nil {
		return nil
	}
	return c.Hostsfile
}

func (c *CreateInputSystemByPackCollectors) GetInterfaces() *CreateInputSystemByPackInterfaces {
	if c == nil {
		return nil
	}
	return c.Interfaces
}

func (c *CreateInputSystemByPackCollectors) GetDisk() *CreateInputSystemByPackDisksAndFileSystems {
	if c == nil {
		return nil
	}
	return c.Disk
}

func (c *CreateInputSystemByPackCollectors) GetMetadata() *CreateInputSystemByPackHostInfo {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackCollectors) GetRoutes() *CreateInputSystemByPackRoutes {
	if c == nil {
		return nil
	}
	return c.Routes
}

func (c *CreateInputSystemByPackCollectors) GetDNS() *CreateInputSystemByPackDNS {
	if c == nil {
		return nil
	}
	return c.DNS
}

func (c *CreateInputSystemByPackCollectors) GetUser() *CreateInputSystemByPackUsersAndGroups {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *CreateInputSystemByPackCollectors) GetFirewall() *CreateInputSystemByPackFirewall {
	if c == nil {
		return nil
	}
	return c.Firewall
}

func (c *CreateInputSystemByPackCollectors) GetServices() *CreateInputSystemByPackServices {
	if c == nil {
		return nil
	}
	return c.Services
}

func (c *CreateInputSystemByPackCollectors) GetPorts() *CreateInputSystemByPackListeningPorts {
	if c == nil {
		return nil
	}
	return c.Ports
}

func (c *CreateInputSystemByPackCollectors) GetLoginUsers() *CreateInputSystemByPackLoggedInUsers {
	if c == nil {
		return nil
	}
	return c.LoginUsers
}

type CreateInputSystemByPackPersistenceSystemState struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputSystemByPackPersistenceSystemState) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackPersistenceSystemState) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackPersistenceSystemState) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputSystemByPackPersistenceSystemState) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputSystemByPackPersistenceSystemState) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputSystemByPackPersistenceSystemState) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputSystemByPackPersistenceSystemState) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputSystemByPackPersistenceSystemState) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputSystemByPackInputSystemState struct {
	// Unique ID for this input
	ID       string                                 `json:"id"`
	Type     CreateInputSystemByPackTypeSystemState `json:"type"`
	Disabled *bool                                  `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
	Interval *float64 `json:"interval,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata     `json:"metadata,omitempty"`
	Collectors  *CreateInputSystemByPackCollectors             `json:"collectors,omitempty"`
	Persistence *CreateInputSystemByPackPersistenceSystemState `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
	DisableNativeModule *bool `json:"disableNativeModule,omitempty"`
	// Enable only to collect LastLog data via legacy implementation. This option will be removed in a future release. Please contact Support before enabling. [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
	DisableNativeLastLogModule *bool   `json:"disableNativeLastLogModule,omitempty"`
	Description                *string `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputSystemState) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSystemState) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSystemState) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSystemState) GetType() CreateInputSystemByPackTypeSystemState {
	if c == nil {
		return CreateInputSystemByPackTypeSystemState("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSystemState) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSystemState) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSystemState) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSystemState) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSystemState) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSystemState) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSystemState) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSystemState) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSystemState) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputSystemState) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSystemState) GetCollectors() *CreateInputSystemByPackCollectors {
	if c == nil {
		return nil
	}
	return c.Collectors
}

func (c *CreateInputSystemByPackInputSystemState) GetPersistence() *CreateInputSystemByPackPersistenceSystemState {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputSystemByPackInputSystemState) GetDisableNativeModule() *bool {
	if c == nil {
		return nil
	}
	return c.DisableNativeModule
}

func (c *CreateInputSystemByPackInputSystemState) GetDisableNativeLastLogModule() *bool {
	if c == nil {
		return nil
	}
	return c.DisableNativeLastLogModule
}

func (c *CreateInputSystemByPackInputSystemState) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeSystemMetrics string

const (
	CreateInputSystemByPackTypeSystemMetricsSystemMetrics CreateInputSystemByPackTypeSystemMetrics = "system_metrics"
)

func (e CreateInputSystemByPackTypeSystemMetrics) ToPointer() *CreateInputSystemByPackTypeSystemMetrics {
	return &e
}
func (e *CreateInputSystemByPackTypeSystemMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system_metrics":
		*e = CreateInputSystemByPackTypeSystemMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeSystemMetrics: %v", v)
	}
}

// CreateInputSystemByPackSystemModeSystemMetrics - Select the level of detail for system metrics
type CreateInputSystemByPackSystemModeSystemMetrics string

const (
	// CreateInputSystemByPackSystemModeSystemMetricsBasic Basic
	CreateInputSystemByPackSystemModeSystemMetricsBasic CreateInputSystemByPackSystemModeSystemMetrics = "basic"
	// CreateInputSystemByPackSystemModeSystemMetricsAll All
	CreateInputSystemByPackSystemModeSystemMetricsAll CreateInputSystemByPackSystemModeSystemMetrics = "all"
	// CreateInputSystemByPackSystemModeSystemMetricsCustom Custom
	CreateInputSystemByPackSystemModeSystemMetricsCustom CreateInputSystemByPackSystemModeSystemMetrics = "custom"
	// CreateInputSystemByPackSystemModeSystemMetricsDisabled Disabled
	CreateInputSystemByPackSystemModeSystemMetricsDisabled CreateInputSystemByPackSystemModeSystemMetrics = "disabled"
)

func (e CreateInputSystemByPackSystemModeSystemMetrics) ToPointer() *CreateInputSystemByPackSystemModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackSystemModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackSystemSystemMetrics struct {
	// Select the level of detail for system metrics
	Mode *CreateInputSystemByPackSystemModeSystemMetrics `json:"mode,omitempty"`
	// Generate metrics for the numbers of processes in various states
	Processes *bool `json:"processes,omitempty"`
}

func (c CreateInputSystemByPackSystemSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackSystemSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackSystemSystemMetrics) GetMode() *CreateInputSystemByPackSystemModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackSystemSystemMetrics) GetProcesses() *bool {
	if c == nil {
		return nil
	}
	return c.Processes
}

// CreateInputSystemByPackCPUModeSystemMetrics - Select the level of detail for CPU metrics
type CreateInputSystemByPackCPUModeSystemMetrics string

const (
	// CreateInputSystemByPackCPUModeSystemMetricsBasic Basic
	CreateInputSystemByPackCPUModeSystemMetricsBasic CreateInputSystemByPackCPUModeSystemMetrics = "basic"
	// CreateInputSystemByPackCPUModeSystemMetricsAll All
	CreateInputSystemByPackCPUModeSystemMetricsAll CreateInputSystemByPackCPUModeSystemMetrics = "all"
	// CreateInputSystemByPackCPUModeSystemMetricsCustom Custom
	CreateInputSystemByPackCPUModeSystemMetricsCustom CreateInputSystemByPackCPUModeSystemMetrics = "custom"
	// CreateInputSystemByPackCPUModeSystemMetricsDisabled Disabled
	CreateInputSystemByPackCPUModeSystemMetricsDisabled CreateInputSystemByPackCPUModeSystemMetrics = "disabled"
)

func (e CreateInputSystemByPackCPUModeSystemMetrics) ToPointer() *CreateInputSystemByPackCPUModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackCPUModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackCPUSystemMetrics struct {
	// Select the level of detail for CPU metrics
	Mode *CreateInputSystemByPackCPUModeSystemMetrics `json:"mode,omitempty"`
	// Generate metrics for each CPU
	PerCPU *bool `json:"perCpu,omitempty"`
	// Generate metrics for all CPU states
	Detail *bool `json:"detail,omitempty"`
	// Generate raw, monotonic CPU time counters
	Time *bool `json:"time,omitempty"`
}

func (c CreateInputSystemByPackCPUSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackCPUSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackCPUSystemMetrics) GetMode() *CreateInputSystemByPackCPUModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackCPUSystemMetrics) GetPerCPU() *bool {
	if c == nil {
		return nil
	}
	return c.PerCPU
}

func (c *CreateInputSystemByPackCPUSystemMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputSystemByPackCPUSystemMetrics) GetTime() *bool {
	if c == nil {
		return nil
	}
	return c.Time
}

// CreateInputSystemByPackMemoryModeSystemMetrics - Select the level of detail for memory metrics
type CreateInputSystemByPackMemoryModeSystemMetrics string

const (
	// CreateInputSystemByPackMemoryModeSystemMetricsBasic Basic
	CreateInputSystemByPackMemoryModeSystemMetricsBasic CreateInputSystemByPackMemoryModeSystemMetrics = "basic"
	// CreateInputSystemByPackMemoryModeSystemMetricsAll All
	CreateInputSystemByPackMemoryModeSystemMetricsAll CreateInputSystemByPackMemoryModeSystemMetrics = "all"
	// CreateInputSystemByPackMemoryModeSystemMetricsCustom Custom
	CreateInputSystemByPackMemoryModeSystemMetricsCustom CreateInputSystemByPackMemoryModeSystemMetrics = "custom"
	// CreateInputSystemByPackMemoryModeSystemMetricsDisabled Disabled
	CreateInputSystemByPackMemoryModeSystemMetricsDisabled CreateInputSystemByPackMemoryModeSystemMetrics = "disabled"
)

func (e CreateInputSystemByPackMemoryModeSystemMetrics) ToPointer() *CreateInputSystemByPackMemoryModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackMemoryModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackMemorySystemMetrics struct {
	// Select the level of detail for memory metrics
	Mode *CreateInputSystemByPackMemoryModeSystemMetrics `json:"mode,omitempty"`
	// Generate metrics for all memory states
	Detail *bool `json:"detail,omitempty"`
}

func (c CreateInputSystemByPackMemorySystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackMemorySystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackMemorySystemMetrics) GetMode() *CreateInputSystemByPackMemoryModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackMemorySystemMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

// CreateInputSystemByPackNetworkModeSystemMetrics - Select the level of detail for network metrics
type CreateInputSystemByPackNetworkModeSystemMetrics string

const (
	// CreateInputSystemByPackNetworkModeSystemMetricsBasic Basic
	CreateInputSystemByPackNetworkModeSystemMetricsBasic CreateInputSystemByPackNetworkModeSystemMetrics = "basic"
	// CreateInputSystemByPackNetworkModeSystemMetricsAll All
	CreateInputSystemByPackNetworkModeSystemMetricsAll CreateInputSystemByPackNetworkModeSystemMetrics = "all"
	// CreateInputSystemByPackNetworkModeSystemMetricsCustom Custom
	CreateInputSystemByPackNetworkModeSystemMetricsCustom CreateInputSystemByPackNetworkModeSystemMetrics = "custom"
	// CreateInputSystemByPackNetworkModeSystemMetricsDisabled Disabled
	CreateInputSystemByPackNetworkModeSystemMetricsDisabled CreateInputSystemByPackNetworkModeSystemMetrics = "disabled"
)

func (e CreateInputSystemByPackNetworkModeSystemMetrics) ToPointer() *CreateInputSystemByPackNetworkModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackNetworkModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackNetworkSystemMetrics struct {
	// Select the level of detail for network metrics
	Mode *CreateInputSystemByPackNetworkModeSystemMetrics `json:"mode,omitempty"`
	// Generate full network metrics
	Detail *bool `json:"detail,omitempty"`
	// Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
	Protocols *bool `json:"protocols,omitempty"`
	// Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Generate separate metrics for each interface
	PerInterface *bool `json:"perInterface,omitempty"`
}

func (c CreateInputSystemByPackNetworkSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackNetworkSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackNetworkSystemMetrics) GetMode() *CreateInputSystemByPackNetworkModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackNetworkSystemMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputSystemByPackNetworkSystemMetrics) GetProtocols() *bool {
	if c == nil {
		return nil
	}
	return c.Protocols
}

func (c *CreateInputSystemByPackNetworkSystemMetrics) GetDevices() []string {
	if c == nil {
		return nil
	}
	return c.Devices
}

func (c *CreateInputSystemByPackNetworkSystemMetrics) GetPerInterface() *bool {
	if c == nil {
		return nil
	}
	return c.PerInterface
}

// CreateInputSystemByPackDiskModeSystemMetrics - Select the level of detail for disk metrics
type CreateInputSystemByPackDiskModeSystemMetrics string

const (
	// CreateInputSystemByPackDiskModeSystemMetricsBasic Basic
	CreateInputSystemByPackDiskModeSystemMetricsBasic CreateInputSystemByPackDiskModeSystemMetrics = "basic"
	// CreateInputSystemByPackDiskModeSystemMetricsAll All
	CreateInputSystemByPackDiskModeSystemMetricsAll CreateInputSystemByPackDiskModeSystemMetrics = "all"
	// CreateInputSystemByPackDiskModeSystemMetricsCustom Custom
	CreateInputSystemByPackDiskModeSystemMetricsCustom CreateInputSystemByPackDiskModeSystemMetrics = "custom"
	// CreateInputSystemByPackDiskModeSystemMetricsDisabled Disabled
	CreateInputSystemByPackDiskModeSystemMetricsDisabled CreateInputSystemByPackDiskModeSystemMetrics = "disabled"
)

func (e CreateInputSystemByPackDiskModeSystemMetrics) ToPointer() *CreateInputSystemByPackDiskModeSystemMetrics {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackDiskModeSystemMetrics) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackDiskSystemMetrics struct {
	// Select the level of detail for disk metrics
	Mode *CreateInputSystemByPackDiskModeSystemMetrics `json:"mode,omitempty"`
	// Generate full disk metrics
	Detail *bool `json:"detail,omitempty"`
	// Generate filesystem inode metrics
	Inodes *bool `json:"inodes,omitempty"`
	// Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty.
	Mountpoints []string `json:"mountpoints,omitempty"`
	// Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty.
	Fstypes []string `json:"fstypes,omitempty"`
	// Generate separate metrics for each device
	PerDevice *bool `json:"perDevice,omitempty"`
}

func (c CreateInputSystemByPackDiskSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackDiskSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackDiskSystemMetrics) GetMode() *CreateInputSystemByPackDiskModeSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackDiskSystemMetrics) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

func (c *CreateInputSystemByPackDiskSystemMetrics) GetInodes() *bool {
	if c == nil {
		return nil
	}
	return c.Inodes
}

func (c *CreateInputSystemByPackDiskSystemMetrics) GetDevices() []string {
	if c == nil {
		return nil
	}
	return c.Devices
}

func (c *CreateInputSystemByPackDiskSystemMetrics) GetMountpoints() []string {
	if c == nil {
		return nil
	}
	return c.Mountpoints
}

func (c *CreateInputSystemByPackDiskSystemMetrics) GetFstypes() []string {
	if c == nil {
		return nil
	}
	return c.Fstypes
}

func (c *CreateInputSystemByPackDiskSystemMetrics) GetPerDevice() *bool {
	if c == nil {
		return nil
	}
	return c.PerDevice
}

type CreateInputSystemByPackCustomSystemMetrics struct {
	System  *CreateInputSystemByPackSystemSystemMetrics  `json:"system,omitempty"`
	CPU     *CreateInputSystemByPackCPUSystemMetrics     `json:"cpu,omitempty"`
	Memory  *CreateInputSystemByPackMemorySystemMetrics  `json:"memory,omitempty"`
	Network *CreateInputSystemByPackNetworkSystemMetrics `json:"network,omitempty"`
	Disk    *CreateInputSystemByPackDiskSystemMetrics    `json:"disk,omitempty"`
}

func (c CreateInputSystemByPackCustomSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackCustomSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackCustomSystemMetrics) GetSystem() *CreateInputSystemByPackSystemSystemMetrics {
	if c == nil {
		return nil
	}
	return c.System
}

func (c *CreateInputSystemByPackCustomSystemMetrics) GetCPU() *CreateInputSystemByPackCPUSystemMetrics {
	if c == nil {
		return nil
	}
	return c.CPU
}

func (c *CreateInputSystemByPackCustomSystemMetrics) GetMemory() *CreateInputSystemByPackMemorySystemMetrics {
	if c == nil {
		return nil
	}
	return c.Memory
}

func (c *CreateInputSystemByPackCustomSystemMetrics) GetNetwork() *CreateInputSystemByPackNetworkSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Network
}

func (c *CreateInputSystemByPackCustomSystemMetrics) GetDisk() *CreateInputSystemByPackDiskSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Disk
}

type CreateInputSystemByPackHostSystemMetrics struct {
	// Select level of detail for host metrics
	Mode   *components.ModeOptionsHost                 `json:"mode,omitempty"`
	Custom *CreateInputSystemByPackCustomSystemMetrics `json:"custom,omitempty"`
}

func (c CreateInputSystemByPackHostSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackHostSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackHostSystemMetrics) GetMode() *components.ModeOptionsHost {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackHostSystemMetrics) GetCustom() *CreateInputSystemByPackCustomSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Custom
}

// CreateInputSystemByPackContainerMode - Select the level of detail for container metrics
type CreateInputSystemByPackContainerMode string

const (
	// CreateInputSystemByPackContainerModeBasic Basic
	CreateInputSystemByPackContainerModeBasic CreateInputSystemByPackContainerMode = "basic"
	// CreateInputSystemByPackContainerModeAll All
	CreateInputSystemByPackContainerModeAll CreateInputSystemByPackContainerMode = "all"
	// CreateInputSystemByPackContainerModeCustom Custom
	CreateInputSystemByPackContainerModeCustom CreateInputSystemByPackContainerMode = "custom"
	// CreateInputSystemByPackContainerModeDisabled Disabled
	CreateInputSystemByPackContainerModeDisabled CreateInputSystemByPackContainerMode = "disabled"
)

func (e CreateInputSystemByPackContainerMode) ToPointer() *CreateInputSystemByPackContainerMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackContainerMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackContainerFilter struct {
	Expr string `json:"expr"`
}

func (c CreateInputSystemByPackContainerFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackContainerFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"expr"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackContainerFilter) GetExpr() string {
	if c == nil {
		return ""
	}
	return c.Expr
}

type CreateInputSystemByPackContainer struct {
	// Select the level of detail for container metrics
	Mode *CreateInputSystemByPackContainerMode `json:"mode,omitempty"`
	// Full paths for Docker's UNIX-domain socket
	DockerSocket []string `json:"dockerSocket,omitempty"`
	// Timeout, in seconds, for the Docker API
	DockerTimeout *float64 `json:"dockerTimeout,omitempty"`
	// Containers matching any of these will be included. All are included if no filters are added.
	Filters []CreateInputSystemByPackContainerFilter `json:"filters,omitempty"`
	// Include stopped and paused containers
	AllContainers *bool `json:"allContainers,omitempty"`
	// Generate separate metrics for each device
	PerDevice *bool `json:"perDevice,omitempty"`
	// Generate full container metrics
	Detail *bool `json:"detail,omitempty"`
}

func (c CreateInputSystemByPackContainer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackContainer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackContainer) GetMode() *CreateInputSystemByPackContainerMode {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CreateInputSystemByPackContainer) GetDockerSocket() []string {
	if c == nil {
		return nil
	}
	return c.DockerSocket
}

func (c *CreateInputSystemByPackContainer) GetDockerTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.DockerTimeout
}

func (c *CreateInputSystemByPackContainer) GetFilters() []CreateInputSystemByPackContainerFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *CreateInputSystemByPackContainer) GetAllContainers() *bool {
	if c == nil {
		return nil
	}
	return c.AllContainers
}

func (c *CreateInputSystemByPackContainer) GetPerDevice() *bool {
	if c == nil {
		return nil
	}
	return c.PerDevice
}

func (c *CreateInputSystemByPackContainer) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

type CreateInputSystemByPackPersistenceSystemMetrics struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `json:"enable,omitempty"`
	// Time span for each file bucket
	TimeWindow *string `json:"timeWindow,omitempty"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `json:"maxDataTime,omitempty"`
	Compress    *components.DataCompressionFormatOptionsPersistence `json:"compress,omitempty"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics
	DestPath *string `json:"destPath,omitempty"`
}

func (c CreateInputSystemByPackPersistenceSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackPersistenceSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackPersistenceSystemMetrics) GetEnable() *bool {
	if c == nil {
		return nil
	}
	return c.Enable
}

func (c *CreateInputSystemByPackPersistenceSystemMetrics) GetTimeWindow() *string {
	if c == nil {
		return nil
	}
	return c.TimeWindow
}

func (c *CreateInputSystemByPackPersistenceSystemMetrics) GetMaxDataSize() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataSize
}

func (c *CreateInputSystemByPackPersistenceSystemMetrics) GetMaxDataTime() *string {
	if c == nil {
		return nil
	}
	return c.MaxDataTime
}

func (c *CreateInputSystemByPackPersistenceSystemMetrics) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputSystemByPackPersistenceSystemMetrics) GetDestPath() *string {
	if c == nil {
		return nil
	}
	return c.DestPath
}

type CreateInputSystemByPackInputSystemMetrics struct {
	// Unique ID for this input
	ID       string                                   `json:"id"`
	Type     CreateInputSystemByPackTypeSystemMetrics `json:"type"`
	Disabled *bool                                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval  *float64                                  `json:"interval,omitempty"`
	Host      *CreateInputSystemByPackHostSystemMetrics `json:"host,omitempty"`
	Process   *components.ProcessType                   `json:"process,omitempty"`
	Container *CreateInputSystemByPackContainer         `json:"container,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata       `json:"metadata,omitempty"`
	Persistence *CreateInputSystemByPackPersistenceSystemMetrics `json:"persistence,omitempty"`
	Description *string                                          `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputSystemMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSystemMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetType() CreateInputSystemByPackTypeSystemMetrics {
	if c == nil {
		return CreateInputSystemByPackTypeSystemMetrics("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetHost() *CreateInputSystemByPackHostSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetProcess() *components.ProcessType {
	if c == nil {
		return nil
	}
	return c.Process
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetContainer() *CreateInputSystemByPackContainer {
	if c == nil {
		return nil
	}
	return c.Container
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetPersistence() *CreateInputSystemByPackPersistenceSystemMetrics {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputSystemByPackInputSystemMetrics) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeTcpjson string

const (
	CreateInputSystemByPackTypeTcpjsonTcpjson CreateInputSystemByPackTypeTcpjson = "tcpjson"
)

func (e CreateInputSystemByPackTypeTcpjson) ToPointer() *CreateInputSystemByPackTypeTcpjson {
	return &e
}
func (e *CreateInputSystemByPackTypeTcpjson) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcpjson":
		*e = CreateInputSystemByPackTypeTcpjson(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeTcpjson: %v", v)
	}
}

type CreateInputSystemByPackInputTcpjson struct {
	// Unique ID for this input
	ID       string                             `json:"id"`
	Type     CreateInputSystemByPackTypeTcpjson `json:"type"`
	Disabled *bool                              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `json:"enableLoadBalancing,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	Description *string                                                `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `json:"authToken,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputTcpjson) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputTcpjson) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputTcpjson) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputTcpjson) GetType() CreateInputSystemByPackTypeTcpjson {
	if c == nil {
		return CreateInputSystemByPackTypeTcpjson("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputTcpjson) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputTcpjson) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputTcpjson) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputTcpjson) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputTcpjson) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputTcpjson) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputTcpjson) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputTcpjson) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputTcpjson) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputTcpjson) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputTcpjson) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputTcpjson) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputTcpjson) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputTcpjson) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputSystemByPackInputTcpjson) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputSystemByPackInputTcpjson) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputSystemByPackInputTcpjson) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputTcpjson) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputTcpjson) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputSystemByPackInputTcpjson) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputTcpjson) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputTcpjson) GetAuthToken() *string {
	if c == nil {
		return nil
	}
	return c.AuthToken
}

func (c *CreateInputSystemByPackInputTcpjson) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputTcpjson) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputTcpjson) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeCriblLakeHTTP string

const (
	CreateInputSystemByPackTypeCriblLakeHTTPCriblLakeHTTP CreateInputSystemByPackTypeCriblLakeHTTP = "cribl_lake_http"
)

func (e CreateInputSystemByPackTypeCriblLakeHTTP) ToPointer() *CreateInputSystemByPackTypeCriblLakeHTTP {
	return &e
}
func (e *CreateInputSystemByPackTypeCriblLakeHTTP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_lake_http":
		*e = CreateInputSystemByPackTypeCriblLakeHTTP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeCriblLakeHTTP: %v", v)
	}
}

type CreateInputSystemByPackSplunkHecMetadata struct {
	Enabled               *bool    `json:"enabled,omitempty"`
	DefaultDataset        *string  `json:"defaultDataset,omitempty"`
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
}

func (c CreateInputSystemByPackSplunkHecMetadata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackSplunkHecMetadata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackSplunkHecMetadata) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputSystemByPackSplunkHecMetadata) GetDefaultDataset() *string {
	if c == nil {
		return nil
	}
	return c.DefaultDataset
}

func (c *CreateInputSystemByPackSplunkHecMetadata) GetAllowedIndexesAtToken() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexesAtToken
}

type CreateInputSystemByPackElasticsearchMetadata struct {
	Enabled        *bool   `json:"enabled,omitempty"`
	DefaultDataset *string `json:"defaultDataset,omitempty"`
}

func (c CreateInputSystemByPackElasticsearchMetadata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackElasticsearchMetadata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackElasticsearchMetadata) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputSystemByPackElasticsearchMetadata) GetDefaultDataset() *string {
	if c == nil {
		return nil
	}
	return c.DefaultDataset
}

type CreateInputSystemByPackAuthTokensExt struct {
	Token       string  `json:"token"`
	Description *string `json:"description,omitempty"`
	// Fields to add to events referencing this token
	Metadata              []components.ItemsTypeNotificationMetadata    `json:"metadata,omitempty"`
	SplunkHecMetadata     *CreateInputSystemByPackSplunkHecMetadata     `json:"splunkHecMetadata,omitempty"`
	ElasticsearchMetadata *CreateInputSystemByPackElasticsearchMetadata `json:"elasticsearchMetadata,omitempty"`
}

func (c CreateInputSystemByPackAuthTokensExt) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackAuthTokensExt) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"token"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackAuthTokensExt) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CreateInputSystemByPackAuthTokensExt) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackAuthTokensExt) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackAuthTokensExt) GetSplunkHecMetadata() *CreateInputSystemByPackSplunkHecMetadata {
	if c == nil {
		return nil
	}
	return c.SplunkHecMetadata
}

func (c *CreateInputSystemByPackAuthTokensExt) GetElasticsearchMetadata() *CreateInputSystemByPackElasticsearchMetadata {
	if c == nil {
		return nil
	}
	return c.ElasticsearchMetadata
}

type CreateInputSystemByPackInputCriblLakeHTTP struct {
	// Unique ID for this input
	ID       string                                   `json:"id"`
	Type     CreateInputSystemByPackTypeCriblLakeHTTP `json:"type"`
	Disabled *bool                                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `json:"criblAPI,omitempty"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `json:"elasticAPI,omitempty"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `json:"splunkHecAPI,omitempty"`
	SplunkHecAcks *bool   `json:"splunkHecAcks,omitempty"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	AuthTokensExt []CreateInputSystemByPackAuthTokensExt     `json:"authTokensExt,omitempty"`
	Description   *string                                    `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime.
	TemplateSplunkHecAPI *string `json:"__template_splunkHecAPI,omitempty"`
}

func (c CreateInputSystemByPackInputCriblLakeHTTP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetType() CreateInputSystemByPackTypeCriblLakeHTTP {
	if c == nil {
		return CreateInputSystemByPackTypeCriblLakeHTTP("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetCriblAPI() *string {
	if c == nil {
		return nil
	}
	return c.CriblAPI
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetElasticAPI() *string {
	if c == nil {
		return nil
	}
	return c.ElasticAPI
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.SplunkHecAPI
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetSplunkHecAcks() *bool {
	if c == nil {
		return nil
	}
	return c.SplunkHecAcks
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetAuthTokensExt() []CreateInputSystemByPackAuthTokensExt {
	if c == nil {
		return nil
	}
	return c.AuthTokensExt
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputSystemByPackInputCriblLakeHTTP) GetTemplateSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplateSplunkHecAPI
}

type CreateInputSystemByPackTypeCriblHTTP string

const (
	CreateInputSystemByPackTypeCriblHTTPCriblHTTP CreateInputSystemByPackTypeCriblHTTP = "cribl_http"
)

func (e CreateInputSystemByPackTypeCriblHTTP) ToPointer() *CreateInputSystemByPackTypeCriblHTTP {
	return &e
}
func (e *CreateInputSystemByPackTypeCriblHTTP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_http":
		*e = CreateInputSystemByPackTypeCriblHTTP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeCriblHTTP: %v", v)
	}
}

type CreateInputSystemByPackInputCriblHTTP struct {
	// Unique ID for this input
	ID       string                               `json:"id"`
	Type     CreateInputSystemByPackTypeCriblHTTP `json:"type"`
	Disabled *bool                                `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
	AuthTokens []components.ItemsTypeAuthTokens      `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputCriblHTTP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputCriblHTTP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetType() CreateInputSystemByPackTypeCriblHTTP {
	if c == nil {
		return CreateInputSystemByPackTypeCriblHTTP("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputCriblHTTP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeCriblTCP string

const (
	CreateInputSystemByPackTypeCriblTCPCriblTCP CreateInputSystemByPackTypeCriblTCP = "cribl_tcp"
)

func (e CreateInputSystemByPackTypeCriblTCP) ToPointer() *CreateInputSystemByPackTypeCriblTCP {
	return &e
}
func (e *CreateInputSystemByPackTypeCriblTCP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_tcp":
		*e = CreateInputSystemByPackTypeCriblTCP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeCriblTCP: %v", v)
	}
}

type CreateInputSystemByPackInputCriblTCP struct {
	// Unique ID for this input
	ID       string                              `json:"id"`
	Type     CreateInputSystemByPackTypeCriblTCP `json:"type"`
	Disabled *bool                               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `json:"enableLoadBalancing,omitempty"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
	AuthTokens  []components.ItemsTypeAuthTokens `json:"authTokens,omitempty"`
	Description *string                          `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputCriblTCP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputCriblTCP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputCriblTCP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputCriblTCP) GetType() CreateInputSystemByPackTypeCriblTCP {
	if c == nil {
		return CreateInputSystemByPackTypeCriblTCP("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputCriblTCP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputCriblTCP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputCriblTCP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputCriblTCP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputCriblTCP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputCriblTCP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputCriblTCP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputCriblTCP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputCriblTCP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputCriblTCP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputCriblTCP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputCriblTCP) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputCriblTCP) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputSystemByPackInputCriblTCP) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputSystemByPackInputCriblTCP) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputSystemByPackInputCriblTCP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputCriblTCP) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputCriblTCP) GetEnableLoadBalancing() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoadBalancing
}

func (c *CreateInputSystemByPackInputCriblTCP) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputCriblTCP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputCriblTCP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputCriblTCP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeCribl string

const (
	CreateInputSystemByPackTypeCriblCribl CreateInputSystemByPackTypeCribl = "cribl"
)

func (e CreateInputSystemByPackTypeCribl) ToPointer() *CreateInputSystemByPackTypeCribl {
	return &e
}
func (e *CreateInputSystemByPackTypeCribl) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl":
		*e = CreateInputSystemByPackTypeCribl(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeCribl: %v", v)
	}
}

type CreateInputSystemByPackInputCribl struct {
	// Unique ID for this input
	ID       string                           `json:"id"`
	Type     CreateInputSystemByPackTypeCribl `json:"type"`
	Disabled *bool                            `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	Filter      *string                                   `json:"filter,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputCribl) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputCribl) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputCribl) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputCribl) GetType() CreateInputSystemByPackTypeCribl {
	if c == nil {
		return CreateInputSystemByPackTypeCribl("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputCribl) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputCribl) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputCribl) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputCribl) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputCribl) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputCribl) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputCribl) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputCribl) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputCribl) GetFilter() *string {
	if c == nil {
		return nil
	}
	return c.Filter
}

func (c *CreateInputSystemByPackInputCribl) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputCribl) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeGooglePubsub string

const (
	CreateInputSystemByPackTypeGooglePubsubGooglePubsub CreateInputSystemByPackTypeGooglePubsub = "google_pubsub"
)

func (e CreateInputSystemByPackTypeGooglePubsub) ToPointer() *CreateInputSystemByPackTypeGooglePubsub {
	return &e
}
func (e *CreateInputSystemByPackTypeGooglePubsub) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "google_pubsub":
		*e = CreateInputSystemByPackTypeGooglePubsub(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeGooglePubsub: %v", v)
	}
}

type CreateInputSystemByPackInputGooglePubsub struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackTypeGooglePubsub `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
	TopicName string `json:"topicName"`
	// ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
	SubscriptionName string `json:"subscriptionName"`
	// Use when the subscription is not created by this Source and topic is not known
	MonitorSubscription *bool `json:"monitorSubscription,omitempty"`
	// Create topic if it does not exist
	CreateTopic *bool `json:"createTopic,omitempty"`
	// Create subscription if it does not exist
	CreateSubscription *bool `json:"createSubscription,omitempty"`
	// Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
	Region *string `json:"region,omitempty"`
	// Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
	GoogleAuthMethod *components.GoogleAuthenticationMethodOptions `json:"googleAuthMethod,omitempty"`
	// Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`
	// Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`
	// If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
	MaxBacklog *float64 `json:"maxBacklog,omitempty"`
	// How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
	Concurrency *float64 `json:"concurrency,omitempty"`
	// Pull request timeout, in milliseconds
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
	OrderedDelivery *bool `json:"orderedDelivery,omitempty"`
	// Binds 'topicName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'topicName' at runtime.
	TemplateTopicName *string `json:"__template_topicName,omitempty"`
	// Binds 'subscriptionName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'subscriptionName' at runtime.
	TemplateSubscriptionName *string `json:"__template_subscriptionName,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
}

func (c CreateInputSystemByPackInputGooglePubsub) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputGooglePubsub) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "topicName", "subscriptionName"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetType() CreateInputSystemByPackTypeGooglePubsub {
	if c == nil {
		return CreateInputSystemByPackTypeGooglePubsub("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetTopicName() string {
	if c == nil {
		return ""
	}
	return c.TopicName
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetSubscriptionName() string {
	if c == nil {
		return ""
	}
	return c.SubscriptionName
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetMonitorSubscription() *bool {
	if c == nil {
		return nil
	}
	return c.MonitorSubscription
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetCreateTopic() *bool {
	if c == nil {
		return nil
	}
	return c.CreateTopic
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetCreateSubscription() *bool {
	if c == nil {
		return nil
	}
	return c.CreateSubscription
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetGoogleAuthMethod() *components.GoogleAuthenticationMethodOptions {
	if c == nil {
		return nil
	}
	return c.GoogleAuthMethod
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetServiceAccountCredentials() *string {
	if c == nil {
		return nil
	}
	return c.ServiceAccountCredentials
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetSecret() *string {
	if c == nil {
		return nil
	}
	return c.Secret
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetMaxBacklog() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBacklog
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetConcurrency() *float64 {
	if c == nil {
		return nil
	}
	return c.Concurrency
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetOrderedDelivery() *bool {
	if c == nil {
		return nil
	}
	return c.OrderedDelivery
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetTemplateTopicName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTopicName
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetTemplateSubscriptionName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateSubscriptionName
}

func (c *CreateInputSystemByPackInputGooglePubsub) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

type CreateInputSystemByPackTypeFirehose string

const (
	CreateInputSystemByPackTypeFirehoseFirehose CreateInputSystemByPackTypeFirehose = "firehose"
)

func (e CreateInputSystemByPackTypeFirehose) ToPointer() *CreateInputSystemByPackTypeFirehose {
	return &e
}
func (e *CreateInputSystemByPackTypeFirehose) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "firehose":
		*e = CreateInputSystemByPackTypeFirehose(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeFirehose: %v", v)
	}
}

type CreateInputSystemByPackInputFirehose struct {
	// Unique ID for this input
	ID       string                              `json:"id"`
	Type     CreateInputSystemByPackTypeFirehose `json:"type"`
	Disabled *bool                               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputFirehose) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputFirehose) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputFirehose) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputFirehose) GetType() CreateInputSystemByPackTypeFirehose {
	if c == nil {
		return CreateInputSystemByPackTypeFirehose("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputFirehose) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputFirehose) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputFirehose) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputFirehose) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputFirehose) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputFirehose) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputFirehose) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputFirehose) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputFirehose) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputFirehose) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputFirehose) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputFirehose) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputFirehose) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputFirehose) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputFirehose) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputFirehose) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputFirehose) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputFirehose) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputFirehose) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputFirehose) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputFirehose) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputFirehose) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputFirehose) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputFirehose) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputFirehose) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputFirehose) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputFirehose) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackInputExecType string

const (
	CreateInputSystemByPackInputExecTypeExec CreateInputSystemByPackInputExecType = "exec"
)

func (e CreateInputSystemByPackInputExecType) ToPointer() *CreateInputSystemByPackInputExecType {
	return &e
}
func (e *CreateInputSystemByPackInputExecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = CreateInputSystemByPackInputExecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackInputExecType: %v", v)
	}
}

// CreateInputSystemByPackScheduleType - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type CreateInputSystemByPackScheduleType string

const (
	CreateInputSystemByPackScheduleTypeInterval     CreateInputSystemByPackScheduleType = "interval"
	CreateInputSystemByPackScheduleTypeCronSchedule CreateInputSystemByPackScheduleType = "cronSchedule"
)

func (e CreateInputSystemByPackScheduleType) ToPointer() *CreateInputSystemByPackScheduleType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackScheduleType) IsExact() bool {
	if e != nil {
		switch *e {
		case "interval", "cronSchedule":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputExec struct {
	// Unique ID for this input
	ID       string                               `json:"id"`
	Type     CreateInputSystemByPackInputExecType `json:"type"`
	Disabled *bool                                `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `json:"retries,omitempty"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *CreateInputSystemByPackScheduleType `json:"scheduleType,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `json:"interval,omitempty"`
	// Cron schedule to execute the command on.
	CronSchedule *string `json:"cronSchedule,omitempty"`
}

func (c CreateInputSystemByPackInputExec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputExec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "command"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputExec) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputExec) GetType() CreateInputSystemByPackInputExecType {
	if c == nil {
		return CreateInputSystemByPackInputExecType("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputExec) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputExec) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputExec) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputExec) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputExec) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputExec) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputExec) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputExec) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputExec) GetCommand() string {
	if c == nil {
		return ""
	}
	return c.Command
}

func (c *CreateInputSystemByPackInputExec) GetRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.Retries
}

func (c *CreateInputSystemByPackInputExec) GetScheduleType() *CreateInputSystemByPackScheduleType {
	if c == nil {
		return nil
	}
	return c.ScheduleType
}

func (c *CreateInputSystemByPackInputExec) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputExec) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputExec) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputExec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputExec) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputExec) GetCronSchedule() *string {
	if c == nil {
		return nil
	}
	return c.CronSchedule
}

type CreateInputSystemByPackTypeEventhub string

const (
	CreateInputSystemByPackTypeEventhubEventhub CreateInputSystemByPackTypeEventhub = "eventhub"
)

func (e CreateInputSystemByPackTypeEventhub) ToPointer() *CreateInputSystemByPackTypeEventhub {
	return &e
}
func (e *CreateInputSystemByPackTypeEventhub) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eventhub":
		*e = CreateInputSystemByPackTypeEventhub(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeEventhub: %v", v)
	}
}

type CreateInputSystemByPackInputEventhub struct {
	// Unique ID for this input
	ID       string                              `json:"id"`
	Type     CreateInputSystemByPackTypeEventhub `json:"type"`
	Disabled *bool                               `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
	Brokers []string `json:"brokers"`
	// The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
	Topics []string `json:"topics"`
	// The consumer group this instance belongs to. Default is 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	// Start reading from earliest available data; relevant only during initial subscription
	FromBeginning *bool `json:"fromBeginning,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `json:"maxRetries,omitempty"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `json:"maxBackOff,omitempty"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `json:"initialBackoff,omitempty"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `json:"backoffRate,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `json:"authenticationTimeout,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `json:"reauthenticationThreshold,omitempty"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType1       `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideType `json:"tls,omitempty"`
	//       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
	//       Value must be lower than rebalanceTimeout.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	SessionTimeout *float64 `json:"sessionTimeout,omitempty"`
	//       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	RebalanceTimeout *float64 `json:"rebalanceTimeout,omitempty"`
	//       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	HeartbeatInterval *float64 `json:"heartbeatInterval,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `json:"maxBytesPerPartition,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `json:"maxBytes,omitempty"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `json:"maxSocketErrors,omitempty"`
	// Minimize duplicate events by starting only one consumer for each topic partition
	MinimizeDuplicates *bool `json:"minimizeDuplicates,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputEventhub) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputEventhub) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputEventhub) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputEventhub) GetType() CreateInputSystemByPackTypeEventhub {
	if c == nil {
		return CreateInputSystemByPackTypeEventhub("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputEventhub) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputEventhub) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputEventhub) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputEventhub) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputEventhub) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputEventhub) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputEventhub) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputEventhub) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputEventhub) GetBrokers() []string {
	if c == nil {
		return []string{}
	}
	return c.Brokers
}

func (c *CreateInputSystemByPackInputEventhub) GetTopics() []string {
	if c == nil {
		return []string{}
	}
	return c.Topics
}

func (c *CreateInputSystemByPackInputEventhub) GetGroupID() *string {
	if c == nil {
		return nil
	}
	return c.GroupID
}

func (c *CreateInputSystemByPackInputEventhub) GetFromBeginning() *bool {
	if c == nil {
		return nil
	}
	return c.FromBeginning
}

func (c *CreateInputSystemByPackInputEventhub) GetConnectionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ConnectionTimeout
}

func (c *CreateInputSystemByPackInputEventhub) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputEventhub) GetMaxRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRetries
}

func (c *CreateInputSystemByPackInputEventhub) GetMaxBackOff() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBackOff
}

func (c *CreateInputSystemByPackInputEventhub) GetInitialBackoff() *float64 {
	if c == nil {
		return nil
	}
	return c.InitialBackoff
}

func (c *CreateInputSystemByPackInputEventhub) GetBackoffRate() *float64 {
	if c == nil {
		return nil
	}
	return c.BackoffRate
}

func (c *CreateInputSystemByPackInputEventhub) GetAuthenticationTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.AuthenticationTimeout
}

func (c *CreateInputSystemByPackInputEventhub) GetReauthenticationThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.ReauthenticationThreshold
}

func (c *CreateInputSystemByPackInputEventhub) GetSasl() *components.AuthenticationType1 {
	if c == nil {
		return nil
	}
	return c.Sasl
}

func (c *CreateInputSystemByPackInputEventhub) GetTLS() *components.TLSSettingsClientSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputEventhub) GetSessionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SessionTimeout
}

func (c *CreateInputSystemByPackInputEventhub) GetRebalanceTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RebalanceTimeout
}

func (c *CreateInputSystemByPackInputEventhub) GetHeartbeatInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.HeartbeatInterval
}

func (c *CreateInputSystemByPackInputEventhub) GetAutoCommitInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitInterval
}

func (c *CreateInputSystemByPackInputEventhub) GetAutoCommitThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitThreshold
}

func (c *CreateInputSystemByPackInputEventhub) GetMaxBytesPerPartition() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytesPerPartition
}

func (c *CreateInputSystemByPackInputEventhub) GetMaxBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytes
}

func (c *CreateInputSystemByPackInputEventhub) GetMaxSocketErrors() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxSocketErrors
}

func (c *CreateInputSystemByPackInputEventhub) GetMinimizeDuplicates() *bool {
	if c == nil {
		return nil
	}
	return c.MinimizeDuplicates
}

func (c *CreateInputSystemByPackInputEventhub) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputEventhub) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeOffice365MsgTrace string

const (
	CreateInputSystemByPackTypeOffice365MsgTraceOffice365MsgTrace CreateInputSystemByPackTypeOffice365MsgTrace = "office365_msg_trace"
)

func (e CreateInputSystemByPackTypeOffice365MsgTrace) ToPointer() *CreateInputSystemByPackTypeOffice365MsgTrace {
	return &e
}
func (e *CreateInputSystemByPackTypeOffice365MsgTrace) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_msg_trace":
		*e = CreateInputSystemByPackTypeOffice365MsgTrace(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeOffice365MsgTrace: %v", v)
	}
}

// CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace - Select authentication method.
type CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace string

const (
	CreateInputSystemByPackAuthenticationMethodOffice365MsgTraceManual      CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace = "manual"
	CreateInputSystemByPackAuthenticationMethodOffice365MsgTraceSecret      CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace = "secret"
	CreateInputSystemByPackAuthenticationMethodOffice365MsgTraceOauth       CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace = "oauth"
	CreateInputSystemByPackAuthenticationMethodOffice365MsgTraceOauthSecret CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace = "oauthSecret"
	CreateInputSystemByPackAuthenticationMethodOffice365MsgTraceOauthCert   CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace = "oauthCert"
)

func (e CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace) ToPointer() *CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "oauth", "oauthSecret", "oauthCert":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackLogLevelOffice365MsgTrace - Log Level (verbosity) for collection runtime behavior.
type CreateInputSystemByPackLogLevelOffice365MsgTrace string

const (
	CreateInputSystemByPackLogLevelOffice365MsgTraceError CreateInputSystemByPackLogLevelOffice365MsgTrace = "error"
	CreateInputSystemByPackLogLevelOffice365MsgTraceWarn  CreateInputSystemByPackLogLevelOffice365MsgTrace = "warn"
	CreateInputSystemByPackLogLevelOffice365MsgTraceInfo  CreateInputSystemByPackLogLevelOffice365MsgTrace = "info"
	CreateInputSystemByPackLogLevelOffice365MsgTraceDebug CreateInputSystemByPackLogLevelOffice365MsgTrace = "debug"
	CreateInputSystemByPackLogLevelOffice365MsgTraceSilly CreateInputSystemByPackLogLevelOffice365MsgTrace = "silly"
)

func (e CreateInputSystemByPackLogLevelOffice365MsgTrace) ToPointer() *CreateInputSystemByPackLogLevelOffice365MsgTrace {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackLogLevelOffice365MsgTrace) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug", "silly":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackCertOptions struct {
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	// Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
	PrivKeyPath string `json:"privKeyPath"`
	// Passphrase to use to decrypt the private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
	CertPath string `json:"certPath"`
}

func (c CreateInputSystemByPackCertOptions) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackCertOptions) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"privKeyPath", "certPath"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackCertOptions) GetCertificateName() *string {
	if c == nil {
		return nil
	}
	return c.CertificateName
}

func (c *CreateInputSystemByPackCertOptions) GetPrivKeyPath() string {
	if c == nil {
		return ""
	}
	return c.PrivKeyPath
}

func (c *CreateInputSystemByPackCertOptions) GetPassphrase() *string {
	if c == nil {
		return nil
	}
	return c.Passphrase
}

func (c *CreateInputSystemByPackCertOptions) GetCertPath() string {
	if c == nil {
		return ""
	}
	return c.CertPath
}

type CreateInputSystemByPackInputOffice365MsgTrace struct {
	// Unique ID for this input
	ID       string                                       `json:"id"`
	Type     CreateInputSystemByPackTypeOffice365MsgTrace `json:"type"`
	Disabled *bool                                        `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// URL to use when retrieving report data.
	URL string `json:"url"`
	// How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
	Interval float64 `json:"interval"`
	// Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
	StartDate *string `json:"startDate,omitempty"`
	// Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
	EndDate *string `json:"endDate,omitempty"`
	// HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
	Timeout *float64 `json:"timeout,omitempty"`
	// Disables time filtering of events when a date range is specified.
	DisableTimeFilter *bool `json:"disableTimeFilter,omitempty"`
	// Select authentication method.
	AuthType *CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace `json:"authType,omitempty"`
	// Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `json:"rescheduleDroppedTasks,omitempty"`
	// Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float64 `json:"maxTaskReschedule,omitempty"`
	// Log Level (verbosity) for collection runtime behavior.
	LogLevel *CreateInputSystemByPackLogLevelOffice365MsgTrace `json:"logLevel,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules  *components.RetryRulesType1                `json:"retryRules,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Username to run Message Trace API call.
	Username *string `json:"username,omitempty"`
	// Password to run Message Trace API call.
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials.
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// client_secret to pass in the OAuth request parameter.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Directory ID (tenant identifier) in Azure Active Directory.
	TenantID *string `json:"tenantId,omitempty"`
	// client_id to pass in the OAuth request parameter.
	ClientID *string `json:"clientId,omitempty"`
	// Resource to pass in the OAuth request parameter.
	Resource *string `json:"resource,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `json:"planType,omitempty"`
	// Select or create a secret that references your client_secret to pass in the OAuth request parameter.
	TextSecret  *string                             `json:"textSecret,omitempty"`
	CertOptions *CreateInputSystemByPackCertOptions `json:"certOptions,omitempty"`
	// Binds 'url' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'url' at runtime.
	TemplateURL *string `json:"__template_url,omitempty"`
	// Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime.
	TemplateTenantID *string `json:"__template_tenantId,omitempty"`
	// Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime.
	TemplateClientID *string `json:"__template_clientId,omitempty"`
	// Binds 'resource' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'resource' at runtime.
	TemplateResource *string `json:"__template_resource,omitempty"`
}

func (c CreateInputSystemByPackInputOffice365MsgTrace) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "url", "interval"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetType() CreateInputSystemByPackTypeOffice365MsgTrace {
	if c == nil {
		return CreateInputSystemByPackTypeOffice365MsgTrace("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetURL() string {
	if c == nil {
		return ""
	}
	return c.URL
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetInterval() float64 {
	if c == nil {
		return 0.0
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetStartDate() *string {
	if c == nil {
		return nil
	}
	return c.StartDate
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetEndDate() *string {
	if c == nil {
		return nil
	}
	return c.EndDate
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetDisableTimeFilter() *bool {
	if c == nil {
		return nil
	}
	return c.DisableTimeFilter
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetAuthType() *CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetRescheduleDroppedTasks() *bool {
	if c == nil {
		return nil
	}
	return c.RescheduleDroppedTasks
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetMaxTaskReschedule() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxTaskReschedule
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetLogLevel() *CreateInputSystemByPackLogLevelOffice365MsgTrace {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetRetryRules() *components.RetryRulesType1 {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TenantID
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetClientID() *string {
	if c == nil {
		return nil
	}
	return c.ClientID
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetResource() *string {
	if c == nil {
		return nil
	}
	return c.Resource
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetPlanType() *components.SubscriptionPlanOptions {
	if c == nil {
		return nil
	}
	return c.PlanType
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetCertOptions() *CreateInputSystemByPackCertOptions {
	if c == nil {
		return nil
	}
	return c.CertOptions
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetTemplateURL() *string {
	if c == nil {
		return nil
	}
	return c.TemplateURL
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetTemplateTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTenantID
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetTemplateClientID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientID
}

func (c *CreateInputSystemByPackInputOffice365MsgTrace) GetTemplateResource() *string {
	if c == nil {
		return nil
	}
	return c.TemplateResource
}

type CreateInputSystemByPackTypeOffice365Service string

const (
	CreateInputSystemByPackTypeOffice365ServiceOffice365Service CreateInputSystemByPackTypeOffice365Service = "office365_service"
)

func (e CreateInputSystemByPackTypeOffice365Service) ToPointer() *CreateInputSystemByPackTypeOffice365Service {
	return &e
}
func (e *CreateInputSystemByPackTypeOffice365Service) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_service":
		*e = CreateInputSystemByPackTypeOffice365Service(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeOffice365Service: %v", v)
	}
}

type CreateInputSystemByPackContentConfigOffice365Service struct {
	// Office 365 Services API Content Type
	ContentType *string `json:"contentType,omitempty"`
	// If interval type is minutes the value entered must evenly divisible by 60 or save will fail
	Description *string  `json:"description,omitempty"`
	Interval    *float64 `json:"interval,omitempty"`
	// Collector runtime Log Level
	LogLevel *components.LogLevelOptionsContentConfigItems `json:"logLevel,omitempty"`
	Enabled  *bool                                         `json:"enabled,omitempty"`
}

func (c CreateInputSystemByPackContentConfigOffice365Service) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackContentConfigOffice365Service) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackContentConfigOffice365Service) GetContentType() *string {
	if c == nil {
		return nil
	}
	return c.ContentType
}

func (c *CreateInputSystemByPackContentConfigOffice365Service) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackContentConfigOffice365Service) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackContentConfigOffice365Service) GetLogLevel() *components.LogLevelOptionsContentConfigItems {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputSystemByPackContentConfigOffice365Service) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

type CreateInputSystemByPackInputOffice365Service struct {
	// Unique ID for this input
	ID       string                                      `json:"id"`
	Type     CreateInputSystemByPackTypeOffice365Service `json:"type"`
	Disabled *bool                                       `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `json:"planType,omitempty"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `json:"timeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []CreateInputSystemByPackContentConfigOffice365Service `json:"contentConfig,omitempty"`
	RetryRules    *components.RetryRulesType1                            `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `json:"authType,omitempty"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime.
	TemplateTenantID *string `json:"__template_tenantId,omitempty"`
	// Binds 'appId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'appId' at runtime.
	TemplateAppID *string `json:"__template_appId,omitempty"`
	// Binds 'clientSecret' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientSecret' at runtime.
	TemplateClientSecret *string `json:"__template_clientSecret,omitempty"`
}

func (c CreateInputSystemByPackInputOffice365Service) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputOffice365Service) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputOffice365Service) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputOffice365Service) GetType() CreateInputSystemByPackTypeOffice365Service {
	if c == nil {
		return CreateInputSystemByPackTypeOffice365Service("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputOffice365Service) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputOffice365Service) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputOffice365Service) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputOffice365Service) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputOffice365Service) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputOffice365Service) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputOffice365Service) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputOffice365Service) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputOffice365Service) GetPlanType() *components.SubscriptionPlanOptions {
	if c == nil {
		return nil
	}
	return c.PlanType
}

func (c *CreateInputSystemByPackInputOffice365Service) GetTenantID() string {
	if c == nil {
		return ""
	}
	return c.TenantID
}

func (c *CreateInputSystemByPackInputOffice365Service) GetAppID() string {
	if c == nil {
		return ""
	}
	return c.AppID
}

func (c *CreateInputSystemByPackInputOffice365Service) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputSystemByPackInputOffice365Service) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputSystemByPackInputOffice365Service) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputSystemByPackInputOffice365Service) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputSystemByPackInputOffice365Service) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputSystemByPackInputOffice365Service) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputSystemByPackInputOffice365Service) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputOffice365Service) GetContentConfig() []CreateInputSystemByPackContentConfigOffice365Service {
	if c == nil {
		return nil
	}
	return c.ContentConfig
}

func (c *CreateInputSystemByPackInputOffice365Service) GetRetryRules() *components.RetryRulesType1 {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputSystemByPackInputOffice365Service) GetAuthType() *components.AuthenticationMethodOptions1 {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputOffice365Service) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputOffice365Service) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateInputSystemByPackInputOffice365Service) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputOffice365Service) GetTemplateTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTenantID
}

func (c *CreateInputSystemByPackInputOffice365Service) GetTemplateAppID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAppID
}

func (c *CreateInputSystemByPackInputOffice365Service) GetTemplateClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientSecret
}

type CreateInputSystemByPackTypeOffice365Mgmt string

const (
	CreateInputSystemByPackTypeOffice365MgmtOffice365Mgmt CreateInputSystemByPackTypeOffice365Mgmt = "office365_mgmt"
)

func (e CreateInputSystemByPackTypeOffice365Mgmt) ToPointer() *CreateInputSystemByPackTypeOffice365Mgmt {
	return &e
}
func (e *CreateInputSystemByPackTypeOffice365Mgmt) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_mgmt":
		*e = CreateInputSystemByPackTypeOffice365Mgmt(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeOffice365Mgmt: %v", v)
	}
}

type CreateInputSystemByPackContentConfigOffice365Mgmt struct {
	// Office 365 Management Activity API Content Type
	ContentType *string `json:"contentType,omitempty"`
	// If interval type is minutes the value entered must evenly divisible by 60 or save will fail
	Description *string  `json:"description,omitempty"`
	Interval    *float64 `json:"interval,omitempty"`
	// Collector runtime Log Level
	LogLevel *components.LogLevelOptionsContentConfigItems `json:"logLevel,omitempty"`
	Enabled  *bool                                         `json:"enabled,omitempty"`
}

func (c CreateInputSystemByPackContentConfigOffice365Mgmt) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackContentConfigOffice365Mgmt) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackContentConfigOffice365Mgmt) GetContentType() *string {
	if c == nil {
		return nil
	}
	return c.ContentType
}

func (c *CreateInputSystemByPackContentConfigOffice365Mgmt) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackContentConfigOffice365Mgmt) GetInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.Interval
}

func (c *CreateInputSystemByPackContentConfigOffice365Mgmt) GetLogLevel() *components.LogLevelOptionsContentConfigItems {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputSystemByPackContentConfigOffice365Mgmt) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

type CreateInputSystemByPackInputOffice365Mgmt struct {
	// Unique ID for this input
	ID       string                                   `json:"id"`
	Type     CreateInputSystemByPackTypeOffice365Mgmt `json:"type"`
	Disabled *bool                                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType components.SubscriptionPlanOptions `json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `json:"timeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
	PublisherIdentifier *string `json:"publisherIdentifier,omitempty"`
	// Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []CreateInputSystemByPackContentConfigOffice365Mgmt `json:"contentConfig,omitempty"`
	// Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
	IngestionLag *float64                    `json:"ingestionLag,omitempty"`
	RetryRules   *components.RetryRulesType1 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `json:"authType,omitempty"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime.
	TemplateTenantID *string `json:"__template_tenantId,omitempty"`
	// Binds 'appId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'appId' at runtime.
	TemplateAppID *string `json:"__template_appId,omitempty"`
	// Binds 'publisherIdentifier' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'publisherIdentifier' at runtime.
	TemplatePublisherIdentifier *string `json:"__template_publisherIdentifier,omitempty"`
	// Binds 'clientSecret' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientSecret' at runtime.
	TemplateClientSecret *string `json:"__template_clientSecret,omitempty"`
}

func (c CreateInputSystemByPackInputOffice365Mgmt) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "planType", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetType() CreateInputSystemByPackTypeOffice365Mgmt {
	if c == nil {
		return CreateInputSystemByPackTypeOffice365Mgmt("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetPlanType() components.SubscriptionPlanOptions {
	if c == nil {
		return components.SubscriptionPlanOptions("")
	}
	return c.PlanType
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetTenantID() string {
	if c == nil {
		return ""
	}
	return c.TenantID
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetAppID() string {
	if c == nil {
		return ""
	}
	return c.AppID
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetPublisherIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.PublisherIdentifier
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetContentConfig() []CreateInputSystemByPackContentConfigOffice365Mgmt {
	if c == nil {
		return nil
	}
	return c.ContentConfig
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetIngestionLag() *float64 {
	if c == nil {
		return nil
	}
	return c.IngestionLag
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetRetryRules() *components.RetryRulesType1 {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetAuthType() *components.AuthenticationMethodOptions1 {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientSecret
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetTemplateTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTenantID
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetTemplateAppID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAppID
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetTemplatePublisherIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePublisherIdentifier
}

func (c *CreateInputSystemByPackInputOffice365Mgmt) GetTemplateClientSecret() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientSecret
}

type CreateInputSystemByPackTypeEdgePrometheus string

const (
	CreateInputSystemByPackTypeEdgePrometheusEdgePrometheus CreateInputSystemByPackTypeEdgePrometheus = "edge_prometheus"
)

func (e CreateInputSystemByPackTypeEdgePrometheus) ToPointer() *CreateInputSystemByPackTypeEdgePrometheus {
	return &e
}
func (e *CreateInputSystemByPackTypeEdgePrometheus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "edge_prometheus":
		*e = CreateInputSystemByPackTypeEdgePrometheus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeEdgePrometheus: %v", v)
	}
}

// CreateInputSystemByPackDiscoveryTypeEdgePrometheus - Target discovery mechanism. Use static to manually enter a list of targets.
type CreateInputSystemByPackDiscoveryTypeEdgePrometheus string

const (
	// CreateInputSystemByPackDiscoveryTypeEdgePrometheusStatic Static
	CreateInputSystemByPackDiscoveryTypeEdgePrometheusStatic CreateInputSystemByPackDiscoveryTypeEdgePrometheus = "static"
	// CreateInputSystemByPackDiscoveryTypeEdgePrometheusDNS DNS
	CreateInputSystemByPackDiscoveryTypeEdgePrometheusDNS CreateInputSystemByPackDiscoveryTypeEdgePrometheus = "dns"
	// CreateInputSystemByPackDiscoveryTypeEdgePrometheusEc2 AWS EC2
	CreateInputSystemByPackDiscoveryTypeEdgePrometheusEc2 CreateInputSystemByPackDiscoveryTypeEdgePrometheus = "ec2"
	// CreateInputSystemByPackDiscoveryTypeEdgePrometheusK8sNode Kubernetes Node
	CreateInputSystemByPackDiscoveryTypeEdgePrometheusK8sNode CreateInputSystemByPackDiscoveryTypeEdgePrometheus = "k8s-node"
	// CreateInputSystemByPackDiscoveryTypeEdgePrometheusK8sPods Kubernetes Pods
	CreateInputSystemByPackDiscoveryTypeEdgePrometheusK8sPods CreateInputSystemByPackDiscoveryTypeEdgePrometheus = "k8s-pods"
)

func (e CreateInputSystemByPackDiscoveryTypeEdgePrometheus) ToPointer() *CreateInputSystemByPackDiscoveryTypeEdgePrometheus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackDiscoveryTypeEdgePrometheus) IsExact() bool {
	if e != nil {
		switch *e {
		case "static", "dns", "ec2", "k8s-node", "k8s-pods":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackAuthenticationMethodEdgePrometheus - Enter credentials directly, or select a stored secret
type CreateInputSystemByPackAuthenticationMethodEdgePrometheus string

const (
	CreateInputSystemByPackAuthenticationMethodEdgePrometheusManual     CreateInputSystemByPackAuthenticationMethodEdgePrometheus = "manual"
	CreateInputSystemByPackAuthenticationMethodEdgePrometheusSecret     CreateInputSystemByPackAuthenticationMethodEdgePrometheus = "secret"
	CreateInputSystemByPackAuthenticationMethodEdgePrometheusKubernetes CreateInputSystemByPackAuthenticationMethodEdgePrometheus = "kubernetes"
)

func (e CreateInputSystemByPackAuthenticationMethodEdgePrometheus) ToPointer() *CreateInputSystemByPackAuthenticationMethodEdgePrometheus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackAuthenticationMethodEdgePrometheus) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "kubernetes":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackTarget struct {
	// Protocol to use when collecting metrics
	Protocol *components.ProtocolOptionsTargetsItems `json:"protocol,omitempty"`
	// Name of host from which to pull metrics.
	Host string `json:"host"`
	// The port number in the metrics URL for discovered targets.
	Port *float64 `json:"port,omitempty"`
	// Path to use when collecting metrics from discovered targets
	Path *string `json:"path,omitempty"`
}

func (c CreateInputSystemByPackTarget) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackTarget) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"host"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackTarget) GetProtocol() *components.ProtocolOptionsTargetsItems {
	if c == nil {
		return nil
	}
	return c.Protocol
}

func (c *CreateInputSystemByPackTarget) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackTarget) GetPort() *float64 {
	if c == nil {
		return nil
	}
	return c.Port
}

func (c *CreateInputSystemByPackTarget) GetPath() *string {
	if c == nil {
		return nil
	}
	return c.Path
}

type CreateInputSystemByPackPodFilter struct {
	// JavaScript expression applied to pods objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (c CreateInputSystemByPackPodFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackPodFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackPodFilter) GetFilter() string {
	if c == nil {
		return ""
	}
	return c.Filter
}

func (c *CreateInputSystemByPackPodFilter) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackInputEdgePrometheus struct {
	// Unique ID for this input
	ID       string                                    `json:"id"`
	Type     CreateInputSystemByPackTypeEdgePrometheus `json:"type"`
	Disabled *bool                                     `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType CreateInputSystemByPackDiscoveryTypeEdgePrometheus `json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval float64 `json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64                     `json:"timeout,omitempty"`
	Persistence *components.DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *CreateInputSystemByPackAuthenticationMethodEdgePrometheus `json:"authType,omitempty"`
	Description *string                                                    `json:"description,omitempty"`
	Targets     []CreateInputSystemByPackTarget                            `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `json:"recordType,omitempty"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `json:"scrapePort,omitempty"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *components.ProtocolOptionsTargetsItems `json:"scrapeProtocol,omitempty"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `json:"scrapePath,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `json:"usePublicIp,omitempty"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `json:"scrapeProtocolExpr,omitempty"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `json:"scrapePortExpr,omitempty"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `json:"scrapePathExpr,omitempty"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []CreateInputSystemByPackPodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
}

func (c CreateInputSystemByPackInputEdgePrometheus) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputEdgePrometheus) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "discoveryType", "interval"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetType() CreateInputSystemByPackTypeEdgePrometheus {
	if c == nil {
		return CreateInputSystemByPackTypeEdgePrometheus("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetDimensionList() []string {
	if c == nil {
		return nil
	}
	return c.DimensionList
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetDiscoveryType() CreateInputSystemByPackDiscoveryTypeEdgePrometheus {
	if c == nil {
		return CreateInputSystemByPackDiscoveryTypeEdgePrometheus("")
	}
	return c.DiscoveryType
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetInterval() float64 {
	if c == nil {
		return 0.0
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetPersistence() *components.DiskSpoolingType {
	if c == nil {
		return nil
	}
	return c.Persistence
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetAuthType() *CreateInputSystemByPackAuthenticationMethodEdgePrometheus {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetTargets() []CreateInputSystemByPackTarget {
	if c == nil {
		return nil
	}
	return c.Targets
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetRecordType() *components.RecordTypeOptions {
	if c == nil {
		return nil
	}
	return c.RecordType
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetScrapePort() *float64 {
	if c == nil {
		return nil
	}
	return c.ScrapePort
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetNameList() []string {
	if c == nil {
		return nil
	}
	return c.NameList
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetScrapeProtocol() *components.ProtocolOptionsTargetsItems {
	if c == nil {
		return nil
	}
	return c.ScrapeProtocol
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetScrapePath() *string {
	if c == nil {
		return nil
	}
	return c.ScrapePath
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetUsePublicIP() *bool {
	if c == nil {
		return nil
	}
	return c.UsePublicIP
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if c == nil {
		return nil
	}
	return c.SearchFilter
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetScrapeProtocolExpr() *string {
	if c == nil {
		return nil
	}
	return c.ScrapeProtocolExpr
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetScrapePortExpr() *string {
	if c == nil {
		return nil
	}
	return c.ScrapePortExpr
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetScrapePathExpr() *string {
	if c == nil {
		return nil
	}
	return c.ScrapePathExpr
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetPodFilter() []CreateInputSystemByPackPodFilter {
	if c == nil {
		return nil
	}
	return c.PodFilter
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputEdgePrometheus) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

type CreateInputSystemByPackTypePrometheus string

const (
	CreateInputSystemByPackTypePrometheusPrometheus CreateInputSystemByPackTypePrometheus = "prometheus"
)

func (e CreateInputSystemByPackTypePrometheus) ToPointer() *CreateInputSystemByPackTypePrometheus {
	return &e
}
func (e *CreateInputSystemByPackTypePrometheus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prometheus":
		*e = CreateInputSystemByPackTypePrometheus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypePrometheus: %v", v)
	}
}

// CreateInputSystemByPackDiscoveryTypePrometheus - Target discovery mechanism. Use static to manually enter a list of targets.
type CreateInputSystemByPackDiscoveryTypePrometheus string

const (
	// CreateInputSystemByPackDiscoveryTypePrometheusStatic Static
	CreateInputSystemByPackDiscoveryTypePrometheusStatic CreateInputSystemByPackDiscoveryTypePrometheus = "static"
	// CreateInputSystemByPackDiscoveryTypePrometheusDNS DNS
	CreateInputSystemByPackDiscoveryTypePrometheusDNS CreateInputSystemByPackDiscoveryTypePrometheus = "dns"
	// CreateInputSystemByPackDiscoveryTypePrometheusEc2 AWS EC2
	CreateInputSystemByPackDiscoveryTypePrometheusEc2 CreateInputSystemByPackDiscoveryTypePrometheus = "ec2"
)

func (e CreateInputSystemByPackDiscoveryTypePrometheus) ToPointer() *CreateInputSystemByPackDiscoveryTypePrometheus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackDiscoveryTypePrometheus) IsExact() bool {
	if e != nil {
		switch *e {
		case "static", "dns", "ec2":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackLogLevelPrometheus - Collector runtime log level
type CreateInputSystemByPackLogLevelPrometheus string

const (
	CreateInputSystemByPackLogLevelPrometheusError CreateInputSystemByPackLogLevelPrometheus = "error"
	CreateInputSystemByPackLogLevelPrometheusWarn  CreateInputSystemByPackLogLevelPrometheus = "warn"
	CreateInputSystemByPackLogLevelPrometheusInfo  CreateInputSystemByPackLogLevelPrometheus = "info"
	CreateInputSystemByPackLogLevelPrometheusDebug CreateInputSystemByPackLogLevelPrometheus = "debug"
)

func (e CreateInputSystemByPackLogLevelPrometheus) ToPointer() *CreateInputSystemByPackLogLevelPrometheus {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackLogLevelPrometheus) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackMetricsProtocol - Protocol to use when collecting metrics
type CreateInputSystemByPackMetricsProtocol string

const (
	CreateInputSystemByPackMetricsProtocolHTTP  CreateInputSystemByPackMetricsProtocol = "http"
	CreateInputSystemByPackMetricsProtocolHTTPS CreateInputSystemByPackMetricsProtocol = "https"
)

func (e CreateInputSystemByPackMetricsProtocol) ToPointer() *CreateInputSystemByPackMetricsProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackMetricsProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "http", "https":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputPrometheus struct {
	// Unique ID for this input
	ID       string                                `json:"id"`
	Type     CreateInputSystemByPackTypePrometheus `json:"type"`
	Disabled *bool                                 `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *CreateInputSystemByPackDiscoveryTypePrometheus `json:"discoveryType,omitempty"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval float64 `json:"interval"`
	// Collector runtime log level
	LogLevel CreateInputSystemByPackLogLevelPrometheus `json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `json:"timeout,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptionsSasl `json:"authType,omitempty"`
	Description *string                                     `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `json:"recordType,omitempty"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `json:"scrapePort,omitempty"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *CreateInputSystemByPackMetricsProtocol `json:"scrapeProtocol,omitempty"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `json:"scrapePath,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod,omitempty"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `json:"usePublicIp,omitempty"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `json:"durationSeconds,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Binds 'logLevel' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'logLevel' at runtime.
	TemplateLogLevel *string `json:"__template_logLevel,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
}

func (c CreateInputSystemByPackInputPrometheus) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputPrometheus) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "interval", "logLevel"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputPrometheus) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputPrometheus) GetType() CreateInputSystemByPackTypePrometheus {
	if c == nil {
		return CreateInputSystemByPackTypePrometheus("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputPrometheus) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputPrometheus) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputPrometheus) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputPrometheus) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputPrometheus) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputPrometheus) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputPrometheus) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputPrometheus) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputPrometheus) GetDimensionList() []string {
	if c == nil {
		return nil
	}
	return c.DimensionList
}

func (c *CreateInputSystemByPackInputPrometheus) GetDiscoveryType() *CreateInputSystemByPackDiscoveryTypePrometheus {
	if c == nil {
		return nil
	}
	return c.DiscoveryType
}

func (c *CreateInputSystemByPackInputPrometheus) GetInterval() float64 {
	if c == nil {
		return 0.0
	}
	return c.Interval
}

func (c *CreateInputSystemByPackInputPrometheus) GetLogLevel() CreateInputSystemByPackLogLevelPrometheus {
	if c == nil {
		return CreateInputSystemByPackLogLevelPrometheus("")
	}
	return c.LogLevel
}

func (c *CreateInputSystemByPackInputPrometheus) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputPrometheus) GetTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateInputSystemByPackInputPrometheus) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputSystemByPackInputPrometheus) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputSystemByPackInputPrometheus) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputSystemByPackInputPrometheus) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputSystemByPackInputPrometheus) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputSystemByPackInputPrometheus) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputPrometheus) GetAuthType() *components.AuthenticationMethodOptionsSasl {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputPrometheus) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputPrometheus) GetTargetList() []string {
	if c == nil {
		return nil
	}
	return c.TargetList
}

func (c *CreateInputSystemByPackInputPrometheus) GetRecordType() *components.RecordTypeOptions {
	if c == nil {
		return nil
	}
	return c.RecordType
}

func (c *CreateInputSystemByPackInputPrometheus) GetScrapePort() *float64 {
	if c == nil {
		return nil
	}
	return c.ScrapePort
}

func (c *CreateInputSystemByPackInputPrometheus) GetNameList() []string {
	if c == nil {
		return nil
	}
	return c.NameList
}

func (c *CreateInputSystemByPackInputPrometheus) GetScrapeProtocol() *CreateInputSystemByPackMetricsProtocol {
	if c == nil {
		return nil
	}
	return c.ScrapeProtocol
}

func (c *CreateInputSystemByPackInputPrometheus) GetScrapePath() *string {
	if c == nil {
		return nil
	}
	return c.ScrapePath
}

func (c *CreateInputSystemByPackInputPrometheus) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return nil
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputPrometheus) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputPrometheus) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputPrometheus) GetUsePublicIP() *bool {
	if c == nil {
		return nil
	}
	return c.UsePublicIP
}

func (c *CreateInputSystemByPackInputPrometheus) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if c == nil {
		return nil
	}
	return c.SearchFilter
}

func (c *CreateInputSystemByPackInputPrometheus) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputPrometheus) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputPrometheus) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputPrometheus) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputPrometheus) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputPrometheus) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputPrometheus) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputPrometheus) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputPrometheus) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputPrometheus) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackInputPrometheus) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackInputPrometheus) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackInputPrometheus) GetTemplateLogLevel() *string {
	if c == nil {
		return nil
	}
	return c.TemplateLogLevel
}

func (c *CreateInputSystemByPackInputPrometheus) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

func (c *CreateInputSystemByPackInputPrometheus) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputPrometheus) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputPrometheus) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputPrometheus) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

type CreateInputSystemByPackTypePrometheusRw string

const (
	CreateInputSystemByPackTypePrometheusRwPrometheusRw CreateInputSystemByPackTypePrometheusRw = "prometheus_rw"
)

func (e CreateInputSystemByPackTypePrometheusRw) ToPointer() *CreateInputSystemByPackTypePrometheusRw {
	return &e
}
func (e *CreateInputSystemByPackTypePrometheusRw) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prometheus_rw":
		*e = CreateInputSystemByPackTypePrometheusRw(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypePrometheusRw: %v", v)
	}
}

type CreateInputSystemByPackInputPrometheusRw struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackTypePrometheusRw `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
	PrometheusAPI string `json:"prometheusAPI"`
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `json:"authType,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'prometheusAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'prometheusAPI' at runtime.
	TemplatePrometheusAPI *string `json:"__template_prometheusAPI,omitempty"`
}

func (c CreateInputSystemByPackInputPrometheusRw) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputPrometheusRw) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "prometheusAPI"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetType() CreateInputSystemByPackTypePrometheusRw {
	if c == nil {
		return CreateInputSystemByPackTypePrometheusRw("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetPrometheusAPI() string {
	if c == nil {
		return ""
	}
	return c.PrometheusAPI
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputSystemByPackInputPrometheusRw) GetTemplatePrometheusAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePrometheusAPI
}

type CreateInputSystemByPackTypeLoki string

const (
	CreateInputSystemByPackTypeLokiLoki CreateInputSystemByPackTypeLoki = "loki"
)

func (e CreateInputSystemByPackTypeLoki) ToPointer() *CreateInputSystemByPackTypeLoki {
	return &e
}
func (e *CreateInputSystemByPackTypeLoki) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "loki":
		*e = CreateInputSystemByPackTypeLoki(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeLoki: %v", v)
	}
}

type CreateInputSystemByPackInputLoki struct {
	// Unique ID for this input
	ID       string                          `json:"id"`
	Type     CreateInputSystemByPackTypeLoki `json:"type"`
	Disabled *bool                           `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
	LokiAPI string `json:"lokiAPI"`
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `json:"authType,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputLoki) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputLoki) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "lokiAPI"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputLoki) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputLoki) GetType() CreateInputSystemByPackTypeLoki {
	if c == nil {
		return CreateInputSystemByPackTypeLoki("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputLoki) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputLoki) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputLoki) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputLoki) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputLoki) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputLoki) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputLoki) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputLoki) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputLoki) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputLoki) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputLoki) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputLoki) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputLoki) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputLoki) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputLoki) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputLoki) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputLoki) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputLoki) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputLoki) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputLoki) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputLoki) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputLoki) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputLoki) GetLokiAPI() string {
	if c == nil {
		return ""
	}
	return c.LokiAPI
}

func (c *CreateInputSystemByPackInputLoki) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputLoki) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputLoki) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputLoki) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackInputLoki) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackInputLoki) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackInputLoki) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackInputLoki) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputLoki) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputLoki) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackInputGrafanaType2 string

const (
	CreateInputSystemByPackInputGrafanaType2Grafana CreateInputSystemByPackInputGrafanaType2 = "grafana"
)

func (e CreateInputSystemByPackInputGrafanaType2) ToPointer() *CreateInputSystemByPackInputGrafanaType2 {
	return &e
}
func (e *CreateInputSystemByPackInputGrafanaType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = CreateInputSystemByPackInputGrafanaType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackInputGrafanaType2: %v", v)
	}
}

type CreateInputSystemByPackPrometheusAuth2 struct {
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `json:"authType,omitempty"`
	Username *string                                             `json:"username,omitempty"`
	Password *string                                             `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputSystemByPackPrometheusAuth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackPrometheusAuth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackPrometheusAuth2) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackPrometheusAuth2) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackPrometheusAuth2) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackPrometheusAuth2) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackPrometheusAuth2) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackPrometheusAuth2) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputSystemByPackLokiAuth2 struct {
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `json:"authType,omitempty"`
	Username *string                                       `json:"username,omitempty"`
	Password *string                                       `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputSystemByPackLokiAuth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackLokiAuth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackLokiAuth2) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackLokiAuth2) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackLokiAuth2) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackLokiAuth2) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackLokiAuth2) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackLokiAuth2) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputSystemByPackInputGrafanaGrafana2 struct {
	// Unique ID for this input
	ID       string                                   `json:"id"`
	Type     CreateInputSystemByPackInputGrafanaType2 `json:"type"`
	Disabled *bool                                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
	PrometheusAPI *string `json:"prometheusAPI,omitempty"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
	LokiAPI        string                                  `json:"lokiAPI"`
	PrometheusAuth *CreateInputSystemByPackPrometheusAuth2 `json:"prometheusAuth,omitempty"`
	LokiAuth       *CreateInputSystemByPackLokiAuth2       `json:"lokiAuth,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputGrafanaGrafana2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "lokiAPI"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetType() CreateInputSystemByPackInputGrafanaType2 {
	if c == nil {
		return CreateInputSystemByPackInputGrafanaType2("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetPrometheusAPI() *string {
	if c == nil {
		return nil
	}
	return c.PrometheusAPI
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetLokiAPI() string {
	if c == nil {
		return ""
	}
	return c.LokiAPI
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetPrometheusAuth() *CreateInputSystemByPackPrometheusAuth2 {
	if c == nil {
		return nil
	}
	return c.PrometheusAuth
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetLokiAuth() *CreateInputSystemByPackLokiAuth2 {
	if c == nil {
		return nil
	}
	return c.LokiAuth
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputGrafanaGrafana2) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackInputGrafanaType1 string

const (
	CreateInputSystemByPackInputGrafanaType1Grafana CreateInputSystemByPackInputGrafanaType1 = "grafana"
)

func (e CreateInputSystemByPackInputGrafanaType1) ToPointer() *CreateInputSystemByPackInputGrafanaType1 {
	return &e
}
func (e *CreateInputSystemByPackInputGrafanaType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = CreateInputSystemByPackInputGrafanaType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackInputGrafanaType1: %v", v)
	}
}

type CreateInputSystemByPackPrometheusAuth1 struct {
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `json:"authType,omitempty"`
	Username *string                                             `json:"username,omitempty"`
	Password *string                                             `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputSystemByPackPrometheusAuth1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackPrometheusAuth1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackPrometheusAuth1) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackPrometheusAuth1) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackPrometheusAuth1) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackPrometheusAuth1) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackPrometheusAuth1) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackPrometheusAuth1) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputSystemByPackLokiAuth1 struct {
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `json:"authType,omitempty"`
	Username *string                                       `json:"username,omitempty"`
	Password *string                                       `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputSystemByPackLokiAuth1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackLokiAuth1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackLokiAuth1) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackLokiAuth1) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackLokiAuth1) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackLokiAuth1) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackLokiAuth1) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackLokiAuth1) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputSystemByPackInputGrafanaGrafana1 struct {
	// Unique ID for this input
	ID       string                                   `json:"id"`
	Type     CreateInputSystemByPackInputGrafanaType1 `json:"type"`
	Disabled *bool                                    `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
	PrometheusAPI string `json:"prometheusAPI"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
	LokiAPI        *string                                 `json:"lokiAPI,omitempty"`
	PrometheusAuth *CreateInputSystemByPackPrometheusAuth1 `json:"prometheusAuth,omitempty"`
	LokiAuth       *CreateInputSystemByPackLokiAuth1       `json:"lokiAuth,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputGrafanaGrafana1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "prometheusAPI"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetType() CreateInputSystemByPackInputGrafanaType1 {
	if c == nil {
		return CreateInputSystemByPackInputGrafanaType1("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetPrometheusAPI() string {
	if c == nil {
		return ""
	}
	return c.PrometheusAPI
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetLokiAPI() *string {
	if c == nil {
		return nil
	}
	return c.LokiAPI
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetPrometheusAuth() *CreateInputSystemByPackPrometheusAuth1 {
	if c == nil {
		return nil
	}
	return c.PrometheusAuth
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetLokiAuth() *CreateInputSystemByPackLokiAuth1 {
	if c == nil {
		return nil
	}
	return c.LokiAuth
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputGrafanaGrafana1) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackInputGrafanaUnionType string

const (
	CreateInputSystemByPackInputGrafanaUnionTypeCreateInputSystemByPackInputGrafanaGrafana1 CreateInputSystemByPackInputGrafanaUnionType = "createInputSystemByPack_InputGrafana_Grafana_1"
	CreateInputSystemByPackInputGrafanaUnionTypeCreateInputSystemByPackInputGrafanaGrafana2 CreateInputSystemByPackInputGrafanaUnionType = "createInputSystemByPack_InputGrafana_Grafana_2"
)

type CreateInputSystemByPackInputGrafanaUnion struct {
	CreateInputSystemByPackInputGrafanaGrafana1 *CreateInputSystemByPackInputGrafanaGrafana1 `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputGrafanaGrafana2 *CreateInputSystemByPackInputGrafanaGrafana2 `queryParam:"inline" union:"member"`

	Type CreateInputSystemByPackInputGrafanaUnionType
}

func CreateCreateInputSystemByPackInputGrafanaUnionCreateInputSystemByPackInputGrafanaGrafana1(createInputSystemByPackInputGrafanaGrafana1 CreateInputSystemByPackInputGrafanaGrafana1) CreateInputSystemByPackInputGrafanaUnion {
	typ := CreateInputSystemByPackInputGrafanaUnionTypeCreateInputSystemByPackInputGrafanaGrafana1

	return CreateInputSystemByPackInputGrafanaUnion{
		CreateInputSystemByPackInputGrafanaGrafana1: &createInputSystemByPackInputGrafanaGrafana1,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackInputGrafanaUnionCreateInputSystemByPackInputGrafanaGrafana2(createInputSystemByPackInputGrafanaGrafana2 CreateInputSystemByPackInputGrafanaGrafana2) CreateInputSystemByPackInputGrafanaUnion {
	typ := CreateInputSystemByPackInputGrafanaUnionTypeCreateInputSystemByPackInputGrafanaGrafana2

	return CreateInputSystemByPackInputGrafanaUnion{
		CreateInputSystemByPackInputGrafanaGrafana2: &createInputSystemByPackInputGrafanaGrafana2,
		Type: typ,
	}
}

func (u *CreateInputSystemByPackInputGrafanaUnion) UnmarshalJSON(data []byte) error {

	var createInputSystemByPackInputGrafanaGrafana1 CreateInputSystemByPackInputGrafanaGrafana1 = CreateInputSystemByPackInputGrafanaGrafana1{}
	if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputGrafanaGrafana1, "", true, nil); err == nil {
		u.CreateInputSystemByPackInputGrafanaGrafana1 = &createInputSystemByPackInputGrafanaGrafana1
		u.Type = CreateInputSystemByPackInputGrafanaUnionTypeCreateInputSystemByPackInputGrafanaGrafana1
		return nil
	}

	var createInputSystemByPackInputGrafanaGrafana2 CreateInputSystemByPackInputGrafanaGrafana2 = CreateInputSystemByPackInputGrafanaGrafana2{}
	if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputGrafanaGrafana2, "", true, nil); err == nil {
		u.CreateInputSystemByPackInputGrafanaGrafana2 = &createInputSystemByPackInputGrafanaGrafana2
		u.Type = CreateInputSystemByPackInputGrafanaUnionTypeCreateInputSystemByPackInputGrafanaGrafana2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputSystemByPackInputGrafanaUnion", string(data))
}

func (u CreateInputSystemByPackInputGrafanaUnion) MarshalJSON() ([]byte, error) {
	if u.CreateInputSystemByPackInputGrafanaGrafana1 != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputGrafanaGrafana1, "", true)
	}

	if u.CreateInputSystemByPackInputGrafanaGrafana2 != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputGrafanaGrafana2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateInputSystemByPackInputGrafanaUnion: all fields are null")
}

type CreateInputSystemByPackTypeConfluentCloud string

const (
	CreateInputSystemByPackTypeConfluentCloudConfluentCloud CreateInputSystemByPackTypeConfluentCloud = "confluent_cloud"
)

func (e CreateInputSystemByPackTypeConfluentCloud) ToPointer() *CreateInputSystemByPackTypeConfluentCloud {
	return &e
}
func (e *CreateInputSystemByPackTypeConfluentCloud) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "confluent_cloud":
		*e = CreateInputSystemByPackTypeConfluentCloud(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeConfluentCloud: %v", v)
	}
}

type CreateInputSystemByPackInputConfluentCloud struct {
	// Unique ID for this input
	ID       string                                    `json:"id"`
	Type     CreateInputSystemByPackTypeConfluentCloud `json:"type"`
	Disabled *bool                                     `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
	Brokers []string                                                 `json:"brokers"`
	TLS     *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `json:"fromBeginning,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `json:"maxRetries,omitempty"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `json:"maxBackOff,omitempty"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `json:"initialBackoff,omitempty"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `json:"backoffRate,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `json:"authenticationTimeout,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `json:"reauthenticationThreshold,omitempty"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType `json:"sasl,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `json:"sessionTimeout,omitempty"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `json:"rebalanceTimeout,omitempty"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `json:"heartbeatInterval,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `json:"maxBytesPerPartition,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `json:"maxBytes,omitempty"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `json:"maxSocketErrors,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputConfluentCloud) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputConfluentCloud) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetType() CreateInputSystemByPackTypeConfluentCloud {
	if c == nil {
		return CreateInputSystemByPackTypeConfluentCloud("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetBrokers() []string {
	if c == nil {
		return []string{}
	}
	return c.Brokers
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetTopics() []string {
	if c == nil {
		return []string{}
	}
	return c.Topics
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetGroupID() *string {
	if c == nil {
		return nil
	}
	return c.GroupID
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetFromBeginning() *bool {
	if c == nil {
		return nil
	}
	return c.FromBeginning
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if c == nil {
		return nil
	}
	return c.KafkaSchemaRegistry
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetConnectionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ConnectionTimeout
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetMaxRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRetries
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetMaxBackOff() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBackOff
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetInitialBackoff() *float64 {
	if c == nil {
		return nil
	}
	return c.InitialBackoff
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetBackoffRate() *float64 {
	if c == nil {
		return nil
	}
	return c.BackoffRate
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetAuthenticationTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.AuthenticationTimeout
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetReauthenticationThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.ReauthenticationThreshold
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetSasl() *components.AuthenticationType {
	if c == nil {
		return nil
	}
	return c.Sasl
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetSessionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SessionTimeout
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetRebalanceTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RebalanceTimeout
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetHeartbeatInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.HeartbeatInterval
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetAutoCommitInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitInterval
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetAutoCommitThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitThreshold
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetMaxBytesPerPartition() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytesPerPartition
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetMaxBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytes
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetMaxSocketErrors() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxSocketErrors
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputConfluentCloud) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeElastic string

const (
	CreateInputSystemByPackTypeElasticElastic CreateInputSystemByPackTypeElastic = "elastic"
)

func (e CreateInputSystemByPackTypeElastic) ToPointer() *CreateInputSystemByPackTypeElastic {
	return &e
}
func (e *CreateInputSystemByPackTypeElastic) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "elastic":
		*e = CreateInputSystemByPackTypeElastic(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeElastic: %v", v)
	}
}

type CreateInputSystemByPackAuthenticationTypeElastic string

const (
	// CreateInputSystemByPackAuthenticationTypeElasticNone None
	CreateInputSystemByPackAuthenticationTypeElasticNone CreateInputSystemByPackAuthenticationTypeElastic = "none"
	// CreateInputSystemByPackAuthenticationTypeElasticBasic Basic
	CreateInputSystemByPackAuthenticationTypeElasticBasic CreateInputSystemByPackAuthenticationTypeElastic = "basic"
	// CreateInputSystemByPackAuthenticationTypeElasticCredentialsSecret Basic (credentials secret)
	CreateInputSystemByPackAuthenticationTypeElasticCredentialsSecret CreateInputSystemByPackAuthenticationTypeElastic = "credentialsSecret"
	// CreateInputSystemByPackAuthenticationTypeElasticAuthTokens Auth Tokens
	CreateInputSystemByPackAuthenticationTypeElasticAuthTokens CreateInputSystemByPackAuthenticationTypeElastic = "authTokens"
)

func (e CreateInputSystemByPackAuthenticationTypeElastic) ToPointer() *CreateInputSystemByPackAuthenticationTypeElastic {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackAuthenticationTypeElastic) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "credentialsSecret", "authTokens":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackAPIVersion - The API version to use for communicating with the server
type CreateInputSystemByPackAPIVersion string

const (
	// CreateInputSystemByPackAPIVersionSixDot8Dot4 6.8.4
	CreateInputSystemByPackAPIVersionSixDot8Dot4 CreateInputSystemByPackAPIVersion = "6.8.4"
	// CreateInputSystemByPackAPIVersionEightDot3Dot2 8.3.2
	CreateInputSystemByPackAPIVersionEightDot3Dot2 CreateInputSystemByPackAPIVersion = "8.3.2"
	// CreateInputSystemByPackAPIVersionCustom Custom
	CreateInputSystemByPackAPIVersionCustom CreateInputSystemByPackAPIVersion = "custom"
)

func (e CreateInputSystemByPackAPIVersion) ToPointer() *CreateInputSystemByPackAPIVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackAPIVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "6.8.4", "8.3.2", "custom":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackProxyModeAuthenticationMethod - Enter credentials directly, or select a stored secret
type CreateInputSystemByPackProxyModeAuthenticationMethod string

const (
	CreateInputSystemByPackProxyModeAuthenticationMethodNone   CreateInputSystemByPackProxyModeAuthenticationMethod = "none"
	CreateInputSystemByPackProxyModeAuthenticationMethodManual CreateInputSystemByPackProxyModeAuthenticationMethod = "manual"
	CreateInputSystemByPackProxyModeAuthenticationMethodSecret CreateInputSystemByPackProxyModeAuthenticationMethod = "secret"
)

func (e CreateInputSystemByPackProxyModeAuthenticationMethod) ToPointer() *CreateInputSystemByPackProxyModeAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackProxyModeAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "manual", "secret":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackProxyModeElastic struct {
	// Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details.
	Enabled bool `json:"enabled"`
	// Enter credentials directly, or select a stored secret
	AuthType *CreateInputSystemByPackProxyModeAuthenticationMethod `json:"authType,omitempty"`
	Username *string                                               `json:"username,omitempty"`
	Password *string                                               `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200
	URL *string `json:"url,omitempty"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// List of headers to remove from the request to proxy
	RemoveHeaders []string `json:"removeHeaders,omitempty"`
	// Amount of time, in seconds, to wait for a proxy request to complete before canceling it
	TimeoutSec *float64 `json:"timeoutSec,omitempty"`
	// Binds 'url' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'url' at runtime.
	TemplateURL *string `json:"__template_url,omitempty"`
}

func (c CreateInputSystemByPackProxyModeElastic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackProxyModeElastic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"enabled"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackProxyModeElastic) GetEnabled() bool {
	if c == nil {
		return false
	}
	return c.Enabled
}

func (c *CreateInputSystemByPackProxyModeElastic) GetAuthType() *CreateInputSystemByPackProxyModeAuthenticationMethod {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackProxyModeElastic) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackProxyModeElastic) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackProxyModeElastic) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackProxyModeElastic) GetURL() *string {
	if c == nil {
		return nil
	}
	return c.URL
}

func (c *CreateInputSystemByPackProxyModeElastic) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackProxyModeElastic) GetRemoveHeaders() []string {
	if c == nil {
		return nil
	}
	return c.RemoveHeaders
}

func (c *CreateInputSystemByPackProxyModeElastic) GetTimeoutSec() *float64 {
	if c == nil {
		return nil
	}
	return c.TimeoutSec
}

func (c *CreateInputSystemByPackProxyModeElastic) GetTemplateURL() *string {
	if c == nil {
		return nil
	}
	return c.TemplateURL
}

type CreateInputSystemByPackInputElastic struct {
	// Unique ID for this input
	ID       string                             `json:"id"`
	Type     CreateInputSystemByPackTypeElastic `json:"type"`
	Disabled *bool                              `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
	ElasticAPI string                                            `json:"elasticAPI"`
	AuthType   *CreateInputSystemByPackAuthenticationTypeElastic `json:"authType,omitempty"`
	// The API version to use for communicating with the server
	APIVersion *CreateInputSystemByPackAPIVersion `json:"apiVersion,omitempty"`
	// Headers to add to all events
	ExtraHTTPHeaders []components.ItemsTypeExtraHTTPHeaders `json:"extraHttpHeaders,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *CreateInputSystemByPackProxyModeElastic   `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Bearer tokens to include in the authorization header
	AuthTokens []string `json:"authTokens,omitempty"`
	// Custom version information to respond to requests
	CustomAPIVersion *string `json:"customAPIVersion,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputElastic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputElastic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "elasticAPI"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputElastic) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputElastic) GetType() CreateInputSystemByPackTypeElastic {
	if c == nil {
		return CreateInputSystemByPackTypeElastic("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputElastic) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputElastic) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputElastic) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputElastic) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputElastic) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputElastic) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputElastic) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputElastic) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputElastic) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputElastic) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputElastic) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputElastic) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputElastic) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputElastic) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputElastic) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputElastic) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputElastic) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputElastic) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputElastic) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputElastic) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputElastic) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputElastic) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputElastic) GetElasticAPI() string {
	if c == nil {
		return ""
	}
	return c.ElasticAPI
}

func (c *CreateInputSystemByPackInputElastic) GetAuthType() *CreateInputSystemByPackAuthenticationTypeElastic {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputElastic) GetAPIVersion() *CreateInputSystemByPackAPIVersion {
	if c == nil {
		return nil
	}
	return c.APIVersion
}

func (c *CreateInputSystemByPackInputElastic) GetExtraHTTPHeaders() []components.ItemsTypeExtraHTTPHeaders {
	if c == nil {
		return nil
	}
	return c.ExtraHTTPHeaders
}

func (c *CreateInputSystemByPackInputElastic) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputElastic) GetProxyMode() *CreateInputSystemByPackProxyModeElastic {
	if c == nil {
		return nil
	}
	return c.ProxyMode
}

func (c *CreateInputSystemByPackInputElastic) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputElastic) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackInputElastic) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackInputElastic) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackInputElastic) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputElastic) GetCustomAPIVersion() *string {
	if c == nil {
		return nil
	}
	return c.CustomAPIVersion
}

func (c *CreateInputSystemByPackInputElastic) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputElastic) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeAzureBlob string

const (
	CreateInputSystemByPackTypeAzureBlobAzureBlob CreateInputSystemByPackTypeAzureBlob = "azure_blob"
)

func (e CreateInputSystemByPackTypeAzureBlob) ToPointer() *CreateInputSystemByPackTypeAzureBlob {
	return &e
}
func (e *CreateInputSystemByPackTypeAzureBlob) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azure_blob":
		*e = CreateInputSystemByPackTypeAzureBlob(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeAzureBlob: %v", v)
	}
}

type CreateInputSystemByPackInputAzureBlob struct {
	// Unique ID for this input
	ID       string                               `json:"id"`
	Type     CreateInputSystemByPackTypeAzureBlob `json:"type"`
	Disabled *bool                                `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`
	// The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
	VisibilityTimeout *float64 `json:"visibilityTimeout,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `json:"numReceivers,omitempty"`
	// The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
	MaxMessages *float64 `json:"maxMessages,omitempty"`
	// The duration (in seconds) which pollers should be validated and restarted if exited
	ServicePeriodSecs *float64 `json:"servicePeriodSecs,omitempty"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                                `json:"parquetChunkDownloadTimeout,omitempty"`
	AuthType                    *components.AuthenticationMethodOptions `json:"authType,omitempty"`
	Description                 *string                                 `json:"description,omitempty"`
	// Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// The name of your Azure storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`
	// The service principal's tenant ID
	TenantID *string `json:"tenantId,omitempty"`
	// The service principal's client ID
	ClientID *string `json:"clientId,omitempty"`
	// The Azure cloud to use. Defaults to Azure Public Cloud.
	AzureCloud *string `json:"azureCloud,omitempty"`
	// Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
	EndpointSuffix *string `json:"endpointSuffix,omitempty"`
	// Select or create a stored text secret
	ClientTextSecret *string                                                `json:"clientTextSecret,omitempty"`
	Certificate      *components.CertificateTypeAzureBlobAuthTypeClientCert `json:"certificate,omitempty"`
	// Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime.
	TemplateQueueName *string `json:"__template_queueName,omitempty"`
	// Binds 'connectionString' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'connectionString' at runtime.
	TemplateConnectionString *string `json:"__template_connectionString,omitempty"`
	// Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime.
	TemplateTenantID *string `json:"__template_tenantId,omitempty"`
	// Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime.
	TemplateClientID *string `json:"__template_clientId,omitempty"`
}

func (c CreateInputSystemByPackInputAzureBlob) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputAzureBlob) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputAzureBlob) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputAzureBlob) GetType() CreateInputSystemByPackTypeAzureBlob {
	if c == nil {
		return CreateInputSystemByPackTypeAzureBlob("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputAzureBlob) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputAzureBlob) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputAzureBlob) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputAzureBlob) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputAzureBlob) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputAzureBlob) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputAzureBlob) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputAzureBlob) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputAzureBlob) GetQueueName() string {
	if c == nil {
		return ""
	}
	return c.QueueName
}

func (c *CreateInputSystemByPackInputAzureBlob) GetFileFilter() *string {
	if c == nil {
		return nil
	}
	return c.FileFilter
}

func (c *CreateInputSystemByPackInputAzureBlob) GetVisibilityTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.VisibilityTimeout
}

func (c *CreateInputSystemByPackInputAzureBlob) GetNumReceivers() *float64 {
	if c == nil {
		return nil
	}
	return c.NumReceivers
}

func (c *CreateInputSystemByPackInputAzureBlob) GetMaxMessages() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMessages
}

func (c *CreateInputSystemByPackInputAzureBlob) GetServicePeriodSecs() *float64 {
	if c == nil {
		return nil
	}
	return c.ServicePeriodSecs
}

func (c *CreateInputSystemByPackInputAzureBlob) GetSkipOnError() *bool {
	if c == nil {
		return nil
	}
	return c.SkipOnError
}

func (c *CreateInputSystemByPackInputAzureBlob) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputAzureBlob) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputAzureBlob) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputAzureBlob) GetParquetChunkSizeMB() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkSizeMB
}

func (c *CreateInputSystemByPackInputAzureBlob) GetParquetChunkDownloadTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ParquetChunkDownloadTimeout
}

func (c *CreateInputSystemByPackInputAzureBlob) GetAuthType() *components.AuthenticationMethodOptions {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputAzureBlob) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputAzureBlob) GetConnectionString() *string {
	if c == nil {
		return nil
	}
	return c.ConnectionString
}

func (c *CreateInputSystemByPackInputAzureBlob) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

func (c *CreateInputSystemByPackInputAzureBlob) GetStorageAccountName() *string {
	if c == nil {
		return nil
	}
	return c.StorageAccountName
}

func (c *CreateInputSystemByPackInputAzureBlob) GetTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TenantID
}

func (c *CreateInputSystemByPackInputAzureBlob) GetClientID() *string {
	if c == nil {
		return nil
	}
	return c.ClientID
}

func (c *CreateInputSystemByPackInputAzureBlob) GetAzureCloud() *string {
	if c == nil {
		return nil
	}
	return c.AzureCloud
}

func (c *CreateInputSystemByPackInputAzureBlob) GetEndpointSuffix() *string {
	if c == nil {
		return nil
	}
	return c.EndpointSuffix
}

func (c *CreateInputSystemByPackInputAzureBlob) GetClientTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.ClientTextSecret
}

func (c *CreateInputSystemByPackInputAzureBlob) GetCertificate() *components.CertificateTypeAzureBlobAuthTypeClientCert {
	if c == nil {
		return nil
	}
	return c.Certificate
}

func (c *CreateInputSystemByPackInputAzureBlob) GetTemplateQueueName() *string {
	if c == nil {
		return nil
	}
	return c.TemplateQueueName
}

func (c *CreateInputSystemByPackInputAzureBlob) GetTemplateConnectionString() *string {
	if c == nil {
		return nil
	}
	return c.TemplateConnectionString
}

func (c *CreateInputSystemByPackInputAzureBlob) GetTemplateTenantID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateTenantID
}

func (c *CreateInputSystemByPackInputAzureBlob) GetTemplateClientID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateClientID
}

type CreateInputSystemByPackTypeSplunkHec string

const (
	CreateInputSystemByPackTypeSplunkHecSplunkHec CreateInputSystemByPackTypeSplunkHec = "splunk_hec"
)

func (e CreateInputSystemByPackTypeSplunkHec) ToPointer() *CreateInputSystemByPackTypeSplunkHec {
	return &e
}
func (e *CreateInputSystemByPackTypeSplunkHec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_hec":
		*e = CreateInputSystemByPackTypeSplunkHec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeSplunkHec: %v", v)
	}
}

type CreateInputSystemByPackAuthTokenSplunkHec struct {
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `json:"authType,omitempty"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	// Shared secret to be provided by any client (Authorization: <token>)
	Token   string `json:"token"`
	Enabled *bool  `json:"enabled,omitempty"`
	// Optional token description
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
}

func (c CreateInputSystemByPackAuthTokenSplunkHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackAuthTokenSplunkHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"token"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackAuthTokenSplunkHec) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackAuthTokenSplunkHec) GetTokenSecret() *string {
	if c == nil {
		return nil
	}
	return c.TokenSecret
}

func (c *CreateInputSystemByPackAuthTokenSplunkHec) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CreateInputSystemByPackAuthTokenSplunkHec) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CreateInputSystemByPackAuthTokenSplunkHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackAuthTokenSplunkHec) GetAllowedIndexesAtToken() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexesAtToken
}

func (c *CreateInputSystemByPackAuthTokenSplunkHec) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

type CreateInputSystemByPackInputSplunkHec struct {
	// Unique ID for this input
	ID       string                               `json:"id"`
	Type     CreateInputSystemByPackTypeSplunkHec `json:"type"`
	Disabled *bool                                `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []CreateInputSystemByPackAuthTokenSplunkHec `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType       `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `json:"keepAliveTimeout,omitempty"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
	SplunkHecAPI string `json:"splunkHecAPI"`
	// Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Enable Splunk HEC acknowledgements
	SplunkHecAcks *bool `json:"splunkHecAcks,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `json:"useFwdTimezone,omitempty"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `json:"dropControlFields,omitempty"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `json:"emitTokenMetrics,omitempty"`
	Description      *string `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime.
	TemplateSplunkHecAPI *string `json:"__template_splunkHecAPI,omitempty"`
}

func (c CreateInputSystemByPackInputSplunkHec) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSplunkHec) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port", "splunkHecAPI"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSplunkHec) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSplunkHec) GetType() CreateInputSystemByPackTypeSplunkHec {
	if c == nil {
		return CreateInputSystemByPackTypeSplunkHec("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSplunkHec) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSplunkHec) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSplunkHec) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSplunkHec) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSplunkHec) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSplunkHec) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSplunkHec) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSplunkHec) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSplunkHec) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputSplunkHec) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputSplunkHec) GetAuthTokens() []CreateInputSystemByPackAuthTokenSplunkHec {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputSplunkHec) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputSplunkHec) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputSplunkHec) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputSplunkHec) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputSplunkHec) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputSplunkHec) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputSplunkHec) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputSplunkHec) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputSplunkHec) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputSplunkHec) GetEnableHealthCheck() any {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputSplunkHec) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputSplunkHec) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputSplunkHec) GetSplunkHecAPI() string {
	if c == nil {
		return ""
	}
	return c.SplunkHecAPI
}

func (c *CreateInputSystemByPackInputSplunkHec) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSplunkHec) GetAllowedIndexes() []string {
	if c == nil {
		return nil
	}
	return c.AllowedIndexes
}

func (c *CreateInputSystemByPackInputSplunkHec) GetSplunkHecAcks() *bool {
	if c == nil {
		return nil
	}
	return c.SplunkHecAcks
}

func (c *CreateInputSystemByPackInputSplunkHec) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputSplunkHec) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputSplunkHec) GetUseFwdTimezone() *bool {
	if c == nil {
		return nil
	}
	return c.UseFwdTimezone
}

func (c *CreateInputSystemByPackInputSplunkHec) GetDropControlFields() *bool {
	if c == nil {
		return nil
	}
	return c.DropControlFields
}

func (c *CreateInputSystemByPackInputSplunkHec) GetExtractMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractMetrics
}

func (c *CreateInputSystemByPackInputSplunkHec) GetAccessControlAllowOrigin() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowOrigin
}

func (c *CreateInputSystemByPackInputSplunkHec) GetAccessControlAllowHeaders() []string {
	if c == nil {
		return nil
	}
	return c.AccessControlAllowHeaders
}

func (c *CreateInputSystemByPackInputSplunkHec) GetEmitTokenMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.EmitTokenMetrics
}

func (c *CreateInputSystemByPackInputSplunkHec) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputSplunkHec) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputSplunkHec) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputSystemByPackInputSplunkHec) GetTemplateSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplateSplunkHecAPI
}

type CreateInputSystemByPackTypeSplunkSearch string

const (
	CreateInputSystemByPackTypeSplunkSearchSplunkSearch CreateInputSystemByPackTypeSplunkSearch = "splunk_search"
)

func (e CreateInputSystemByPackTypeSplunkSearch) ToPointer() *CreateInputSystemByPackTypeSplunkSearch {
	return &e
}
func (e *CreateInputSystemByPackTypeSplunkSearch) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_search":
		*e = CreateInputSystemByPackTypeSplunkSearch(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeSplunkSearch: %v", v)
	}
}

type CreateInputSystemByPackEndpointParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (c CreateInputSystemByPackEndpointParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackEndpointParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"name", "value"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackEndpointParam) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateInputSystemByPackEndpointParam) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

type CreateInputSystemByPackEndpointHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (c CreateInputSystemByPackEndpointHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackEndpointHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"name", "value"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackEndpointHeader) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateInputSystemByPackEndpointHeader) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

// CreateInputSystemByPackLogLevelSplunkSearch - Collector runtime log level (verbosity)
type CreateInputSystemByPackLogLevelSplunkSearch string

const (
	CreateInputSystemByPackLogLevelSplunkSearchError CreateInputSystemByPackLogLevelSplunkSearch = "error"
	CreateInputSystemByPackLogLevelSplunkSearchWarn  CreateInputSystemByPackLogLevelSplunkSearch = "warn"
	CreateInputSystemByPackLogLevelSplunkSearchInfo  CreateInputSystemByPackLogLevelSplunkSearch = "info"
	CreateInputSystemByPackLogLevelSplunkSearchDebug CreateInputSystemByPackLogLevelSplunkSearch = "debug"
)

func (e CreateInputSystemByPackLogLevelSplunkSearch) ToPointer() *CreateInputSystemByPackLogLevelSplunkSearch {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackLogLevelSplunkSearch) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackAuthenticationTypeSplunkSearch - Splunk Search authentication type
type CreateInputSystemByPackAuthenticationTypeSplunkSearch string

const (
	// CreateInputSystemByPackAuthenticationTypeSplunkSearchNone None
	CreateInputSystemByPackAuthenticationTypeSplunkSearchNone CreateInputSystemByPackAuthenticationTypeSplunkSearch = "none"
	// CreateInputSystemByPackAuthenticationTypeSplunkSearchBasic Basic
	CreateInputSystemByPackAuthenticationTypeSplunkSearchBasic CreateInputSystemByPackAuthenticationTypeSplunkSearch = "basic"
	// CreateInputSystemByPackAuthenticationTypeSplunkSearchCredentialsSecret Basic (credentials secret)
	CreateInputSystemByPackAuthenticationTypeSplunkSearchCredentialsSecret CreateInputSystemByPackAuthenticationTypeSplunkSearch = "credentialsSecret"
	// CreateInputSystemByPackAuthenticationTypeSplunkSearchToken Token
	CreateInputSystemByPackAuthenticationTypeSplunkSearchToken CreateInputSystemByPackAuthenticationTypeSplunkSearch = "token"
	// CreateInputSystemByPackAuthenticationTypeSplunkSearchTextSecret Token (text secret)
	CreateInputSystemByPackAuthenticationTypeSplunkSearchTextSecret CreateInputSystemByPackAuthenticationTypeSplunkSearch = "textSecret"
)

func (e CreateInputSystemByPackAuthenticationTypeSplunkSearch) ToPointer() *CreateInputSystemByPackAuthenticationTypeSplunkSearch {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackAuthenticationTypeSplunkSearch) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "credentialsSecret", "token", "textSecret":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputSplunkSearch struct {
	// Unique ID for this input
	ID       string                                  `json:"id"`
	Type     CreateInputSystemByPackTypeSplunkSearch `json:"type"`
	Disabled *bool                                   `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitempty"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitempty"`
	// A cron schedule on which to run this job
	CronSchedule string `json:"cronSchedule"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode components.OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional request parameters to send to the endpoint
	EndpointParams []CreateInputSystemByPackEndpointParam `json:"endpointParams,omitempty"`
	// Optional request headers to send to the endpoint
	EndpointHeaders []CreateInputSystemByPackEndpointHeader `json:"endpointHeaders,omitempty"`
	// Collector runtime log level (verbosity)
	LogLevel *CreateInputSystemByPackLogLevelSplunkSearch `json:"logLevel,omitempty"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitempty"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitempty"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Splunk Search authentication type
	AuthType    *CreateInputSystemByPackAuthenticationTypeSplunkSearch `json:"authType,omitempty"`
	Description *string                                                `json:"description,omitempty"`
	Username    *string                                                `json:"username,omitempty"`
	Password    *string                                                `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (c CreateInputSystemByPackInputSplunkSearch) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSplunkSearch) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "searchHead", "search", "cronSchedule", "endpoint", "outputMode"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetType() CreateInputSystemByPackTypeSplunkSearch {
	if c == nil {
		return CreateInputSystemByPackTypeSplunkSearch("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetSearchHead() string {
	if c == nil {
		return ""
	}
	return c.SearchHead
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetSearch() string {
	if c == nil {
		return ""
	}
	return c.Search
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetEarliest() *string {
	if c == nil {
		return nil
	}
	return c.Earliest
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetLatest() *string {
	if c == nil {
		return nil
	}
	return c.Latest
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetCronSchedule() string {
	if c == nil {
		return ""
	}
	return c.CronSchedule
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetEndpoint() string {
	if c == nil {
		return ""
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetOutputMode() components.OutputModeOptionsSplunkCollectorConf {
	if c == nil {
		return components.OutputModeOptionsSplunkCollectorConf("")
	}
	return c.OutputMode
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetEndpointParams() []CreateInputSystemByPackEndpointParam {
	if c == nil {
		return nil
	}
	return c.EndpointParams
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetEndpointHeaders() []CreateInputSystemByPackEndpointHeader {
	if c == nil {
		return nil
	}
	return c.EndpointHeaders
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetLogLevel() *CreateInputSystemByPackLogLevelSplunkSearch {
	if c == nil {
		return nil
	}
	return c.LogLevel
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetUseRoundRobinDNS() *bool {
	if c == nil {
		return nil
	}
	return c.UseRoundRobinDNS
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetEncoding() *string {
	if c == nil {
		return nil
	}
	return c.Encoding
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetKeepAliveTime() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTime
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetJobTimeout() *string {
	if c == nil {
		return nil
	}
	return c.JobTimeout
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetMaxMissedKeepAlives() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxMissedKeepAlives
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetIgnoreGroupJobsLimit() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreGroupJobsLimit
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetRetryRules() *components.RetryRulesType {
	if c == nil {
		return nil
	}
	return c.RetryRules
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetAuthType() *CreateInputSystemByPackAuthenticationTypeSplunkSearch {
	if c == nil {
		return nil
	}
	return c.AuthType
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetToken() *string {
	if c == nil {
		return nil
	}
	return c.Token
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetCredentialsSecret() *string {
	if c == nil {
		return nil
	}
	return c.CredentialsSecret
}

func (c *CreateInputSystemByPackInputSplunkSearch) GetTextSecret() *string {
	if c == nil {
		return nil
	}
	return c.TextSecret
}

type CreateInputSystemByPackTypeSplunk string

const (
	CreateInputSystemByPackTypeSplunkSplunk CreateInputSystemByPackTypeSplunk = "splunk"
)

func (e CreateInputSystemByPackTypeSplunk) ToPointer() *CreateInputSystemByPackTypeSplunk {
	return &e
}
func (e *CreateInputSystemByPackTypeSplunk) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk":
		*e = CreateInputSystemByPackTypeSplunk(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeSplunk: %v", v)
	}
}

type CreateInputSystemByPackAuthTokenSplunk struct {
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	Token       string  `json:"token"`
	Description *string `json:"description,omitempty"`
}

func (c CreateInputSystemByPackAuthTokenSplunk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackAuthTokenSplunk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"token"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackAuthTokenSplunk) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CreateInputSystemByPackAuthTokenSplunk) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

// CreateInputSystemByPackMaxS2SVersion - The highest S2S protocol version to advertise during handshake
type CreateInputSystemByPackMaxS2SVersion string

const (
	// CreateInputSystemByPackMaxS2SVersionV3 v3
	CreateInputSystemByPackMaxS2SVersionV3 CreateInputSystemByPackMaxS2SVersion = "v3"
	// CreateInputSystemByPackMaxS2SVersionV4 v4
	CreateInputSystemByPackMaxS2SVersionV4 CreateInputSystemByPackMaxS2SVersion = "v4"
)

func (e CreateInputSystemByPackMaxS2SVersion) ToPointer() *CreateInputSystemByPackMaxS2SVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackMaxS2SVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "v3", "v4":
			return true
		}
	}
	return false
}

// CreateInputSystemByPackCompression - Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
type CreateInputSystemByPackCompression string

const (
	// CreateInputSystemByPackCompressionDisabled Disabled
	CreateInputSystemByPackCompressionDisabled CreateInputSystemByPackCompression = "disabled"
	// CreateInputSystemByPackCompressionAuto Automatic
	CreateInputSystemByPackCompressionAuto CreateInputSystemByPackCompression = "auto"
	// CreateInputSystemByPackCompressionAlways Always
	CreateInputSystemByPackCompressionAlways CreateInputSystemByPackCompression = "always"
)

func (e CreateInputSystemByPackCompression) ToPointer() *CreateInputSystemByPackCompression {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputSystemByPackCompression) IsExact() bool {
	if e != nil {
		switch *e {
		case "disabled", "auto", "always":
			return true
		}
	}
	return false
}

type CreateInputSystemByPackInputSplunk struct {
	// Unique ID for this input
	ID       string                            `json:"id"`
	Type     CreateInputSystemByPackTypeSplunk `json:"type"`
	Disabled *bool                             `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `json:"maxActiveCxn,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `json:"socketIdleTimeout,omitempty"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `json:"socketEndingMaxWait,omitempty"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `json:"socketMaxLifespan,omitempty"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitempty"`
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	AuthTokens []CreateInputSystemByPackAuthTokenSplunk `json:"authTokens,omitempty"`
	// The highest S2S protocol version to advertise during handshake
	MaxS2Sversion *CreateInputSystemByPackMaxS2SVersion `json:"maxS2Sversion,omitempty"`
	Description   *string                               `json:"description,omitempty"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `json:"useFwdTimezone,omitempty"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `json:"dropControlFields,omitempty"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`
	// Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
	Compress *CreateInputSystemByPackCompression `json:"compress,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
}

func (c CreateInputSystemByPackInputSplunk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputSplunk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputSplunk) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputSplunk) GetType() CreateInputSystemByPackTypeSplunk {
	if c == nil {
		return CreateInputSystemByPackTypeSplunk("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputSplunk) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputSplunk) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputSplunk) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputSplunk) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputSplunk) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputSplunk) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputSplunk) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputSplunk) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputSplunk) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputSplunk) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputSplunk) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputSplunk) GetIPWhitelistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPWhitelistRegex
}

func (c *CreateInputSystemByPackInputSplunk) GetMaxActiveCxn() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveCxn
}

func (c *CreateInputSystemByPackInputSplunk) GetSocketIdleTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketIdleTimeout
}

func (c *CreateInputSystemByPackInputSplunk) GetSocketEndingMaxWait() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketEndingMaxWait
}

func (c *CreateInputSystemByPackInputSplunk) GetSocketMaxLifespan() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketMaxLifespan
}

func (c *CreateInputSystemByPackInputSplunk) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputSplunk) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputSplunk) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputSplunk) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputSplunk) GetAuthTokens() []CreateInputSystemByPackAuthTokenSplunk {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputSplunk) GetMaxS2Sversion() *CreateInputSystemByPackMaxS2SVersion {
	if c == nil {
		return nil
	}
	return c.MaxS2Sversion
}

func (c *CreateInputSystemByPackInputSplunk) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputSplunk) GetUseFwdTimezone() *bool {
	if c == nil {
		return nil
	}
	return c.UseFwdTimezone
}

func (c *CreateInputSystemByPackInputSplunk) GetDropControlFields() *bool {
	if c == nil {
		return nil
	}
	return c.DropControlFields
}

func (c *CreateInputSystemByPackInputSplunk) GetExtractMetrics() *bool {
	if c == nil {
		return nil
	}
	return c.ExtractMetrics
}

func (c *CreateInputSystemByPackInputSplunk) GetCompress() *CreateInputSystemByPackCompression {
	if c == nil {
		return nil
	}
	return c.Compress
}

func (c *CreateInputSystemByPackInputSplunk) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputSplunk) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

type CreateInputSystemByPackTypeHTTP string

const (
	CreateInputSystemByPackTypeHTTPHTTP CreateInputSystemByPackTypeHTTP = "http"
)

func (e CreateInputSystemByPackTypeHTTP) ToPointer() *CreateInputSystemByPackTypeHTTP {
	return &e
}
func (e *CreateInputSystemByPackTypeHTTP) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = CreateInputSystemByPackTypeHTTP(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeHTTP: %v", v)
	}
}

type CreateInputSystemByPackInputHTTP struct {
	// Unique ID for this input
	ID       string                          `json:"id"`
	Type     CreateInputSystemByPackTypeHTTP `json:"type"`
	Disabled *bool                           `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `json:"maxActiveReq,omitempty"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `json:"maxRequestsPerSocket,omitempty"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `json:"socketTimeout,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `json:"keepAliveTimeout,omitempty"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `json:"ipDenylistRegex,omitempty"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `json:"criblAPI,omitempty"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `json:"elasticAPI,omitempty"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `json:"splunkHecAPI,omitempty"`
	SplunkHecAcks *bool   `json:"splunkHecAcks,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
	// Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime.
	TemplateHost *string `json:"__template_host,omitempty"`
	// Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime.
	TemplatePort *string `json:"__template_port,omitempty"`
	// Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime.
	TemplateSplunkHecAPI *string `json:"__template_splunkHecAPI,omitempty"`
}

func (c CreateInputSystemByPackInputHTTP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputHTTP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "host", "port"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputHTTP) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputHTTP) GetType() CreateInputSystemByPackTypeHTTP {
	if c == nil {
		return CreateInputSystemByPackTypeHTTP("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputHTTP) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputHTTP) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputHTTP) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputHTTP) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputHTTP) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputHTTP) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputHTTP) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputHTTP) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputHTTP) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *CreateInputSystemByPackInputHTTP) GetPort() float64 {
	if c == nil {
		return 0.0
	}
	return c.Port
}

func (c *CreateInputSystemByPackInputHTTP) GetAuthTokens() []string {
	if c == nil {
		return nil
	}
	return c.AuthTokens
}

func (c *CreateInputSystemByPackInputHTTP) GetTLS() *components.TLSSettingsServerSideType {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputHTTP) GetMaxActiveReq() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxActiveReq
}

func (c *CreateInputSystemByPackInputHTTP) GetMaxRequestsPerSocket() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxRequestsPerSocket
}

func (c *CreateInputSystemByPackInputHTTP) GetEnableProxyHeader() *bool {
	if c == nil {
		return nil
	}
	return c.EnableProxyHeader
}

func (c *CreateInputSystemByPackInputHTTP) GetCaptureHeaders() *bool {
	if c == nil {
		return nil
	}
	return c.CaptureHeaders
}

func (c *CreateInputSystemByPackInputHTTP) GetActivityLogSampleRate() *float64 {
	if c == nil {
		return nil
	}
	return c.ActivityLogSampleRate
}

func (c *CreateInputSystemByPackInputHTTP) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputHTTP) GetSocketTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SocketTimeout
}

func (c *CreateInputSystemByPackInputHTTP) GetKeepAliveTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.KeepAliveTimeout
}

func (c *CreateInputSystemByPackInputHTTP) GetEnableHealthCheck() *bool {
	if c == nil {
		return nil
	}
	return c.EnableHealthCheck
}

func (c *CreateInputSystemByPackInputHTTP) GetIPAllowlistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPAllowlistRegex
}

func (c *CreateInputSystemByPackInputHTTP) GetIPDenylistRegex() *string {
	if c == nil {
		return nil
	}
	return c.IPDenylistRegex
}

func (c *CreateInputSystemByPackInputHTTP) GetCriblAPI() *string {
	if c == nil {
		return nil
	}
	return c.CriblAPI
}

func (c *CreateInputSystemByPackInputHTTP) GetElasticAPI() *string {
	if c == nil {
		return nil
	}
	return c.ElasticAPI
}

func (c *CreateInputSystemByPackInputHTTP) GetSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.SplunkHecAPI
}

func (c *CreateInputSystemByPackInputHTTP) GetSplunkHecAcks() *bool {
	if c == nil {
		return nil
	}
	return c.SplunkHecAcks
}

func (c *CreateInputSystemByPackInputHTTP) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputHTTP) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if c == nil {
		return nil
	}
	return c.AuthTokensExt
}

func (c *CreateInputSystemByPackInputHTTP) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputHTTP) GetTemplateHost() *string {
	if c == nil {
		return nil
	}
	return c.TemplateHost
}

func (c *CreateInputSystemByPackInputHTTP) GetTemplatePort() *string {
	if c == nil {
		return nil
	}
	return c.TemplatePort
}

func (c *CreateInputSystemByPackInputHTTP) GetTemplateSplunkHecAPI() *string {
	if c == nil {
		return nil
	}
	return c.TemplateSplunkHecAPI
}

type CreateInputSystemByPackTypeMsk string

const (
	CreateInputSystemByPackTypeMskMsk CreateInputSystemByPackTypeMsk = "msk"
)

func (e CreateInputSystemByPackTypeMsk) ToPointer() *CreateInputSystemByPackTypeMsk {
	return &e
}
func (e *CreateInputSystemByPackTypeMsk) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "msk":
		*e = CreateInputSystemByPackTypeMsk(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeMsk: %v", v)
	}
}

type CreateInputSystemByPackInputMsk struct {
	// Unique ID for this input
	ID       string                         `json:"id"`
	Type     CreateInputSystemByPackTypeMsk `json:"type"`
	Disabled *bool                          `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `json:"fromBeginning,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `json:"sessionTimeout,omitempty"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `json:"rebalanceTimeout,omitempty"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `json:"heartbeatInterval,omitempty"`
	// Fields to add to events from this input
	Metadata            []components.ItemsTypeNotificationMetadata        `json:"metadata,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `json:"maxRetries,omitempty"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `json:"maxBackOff,omitempty"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `json:"initialBackoff,omitempty"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `json:"backoffRate,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `json:"authenticationTimeout,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `json:"reauthenticationThreshold,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod components.AuthenticationMethodOptionsS3CollectorConf `json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                               `json:"awsSecretKey,omitempty"`
	// Region where the MSK cluster is located
	Region string `json:"region"`
	// MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing MSK cluster requests
	SignatureVersion *components.SignatureVersionOptions `json:"signatureVersion,omitempty"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64                                                 `json:"durationSeconds,omitempty"`
	TLS             *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `json:"maxBytesPerPartition,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `json:"maxBytes,omitempty"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `json:"maxSocketErrors,omitempty"`
	Description     *string  `json:"description,omitempty"`
	AwsAPIKey       *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime.
	TemplateAwsSecretKey *string `json:"__template_awsSecretKey,omitempty"`
	// Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime.
	TemplateRegion *string `json:"__template_region,omitempty"`
	// Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime.
	TemplateAssumeRoleArn *string `json:"__template_assumeRoleArn,omitempty"`
	// Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime.
	TemplateAssumeRoleExternalID *string `json:"__template_assumeRoleExternalId,omitempty"`
	// Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime.
	TemplateAwsAPIKey *string `json:"__template_awsApiKey,omitempty"`
}

func (c CreateInputSystemByPackInputMsk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputMsk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "brokers", "topics", "awsAuthenticationMethod", "region"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputMsk) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputMsk) GetType() CreateInputSystemByPackTypeMsk {
	if c == nil {
		return CreateInputSystemByPackTypeMsk("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputMsk) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputMsk) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputMsk) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputMsk) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputMsk) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputMsk) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputMsk) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputMsk) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputMsk) GetBrokers() []string {
	if c == nil {
		return []string{}
	}
	return c.Brokers
}

func (c *CreateInputSystemByPackInputMsk) GetTopics() []string {
	if c == nil {
		return []string{}
	}
	return c.Topics
}

func (c *CreateInputSystemByPackInputMsk) GetGroupID() *string {
	if c == nil {
		return nil
	}
	return c.GroupID
}

func (c *CreateInputSystemByPackInputMsk) GetFromBeginning() *bool {
	if c == nil {
		return nil
	}
	return c.FromBeginning
}

func (c *CreateInputSystemByPackInputMsk) GetSessionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SessionTimeout
}

func (c *CreateInputSystemByPackInputMsk) GetRebalanceTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RebalanceTimeout
}

func (c *CreateInputSystemByPackInputMsk) GetHeartbeatInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.HeartbeatInterval
}

func (c *CreateInputSystemByPackInputMsk) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputMsk) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if c == nil {
		return nil
	}
	return c.KafkaSchemaRegistry
}

func (c *CreateInputSystemByPackInputMsk) GetConnectionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ConnectionTimeout
}

func (c *CreateInputSystemByPackInputMsk) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputMsk) GetMaxRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRetries
}

func (c *CreateInputSystemByPackInputMsk) GetMaxBackOff() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBackOff
}

func (c *CreateInputSystemByPackInputMsk) GetInitialBackoff() *float64 {
	if c == nil {
		return nil
	}
	return c.InitialBackoff
}

func (c *CreateInputSystemByPackInputMsk) GetBackoffRate() *float64 {
	if c == nil {
		return nil
	}
	return c.BackoffRate
}

func (c *CreateInputSystemByPackInputMsk) GetAuthenticationTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.AuthenticationTimeout
}

func (c *CreateInputSystemByPackInputMsk) GetReauthenticationThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.ReauthenticationThreshold
}

func (c *CreateInputSystemByPackInputMsk) GetAwsAuthenticationMethod() components.AuthenticationMethodOptionsS3CollectorConf {
	if c == nil {
		return components.AuthenticationMethodOptionsS3CollectorConf("")
	}
	return c.AwsAuthenticationMethod
}

func (c *CreateInputSystemByPackInputMsk) GetAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecretKey
}

func (c *CreateInputSystemByPackInputMsk) GetRegion() string {
	if c == nil {
		return ""
	}
	return c.Region
}

func (c *CreateInputSystemByPackInputMsk) GetEndpoint() *string {
	if c == nil {
		return nil
	}
	return c.Endpoint
}

func (c *CreateInputSystemByPackInputMsk) GetSignatureVersion() *components.SignatureVersionOptions {
	if c == nil {
		return nil
	}
	return c.SignatureVersion
}

func (c *CreateInputSystemByPackInputMsk) GetReuseConnections() *bool {
	if c == nil {
		return nil
	}
	return c.ReuseConnections
}

func (c *CreateInputSystemByPackInputMsk) GetRejectUnauthorized() *bool {
	if c == nil {
		return nil
	}
	return c.RejectUnauthorized
}

func (c *CreateInputSystemByPackInputMsk) GetEnableAssumeRole() *bool {
	if c == nil {
		return nil
	}
	return c.EnableAssumeRole
}

func (c *CreateInputSystemByPackInputMsk) GetAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleArn
}

func (c *CreateInputSystemByPackInputMsk) GetAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.AssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputMsk) GetDurationSeconds() *float64 {
	if c == nil {
		return nil
	}
	return c.DurationSeconds
}

func (c *CreateInputSystemByPackInputMsk) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputMsk) GetAutoCommitInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitInterval
}

func (c *CreateInputSystemByPackInputMsk) GetAutoCommitThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitThreshold
}

func (c *CreateInputSystemByPackInputMsk) GetMaxBytesPerPartition() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytesPerPartition
}

func (c *CreateInputSystemByPackInputMsk) GetMaxBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytes
}

func (c *CreateInputSystemByPackInputMsk) GetMaxSocketErrors() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxSocketErrors
}

func (c *CreateInputSystemByPackInputMsk) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateInputSystemByPackInputMsk) GetAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.AwsAPIKey
}

func (c *CreateInputSystemByPackInputMsk) GetAwsSecret() *string {
	if c == nil {
		return nil
	}
	return c.AwsSecret
}

func (c *CreateInputSystemByPackInputMsk) GetTemplateAwsSecretKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsSecretKey
}

func (c *CreateInputSystemByPackInputMsk) GetTemplateRegion() *string {
	if c == nil {
		return nil
	}
	return c.TemplateRegion
}

func (c *CreateInputSystemByPackInputMsk) GetTemplateAssumeRoleArn() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleArn
}

func (c *CreateInputSystemByPackInputMsk) GetTemplateAssumeRoleExternalID() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAssumeRoleExternalID
}

func (c *CreateInputSystemByPackInputMsk) GetTemplateAwsAPIKey() *string {
	if c == nil {
		return nil
	}
	return c.TemplateAwsAPIKey
}

type CreateInputSystemByPackTypeKafka string

const (
	CreateInputSystemByPackTypeKafkaKafka CreateInputSystemByPackTypeKafka = "kafka"
)

func (e CreateInputSystemByPackTypeKafka) ToPointer() *CreateInputSystemByPackTypeKafka {
	return &e
}
func (e *CreateInputSystemByPackTypeKafka) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kafka":
		*e = CreateInputSystemByPackTypeKafka(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeKafka: %v", v)
	}
}

type CreateInputSystemByPackInputKafka struct {
	// Unique ID for this input
	ID       string                           `json:"id"`
	Type     CreateInputSystemByPackTypeKafka `json:"type"`
	Disabled *bool                            `json:"disabled,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `json:"fromBeginning,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `json:"connectionTimeout,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `json:"requestTimeout,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `json:"maxRetries,omitempty"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `json:"maxBackOff,omitempty"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `json:"initialBackoff,omitempty"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `json:"backoffRate,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `json:"authenticationTimeout,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `json:"reauthenticationThreshold,omitempty"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType                           `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `json:"sessionTimeout,omitempty"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `json:"rebalanceTimeout,omitempty"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `json:"heartbeatInterval,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `json:"maxBytesPerPartition,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `json:"maxBytes,omitempty"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `json:"maxSocketErrors,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (c CreateInputSystemByPackInputKafka) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputKafka) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputKafka) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputKafka) GetType() CreateInputSystemByPackTypeKafka {
	if c == nil {
		return CreateInputSystemByPackTypeKafka("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputKafka) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputKafka) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputKafka) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputKafka) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputKafka) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputKafka) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputKafka) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputKafka) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputKafka) GetBrokers() []string {
	if c == nil {
		return []string{}
	}
	return c.Brokers
}

func (c *CreateInputSystemByPackInputKafka) GetTopics() []string {
	if c == nil {
		return []string{}
	}
	return c.Topics
}

func (c *CreateInputSystemByPackInputKafka) GetGroupID() *string {
	if c == nil {
		return nil
	}
	return c.GroupID
}

func (c *CreateInputSystemByPackInputKafka) GetFromBeginning() *bool {
	if c == nil {
		return nil
	}
	return c.FromBeginning
}

func (c *CreateInputSystemByPackInputKafka) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if c == nil {
		return nil
	}
	return c.KafkaSchemaRegistry
}

func (c *CreateInputSystemByPackInputKafka) GetConnectionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.ConnectionTimeout
}

func (c *CreateInputSystemByPackInputKafka) GetRequestTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RequestTimeout
}

func (c *CreateInputSystemByPackInputKafka) GetMaxRetries() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRetries
}

func (c *CreateInputSystemByPackInputKafka) GetMaxBackOff() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBackOff
}

func (c *CreateInputSystemByPackInputKafka) GetInitialBackoff() *float64 {
	if c == nil {
		return nil
	}
	return c.InitialBackoff
}

func (c *CreateInputSystemByPackInputKafka) GetBackoffRate() *float64 {
	if c == nil {
		return nil
	}
	return c.BackoffRate
}

func (c *CreateInputSystemByPackInputKafka) GetAuthenticationTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.AuthenticationTimeout
}

func (c *CreateInputSystemByPackInputKafka) GetReauthenticationThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.ReauthenticationThreshold
}

func (c *CreateInputSystemByPackInputKafka) GetSasl() *components.AuthenticationType {
	if c == nil {
		return nil
	}
	return c.Sasl
}

func (c *CreateInputSystemByPackInputKafka) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if c == nil {
		return nil
	}
	return c.TLS
}

func (c *CreateInputSystemByPackInputKafka) GetSessionTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.SessionTimeout
}

func (c *CreateInputSystemByPackInputKafka) GetRebalanceTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.RebalanceTimeout
}

func (c *CreateInputSystemByPackInputKafka) GetHeartbeatInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.HeartbeatInterval
}

func (c *CreateInputSystemByPackInputKafka) GetAutoCommitInterval() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitInterval
}

func (c *CreateInputSystemByPackInputKafka) GetAutoCommitThreshold() *float64 {
	if c == nil {
		return nil
	}
	return c.AutoCommitThreshold
}

func (c *CreateInputSystemByPackInputKafka) GetMaxBytesPerPartition() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytesPerPartition
}

func (c *CreateInputSystemByPackInputKafka) GetMaxBytes() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxBytes
}

func (c *CreateInputSystemByPackInputKafka) GetMaxSocketErrors() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxSocketErrors
}

func (c *CreateInputSystemByPackInputKafka) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputKafka) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

type CreateInputSystemByPackTypeCollection string

const (
	CreateInputSystemByPackTypeCollectionCollection CreateInputSystemByPackTypeCollection = "collection"
)

func (e CreateInputSystemByPackTypeCollection) ToPointer() *CreateInputSystemByPackTypeCollection {
	return &e
}
func (e *CreateInputSystemByPackTypeCollection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "collection":
		*e = CreateInputSystemByPackTypeCollection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateInputSystemByPackTypeCollection: %v", v)
	}
}

type CreateInputSystemByPackInputCollection struct {
	// Unique ID for this input
	ID       string                                `json:"id"`
	Type     CreateInputSystemByPackTypeCollection `json:"type"`
	Disabled *bool                                 `json:"disabled,omitempty"`
	// Pipeline to process results
	Pipeline *string `json:"pipeline,omitempty"`
	// Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnectionsOptional `json:"connections,omitempty"`
	Pq          *components.PqType                        `json:"pq,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64                                          `json:"staleChannelFlushMs,omitempty"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `json:"throttleRatePerSec,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Destination to send results to
	Output *string `json:"output,omitempty"`
}

func (c CreateInputSystemByPackInputCollection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateInputSystemByPackInputCollection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (c *CreateInputSystemByPackInputCollection) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CreateInputSystemByPackInputCollection) GetType() CreateInputSystemByPackTypeCollection {
	if c == nil {
		return CreateInputSystemByPackTypeCollection("")
	}
	return c.Type
}

func (c *CreateInputSystemByPackInputCollection) GetDisabled() *bool {
	if c == nil {
		return nil
	}
	return c.Disabled
}

func (c *CreateInputSystemByPackInputCollection) GetPipeline() *string {
	if c == nil {
		return nil
	}
	return c.Pipeline
}

func (c *CreateInputSystemByPackInputCollection) GetSendToRoutes() *bool {
	if c == nil {
		return nil
	}
	return c.SendToRoutes
}

func (c *CreateInputSystemByPackInputCollection) GetEnvironment() *string {
	if c == nil {
		return nil
	}
	return c.Environment
}

func (c *CreateInputSystemByPackInputCollection) GetPqEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.PqEnabled
}

func (c *CreateInputSystemByPackInputCollection) GetStreamtags() []string {
	if c == nil {
		return nil
	}
	return c.Streamtags
}

func (c *CreateInputSystemByPackInputCollection) GetConnections() []components.ItemsTypeConnectionsOptional {
	if c == nil {
		return nil
	}
	return c.Connections
}

func (c *CreateInputSystemByPackInputCollection) GetPq() *components.PqType {
	if c == nil {
		return nil
	}
	return c.Pq
}

func (c *CreateInputSystemByPackInputCollection) GetBreakerRulesets() []string {
	if c == nil {
		return nil
	}
	return c.BreakerRulesets
}

func (c *CreateInputSystemByPackInputCollection) GetStaleChannelFlushMs() *float64 {
	if c == nil {
		return nil
	}
	return c.StaleChannelFlushMs
}

func (c *CreateInputSystemByPackInputCollection) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if c == nil {
		return nil
	}
	return c.Preprocess
}

func (c *CreateInputSystemByPackInputCollection) GetThrottleRatePerSec() *string {
	if c == nil {
		return nil
	}
	return c.ThrottleRatePerSec
}

func (c *CreateInputSystemByPackInputCollection) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateInputSystemByPackInputCollection) GetOutput() *string {
	if c == nil {
		return nil
	}
	return c.Output
}

type CreateInputSystemByPackRequestBodyType string

const (
	CreateInputSystemByPackRequestBodyTypeCollection           CreateInputSystemByPackRequestBodyType = "collection"
	CreateInputSystemByPackRequestBodyTypeKafka                CreateInputSystemByPackRequestBodyType = "kafka"
	CreateInputSystemByPackRequestBodyTypeMsk                  CreateInputSystemByPackRequestBodyType = "msk"
	CreateInputSystemByPackRequestBodyTypeHTTP                 CreateInputSystemByPackRequestBodyType = "http"
	CreateInputSystemByPackRequestBodyTypeSplunk               CreateInputSystemByPackRequestBodyType = "splunk"
	CreateInputSystemByPackRequestBodyTypeSplunkSearch         CreateInputSystemByPackRequestBodyType = "splunk_search"
	CreateInputSystemByPackRequestBodyTypeSplunkHec            CreateInputSystemByPackRequestBodyType = "splunk_hec"
	CreateInputSystemByPackRequestBodyTypeAzureBlob            CreateInputSystemByPackRequestBodyType = "azure_blob"
	CreateInputSystemByPackRequestBodyTypeElastic              CreateInputSystemByPackRequestBodyType = "elastic"
	CreateInputSystemByPackRequestBodyTypeConfluentCloud       CreateInputSystemByPackRequestBodyType = "confluent_cloud"
	CreateInputSystemByPackRequestBodyTypeGrafana              CreateInputSystemByPackRequestBodyType = "grafana"
	CreateInputSystemByPackRequestBodyTypeLoki                 CreateInputSystemByPackRequestBodyType = "loki"
	CreateInputSystemByPackRequestBodyTypePrometheusRw         CreateInputSystemByPackRequestBodyType = "prometheus_rw"
	CreateInputSystemByPackRequestBodyTypePrometheus           CreateInputSystemByPackRequestBodyType = "prometheus"
	CreateInputSystemByPackRequestBodyTypeEdgePrometheus       CreateInputSystemByPackRequestBodyType = "edge_prometheus"
	CreateInputSystemByPackRequestBodyTypeOffice365Mgmt        CreateInputSystemByPackRequestBodyType = "office365_mgmt"
	CreateInputSystemByPackRequestBodyTypeOffice365Service     CreateInputSystemByPackRequestBodyType = "office365_service"
	CreateInputSystemByPackRequestBodyTypeOffice365MsgTrace    CreateInputSystemByPackRequestBodyType = "office365_msg_trace"
	CreateInputSystemByPackRequestBodyTypeEventhub             CreateInputSystemByPackRequestBodyType = "eventhub"
	CreateInputSystemByPackRequestBodyTypeExec                 CreateInputSystemByPackRequestBodyType = "exec"
	CreateInputSystemByPackRequestBodyTypeFirehose             CreateInputSystemByPackRequestBodyType = "firehose"
	CreateInputSystemByPackRequestBodyTypeGooglePubsub         CreateInputSystemByPackRequestBodyType = "google_pubsub"
	CreateInputSystemByPackRequestBodyTypeCribl                CreateInputSystemByPackRequestBodyType = "cribl"
	CreateInputSystemByPackRequestBodyTypeCriblTCP             CreateInputSystemByPackRequestBodyType = "cribl_tcp"
	CreateInputSystemByPackRequestBodyTypeCriblHTTP            CreateInputSystemByPackRequestBodyType = "cribl_http"
	CreateInputSystemByPackRequestBodyTypeCriblLakeHTTP        CreateInputSystemByPackRequestBodyType = "cribl_lake_http"
	CreateInputSystemByPackRequestBodyTypeTcpjson              CreateInputSystemByPackRequestBodyType = "tcpjson"
	CreateInputSystemByPackRequestBodyTypeSystemMetrics        CreateInputSystemByPackRequestBodyType = "system_metrics"
	CreateInputSystemByPackRequestBodyTypeSystemState          CreateInputSystemByPackRequestBodyType = "system_state"
	CreateInputSystemByPackRequestBodyTypeKubeMetrics          CreateInputSystemByPackRequestBodyType = "kube_metrics"
	CreateInputSystemByPackRequestBodyTypeKubeLogs             CreateInputSystemByPackRequestBodyType = "kube_logs"
	CreateInputSystemByPackRequestBodyTypeKubeEvents           CreateInputSystemByPackRequestBodyType = "kube_events"
	CreateInputSystemByPackRequestBodyTypeWindowsMetrics       CreateInputSystemByPackRequestBodyType = "windows_metrics"
	CreateInputSystemByPackRequestBodyTypeCrowdstrike          CreateInputSystemByPackRequestBodyType = "crowdstrike"
	CreateInputSystemByPackRequestBodyTypeDatadogAgent         CreateInputSystemByPackRequestBodyType = "datadog_agent"
	CreateInputSystemByPackRequestBodyTypeDatagen              CreateInputSystemByPackRequestBodyType = "datagen"
	CreateInputSystemByPackRequestBodyTypeHTTPRaw              CreateInputSystemByPackRequestBodyType = "http_raw"
	CreateInputSystemByPackRequestBodyTypeKinesis              CreateInputSystemByPackRequestBodyType = "kinesis"
	CreateInputSystemByPackRequestBodyTypeCriblmetrics         CreateInputSystemByPackRequestBodyType = "criblmetrics"
	CreateInputSystemByPackRequestBodyTypeMetrics              CreateInputSystemByPackRequestBodyType = "metrics"
	CreateInputSystemByPackRequestBodyTypeS3                   CreateInputSystemByPackRequestBodyType = "s3"
	CreateInputSystemByPackRequestBodyTypeS3Inventory          CreateInputSystemByPackRequestBodyType = "s3_inventory"
	CreateInputSystemByPackRequestBodyTypeSnmp                 CreateInputSystemByPackRequestBodyType = "snmp"
	CreateInputSystemByPackRequestBodyTypeOpenTelemetry        CreateInputSystemByPackRequestBodyType = "open_telemetry"
	CreateInputSystemByPackRequestBodyTypeModelDrivenTelemetry CreateInputSystemByPackRequestBodyType = "model_driven_telemetry"
	CreateInputSystemByPackRequestBodyTypeSqs                  CreateInputSystemByPackRequestBodyType = "sqs"
	CreateInputSystemByPackRequestBodyTypeSyslog               CreateInputSystemByPackRequestBodyType = "syslog"
	CreateInputSystemByPackRequestBodyTypeFile                 CreateInputSystemByPackRequestBodyType = "file"
	CreateInputSystemByPackRequestBodyTypeTCP                  CreateInputSystemByPackRequestBodyType = "tcp"
	CreateInputSystemByPackRequestBodyTypeAppscope             CreateInputSystemByPackRequestBodyType = "appscope"
	CreateInputSystemByPackRequestBodyTypeWef                  CreateInputSystemByPackRequestBodyType = "wef"
	CreateInputSystemByPackRequestBodyTypeWinEventLogs         CreateInputSystemByPackRequestBodyType = "win_event_logs"
	CreateInputSystemByPackRequestBodyTypeRawUDP               CreateInputSystemByPackRequestBodyType = "raw_udp"
	CreateInputSystemByPackRequestBodyTypeJournalFiles         CreateInputSystemByPackRequestBodyType = "journal_files"
	CreateInputSystemByPackRequestBodyTypeWiz                  CreateInputSystemByPackRequestBodyType = "wiz"
	CreateInputSystemByPackRequestBodyTypeWizWebhook           CreateInputSystemByPackRequestBodyType = "wiz_webhook"
	CreateInputSystemByPackRequestBodyTypeNetflow              CreateInputSystemByPackRequestBodyType = "netflow"
	CreateInputSystemByPackRequestBodyTypeSecurityLake         CreateInputSystemByPackRequestBodyType = "security_lake"
	CreateInputSystemByPackRequestBodyTypeZscalerHec           CreateInputSystemByPackRequestBodyType = "zscaler_hec"
	CreateInputSystemByPackRequestBodyTypeCloudflareHec        CreateInputSystemByPackRequestBodyType = "cloudflare_hec"
)

// CreateInputSystemByPackRequestBody - Input object
type CreateInputSystemByPackRequestBody struct {
	CreateInputSystemByPackInputCollection           *CreateInputSystemByPackInputCollection           `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputKafka                *CreateInputSystemByPackInputKafka                `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputMsk                  *CreateInputSystemByPackInputMsk                  `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputHTTP                 *CreateInputSystemByPackInputHTTP                 `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSplunk               *CreateInputSystemByPackInputSplunk               `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSplunkSearch         *CreateInputSystemByPackInputSplunkSearch         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSplunkHec            *CreateInputSystemByPackInputSplunkHec            `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputAzureBlob            *CreateInputSystemByPackInputAzureBlob            `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputElastic              *CreateInputSystemByPackInputElastic              `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputConfluentCloud       *CreateInputSystemByPackInputConfluentCloud       `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputGrafanaUnion         *CreateInputSystemByPackInputGrafanaUnion         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputLoki                 *CreateInputSystemByPackInputLoki                 `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputPrometheusRw         *CreateInputSystemByPackInputPrometheusRw         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputPrometheus           *CreateInputSystemByPackInputPrometheus           `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputEdgePrometheus       *CreateInputSystemByPackInputEdgePrometheus       `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputOffice365Mgmt        *CreateInputSystemByPackInputOffice365Mgmt        `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputOffice365Service     *CreateInputSystemByPackInputOffice365Service     `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputOffice365MsgTrace    *CreateInputSystemByPackInputOffice365MsgTrace    `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputEventhub             *CreateInputSystemByPackInputEventhub             `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputExec                 *CreateInputSystemByPackInputExec                 `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputFirehose             *CreateInputSystemByPackInputFirehose             `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputGooglePubsub         *CreateInputSystemByPackInputGooglePubsub         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputCribl                *CreateInputSystemByPackInputCribl                `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputCriblTCP             *CreateInputSystemByPackInputCriblTCP             `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputCriblHTTP            *CreateInputSystemByPackInputCriblHTTP            `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputCriblLakeHTTP        *CreateInputSystemByPackInputCriblLakeHTTP        `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputTcpjson              *CreateInputSystemByPackInputTcpjson              `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSystemMetrics        *CreateInputSystemByPackInputSystemMetrics        `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSystemState          *CreateInputSystemByPackInputSystemState          `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputKubeMetrics          *CreateInputSystemByPackInputKubeMetrics          `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputKubeLogs             *CreateInputSystemByPackInputKubeLogs             `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputKubeEvents           *CreateInputSystemByPackInputKubeEvents           `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputWindowsMetrics       *CreateInputSystemByPackInputWindowsMetrics       `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputCrowdstrike          *CreateInputSystemByPackInputCrowdstrike          `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputDatadogAgent         *CreateInputSystemByPackInputDatadogAgent         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputDatagen              *CreateInputSystemByPackInputDatagen              `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputHTTPRaw              *CreateInputSystemByPackInputHTTPRaw              `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputKinesis              *CreateInputSystemByPackInputKinesis              `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputCriblmetrics         *CreateInputSystemByPackInputCriblmetrics         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputMetrics              *CreateInputSystemByPackInputMetrics              `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputS3                   *CreateInputSystemByPackInputS3                   `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputS3Inventory          *CreateInputSystemByPackInputS3Inventory          `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSnmp                 *CreateInputSystemByPackInputSnmp                 `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputOpenTelemetry        *CreateInputSystemByPackInputOpenTelemetry        `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputModelDrivenTelemetry *CreateInputSystemByPackInputModelDrivenTelemetry `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSqs                  *CreateInputSystemByPackInputSqs                  `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSyslogUnion          *CreateInputSystemByPackInputSyslogUnion          `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputFile                 *CreateInputSystemByPackInputFile                 `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputTCP                  *CreateInputSystemByPackInputTCP                  `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputAppscope             *CreateInputSystemByPackInputAppscope             `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputWef                  *CreateInputSystemByPackInputWef                  `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputWinEventLogs         *CreateInputSystemByPackInputWinEventLogs         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputRawUDP               *CreateInputSystemByPackInputRawUDP               `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputJournalFiles         *CreateInputSystemByPackInputJournalFiles         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputWiz                  *CreateInputSystemByPackInputWiz                  `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputWizWebhook           *CreateInputSystemByPackInputWizWebhook           `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputNetflow              *CreateInputSystemByPackInputNetflow              `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputSecurityLake         *CreateInputSystemByPackInputSecurityLake         `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputZscalerHec           *CreateInputSystemByPackInputZscalerHec           `queryParam:"inline" union:"member"`
	CreateInputSystemByPackInputCloudflareHec        *CreateInputSystemByPackInputCloudflareHec        `queryParam:"inline" union:"member"`

	Type CreateInputSystemByPackRequestBodyType
}

func CreateCreateInputSystemByPackRequestBodyCollection(collection CreateInputSystemByPackInputCollection) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeCollection

	typStr := CreateInputSystemByPackTypeCollection(typ)
	collection.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputCollection: &collection,
		Type:                                   typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyKafka(kafka CreateInputSystemByPackInputKafka) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeKafka

	typStr := CreateInputSystemByPackTypeKafka(typ)
	kafka.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputKafka: &kafka,
		Type:                              typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyMsk(msk CreateInputSystemByPackInputMsk) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeMsk

	typStr := CreateInputSystemByPackTypeMsk(typ)
	msk.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputMsk: &msk,
		Type:                            typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyHTTP(http CreateInputSystemByPackInputHTTP) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeHTTP

	typStr := CreateInputSystemByPackTypeHTTP(typ)
	http.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputHTTP: &http,
		Type:                             typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySplunk(splunk CreateInputSystemByPackInputSplunk) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSplunk

	typStr := CreateInputSystemByPackTypeSplunk(typ)
	splunk.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSplunk: &splunk,
		Type:                               typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySplunkSearch(splunkSearch CreateInputSystemByPackInputSplunkSearch) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSplunkSearch

	typStr := CreateInputSystemByPackTypeSplunkSearch(typ)
	splunkSearch.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSplunkSearch: &splunkSearch,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySplunkHec(splunkHec CreateInputSystemByPackInputSplunkHec) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSplunkHec

	typStr := CreateInputSystemByPackTypeSplunkHec(typ)
	splunkHec.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSplunkHec: &splunkHec,
		Type:                                  typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyAzureBlob(azureBlob CreateInputSystemByPackInputAzureBlob) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeAzureBlob

	typStr := CreateInputSystemByPackTypeAzureBlob(typ)
	azureBlob.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputAzureBlob: &azureBlob,
		Type:                                  typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyElastic(elastic CreateInputSystemByPackInputElastic) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeElastic

	typStr := CreateInputSystemByPackTypeElastic(typ)
	elastic.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputElastic: &elastic,
		Type:                                typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyConfluentCloud(confluentCloud CreateInputSystemByPackInputConfluentCloud) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeConfluentCloud

	typStr := CreateInputSystemByPackTypeConfluentCloud(typ)
	confluentCloud.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputConfluentCloud: &confluentCloud,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyGrafana(grafana CreateInputSystemByPackInputGrafanaUnion) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeGrafana

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputGrafanaUnion: &grafana,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyLoki(loki CreateInputSystemByPackInputLoki) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeLoki

	typStr := CreateInputSystemByPackTypeLoki(typ)
	loki.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputLoki: &loki,
		Type:                             typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyPrometheusRw(prometheusRw CreateInputSystemByPackInputPrometheusRw) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypePrometheusRw

	typStr := CreateInputSystemByPackTypePrometheusRw(typ)
	prometheusRw.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputPrometheusRw: &prometheusRw,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyPrometheus(prometheus CreateInputSystemByPackInputPrometheus) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypePrometheus

	typStr := CreateInputSystemByPackTypePrometheus(typ)
	prometheus.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputPrometheus: &prometheus,
		Type:                                   typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyEdgePrometheus(edgePrometheus CreateInputSystemByPackInputEdgePrometheus) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeEdgePrometheus

	typStr := CreateInputSystemByPackTypeEdgePrometheus(typ)
	edgePrometheus.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputEdgePrometheus: &edgePrometheus,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyOffice365Mgmt(office365Mgmt CreateInputSystemByPackInputOffice365Mgmt) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeOffice365Mgmt

	typStr := CreateInputSystemByPackTypeOffice365Mgmt(typ)
	office365Mgmt.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputOffice365Mgmt: &office365Mgmt,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyOffice365Service(office365Service CreateInputSystemByPackInputOffice365Service) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeOffice365Service

	typStr := CreateInputSystemByPackTypeOffice365Service(typ)
	office365Service.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputOffice365Service: &office365Service,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyOffice365MsgTrace(office365MsgTrace CreateInputSystemByPackInputOffice365MsgTrace) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeOffice365MsgTrace

	typStr := CreateInputSystemByPackTypeOffice365MsgTrace(typ)
	office365MsgTrace.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputOffice365MsgTrace: &office365MsgTrace,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyEventhub(eventhub CreateInputSystemByPackInputEventhub) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeEventhub

	typStr := CreateInputSystemByPackTypeEventhub(typ)
	eventhub.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputEventhub: &eventhub,
		Type:                                 typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyExec(exec CreateInputSystemByPackInputExec) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeExec

	typStr := CreateInputSystemByPackInputExecType(typ)
	exec.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputExec: &exec,
		Type:                             typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyFirehose(firehose CreateInputSystemByPackInputFirehose) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeFirehose

	typStr := CreateInputSystemByPackTypeFirehose(typ)
	firehose.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputFirehose: &firehose,
		Type:                                 typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyGooglePubsub(googlePubsub CreateInputSystemByPackInputGooglePubsub) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeGooglePubsub

	typStr := CreateInputSystemByPackTypeGooglePubsub(typ)
	googlePubsub.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputGooglePubsub: &googlePubsub,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyCribl(cribl CreateInputSystemByPackInputCribl) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeCribl

	typStr := CreateInputSystemByPackTypeCribl(typ)
	cribl.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputCribl: &cribl,
		Type:                              typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyCriblTCP(criblTCP CreateInputSystemByPackInputCriblTCP) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeCriblTCP

	typStr := CreateInputSystemByPackTypeCriblTCP(typ)
	criblTCP.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputCriblTCP: &criblTCP,
		Type:                                 typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyCriblHTTP(criblHTTP CreateInputSystemByPackInputCriblHTTP) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeCriblHTTP

	typStr := CreateInputSystemByPackTypeCriblHTTP(typ)
	criblHTTP.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputCriblHTTP: &criblHTTP,
		Type:                                  typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyCriblLakeHTTP(criblLakeHTTP CreateInputSystemByPackInputCriblLakeHTTP) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeCriblLakeHTTP

	typStr := CreateInputSystemByPackTypeCriblLakeHTTP(typ)
	criblLakeHTTP.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputCriblLakeHTTP: &criblLakeHTTP,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyTcpjson(tcpjson CreateInputSystemByPackInputTcpjson) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeTcpjson

	typStr := CreateInputSystemByPackTypeTcpjson(typ)
	tcpjson.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputTcpjson: &tcpjson,
		Type:                                typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySystemMetrics(systemMetrics CreateInputSystemByPackInputSystemMetrics) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSystemMetrics

	typStr := CreateInputSystemByPackTypeSystemMetrics(typ)
	systemMetrics.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSystemMetrics: &systemMetrics,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySystemState(systemState CreateInputSystemByPackInputSystemState) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSystemState

	typStr := CreateInputSystemByPackTypeSystemState(typ)
	systemState.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSystemState: &systemState,
		Type:                                    typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyKubeMetrics(kubeMetrics CreateInputSystemByPackInputKubeMetrics) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeKubeMetrics

	typStr := CreateInputSystemByPackTypeKubeMetrics(typ)
	kubeMetrics.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputKubeMetrics: &kubeMetrics,
		Type:                                    typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyKubeLogs(kubeLogs CreateInputSystemByPackInputKubeLogs) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeKubeLogs

	typStr := CreateInputSystemByPackTypeKubeLogs(typ)
	kubeLogs.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputKubeLogs: &kubeLogs,
		Type:                                 typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyKubeEvents(kubeEvents CreateInputSystemByPackInputKubeEvents) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeKubeEvents

	typStr := CreateInputSystemByPackTypeKubeEvents(typ)
	kubeEvents.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputKubeEvents: &kubeEvents,
		Type:                                   typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyWindowsMetrics(windowsMetrics CreateInputSystemByPackInputWindowsMetrics) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeWindowsMetrics

	typStr := CreateInputSystemByPackTypeWindowsMetrics(typ)
	windowsMetrics.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputWindowsMetrics: &windowsMetrics,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyCrowdstrike(crowdstrike CreateInputSystemByPackInputCrowdstrike) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeCrowdstrike

	typStr := CreateInputSystemByPackTypeCrowdstrike(typ)
	crowdstrike.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputCrowdstrike: &crowdstrike,
		Type:                                    typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyDatadogAgent(datadogAgent CreateInputSystemByPackInputDatadogAgent) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeDatadogAgent

	typStr := CreateInputSystemByPackTypeDatadogAgent(typ)
	datadogAgent.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputDatadogAgent: &datadogAgent,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyDatagen(datagen CreateInputSystemByPackInputDatagen) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeDatagen

	typStr := CreateInputSystemByPackTypeDatagen(typ)
	datagen.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputDatagen: &datagen,
		Type:                                typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyHTTPRaw(httpRaw CreateInputSystemByPackInputHTTPRaw) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeHTTPRaw

	typStr := CreateInputSystemByPackTypeHTTPRaw(typ)
	httpRaw.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputHTTPRaw: &httpRaw,
		Type:                                typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyKinesis(kinesis CreateInputSystemByPackInputKinesis) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeKinesis

	typStr := CreateInputSystemByPackTypeKinesis(typ)
	kinesis.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputKinesis: &kinesis,
		Type:                                typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyCriblmetrics(criblmetrics CreateInputSystemByPackInputCriblmetrics) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeCriblmetrics

	typStr := CreateInputSystemByPackTypeCriblmetrics(typ)
	criblmetrics.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputCriblmetrics: &criblmetrics,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyMetrics(metrics CreateInputSystemByPackInputMetrics) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeMetrics

	typStr := CreateInputSystemByPackTypeMetrics(typ)
	metrics.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputMetrics: &metrics,
		Type:                                typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyS3(s3 CreateInputSystemByPackInputS3) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeS3

	typStr := CreateInputSystemByPackTypeS3(typ)
	s3.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputS3: &s3,
		Type:                           typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyS3Inventory(s3Inventory CreateInputSystemByPackInputS3Inventory) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeS3Inventory

	typStr := CreateInputSystemByPackTypeS3Inventory(typ)
	s3Inventory.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputS3Inventory: &s3Inventory,
		Type:                                    typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySnmp(snmp CreateInputSystemByPackInputSnmp) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSnmp

	typStr := CreateInputSystemByPackTypeSnmp(typ)
	snmp.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSnmp: &snmp,
		Type:                             typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyOpenTelemetry(openTelemetry CreateInputSystemByPackInputOpenTelemetry) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeOpenTelemetry

	typStr := CreateInputSystemByPackTypeOpenTelemetry(typ)
	openTelemetry.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputOpenTelemetry: &openTelemetry,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyModelDrivenTelemetry(modelDrivenTelemetry CreateInputSystemByPackInputModelDrivenTelemetry) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeModelDrivenTelemetry

	typStr := CreateInputSystemByPackTypeModelDrivenTelemetry(typ)
	modelDrivenTelemetry.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputModelDrivenTelemetry: &modelDrivenTelemetry,
		Type: typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySqs(sqs CreateInputSystemByPackInputSqs) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSqs

	typStr := CreateInputSystemByPackTypeSqs(typ)
	sqs.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSqs: &sqs,
		Type:                            typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySyslog(syslog CreateInputSystemByPackInputSyslogUnion) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSyslog

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSyslogUnion: &syslog,
		Type:                                    typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyFile(file CreateInputSystemByPackInputFile) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeFile

	typStr := CreateInputSystemByPackInputFileType(typ)
	file.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputFile: &file,
		Type:                             typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyTCP(tcp CreateInputSystemByPackInputTCP) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeTCP

	typStr := CreateInputSystemByPackTypeTCP(typ)
	tcp.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputTCP: &tcp,
		Type:                            typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyAppscope(appscope CreateInputSystemByPackInputAppscope) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeAppscope

	typStr := CreateInputSystemByPackTypeAppscope(typ)
	appscope.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputAppscope: &appscope,
		Type:                                 typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyWef(wef CreateInputSystemByPackInputWef) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeWef

	typStr := CreateInputSystemByPackTypeWef(typ)
	wef.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputWef: &wef,
		Type:                            typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyWinEventLogs(winEventLogs CreateInputSystemByPackInputWinEventLogs) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeWinEventLogs

	typStr := CreateInputSystemByPackTypeWinEventLogs(typ)
	winEventLogs.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputWinEventLogs: &winEventLogs,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyRawUDP(rawUDP CreateInputSystemByPackInputRawUDP) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeRawUDP

	typStr := CreateInputSystemByPackTypeRawUDP(typ)
	rawUDP.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputRawUDP: &rawUDP,
		Type:                               typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyJournalFiles(journalFiles CreateInputSystemByPackInputJournalFiles) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeJournalFiles

	typStr := CreateInputSystemByPackInputJournalFilesType(typ)
	journalFiles.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputJournalFiles: &journalFiles,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyWiz(wiz CreateInputSystemByPackInputWiz) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeWiz

	typStr := CreateInputSystemByPackTypeWiz(typ)
	wiz.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputWiz: &wiz,
		Type:                            typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyWizWebhook(wizWebhook CreateInputSystemByPackInputWizWebhook) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeWizWebhook

	typStr := CreateInputSystemByPackTypeWizWebhook(typ)
	wizWebhook.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputWizWebhook: &wizWebhook,
		Type:                                   typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyNetflow(netflow CreateInputSystemByPackInputNetflow) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeNetflow

	typStr := CreateInputSystemByPackTypeNetflow(typ)
	netflow.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputNetflow: &netflow,
		Type:                                typ,
	}
}

func CreateCreateInputSystemByPackRequestBodySecurityLake(securityLake CreateInputSystemByPackInputSecurityLake) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeSecurityLake

	typStr := CreateInputSystemByPackTypeSecurityLake(typ)
	securityLake.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputSecurityLake: &securityLake,
		Type:                                     typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyZscalerHec(zscalerHec CreateInputSystemByPackInputZscalerHec) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeZscalerHec

	typStr := CreateInputSystemByPackTypeZscalerHec(typ)
	zscalerHec.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputZscalerHec: &zscalerHec,
		Type:                                   typ,
	}
}

func CreateCreateInputSystemByPackRequestBodyCloudflareHec(cloudflareHec CreateInputSystemByPackInputCloudflareHec) CreateInputSystemByPackRequestBody {
	typ := CreateInputSystemByPackRequestBodyTypeCloudflareHec

	typStr := CreateInputSystemByPackTypeCloudflareHec(typ)
	cloudflareHec.Type = typStr

	return CreateInputSystemByPackRequestBody{
		CreateInputSystemByPackInputCloudflareHec: &cloudflareHec,
		Type: typ,
	}
}

func (u *CreateInputSystemByPackRequestBody) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "collection":
		createInputSystemByPackInputCollection := new(CreateInputSystemByPackInputCollection)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputCollection, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == collection) type CreateInputSystemByPackInputCollection within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputCollection = createInputSystemByPackInputCollection
		u.Type = CreateInputSystemByPackRequestBodyTypeCollection
		return nil
	case "kafka":
		createInputSystemByPackInputKafka := new(CreateInputSystemByPackInputKafka)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputKafka, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kafka) type CreateInputSystemByPackInputKafka within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputKafka = createInputSystemByPackInputKafka
		u.Type = CreateInputSystemByPackRequestBodyTypeKafka
		return nil
	case "msk":
		createInputSystemByPackInputMsk := new(CreateInputSystemByPackInputMsk)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputMsk, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == msk) type CreateInputSystemByPackInputMsk within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputMsk = createInputSystemByPackInputMsk
		u.Type = CreateInputSystemByPackRequestBodyTypeMsk
		return nil
	case "http":
		createInputSystemByPackInputHTTP := new(CreateInputSystemByPackInputHTTP)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http) type CreateInputSystemByPackInputHTTP within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputHTTP = createInputSystemByPackInputHTTP
		u.Type = CreateInputSystemByPackRequestBodyTypeHTTP
		return nil
	case "splunk":
		createInputSystemByPackInputSplunk := new(CreateInputSystemByPackInputSplunk)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSplunk, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk) type CreateInputSystemByPackInputSplunk within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSplunk = createInputSystemByPackInputSplunk
		u.Type = CreateInputSystemByPackRequestBodyTypeSplunk
		return nil
	case "splunk_search":
		createInputSystemByPackInputSplunkSearch := new(CreateInputSystemByPackInputSplunkSearch)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSplunkSearch, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk_search) type CreateInputSystemByPackInputSplunkSearch within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSplunkSearch = createInputSystemByPackInputSplunkSearch
		u.Type = CreateInputSystemByPackRequestBodyTypeSplunkSearch
		return nil
	case "splunk_hec":
		createInputSystemByPackInputSplunkHec := new(CreateInputSystemByPackInputSplunkHec)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSplunkHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk_hec) type CreateInputSystemByPackInputSplunkHec within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSplunkHec = createInputSystemByPackInputSplunkHec
		u.Type = CreateInputSystemByPackRequestBodyTypeSplunkHec
		return nil
	case "azure_blob":
		createInputSystemByPackInputAzureBlob := new(CreateInputSystemByPackInputAzureBlob)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputAzureBlob, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == azure_blob) type CreateInputSystemByPackInputAzureBlob within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputAzureBlob = createInputSystemByPackInputAzureBlob
		u.Type = CreateInputSystemByPackRequestBodyTypeAzureBlob
		return nil
	case "elastic":
		createInputSystemByPackInputElastic := new(CreateInputSystemByPackInputElastic)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputElastic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == elastic) type CreateInputSystemByPackInputElastic within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputElastic = createInputSystemByPackInputElastic
		u.Type = CreateInputSystemByPackRequestBodyTypeElastic
		return nil
	case "confluent_cloud":
		createInputSystemByPackInputConfluentCloud := new(CreateInputSystemByPackInputConfluentCloud)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputConfluentCloud, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == confluent_cloud) type CreateInputSystemByPackInputConfluentCloud within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputConfluentCloud = createInputSystemByPackInputConfluentCloud
		u.Type = CreateInputSystemByPackRequestBodyTypeConfluentCloud
		return nil
	case "grafana":
		createInputSystemByPackInputGrafanaUnion := new(CreateInputSystemByPackInputGrafanaUnion)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputGrafanaUnion, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == grafana) type CreateInputSystemByPackInputGrafanaUnion within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputGrafanaUnion = createInputSystemByPackInputGrafanaUnion
		u.Type = CreateInputSystemByPackRequestBodyTypeGrafana
		return nil
	case "loki":
		createInputSystemByPackInputLoki := new(CreateInputSystemByPackInputLoki)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputLoki, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == loki) type CreateInputSystemByPackInputLoki within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputLoki = createInputSystemByPackInputLoki
		u.Type = CreateInputSystemByPackRequestBodyTypeLoki
		return nil
	case "prometheus_rw":
		createInputSystemByPackInputPrometheusRw := new(CreateInputSystemByPackInputPrometheusRw)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputPrometheusRw, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == prometheus_rw) type CreateInputSystemByPackInputPrometheusRw within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputPrometheusRw = createInputSystemByPackInputPrometheusRw
		u.Type = CreateInputSystemByPackRequestBodyTypePrometheusRw
		return nil
	case "prometheus":
		createInputSystemByPackInputPrometheus := new(CreateInputSystemByPackInputPrometheus)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputPrometheus, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == prometheus) type CreateInputSystemByPackInputPrometheus within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputPrometheus = createInputSystemByPackInputPrometheus
		u.Type = CreateInputSystemByPackRequestBodyTypePrometheus
		return nil
	case "edge_prometheus":
		createInputSystemByPackInputEdgePrometheus := new(CreateInputSystemByPackInputEdgePrometheus)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputEdgePrometheus, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == edge_prometheus) type CreateInputSystemByPackInputEdgePrometheus within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputEdgePrometheus = createInputSystemByPackInputEdgePrometheus
		u.Type = CreateInputSystemByPackRequestBodyTypeEdgePrometheus
		return nil
	case "office365_mgmt":
		createInputSystemByPackInputOffice365Mgmt := new(CreateInputSystemByPackInputOffice365Mgmt)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputOffice365Mgmt, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_mgmt) type CreateInputSystemByPackInputOffice365Mgmt within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputOffice365Mgmt = createInputSystemByPackInputOffice365Mgmt
		u.Type = CreateInputSystemByPackRequestBodyTypeOffice365Mgmt
		return nil
	case "office365_service":
		createInputSystemByPackInputOffice365Service := new(CreateInputSystemByPackInputOffice365Service)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputOffice365Service, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_service) type CreateInputSystemByPackInputOffice365Service within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputOffice365Service = createInputSystemByPackInputOffice365Service
		u.Type = CreateInputSystemByPackRequestBodyTypeOffice365Service
		return nil
	case "office365_msg_trace":
		createInputSystemByPackInputOffice365MsgTrace := new(CreateInputSystemByPackInputOffice365MsgTrace)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputOffice365MsgTrace, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_msg_trace) type CreateInputSystemByPackInputOffice365MsgTrace within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputOffice365MsgTrace = createInputSystemByPackInputOffice365MsgTrace
		u.Type = CreateInputSystemByPackRequestBodyTypeOffice365MsgTrace
		return nil
	case "eventhub":
		createInputSystemByPackInputEventhub := new(CreateInputSystemByPackInputEventhub)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputEventhub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == eventhub) type CreateInputSystemByPackInputEventhub within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputEventhub = createInputSystemByPackInputEventhub
		u.Type = CreateInputSystemByPackRequestBodyTypeEventhub
		return nil
	case "exec":
		createInputSystemByPackInputExec := new(CreateInputSystemByPackInputExec)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputExec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == exec) type CreateInputSystemByPackInputExec within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputExec = createInputSystemByPackInputExec
		u.Type = CreateInputSystemByPackRequestBodyTypeExec
		return nil
	case "firehose":
		createInputSystemByPackInputFirehose := new(CreateInputSystemByPackInputFirehose)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputFirehose, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == firehose) type CreateInputSystemByPackInputFirehose within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputFirehose = createInputSystemByPackInputFirehose
		u.Type = CreateInputSystemByPackRequestBodyTypeFirehose
		return nil
	case "google_pubsub":
		createInputSystemByPackInputGooglePubsub := new(CreateInputSystemByPackInputGooglePubsub)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputGooglePubsub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == google_pubsub) type CreateInputSystemByPackInputGooglePubsub within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputGooglePubsub = createInputSystemByPackInputGooglePubsub
		u.Type = CreateInputSystemByPackRequestBodyTypeGooglePubsub
		return nil
	case "cribl":
		createInputSystemByPackInputCribl := new(CreateInputSystemByPackInputCribl)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputCribl, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl) type CreateInputSystemByPackInputCribl within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputCribl = createInputSystemByPackInputCribl
		u.Type = CreateInputSystemByPackRequestBodyTypeCribl
		return nil
	case "cribl_tcp":
		createInputSystemByPackInputCriblTCP := new(CreateInputSystemByPackInputCriblTCP)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputCriblTCP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_tcp) type CreateInputSystemByPackInputCriblTCP within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputCriblTCP = createInputSystemByPackInputCriblTCP
		u.Type = CreateInputSystemByPackRequestBodyTypeCriblTCP
		return nil
	case "cribl_http":
		createInputSystemByPackInputCriblHTTP := new(CreateInputSystemByPackInputCriblHTTP)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputCriblHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_http) type CreateInputSystemByPackInputCriblHTTP within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputCriblHTTP = createInputSystemByPackInputCriblHTTP
		u.Type = CreateInputSystemByPackRequestBodyTypeCriblHTTP
		return nil
	case "cribl_lake_http":
		createInputSystemByPackInputCriblLakeHTTP := new(CreateInputSystemByPackInputCriblLakeHTTP)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputCriblLakeHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_lake_http) type CreateInputSystemByPackInputCriblLakeHTTP within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputCriblLakeHTTP = createInputSystemByPackInputCriblLakeHTTP
		u.Type = CreateInputSystemByPackRequestBodyTypeCriblLakeHTTP
		return nil
	case "tcpjson":
		createInputSystemByPackInputTcpjson := new(CreateInputSystemByPackInputTcpjson)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputTcpjson, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == tcpjson) type CreateInputSystemByPackInputTcpjson within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputTcpjson = createInputSystemByPackInputTcpjson
		u.Type = CreateInputSystemByPackRequestBodyTypeTcpjson
		return nil
	case "system_metrics":
		createInputSystemByPackInputSystemMetrics := new(CreateInputSystemByPackInputSystemMetrics)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSystemMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == system_metrics) type CreateInputSystemByPackInputSystemMetrics within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSystemMetrics = createInputSystemByPackInputSystemMetrics
		u.Type = CreateInputSystemByPackRequestBodyTypeSystemMetrics
		return nil
	case "system_state":
		createInputSystemByPackInputSystemState := new(CreateInputSystemByPackInputSystemState)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSystemState, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == system_state) type CreateInputSystemByPackInputSystemState within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSystemState = createInputSystemByPackInputSystemState
		u.Type = CreateInputSystemByPackRequestBodyTypeSystemState
		return nil
	case "kube_metrics":
		createInputSystemByPackInputKubeMetrics := new(CreateInputSystemByPackInputKubeMetrics)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputKubeMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_metrics) type CreateInputSystemByPackInputKubeMetrics within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputKubeMetrics = createInputSystemByPackInputKubeMetrics
		u.Type = CreateInputSystemByPackRequestBodyTypeKubeMetrics
		return nil
	case "kube_logs":
		createInputSystemByPackInputKubeLogs := new(CreateInputSystemByPackInputKubeLogs)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputKubeLogs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_logs) type CreateInputSystemByPackInputKubeLogs within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputKubeLogs = createInputSystemByPackInputKubeLogs
		u.Type = CreateInputSystemByPackRequestBodyTypeKubeLogs
		return nil
	case "kube_events":
		createInputSystemByPackInputKubeEvents := new(CreateInputSystemByPackInputKubeEvents)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputKubeEvents, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_events) type CreateInputSystemByPackInputKubeEvents within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputKubeEvents = createInputSystemByPackInputKubeEvents
		u.Type = CreateInputSystemByPackRequestBodyTypeKubeEvents
		return nil
	case "windows_metrics":
		createInputSystemByPackInputWindowsMetrics := new(CreateInputSystemByPackInputWindowsMetrics)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputWindowsMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == windows_metrics) type CreateInputSystemByPackInputWindowsMetrics within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputWindowsMetrics = createInputSystemByPackInputWindowsMetrics
		u.Type = CreateInputSystemByPackRequestBodyTypeWindowsMetrics
		return nil
	case "crowdstrike":
		createInputSystemByPackInputCrowdstrike := new(CreateInputSystemByPackInputCrowdstrike)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputCrowdstrike, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == crowdstrike) type CreateInputSystemByPackInputCrowdstrike within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputCrowdstrike = createInputSystemByPackInputCrowdstrike
		u.Type = CreateInputSystemByPackRequestBodyTypeCrowdstrike
		return nil
	case "datadog_agent":
		createInputSystemByPackInputDatadogAgent := new(CreateInputSystemByPackInputDatadogAgent)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputDatadogAgent, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == datadog_agent) type CreateInputSystemByPackInputDatadogAgent within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputDatadogAgent = createInputSystemByPackInputDatadogAgent
		u.Type = CreateInputSystemByPackRequestBodyTypeDatadogAgent
		return nil
	case "datagen":
		createInputSystemByPackInputDatagen := new(CreateInputSystemByPackInputDatagen)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputDatagen, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == datagen) type CreateInputSystemByPackInputDatagen within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputDatagen = createInputSystemByPackInputDatagen
		u.Type = CreateInputSystemByPackRequestBodyTypeDatagen
		return nil
	case "http_raw":
		createInputSystemByPackInputHTTPRaw := new(CreateInputSystemByPackInputHTTPRaw)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputHTTPRaw, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http_raw) type CreateInputSystemByPackInputHTTPRaw within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputHTTPRaw = createInputSystemByPackInputHTTPRaw
		u.Type = CreateInputSystemByPackRequestBodyTypeHTTPRaw
		return nil
	case "kinesis":
		createInputSystemByPackInputKinesis := new(CreateInputSystemByPackInputKinesis)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputKinesis, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kinesis) type CreateInputSystemByPackInputKinesis within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputKinesis = createInputSystemByPackInputKinesis
		u.Type = CreateInputSystemByPackRequestBodyTypeKinesis
		return nil
	case "criblmetrics":
		createInputSystemByPackInputCriblmetrics := new(CreateInputSystemByPackInputCriblmetrics)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputCriblmetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == criblmetrics) type CreateInputSystemByPackInputCriblmetrics within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputCriblmetrics = createInputSystemByPackInputCriblmetrics
		u.Type = CreateInputSystemByPackRequestBodyTypeCriblmetrics
		return nil
	case "metrics":
		createInputSystemByPackInputMetrics := new(CreateInputSystemByPackInputMetrics)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == metrics) type CreateInputSystemByPackInputMetrics within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputMetrics = createInputSystemByPackInputMetrics
		u.Type = CreateInputSystemByPackRequestBodyTypeMetrics
		return nil
	case "s3":
		createInputSystemByPackInputS3 := new(CreateInputSystemByPackInputS3)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputS3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == s3) type CreateInputSystemByPackInputS3 within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputS3 = createInputSystemByPackInputS3
		u.Type = CreateInputSystemByPackRequestBodyTypeS3
		return nil
	case "s3_inventory":
		createInputSystemByPackInputS3Inventory := new(CreateInputSystemByPackInputS3Inventory)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputS3Inventory, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == s3_inventory) type CreateInputSystemByPackInputS3Inventory within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputS3Inventory = createInputSystemByPackInputS3Inventory
		u.Type = CreateInputSystemByPackRequestBodyTypeS3Inventory
		return nil
	case "snmp":
		createInputSystemByPackInputSnmp := new(CreateInputSystemByPackInputSnmp)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSnmp, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == snmp) type CreateInputSystemByPackInputSnmp within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSnmp = createInputSystemByPackInputSnmp
		u.Type = CreateInputSystemByPackRequestBodyTypeSnmp
		return nil
	case "open_telemetry":
		createInputSystemByPackInputOpenTelemetry := new(CreateInputSystemByPackInputOpenTelemetry)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputOpenTelemetry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == open_telemetry) type CreateInputSystemByPackInputOpenTelemetry within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputOpenTelemetry = createInputSystemByPackInputOpenTelemetry
		u.Type = CreateInputSystemByPackRequestBodyTypeOpenTelemetry
		return nil
	case "model_driven_telemetry":
		createInputSystemByPackInputModelDrivenTelemetry := new(CreateInputSystemByPackInputModelDrivenTelemetry)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputModelDrivenTelemetry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == model_driven_telemetry) type CreateInputSystemByPackInputModelDrivenTelemetry within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputModelDrivenTelemetry = createInputSystemByPackInputModelDrivenTelemetry
		u.Type = CreateInputSystemByPackRequestBodyTypeModelDrivenTelemetry
		return nil
	case "sqs":
		createInputSystemByPackInputSqs := new(CreateInputSystemByPackInputSqs)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSqs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == sqs) type CreateInputSystemByPackInputSqs within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSqs = createInputSystemByPackInputSqs
		u.Type = CreateInputSystemByPackRequestBodyTypeSqs
		return nil
	case "syslog":
		createInputSystemByPackInputSyslogUnion := new(CreateInputSystemByPackInputSyslogUnion)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSyslogUnion, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == syslog) type CreateInputSystemByPackInputSyslogUnion within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSyslogUnion = createInputSystemByPackInputSyslogUnion
		u.Type = CreateInputSystemByPackRequestBodyTypeSyslog
		return nil
	case "file":
		createInputSystemByPackInputFile := new(CreateInputSystemByPackInputFile)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputFile, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == file) type CreateInputSystemByPackInputFile within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputFile = createInputSystemByPackInputFile
		u.Type = CreateInputSystemByPackRequestBodyTypeFile
		return nil
	case "tcp":
		createInputSystemByPackInputTCP := new(CreateInputSystemByPackInputTCP)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputTCP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == tcp) type CreateInputSystemByPackInputTCP within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputTCP = createInputSystemByPackInputTCP
		u.Type = CreateInputSystemByPackRequestBodyTypeTCP
		return nil
	case "appscope":
		createInputSystemByPackInputAppscope := new(CreateInputSystemByPackInputAppscope)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputAppscope, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == appscope) type CreateInputSystemByPackInputAppscope within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputAppscope = createInputSystemByPackInputAppscope
		u.Type = CreateInputSystemByPackRequestBodyTypeAppscope
		return nil
	case "wef":
		createInputSystemByPackInputWef := new(CreateInputSystemByPackInputWef)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputWef, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wef) type CreateInputSystemByPackInputWef within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputWef = createInputSystemByPackInputWef
		u.Type = CreateInputSystemByPackRequestBodyTypeWef
		return nil
	case "win_event_logs":
		createInputSystemByPackInputWinEventLogs := new(CreateInputSystemByPackInputWinEventLogs)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputWinEventLogs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == win_event_logs) type CreateInputSystemByPackInputWinEventLogs within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputWinEventLogs = createInputSystemByPackInputWinEventLogs
		u.Type = CreateInputSystemByPackRequestBodyTypeWinEventLogs
		return nil
	case "raw_udp":
		createInputSystemByPackInputRawUDP := new(CreateInputSystemByPackInputRawUDP)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputRawUDP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == raw_udp) type CreateInputSystemByPackInputRawUDP within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputRawUDP = createInputSystemByPackInputRawUDP
		u.Type = CreateInputSystemByPackRequestBodyTypeRawUDP
		return nil
	case "journal_files":
		createInputSystemByPackInputJournalFiles := new(CreateInputSystemByPackInputJournalFiles)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputJournalFiles, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == journal_files) type CreateInputSystemByPackInputJournalFiles within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputJournalFiles = createInputSystemByPackInputJournalFiles
		u.Type = CreateInputSystemByPackRequestBodyTypeJournalFiles
		return nil
	case "wiz":
		createInputSystemByPackInputWiz := new(CreateInputSystemByPackInputWiz)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputWiz, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wiz) type CreateInputSystemByPackInputWiz within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputWiz = createInputSystemByPackInputWiz
		u.Type = CreateInputSystemByPackRequestBodyTypeWiz
		return nil
	case "wiz_webhook":
		createInputSystemByPackInputWizWebhook := new(CreateInputSystemByPackInputWizWebhook)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputWizWebhook, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wiz_webhook) type CreateInputSystemByPackInputWizWebhook within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputWizWebhook = createInputSystemByPackInputWizWebhook
		u.Type = CreateInputSystemByPackRequestBodyTypeWizWebhook
		return nil
	case "netflow":
		createInputSystemByPackInputNetflow := new(CreateInputSystemByPackInputNetflow)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputNetflow, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == netflow) type CreateInputSystemByPackInputNetflow within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputNetflow = createInputSystemByPackInputNetflow
		u.Type = CreateInputSystemByPackRequestBodyTypeNetflow
		return nil
	case "security_lake":
		createInputSystemByPackInputSecurityLake := new(CreateInputSystemByPackInputSecurityLake)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputSecurityLake, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == security_lake) type CreateInputSystemByPackInputSecurityLake within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputSecurityLake = createInputSystemByPackInputSecurityLake
		u.Type = CreateInputSystemByPackRequestBodyTypeSecurityLake
		return nil
	case "zscaler_hec":
		createInputSystemByPackInputZscalerHec := new(CreateInputSystemByPackInputZscalerHec)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputZscalerHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == zscaler_hec) type CreateInputSystemByPackInputZscalerHec within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputZscalerHec = createInputSystemByPackInputZscalerHec
		u.Type = CreateInputSystemByPackRequestBodyTypeZscalerHec
		return nil
	case "cloudflare_hec":
		createInputSystemByPackInputCloudflareHec := new(CreateInputSystemByPackInputCloudflareHec)
		if err := utils.UnmarshalJSON(data, &createInputSystemByPackInputCloudflareHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cloudflare_hec) type CreateInputSystemByPackInputCloudflareHec within CreateInputSystemByPackRequestBody: %w", string(data), err)
		}

		u.CreateInputSystemByPackInputCloudflareHec = createInputSystemByPackInputCloudflareHec
		u.Type = CreateInputSystemByPackRequestBodyTypeCloudflareHec
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputSystemByPackRequestBody", string(data))
}

func (u CreateInputSystemByPackRequestBody) MarshalJSON() ([]byte, error) {
	if u.CreateInputSystemByPackInputCollection != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputCollection, "", true)
	}

	if u.CreateInputSystemByPackInputKafka != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputKafka, "", true)
	}

	if u.CreateInputSystemByPackInputMsk != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputMsk, "", true)
	}

	if u.CreateInputSystemByPackInputHTTP != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputHTTP, "", true)
	}

	if u.CreateInputSystemByPackInputSplunk != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSplunk, "", true)
	}

	if u.CreateInputSystemByPackInputSplunkSearch != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSplunkSearch, "", true)
	}

	if u.CreateInputSystemByPackInputSplunkHec != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSplunkHec, "", true)
	}

	if u.CreateInputSystemByPackInputAzureBlob != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputAzureBlob, "", true)
	}

	if u.CreateInputSystemByPackInputElastic != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputElastic, "", true)
	}

	if u.CreateInputSystemByPackInputConfluentCloud != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputConfluentCloud, "", true)
	}

	if u.CreateInputSystemByPackInputGrafanaUnion != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputGrafanaUnion, "", true)
	}

	if u.CreateInputSystemByPackInputLoki != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputLoki, "", true)
	}

	if u.CreateInputSystemByPackInputPrometheusRw != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputPrometheusRw, "", true)
	}

	if u.CreateInputSystemByPackInputPrometheus != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputPrometheus, "", true)
	}

	if u.CreateInputSystemByPackInputEdgePrometheus != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputEdgePrometheus, "", true)
	}

	if u.CreateInputSystemByPackInputOffice365Mgmt != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputOffice365Mgmt, "", true)
	}

	if u.CreateInputSystemByPackInputOffice365Service != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputOffice365Service, "", true)
	}

	if u.CreateInputSystemByPackInputOffice365MsgTrace != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputOffice365MsgTrace, "", true)
	}

	if u.CreateInputSystemByPackInputEventhub != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputEventhub, "", true)
	}

	if u.CreateInputSystemByPackInputExec != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputExec, "", true)
	}

	if u.CreateInputSystemByPackInputFirehose != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputFirehose, "", true)
	}

	if u.CreateInputSystemByPackInputGooglePubsub != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputGooglePubsub, "", true)
	}

	if u.CreateInputSystemByPackInputCribl != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputCribl, "", true)
	}

	if u.CreateInputSystemByPackInputCriblTCP != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputCriblTCP, "", true)
	}

	if u.CreateInputSystemByPackInputCriblHTTP != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputCriblHTTP, "", true)
	}

	if u.CreateInputSystemByPackInputCriblLakeHTTP != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputCriblLakeHTTP, "", true)
	}

	if u.CreateInputSystemByPackInputTcpjson != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputTcpjson, "", true)
	}

	if u.CreateInputSystemByPackInputSystemMetrics != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSystemMetrics, "", true)
	}

	if u.CreateInputSystemByPackInputSystemState != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSystemState, "", true)
	}

	if u.CreateInputSystemByPackInputKubeMetrics != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputKubeMetrics, "", true)
	}

	if u.CreateInputSystemByPackInputKubeLogs != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputKubeLogs, "", true)
	}

	if u.CreateInputSystemByPackInputKubeEvents != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputKubeEvents, "", true)
	}

	if u.CreateInputSystemByPackInputWindowsMetrics != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputWindowsMetrics, "", true)
	}

	if u.CreateInputSystemByPackInputCrowdstrike != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputCrowdstrike, "", true)
	}

	if u.CreateInputSystemByPackInputDatadogAgent != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputDatadogAgent, "", true)
	}

	if u.CreateInputSystemByPackInputDatagen != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputDatagen, "", true)
	}

	if u.CreateInputSystemByPackInputHTTPRaw != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputHTTPRaw, "", true)
	}

	if u.CreateInputSystemByPackInputKinesis != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputKinesis, "", true)
	}

	if u.CreateInputSystemByPackInputCriblmetrics != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputCriblmetrics, "", true)
	}

	if u.CreateInputSystemByPackInputMetrics != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputMetrics, "", true)
	}

	if u.CreateInputSystemByPackInputS3 != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputS3, "", true)
	}

	if u.CreateInputSystemByPackInputS3Inventory != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputS3Inventory, "", true)
	}

	if u.CreateInputSystemByPackInputSnmp != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSnmp, "", true)
	}

	if u.CreateInputSystemByPackInputOpenTelemetry != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputOpenTelemetry, "", true)
	}

	if u.CreateInputSystemByPackInputModelDrivenTelemetry != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputModelDrivenTelemetry, "", true)
	}

	if u.CreateInputSystemByPackInputSqs != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSqs, "", true)
	}

	if u.CreateInputSystemByPackInputSyslogUnion != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSyslogUnion, "", true)
	}

	if u.CreateInputSystemByPackInputFile != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputFile, "", true)
	}

	if u.CreateInputSystemByPackInputTCP != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputTCP, "", true)
	}

	if u.CreateInputSystemByPackInputAppscope != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputAppscope, "", true)
	}

	if u.CreateInputSystemByPackInputWef != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputWef, "", true)
	}

	if u.CreateInputSystemByPackInputWinEventLogs != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputWinEventLogs, "", true)
	}

	if u.CreateInputSystemByPackInputRawUDP != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputRawUDP, "", true)
	}

	if u.CreateInputSystemByPackInputJournalFiles != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputJournalFiles, "", true)
	}

	if u.CreateInputSystemByPackInputWiz != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputWiz, "", true)
	}

	if u.CreateInputSystemByPackInputWizWebhook != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputWizWebhook, "", true)
	}

	if u.CreateInputSystemByPackInputNetflow != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputNetflow, "", true)
	}

	if u.CreateInputSystemByPackInputSecurityLake != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputSecurityLake, "", true)
	}

	if u.CreateInputSystemByPackInputZscalerHec != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputZscalerHec, "", true)
	}

	if u.CreateInputSystemByPackInputCloudflareHec != nil {
		return utils.MarshalJSON(u.CreateInputSystemByPackInputCloudflareHec, "", true)
	}

	return nil, errors.New("could not marshal union type CreateInputSystemByPackRequestBody: all fields are null")
}

type CreateInputSystemByPackRequest struct {
	// The <code>id</code> of the Pack to create.
	Pack string `pathParam:"style=simple,explode=false,name=pack"`
	// Input object
	RequestBody CreateInputSystemByPackRequestBody `request:"mediaType=application/json"`
}

func (c *CreateInputSystemByPackRequest) GetPack() string {
	if c == nil {
		return ""
	}
	return c.Pack
}

func (c *CreateInputSystemByPackRequest) GetRequestBody() CreateInputSystemByPackRequestBody {
	if c == nil {
		return CreateInputSystemByPackRequestBody{}
	}
	return c.RequestBody
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyCollection() *CreateInputSystemByPackInputCollection {
	return c.GetRequestBody().CreateInputSystemByPackInputCollection
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyKafka() *CreateInputSystemByPackInputKafka {
	return c.GetRequestBody().CreateInputSystemByPackInputKafka
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyMsk() *CreateInputSystemByPackInputMsk {
	return c.GetRequestBody().CreateInputSystemByPackInputMsk
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyHTTP() *CreateInputSystemByPackInputHTTP {
	return c.GetRequestBody().CreateInputSystemByPackInputHTTP
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySplunk() *CreateInputSystemByPackInputSplunk {
	return c.GetRequestBody().CreateInputSystemByPackInputSplunk
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySplunkSearch() *CreateInputSystemByPackInputSplunkSearch {
	return c.GetRequestBody().CreateInputSystemByPackInputSplunkSearch
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySplunkHec() *CreateInputSystemByPackInputSplunkHec {
	return c.GetRequestBody().CreateInputSystemByPackInputSplunkHec
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyAzureBlob() *CreateInputSystemByPackInputAzureBlob {
	return c.GetRequestBody().CreateInputSystemByPackInputAzureBlob
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyElastic() *CreateInputSystemByPackInputElastic {
	return c.GetRequestBody().CreateInputSystemByPackInputElastic
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyConfluentCloud() *CreateInputSystemByPackInputConfluentCloud {
	return c.GetRequestBody().CreateInputSystemByPackInputConfluentCloud
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyGrafana() *CreateInputSystemByPackInputGrafanaUnion {
	return c.GetRequestBody().CreateInputSystemByPackInputGrafanaUnion
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyLoki() *CreateInputSystemByPackInputLoki {
	return c.GetRequestBody().CreateInputSystemByPackInputLoki
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyPrometheusRw() *CreateInputSystemByPackInputPrometheusRw {
	return c.GetRequestBody().CreateInputSystemByPackInputPrometheusRw
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyPrometheus() *CreateInputSystemByPackInputPrometheus {
	return c.GetRequestBody().CreateInputSystemByPackInputPrometheus
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyEdgePrometheus() *CreateInputSystemByPackInputEdgePrometheus {
	return c.GetRequestBody().CreateInputSystemByPackInputEdgePrometheus
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyOffice365Mgmt() *CreateInputSystemByPackInputOffice365Mgmt {
	return c.GetRequestBody().CreateInputSystemByPackInputOffice365Mgmt
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyOffice365Service() *CreateInputSystemByPackInputOffice365Service {
	return c.GetRequestBody().CreateInputSystemByPackInputOffice365Service
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyOffice365MsgTrace() *CreateInputSystemByPackInputOffice365MsgTrace {
	return c.GetRequestBody().CreateInputSystemByPackInputOffice365MsgTrace
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyEventhub() *CreateInputSystemByPackInputEventhub {
	return c.GetRequestBody().CreateInputSystemByPackInputEventhub
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyExec() *CreateInputSystemByPackInputExec {
	return c.GetRequestBody().CreateInputSystemByPackInputExec
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyFirehose() *CreateInputSystemByPackInputFirehose {
	return c.GetRequestBody().CreateInputSystemByPackInputFirehose
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyGooglePubsub() *CreateInputSystemByPackInputGooglePubsub {
	return c.GetRequestBody().CreateInputSystemByPackInputGooglePubsub
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyCribl() *CreateInputSystemByPackInputCribl {
	return c.GetRequestBody().CreateInputSystemByPackInputCribl
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyCriblTCP() *CreateInputSystemByPackInputCriblTCP {
	return c.GetRequestBody().CreateInputSystemByPackInputCriblTCP
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyCriblHTTP() *CreateInputSystemByPackInputCriblHTTP {
	return c.GetRequestBody().CreateInputSystemByPackInputCriblHTTP
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyCriblLakeHTTP() *CreateInputSystemByPackInputCriblLakeHTTP {
	return c.GetRequestBody().CreateInputSystemByPackInputCriblLakeHTTP
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyTcpjson() *CreateInputSystemByPackInputTcpjson {
	return c.GetRequestBody().CreateInputSystemByPackInputTcpjson
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySystemMetrics() *CreateInputSystemByPackInputSystemMetrics {
	return c.GetRequestBody().CreateInputSystemByPackInputSystemMetrics
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySystemState() *CreateInputSystemByPackInputSystemState {
	return c.GetRequestBody().CreateInputSystemByPackInputSystemState
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyKubeMetrics() *CreateInputSystemByPackInputKubeMetrics {
	return c.GetRequestBody().CreateInputSystemByPackInputKubeMetrics
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyKubeLogs() *CreateInputSystemByPackInputKubeLogs {
	return c.GetRequestBody().CreateInputSystemByPackInputKubeLogs
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyKubeEvents() *CreateInputSystemByPackInputKubeEvents {
	return c.GetRequestBody().CreateInputSystemByPackInputKubeEvents
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyWindowsMetrics() *CreateInputSystemByPackInputWindowsMetrics {
	return c.GetRequestBody().CreateInputSystemByPackInputWindowsMetrics
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyCrowdstrike() *CreateInputSystemByPackInputCrowdstrike {
	return c.GetRequestBody().CreateInputSystemByPackInputCrowdstrike
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyDatadogAgent() *CreateInputSystemByPackInputDatadogAgent {
	return c.GetRequestBody().CreateInputSystemByPackInputDatadogAgent
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyDatagen() *CreateInputSystemByPackInputDatagen {
	return c.GetRequestBody().CreateInputSystemByPackInputDatagen
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyHTTPRaw() *CreateInputSystemByPackInputHTTPRaw {
	return c.GetRequestBody().CreateInputSystemByPackInputHTTPRaw
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyKinesis() *CreateInputSystemByPackInputKinesis {
	return c.GetRequestBody().CreateInputSystemByPackInputKinesis
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyCriblmetrics() *CreateInputSystemByPackInputCriblmetrics {
	return c.GetRequestBody().CreateInputSystemByPackInputCriblmetrics
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyMetrics() *CreateInputSystemByPackInputMetrics {
	return c.GetRequestBody().CreateInputSystemByPackInputMetrics
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyS3() *CreateInputSystemByPackInputS3 {
	return c.GetRequestBody().CreateInputSystemByPackInputS3
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyS3Inventory() *CreateInputSystemByPackInputS3Inventory {
	return c.GetRequestBody().CreateInputSystemByPackInputS3Inventory
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySnmp() *CreateInputSystemByPackInputSnmp {
	return c.GetRequestBody().CreateInputSystemByPackInputSnmp
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyOpenTelemetry() *CreateInputSystemByPackInputOpenTelemetry {
	return c.GetRequestBody().CreateInputSystemByPackInputOpenTelemetry
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyModelDrivenTelemetry() *CreateInputSystemByPackInputModelDrivenTelemetry {
	return c.GetRequestBody().CreateInputSystemByPackInputModelDrivenTelemetry
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySqs() *CreateInputSystemByPackInputSqs {
	return c.GetRequestBody().CreateInputSystemByPackInputSqs
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySyslog() *CreateInputSystemByPackInputSyslogUnion {
	return c.GetRequestBody().CreateInputSystemByPackInputSyslogUnion
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyFile() *CreateInputSystemByPackInputFile {
	return c.GetRequestBody().CreateInputSystemByPackInputFile
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyTCP() *CreateInputSystemByPackInputTCP {
	return c.GetRequestBody().CreateInputSystemByPackInputTCP
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyAppscope() *CreateInputSystemByPackInputAppscope {
	return c.GetRequestBody().CreateInputSystemByPackInputAppscope
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyWef() *CreateInputSystemByPackInputWef {
	return c.GetRequestBody().CreateInputSystemByPackInputWef
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyWinEventLogs() *CreateInputSystemByPackInputWinEventLogs {
	return c.GetRequestBody().CreateInputSystemByPackInputWinEventLogs
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyRawUDP() *CreateInputSystemByPackInputRawUDP {
	return c.GetRequestBody().CreateInputSystemByPackInputRawUDP
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyJournalFiles() *CreateInputSystemByPackInputJournalFiles {
	return c.GetRequestBody().CreateInputSystemByPackInputJournalFiles
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyWiz() *CreateInputSystemByPackInputWiz {
	return c.GetRequestBody().CreateInputSystemByPackInputWiz
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyWizWebhook() *CreateInputSystemByPackInputWizWebhook {
	return c.GetRequestBody().CreateInputSystemByPackInputWizWebhook
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyNetflow() *CreateInputSystemByPackInputNetflow {
	return c.GetRequestBody().CreateInputSystemByPackInputNetflow
}

func (c *CreateInputSystemByPackRequest) GetRequestBodySecurityLake() *CreateInputSystemByPackInputSecurityLake {
	return c.GetRequestBody().CreateInputSystemByPackInputSecurityLake
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyZscalerHec() *CreateInputSystemByPackInputZscalerHec {
	return c.GetRequestBody().CreateInputSystemByPackInputZscalerHec
}

func (c *CreateInputSystemByPackRequest) GetRequestBodyCloudflareHec() *CreateInputSystemByPackInputCloudflareHec {
	return c.GetRequestBody().CreateInputSystemByPackInputCloudflareHec
}

type CreateInputSystemByPackResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// a list of Source objects
	CountedInput *components.CountedInput
}

func (c *CreateInputSystemByPackResponse) GetHTTPMeta() components.HTTPMetadata {
	if c == nil {
		return components.HTTPMetadata{}
	}
	return c.HTTPMeta
}

func (c *CreateInputSystemByPackResponse) GetCountedInput() *components.CountedInput {
	if c == nil {
		return nil
	}
	return c.CountedInput
}
