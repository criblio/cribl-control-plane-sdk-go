// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
	"github.com/criblio/cribl-control-plane-sdk-go/models/components"
)

type InputCloudflareHecPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputCloudflareHecType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputCloudflareHecAuthToken         `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputCloudflareHecPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port", "hecAPI"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetType() InputCloudflareHecType {
	if i == nil {
		return InputCloudflareHecType("")
	}
	return i.Type
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetAuthTokens() []InputCloudflareHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetHecAPI() string {
	if i == nil {
		return ""
	}
	return i.HecAPI
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputCloudflareHecPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCloudflareHecPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputCloudflareHecType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputCloudflareHecAuthToken         `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputCloudflareHecPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port", "hecAPI"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetType() InputCloudflareHecType {
	if i == nil {
		return InputCloudflareHecType("")
	}
	return i.Type
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetAuthTokens() []InputCloudflareHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetHecAPI() string {
	if i == nil {
		return ""
	}
	return i.HecAPI
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputCloudflareHecPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputCloudflareHecType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputCloudflareHecAuthToken         `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port", "hecAPI"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetType() InputCloudflareHecType {
	if i == nil {
		return InputCloudflareHecType("")
	}
	return i.Type
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []InputCloudflareHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetHecAPI() string {
	if i == nil {
		return ""
	}
	return i.HecAPI
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCloudflareHecType string

const (
	InputCloudflareHecTypeCloudflareHec InputCloudflareHecType = "cloudflare_hec"
)

func (e InputCloudflareHecType) ToPointer() *InputCloudflareHecType {
	return &e
}
func (e *InputCloudflareHecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cloudflare_hec":
		*e = InputCloudflareHecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCloudflareHecType: %v", v)
	}
}

// InputCloudflareHecAuthenticationMethod - Select Secret to use a text secret to authenticate
type InputCloudflareHecAuthenticationMethod string

const (
	InputCloudflareHecAuthenticationMethodSecret InputCloudflareHecAuthenticationMethod = "secret"
	InputCloudflareHecAuthenticationMethodManual InputCloudflareHecAuthenticationMethod = "manual"
)

func (e InputCloudflareHecAuthenticationMethod) ToPointer() *InputCloudflareHecAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputCloudflareHecAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "secret", "manual":
			return true
		}
	}
	return false
}

type InputCloudflareHecAuthToken struct {
	// Select Secret to use a text secret to authenticate
	AuthType *InputCloudflareHecAuthenticationMethod `default:"secret" json:"authType"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	// Shared secret to be provided by any client (Authorization: <token>)
	Token       *string `json:"token,omitempty"`
	Enabled     *bool   `default:"true" json:"enabled"`
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
}

func (i InputCloudflareHecAuthToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCloudflareHecAuthToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputCloudflareHecAuthToken) GetAuthType() *InputCloudflareHecAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputCloudflareHecAuthToken) GetTokenSecret() *string {
	if i == nil {
		return nil
	}
	return i.TokenSecret
}

func (i *InputCloudflareHecAuthToken) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputCloudflareHecAuthToken) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *InputCloudflareHecAuthToken) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputCloudflareHecAuthToken) GetAllowedIndexesAtToken() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexesAtToken
}

func (i *InputCloudflareHecAuthToken) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

type InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputCloudflareHecType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputCloudflareHecAuthToken         `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port", "hecAPI"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetType() InputCloudflareHecType {
	if i == nil {
		return InputCloudflareHecType("")
	}
	return i.Type
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []InputCloudflareHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetHecAPI() string {
	if i == nil {
		return ""
	}
	return i.HecAPI
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCloudflareHecUnionType string

const (
	InputCloudflareHecUnionTypeInputCloudflareHecSendToRoutesTrueWithConnectionsConstraint  InputCloudflareHecUnionType = "InputCloudflareHec_SendToRoutesTrueWithConnectionsConstraint"
	InputCloudflareHecUnionTypeInputCloudflareHecSendToRoutesFalseWithConnectionsConstraint InputCloudflareHecUnionType = "InputCloudflareHec_SendToRoutesFalseWithConnectionsConstraint"
	InputCloudflareHecUnionTypeInputCloudflareHecPqEnabledFalseWithPqConstraint             InputCloudflareHecUnionType = "InputCloudflareHec_PqEnabledFalseWithPqConstraint"
	InputCloudflareHecUnionTypeInputCloudflareHecPqEnabledTrueWithPqConstraint              InputCloudflareHecUnionType = "InputCloudflareHec_PqEnabledTrueWithPqConstraint"
)

type InputCloudflareHec struct {
	InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint  *InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint *InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputCloudflareHecPqEnabledFalseWithPqConstraint             *InputCloudflareHecPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputCloudflareHecPqEnabledTrueWithPqConstraint              *InputCloudflareHecPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputCloudflareHecUnionType
}

func CreateInputCloudflareHecInputCloudflareHecSendToRoutesTrueWithConnectionsConstraint(inputCloudflareHecSendToRoutesTrueWithConnectionsConstraint InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint) InputCloudflareHec {
	typ := InputCloudflareHecUnionTypeInputCloudflareHecSendToRoutesTrueWithConnectionsConstraint

	return InputCloudflareHec{
		InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint: &inputCloudflareHecSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCloudflareHecInputCloudflareHecSendToRoutesFalseWithConnectionsConstraint(inputCloudflareHecSendToRoutesFalseWithConnectionsConstraint InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint) InputCloudflareHec {
	typ := InputCloudflareHecUnionTypeInputCloudflareHecSendToRoutesFalseWithConnectionsConstraint

	return InputCloudflareHec{
		InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint: &inputCloudflareHecSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCloudflareHecInputCloudflareHecPqEnabledFalseWithPqConstraint(inputCloudflareHecPqEnabledFalseWithPqConstraint InputCloudflareHecPqEnabledFalseWithPqConstraint) InputCloudflareHec {
	typ := InputCloudflareHecUnionTypeInputCloudflareHecPqEnabledFalseWithPqConstraint

	return InputCloudflareHec{
		InputCloudflareHecPqEnabledFalseWithPqConstraint: &inputCloudflareHecPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputCloudflareHecInputCloudflareHecPqEnabledTrueWithPqConstraint(inputCloudflareHecPqEnabledTrueWithPqConstraint InputCloudflareHecPqEnabledTrueWithPqConstraint) InputCloudflareHec {
	typ := InputCloudflareHecUnionTypeInputCloudflareHecPqEnabledTrueWithPqConstraint

	return InputCloudflareHec{
		InputCloudflareHecPqEnabledTrueWithPqConstraint: &inputCloudflareHecPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputCloudflareHec) UnmarshalJSON(data []byte) error {

	var inputCloudflareHecSendToRoutesTrueWithConnectionsConstraint InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint = InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCloudflareHecSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint = &inputCloudflareHecSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputCloudflareHecUnionTypeInputCloudflareHecSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputCloudflareHecSendToRoutesFalseWithConnectionsConstraint InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint = InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCloudflareHecSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint = &inputCloudflareHecSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputCloudflareHecUnionTypeInputCloudflareHecSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputCloudflareHecPqEnabledFalseWithPqConstraint InputCloudflareHecPqEnabledFalseWithPqConstraint = InputCloudflareHecPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCloudflareHecPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputCloudflareHecPqEnabledFalseWithPqConstraint = &inputCloudflareHecPqEnabledFalseWithPqConstraint
		u.Type = InputCloudflareHecUnionTypeInputCloudflareHecPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputCloudflareHecPqEnabledTrueWithPqConstraint InputCloudflareHecPqEnabledTrueWithPqConstraint = InputCloudflareHecPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCloudflareHecPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputCloudflareHecPqEnabledTrueWithPqConstraint = &inputCloudflareHecPqEnabledTrueWithPqConstraint
		u.Type = InputCloudflareHecUnionTypeInputCloudflareHecPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputCloudflareHec", string(data))
}

func (u InputCloudflareHec) MarshalJSON() ([]byte, error) {
	if u.InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCloudflareHecSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputCloudflareHecPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCloudflareHecPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputCloudflareHecPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCloudflareHecPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputCloudflareHec: all fields are null")
}

type InputZscalerHecPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputZscalerHecType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputZscalerHecAuthToken            `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI *string `default:"/services/collector" json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Whether to enable Zscaler HEC acknowledgements
	HecAcks *bool `default:"false" json:"hecAcks"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputZscalerHecPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetType() InputZscalerHecType {
	if i == nil {
		return InputZscalerHecType("")
	}
	return i.Type
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetAuthTokens() []InputZscalerHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.HecAPI
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.HecAcks
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputZscalerHecPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputZscalerHecPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputZscalerHecType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputZscalerHecAuthToken            `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI *string `default:"/services/collector" json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Whether to enable Zscaler HEC acknowledgements
	HecAcks *bool `default:"false" json:"hecAcks"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputZscalerHecPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetType() InputZscalerHecType {
	if i == nil {
		return InputZscalerHecType("")
	}
	return i.Type
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetAuthTokens() []InputZscalerHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.HecAPI
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.HecAcks
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputZscalerHecPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputZscalerHecSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputZscalerHecType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputZscalerHecAuthToken            `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI *string `default:"/services/collector" json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Whether to enable Zscaler HEC acknowledgements
	HecAcks *bool `default:"false" json:"hecAcks"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetType() InputZscalerHecType {
	if i == nil {
		return InputZscalerHecType("")
	}
	return i.Type
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []InputZscalerHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.HecAPI
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.HecAcks
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputZscalerHecType string

const (
	InputZscalerHecTypeZscalerHec InputZscalerHecType = "zscaler_hec"
)

func (e InputZscalerHecType) ToPointer() *InputZscalerHecType {
	return &e
}
func (e *InputZscalerHecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zscaler_hec":
		*e = InputZscalerHecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputZscalerHecType: %v", v)
	}
}

type InputZscalerHecAuthToken struct {
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	// Shared secret to be provided by any client (Authorization: <token>)
	Token       string  `json:"token"`
	Enabled     *bool   `default:"true" json:"enabled"`
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
}

func (i InputZscalerHecAuthToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputZscalerHecAuthToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"token"}); err != nil {
		return err
	}
	return nil
}

func (i *InputZscalerHecAuthToken) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputZscalerHecAuthToken) GetTokenSecret() *string {
	if i == nil {
		return nil
	}
	return i.TokenSecret
}

func (i *InputZscalerHecAuthToken) GetToken() string {
	if i == nil {
		return ""
	}
	return i.Token
}

func (i *InputZscalerHecAuthToken) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *InputZscalerHecAuthToken) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputZscalerHecAuthToken) GetAllowedIndexesAtToken() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexesAtToken
}

func (i *InputZscalerHecAuthToken) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

type InputZscalerHecSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputZscalerHecType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputZscalerHecAuthToken            `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI *string `default:"/services/collector" json:"hecAPI"`
	// Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Whether to enable Zscaler HEC acknowledgements
	HecAcks *bool `default:"false" json:"hecAcks"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetType() InputZscalerHecType {
	if i == nil {
		return InputZscalerHecType("")
	}
	return i.Type
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []InputZscalerHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.HecAPI
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.HecAcks
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputZscalerHecUnionType string

const (
	InputZscalerHecUnionTypeInputZscalerHecSendToRoutesTrueWithConnectionsConstraint  InputZscalerHecUnionType = "InputZscalerHec_SendToRoutesTrueWithConnectionsConstraint"
	InputZscalerHecUnionTypeInputZscalerHecSendToRoutesFalseWithConnectionsConstraint InputZscalerHecUnionType = "InputZscalerHec_SendToRoutesFalseWithConnectionsConstraint"
	InputZscalerHecUnionTypeInputZscalerHecPqEnabledFalseWithPqConstraint             InputZscalerHecUnionType = "InputZscalerHec_PqEnabledFalseWithPqConstraint"
	InputZscalerHecUnionTypeInputZscalerHecPqEnabledTrueWithPqConstraint              InputZscalerHecUnionType = "InputZscalerHec_PqEnabledTrueWithPqConstraint"
)

type InputZscalerHec struct {
	InputZscalerHecSendToRoutesTrueWithConnectionsConstraint  *InputZscalerHecSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputZscalerHecSendToRoutesFalseWithConnectionsConstraint *InputZscalerHecSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputZscalerHecPqEnabledFalseWithPqConstraint             *InputZscalerHecPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputZscalerHecPqEnabledTrueWithPqConstraint              *InputZscalerHecPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputZscalerHecUnionType
}

func CreateInputZscalerHecInputZscalerHecSendToRoutesTrueWithConnectionsConstraint(inputZscalerHecSendToRoutesTrueWithConnectionsConstraint InputZscalerHecSendToRoutesTrueWithConnectionsConstraint) InputZscalerHec {
	typ := InputZscalerHecUnionTypeInputZscalerHecSendToRoutesTrueWithConnectionsConstraint

	return InputZscalerHec{
		InputZscalerHecSendToRoutesTrueWithConnectionsConstraint: &inputZscalerHecSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputZscalerHecInputZscalerHecSendToRoutesFalseWithConnectionsConstraint(inputZscalerHecSendToRoutesFalseWithConnectionsConstraint InputZscalerHecSendToRoutesFalseWithConnectionsConstraint) InputZscalerHec {
	typ := InputZscalerHecUnionTypeInputZscalerHecSendToRoutesFalseWithConnectionsConstraint

	return InputZscalerHec{
		InputZscalerHecSendToRoutesFalseWithConnectionsConstraint: &inputZscalerHecSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputZscalerHecInputZscalerHecPqEnabledFalseWithPqConstraint(inputZscalerHecPqEnabledFalseWithPqConstraint InputZscalerHecPqEnabledFalseWithPqConstraint) InputZscalerHec {
	typ := InputZscalerHecUnionTypeInputZscalerHecPqEnabledFalseWithPqConstraint

	return InputZscalerHec{
		InputZscalerHecPqEnabledFalseWithPqConstraint: &inputZscalerHecPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputZscalerHecInputZscalerHecPqEnabledTrueWithPqConstraint(inputZscalerHecPqEnabledTrueWithPqConstraint InputZscalerHecPqEnabledTrueWithPqConstraint) InputZscalerHec {
	typ := InputZscalerHecUnionTypeInputZscalerHecPqEnabledTrueWithPqConstraint

	return InputZscalerHec{
		InputZscalerHecPqEnabledTrueWithPqConstraint: &inputZscalerHecPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputZscalerHec) UnmarshalJSON(data []byte) error {

	var inputZscalerHecSendToRoutesTrueWithConnectionsConstraint InputZscalerHecSendToRoutesTrueWithConnectionsConstraint = InputZscalerHecSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputZscalerHecSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputZscalerHecSendToRoutesTrueWithConnectionsConstraint = &inputZscalerHecSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputZscalerHecUnionTypeInputZscalerHecSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputZscalerHecSendToRoutesFalseWithConnectionsConstraint InputZscalerHecSendToRoutesFalseWithConnectionsConstraint = InputZscalerHecSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputZscalerHecSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputZscalerHecSendToRoutesFalseWithConnectionsConstraint = &inputZscalerHecSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputZscalerHecUnionTypeInputZscalerHecSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputZscalerHecPqEnabledFalseWithPqConstraint InputZscalerHecPqEnabledFalseWithPqConstraint = InputZscalerHecPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputZscalerHecPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputZscalerHecPqEnabledFalseWithPqConstraint = &inputZscalerHecPqEnabledFalseWithPqConstraint
		u.Type = InputZscalerHecUnionTypeInputZscalerHecPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputZscalerHecPqEnabledTrueWithPqConstraint InputZscalerHecPqEnabledTrueWithPqConstraint = InputZscalerHecPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputZscalerHecPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputZscalerHecPqEnabledTrueWithPqConstraint = &inputZscalerHecPqEnabledTrueWithPqConstraint
		u.Type = InputZscalerHecUnionTypeInputZscalerHecPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputZscalerHec", string(data))
}

func (u InputZscalerHec) MarshalJSON() ([]byte, error) {
	if u.InputZscalerHecSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputZscalerHecSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputZscalerHecSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputZscalerHecSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputZscalerHecPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputZscalerHecPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputZscalerHecPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputZscalerHecPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputZscalerHec: all fields are null")
}

type InputSecurityLakePqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputSecurityLakeType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputSecurityLakePqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetType() InputSecurityLakeType {
	if i == nil {
		return InputSecurityLakeType("")
	}
	return i.Type
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputSecurityLakePqEnabledTrueWithPqConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputSecurityLakePqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputSecurityLakeType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputSecurityLakePqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetType() InputSecurityLakeType {
	if i == nil {
		return InputSecurityLakeType("")
	}
	return i.Type
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputSecurityLakePqEnabledFalseWithPqConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputSecurityLakeType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetType() InputSecurityLakeType {
	if i == nil {
		return InputSecurityLakeType("")
	}
	return i.Type
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputSecurityLakeType string

const (
	InputSecurityLakeTypeSecurityLake InputSecurityLakeType = "security_lake"
)

func (e InputSecurityLakeType) ToPointer() *InputSecurityLakeType {
	return &e
}
func (e *InputSecurityLakeType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "security_lake":
		*e = InputSecurityLakeType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSecurityLakeType: %v", v)
	}
}

type InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputSecurityLakeType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetType() InputSecurityLakeType {
	if i == nil {
		return InputSecurityLakeType("")
	}
	return i.Type
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputSecurityLakeUnionType string

const (
	InputSecurityLakeUnionTypeInputSecurityLakeSendToRoutesTrueWithConnectionsConstraint  InputSecurityLakeUnionType = "InputSecurityLake_SendToRoutesTrueWithConnectionsConstraint"
	InputSecurityLakeUnionTypeInputSecurityLakeSendToRoutesFalseWithConnectionsConstraint InputSecurityLakeUnionType = "InputSecurityLake_SendToRoutesFalseWithConnectionsConstraint"
	InputSecurityLakeUnionTypeInputSecurityLakePqEnabledFalseWithPqConstraint             InputSecurityLakeUnionType = "InputSecurityLake_PqEnabledFalseWithPqConstraint"
	InputSecurityLakeUnionTypeInputSecurityLakePqEnabledTrueWithPqConstraint              InputSecurityLakeUnionType = "InputSecurityLake_PqEnabledTrueWithPqConstraint"
)

type InputSecurityLake struct {
	InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint  *InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint *InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputSecurityLakePqEnabledFalseWithPqConstraint             *InputSecurityLakePqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputSecurityLakePqEnabledTrueWithPqConstraint              *InputSecurityLakePqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputSecurityLakeUnionType
}

func CreateInputSecurityLakeInputSecurityLakeSendToRoutesTrueWithConnectionsConstraint(inputSecurityLakeSendToRoutesTrueWithConnectionsConstraint InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint) InputSecurityLake {
	typ := InputSecurityLakeUnionTypeInputSecurityLakeSendToRoutesTrueWithConnectionsConstraint

	return InputSecurityLake{
		InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint: &inputSecurityLakeSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSecurityLakeInputSecurityLakeSendToRoutesFalseWithConnectionsConstraint(inputSecurityLakeSendToRoutesFalseWithConnectionsConstraint InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint) InputSecurityLake {
	typ := InputSecurityLakeUnionTypeInputSecurityLakeSendToRoutesFalseWithConnectionsConstraint

	return InputSecurityLake{
		InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint: &inputSecurityLakeSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSecurityLakeInputSecurityLakePqEnabledFalseWithPqConstraint(inputSecurityLakePqEnabledFalseWithPqConstraint InputSecurityLakePqEnabledFalseWithPqConstraint) InputSecurityLake {
	typ := InputSecurityLakeUnionTypeInputSecurityLakePqEnabledFalseWithPqConstraint

	return InputSecurityLake{
		InputSecurityLakePqEnabledFalseWithPqConstraint: &inputSecurityLakePqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputSecurityLakeInputSecurityLakePqEnabledTrueWithPqConstraint(inputSecurityLakePqEnabledTrueWithPqConstraint InputSecurityLakePqEnabledTrueWithPqConstraint) InputSecurityLake {
	typ := InputSecurityLakeUnionTypeInputSecurityLakePqEnabledTrueWithPqConstraint

	return InputSecurityLake{
		InputSecurityLakePqEnabledTrueWithPqConstraint: &inputSecurityLakePqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputSecurityLake) UnmarshalJSON(data []byte) error {

	var inputSecurityLakeSendToRoutesTrueWithConnectionsConstraint InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint = InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSecurityLakeSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint = &inputSecurityLakeSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputSecurityLakeUnionTypeInputSecurityLakeSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputSecurityLakeSendToRoutesFalseWithConnectionsConstraint InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint = InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSecurityLakeSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint = &inputSecurityLakeSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputSecurityLakeUnionTypeInputSecurityLakeSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputSecurityLakePqEnabledFalseWithPqConstraint InputSecurityLakePqEnabledFalseWithPqConstraint = InputSecurityLakePqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSecurityLakePqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputSecurityLakePqEnabledFalseWithPqConstraint = &inputSecurityLakePqEnabledFalseWithPqConstraint
		u.Type = InputSecurityLakeUnionTypeInputSecurityLakePqEnabledFalseWithPqConstraint
		return nil
	}

	var inputSecurityLakePqEnabledTrueWithPqConstraint InputSecurityLakePqEnabledTrueWithPqConstraint = InputSecurityLakePqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSecurityLakePqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputSecurityLakePqEnabledTrueWithPqConstraint = &inputSecurityLakePqEnabledTrueWithPqConstraint
		u.Type = InputSecurityLakeUnionTypeInputSecurityLakePqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSecurityLake", string(data))
}

func (u InputSecurityLake) MarshalJSON() ([]byte, error) {
	if u.InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSecurityLakeSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputSecurityLakePqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSecurityLakePqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputSecurityLakePqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSecurityLakePqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputSecurityLake: all fields are null")
}

type InputNetflowPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputNetflowType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64 `default:"2055" json:"port"`
	// Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
	EnablePassThrough *bool `default:"false" json:"enablePassThrough"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
	TemplateCacheMinutes *float64 `default:"30" json:"templateCacheMinutes"`
	// Accept messages in Netflow V5 format.
	V5Enabled *bool `default:"true" json:"v5Enabled"`
	// Accept messages in Netflow V9 format.
	V9Enabled *bool `default:"true" json:"v9Enabled"`
	// Accept messages in IPFIX format.
	IpfixEnabled *bool `default:"false" json:"ipfixEnabled"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputNetflowPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetType() InputNetflowType {
	if i == nil {
		return InputNetflowType("")
	}
	return i.Type
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetEnablePassThrough() *bool {
	if i == nil {
		return nil
	}
	return i.EnablePassThrough
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetTemplateCacheMinutes() *float64 {
	if i == nil {
		return nil
	}
	return i.TemplateCacheMinutes
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetV5Enabled() *bool {
	if i == nil {
		return nil
	}
	return i.V5Enabled
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetV9Enabled() *bool {
	if i == nil {
		return nil
	}
	return i.V9Enabled
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetIpfixEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.IpfixEnabled
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputNetflowPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputNetflowPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputNetflowType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64 `default:"2055" json:"port"`
	// Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
	EnablePassThrough *bool `default:"false" json:"enablePassThrough"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
	TemplateCacheMinutes *float64 `default:"30" json:"templateCacheMinutes"`
	// Accept messages in Netflow V5 format.
	V5Enabled *bool `default:"true" json:"v5Enabled"`
	// Accept messages in Netflow V9 format.
	V9Enabled *bool `default:"true" json:"v9Enabled"`
	// Accept messages in IPFIX format.
	IpfixEnabled *bool `default:"false" json:"ipfixEnabled"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputNetflowPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetType() InputNetflowType {
	if i == nil {
		return InputNetflowType("")
	}
	return i.Type
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetEnablePassThrough() *bool {
	if i == nil {
		return nil
	}
	return i.EnablePassThrough
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetTemplateCacheMinutes() *float64 {
	if i == nil {
		return nil
	}
	return i.TemplateCacheMinutes
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetV5Enabled() *bool {
	if i == nil {
		return nil
	}
	return i.V5Enabled
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetV9Enabled() *bool {
	if i == nil {
		return nil
	}
	return i.V9Enabled
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetIpfixEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.IpfixEnabled
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputNetflowPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputNetflowSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputNetflowType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64 `default:"2055" json:"port"`
	// Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
	EnablePassThrough *bool `default:"false" json:"enablePassThrough"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
	TemplateCacheMinutes *float64 `default:"30" json:"templateCacheMinutes"`
	// Accept messages in Netflow V5 format.
	V5Enabled *bool `default:"true" json:"v5Enabled"`
	// Accept messages in Netflow V9 format.
	V9Enabled *bool `default:"true" json:"v9Enabled"`
	// Accept messages in IPFIX format.
	IpfixEnabled *bool `default:"false" json:"ipfixEnabled"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputNetflowSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetType() InputNetflowType {
	if i == nil {
		return InputNetflowType("")
	}
	return i.Type
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetEnablePassThrough() *bool {
	if i == nil {
		return nil
	}
	return i.EnablePassThrough
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetTemplateCacheMinutes() *float64 {
	if i == nil {
		return nil
	}
	return i.TemplateCacheMinutes
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetV5Enabled() *bool {
	if i == nil {
		return nil
	}
	return i.V5Enabled
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetV9Enabled() *bool {
	if i == nil {
		return nil
	}
	return i.V9Enabled
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetIpfixEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.IpfixEnabled
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputNetflowSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputNetflowType string

const (
	InputNetflowTypeNetflow InputNetflowType = "netflow"
)

func (e InputNetflowType) ToPointer() *InputNetflowType {
	return &e
}
func (e *InputNetflowType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "netflow":
		*e = InputNetflowType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputNetflowType: %v", v)
	}
}

type InputNetflowSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputNetflowType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64 `default:"2055" json:"port"`
	// Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
	EnablePassThrough *bool `default:"false" json:"enablePassThrough"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
	TemplateCacheMinutes *float64 `default:"30" json:"templateCacheMinutes"`
	// Accept messages in Netflow V5 format.
	V5Enabled *bool `default:"true" json:"v5Enabled"`
	// Accept messages in Netflow V9 format.
	V9Enabled *bool `default:"true" json:"v9Enabled"`
	// Accept messages in IPFIX format.
	IpfixEnabled *bool `default:"false" json:"ipfixEnabled"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputNetflowSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetType() InputNetflowType {
	if i == nil {
		return InputNetflowType("")
	}
	return i.Type
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetEnablePassThrough() *bool {
	if i == nil {
		return nil
	}
	return i.EnablePassThrough
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetTemplateCacheMinutes() *float64 {
	if i == nil {
		return nil
	}
	return i.TemplateCacheMinutes
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetV5Enabled() *bool {
	if i == nil {
		return nil
	}
	return i.V5Enabled
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetV9Enabled() *bool {
	if i == nil {
		return nil
	}
	return i.V9Enabled
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetIpfixEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.IpfixEnabled
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputNetflowSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputNetflowUnionType string

const (
	InputNetflowUnionTypeInputNetflowSendToRoutesTrueWithConnectionsConstraint  InputNetflowUnionType = "InputNetflow_SendToRoutesTrueWithConnectionsConstraint"
	InputNetflowUnionTypeInputNetflowSendToRoutesFalseWithConnectionsConstraint InputNetflowUnionType = "InputNetflow_SendToRoutesFalseWithConnectionsConstraint"
	InputNetflowUnionTypeInputNetflowPqEnabledFalseWithPqConstraint             InputNetflowUnionType = "InputNetflow_PqEnabledFalseWithPqConstraint"
	InputNetflowUnionTypeInputNetflowPqEnabledTrueWithPqConstraint              InputNetflowUnionType = "InputNetflow_PqEnabledTrueWithPqConstraint"
)

type InputNetflow struct {
	InputNetflowSendToRoutesTrueWithConnectionsConstraint  *InputNetflowSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputNetflowSendToRoutesFalseWithConnectionsConstraint *InputNetflowSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputNetflowPqEnabledFalseWithPqConstraint             *InputNetflowPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputNetflowPqEnabledTrueWithPqConstraint              *InputNetflowPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputNetflowUnionType
}

func CreateInputNetflowInputNetflowSendToRoutesTrueWithConnectionsConstraint(inputNetflowSendToRoutesTrueWithConnectionsConstraint InputNetflowSendToRoutesTrueWithConnectionsConstraint) InputNetflow {
	typ := InputNetflowUnionTypeInputNetflowSendToRoutesTrueWithConnectionsConstraint

	return InputNetflow{
		InputNetflowSendToRoutesTrueWithConnectionsConstraint: &inputNetflowSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputNetflowInputNetflowSendToRoutesFalseWithConnectionsConstraint(inputNetflowSendToRoutesFalseWithConnectionsConstraint InputNetflowSendToRoutesFalseWithConnectionsConstraint) InputNetflow {
	typ := InputNetflowUnionTypeInputNetflowSendToRoutesFalseWithConnectionsConstraint

	return InputNetflow{
		InputNetflowSendToRoutesFalseWithConnectionsConstraint: &inputNetflowSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputNetflowInputNetflowPqEnabledFalseWithPqConstraint(inputNetflowPqEnabledFalseWithPqConstraint InputNetflowPqEnabledFalseWithPqConstraint) InputNetflow {
	typ := InputNetflowUnionTypeInputNetflowPqEnabledFalseWithPqConstraint

	return InputNetflow{
		InputNetflowPqEnabledFalseWithPqConstraint: &inputNetflowPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputNetflowInputNetflowPqEnabledTrueWithPqConstraint(inputNetflowPqEnabledTrueWithPqConstraint InputNetflowPqEnabledTrueWithPqConstraint) InputNetflow {
	typ := InputNetflowUnionTypeInputNetflowPqEnabledTrueWithPqConstraint

	return InputNetflow{
		InputNetflowPqEnabledTrueWithPqConstraint: &inputNetflowPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputNetflow) UnmarshalJSON(data []byte) error {

	var inputNetflowSendToRoutesTrueWithConnectionsConstraint InputNetflowSendToRoutesTrueWithConnectionsConstraint = InputNetflowSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputNetflowSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputNetflowSendToRoutesTrueWithConnectionsConstraint = &inputNetflowSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputNetflowUnionTypeInputNetflowSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputNetflowSendToRoutesFalseWithConnectionsConstraint InputNetflowSendToRoutesFalseWithConnectionsConstraint = InputNetflowSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputNetflowSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputNetflowSendToRoutesFalseWithConnectionsConstraint = &inputNetflowSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputNetflowUnionTypeInputNetflowSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputNetflowPqEnabledFalseWithPqConstraint InputNetflowPqEnabledFalseWithPqConstraint = InputNetflowPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputNetflowPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputNetflowPqEnabledFalseWithPqConstraint = &inputNetflowPqEnabledFalseWithPqConstraint
		u.Type = InputNetflowUnionTypeInputNetflowPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputNetflowPqEnabledTrueWithPqConstraint InputNetflowPqEnabledTrueWithPqConstraint = InputNetflowPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputNetflowPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputNetflowPqEnabledTrueWithPqConstraint = &inputNetflowPqEnabledTrueWithPqConstraint
		u.Type = InputNetflowUnionTypeInputNetflowPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputNetflow", string(data))
}

func (u InputNetflow) MarshalJSON() ([]byte, error) {
	if u.InputNetflowSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputNetflowSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputNetflowSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputNetflowSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputNetflowPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputNetflowPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputNetflowPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputNetflowPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputNetflow: all fields are null")
}

type InputWizWebhookPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputWizWebhookType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input. Wildcards are supported (such as /api/v*/hook). Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputWizWebhookPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetType() InputWizWebhookType {
	if i == nil {
		return InputWizWebhookType("")
	}
	return i.Type
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetAllowedPaths() []string {
	if i == nil {
		return nil
	}
	return i.AllowedPaths
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetAllowedMethods() []string {
	if i == nil {
		return nil
	}
	return i.AllowedMethods
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputWizWebhookPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWizWebhookPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputWizWebhookType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input. Wildcards are supported (such as /api/v*/hook). Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputWizWebhookPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetType() InputWizWebhookType {
	if i == nil {
		return InputWizWebhookType("")
	}
	return i.Type
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetAllowedPaths() []string {
	if i == nil {
		return nil
	}
	return i.AllowedPaths
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetAllowedMethods() []string {
	if i == nil {
		return nil
	}
	return i.AllowedMethods
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputWizWebhookPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWizWebhookSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputWizWebhookType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input. Wildcards are supported (such as /api/v*/hook). Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetType() InputWizWebhookType {
	if i == nil {
		return InputWizWebhookType("")
	}
	return i.Type
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetAllowedPaths() []string {
	if i == nil {
		return nil
	}
	return i.AllowedPaths
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetAllowedMethods() []string {
	if i == nil {
		return nil
	}
	return i.AllowedMethods
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWizWebhookType string

const (
	InputWizWebhookTypeWizWebhook InputWizWebhookType = "wiz_webhook"
)

func (e InputWizWebhookType) ToPointer() *InputWizWebhookType {
	return &e
}
func (e *InputWizWebhookType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wiz_webhook":
		*e = InputWizWebhookType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWizWebhookType: %v", v)
	}
}

type InputWizWebhookSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputWizWebhookType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input. Wildcards are supported (such as /api/v*/hook). Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetType() InputWizWebhookType {
	if i == nil {
		return InputWizWebhookType("")
	}
	return i.Type
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetAllowedPaths() []string {
	if i == nil {
		return nil
	}
	return i.AllowedPaths
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetAllowedMethods() []string {
	if i == nil {
		return nil
	}
	return i.AllowedMethods
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWizWebhookUnionType string

const (
	InputWizWebhookUnionTypeInputWizWebhookSendToRoutesTrueWithConnectionsConstraint  InputWizWebhookUnionType = "InputWizWebhook_SendToRoutesTrueWithConnectionsConstraint"
	InputWizWebhookUnionTypeInputWizWebhookSendToRoutesFalseWithConnectionsConstraint InputWizWebhookUnionType = "InputWizWebhook_SendToRoutesFalseWithConnectionsConstraint"
	InputWizWebhookUnionTypeInputWizWebhookPqEnabledFalseWithPqConstraint             InputWizWebhookUnionType = "InputWizWebhook_PqEnabledFalseWithPqConstraint"
	InputWizWebhookUnionTypeInputWizWebhookPqEnabledTrueWithPqConstraint              InputWizWebhookUnionType = "InputWizWebhook_PqEnabledTrueWithPqConstraint"
)

type InputWizWebhook struct {
	InputWizWebhookSendToRoutesTrueWithConnectionsConstraint  *InputWizWebhookSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputWizWebhookSendToRoutesFalseWithConnectionsConstraint *InputWizWebhookSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputWizWebhookPqEnabledFalseWithPqConstraint             *InputWizWebhookPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputWizWebhookPqEnabledTrueWithPqConstraint              *InputWizWebhookPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputWizWebhookUnionType
}

func CreateInputWizWebhookInputWizWebhookSendToRoutesTrueWithConnectionsConstraint(inputWizWebhookSendToRoutesTrueWithConnectionsConstraint InputWizWebhookSendToRoutesTrueWithConnectionsConstraint) InputWizWebhook {
	typ := InputWizWebhookUnionTypeInputWizWebhookSendToRoutesTrueWithConnectionsConstraint

	return InputWizWebhook{
		InputWizWebhookSendToRoutesTrueWithConnectionsConstraint: &inputWizWebhookSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWizWebhookInputWizWebhookSendToRoutesFalseWithConnectionsConstraint(inputWizWebhookSendToRoutesFalseWithConnectionsConstraint InputWizWebhookSendToRoutesFalseWithConnectionsConstraint) InputWizWebhook {
	typ := InputWizWebhookUnionTypeInputWizWebhookSendToRoutesFalseWithConnectionsConstraint

	return InputWizWebhook{
		InputWizWebhookSendToRoutesFalseWithConnectionsConstraint: &inputWizWebhookSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWizWebhookInputWizWebhookPqEnabledFalseWithPqConstraint(inputWizWebhookPqEnabledFalseWithPqConstraint InputWizWebhookPqEnabledFalseWithPqConstraint) InputWizWebhook {
	typ := InputWizWebhookUnionTypeInputWizWebhookPqEnabledFalseWithPqConstraint

	return InputWizWebhook{
		InputWizWebhookPqEnabledFalseWithPqConstraint: &inputWizWebhookPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputWizWebhookInputWizWebhookPqEnabledTrueWithPqConstraint(inputWizWebhookPqEnabledTrueWithPqConstraint InputWizWebhookPqEnabledTrueWithPqConstraint) InputWizWebhook {
	typ := InputWizWebhookUnionTypeInputWizWebhookPqEnabledTrueWithPqConstraint

	return InputWizWebhook{
		InputWizWebhookPqEnabledTrueWithPqConstraint: &inputWizWebhookPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputWizWebhook) UnmarshalJSON(data []byte) error {

	var inputWizWebhookSendToRoutesTrueWithConnectionsConstraint InputWizWebhookSendToRoutesTrueWithConnectionsConstraint = InputWizWebhookSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWizWebhookSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWizWebhookSendToRoutesTrueWithConnectionsConstraint = &inputWizWebhookSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputWizWebhookUnionTypeInputWizWebhookSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputWizWebhookSendToRoutesFalseWithConnectionsConstraint InputWizWebhookSendToRoutesFalseWithConnectionsConstraint = InputWizWebhookSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWizWebhookSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWizWebhookSendToRoutesFalseWithConnectionsConstraint = &inputWizWebhookSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputWizWebhookUnionTypeInputWizWebhookSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputWizWebhookPqEnabledFalseWithPqConstraint InputWizWebhookPqEnabledFalseWithPqConstraint = InputWizWebhookPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWizWebhookPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputWizWebhookPqEnabledFalseWithPqConstraint = &inputWizWebhookPqEnabledFalseWithPqConstraint
		u.Type = InputWizWebhookUnionTypeInputWizWebhookPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputWizWebhookPqEnabledTrueWithPqConstraint InputWizWebhookPqEnabledTrueWithPqConstraint = InputWizWebhookPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWizWebhookPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputWizWebhookPqEnabledTrueWithPqConstraint = &inputWizWebhookPqEnabledTrueWithPqConstraint
		u.Type = InputWizWebhookUnionTypeInputWizWebhookPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputWizWebhook", string(data))
}

func (u InputWizWebhook) MarshalJSON() ([]byte, error) {
	if u.InputWizWebhookSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWizWebhookSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputWizWebhookSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWizWebhookSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputWizWebhookPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWizWebhookPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputWizWebhookPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWizWebhookPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputWizWebhook: all fields are null")
}

type InputWizPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputWizType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
	Endpoint *string `default:"https://api.<region>.app.wiz.io/graphql" json:"endpoint"`
	// The authentication URL to generate an OAuth token
	AuthURL string `json:"authUrl"`
	// The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
	AuthAudienceOverride *string `json:"authAudienceOverride,omitempty"`
	// The client ID of the Wiz application
	ClientID      string                  `json:"clientId"`
	ContentConfig []InputWizContentConfig `json:"contentConfig"`
	// HTTP request inactivity timeout. Use 0 to disable.
	RequestTimeout *float64 `default:"300" json:"requestTimeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// The client secret of the Wiz application
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputWizPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "authUrl", "clientId", "contentConfig"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetType() InputWizType {
	if i == nil {
		return InputWizType("")
	}
	return i.Type
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetAuthURL() string {
	if i == nil {
		return ""
	}
	return i.AuthURL
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetAuthAudienceOverride() *string {
	if i == nil {
		return nil
	}
	return i.AuthAudienceOverride
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetClientID() string {
	if i == nil {
		return ""
	}
	return i.ClientID
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetContentConfig() []InputWizContentConfig {
	if i == nil {
		return []InputWizContentConfig{}
	}
	return i.ContentConfig
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetRetryRules() *components.RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputWizPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputWizPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputWizType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
	Endpoint *string `default:"https://api.<region>.app.wiz.io/graphql" json:"endpoint"`
	// The authentication URL to generate an OAuth token
	AuthURL string `json:"authUrl"`
	// The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
	AuthAudienceOverride *string `json:"authAudienceOverride,omitempty"`
	// The client ID of the Wiz application
	ClientID      string                  `json:"clientId"`
	ContentConfig []InputWizContentConfig `json:"contentConfig"`
	// HTTP request inactivity timeout. Use 0 to disable.
	RequestTimeout *float64 `default:"300" json:"requestTimeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// The client secret of the Wiz application
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputWizPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "authUrl", "clientId", "contentConfig"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetType() InputWizType {
	if i == nil {
		return InputWizType("")
	}
	return i.Type
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetAuthURL() string {
	if i == nil {
		return ""
	}
	return i.AuthURL
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetAuthAudienceOverride() *string {
	if i == nil {
		return nil
	}
	return i.AuthAudienceOverride
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetClientID() string {
	if i == nil {
		return ""
	}
	return i.ClientID
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetContentConfig() []InputWizContentConfig {
	if i == nil {
		return []InputWizContentConfig{}
	}
	return i.ContentConfig
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetRetryRules() *components.RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputWizPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputWizSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputWizType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
	Endpoint *string `default:"https://api.<region>.app.wiz.io/graphql" json:"endpoint"`
	// The authentication URL to generate an OAuth token
	AuthURL string `json:"authUrl"`
	// The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
	AuthAudienceOverride *string `json:"authAudienceOverride,omitempty"`
	// The client ID of the Wiz application
	ClientID      string                  `json:"clientId"`
	ContentConfig []InputWizContentConfig `json:"contentConfig"`
	// HTTP request inactivity timeout. Use 0 to disable.
	RequestTimeout *float64 `default:"300" json:"requestTimeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// The client secret of the Wiz application
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputWizSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "authUrl", "clientId", "contentConfig"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetType() InputWizType {
	if i == nil {
		return InputWizType("")
	}
	return i.Type
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetAuthURL() string {
	if i == nil {
		return ""
	}
	return i.AuthURL
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetAuthAudienceOverride() *string {
	if i == nil {
		return nil
	}
	return i.AuthAudienceOverride
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetClientID() string {
	if i == nil {
		return ""
	}
	return i.ClientID
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetContentConfig() []InputWizContentConfig {
	if i == nil {
		return []InputWizContentConfig{}
	}
	return i.ContentConfig
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputWizSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputWizType string

const (
	InputWizTypeWiz InputWizType = "wiz"
)

func (e InputWizType) ToPointer() *InputWizType {
	return &e
}
func (e *InputWizType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wiz":
		*e = InputWizType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWizType: %v", v)
	}
}

type ManageState struct {
}

func (m ManageState) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *ManageState) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

// InputWizLogLevel - Collector runtime log level
type InputWizLogLevel string

const (
	InputWizLogLevelError InputWizLogLevel = "error"
	InputWizLogLevelWarn  InputWizLogLevel = "warn"
	InputWizLogLevelInfo  InputWizLogLevel = "info"
	InputWizLogLevelDebug InputWizLogLevel = "debug"
	InputWizLogLevelSilly InputWizLogLevel = "silly"
)

func (e InputWizLogLevel) ToPointer() *InputWizLogLevel {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWizLogLevel) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug", "silly":
			return true
		}
	}
	return false
}

type InputWizContentConfig struct {
	// The name of the Wiz query
	ContentType        string  `json:"contentType"`
	ContentDescription *string `json:"contentDescription,omitempty"`
	Enabled            *bool   `default:"false" json:"enabled"`
	// Track collection progress between consecutive scheduled executions
	StateTracking *bool `default:"false" json:"stateTracking"`
	// JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information.
	StateUpdateExpression *string `default:"__timestampExtracted !== false && {latestTime: (state.latestTime || 0) > _time ? state.latestTime : _time}" json:"stateUpdateExpression"`
	// JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep.
	StateMergeExpression *string      `default:"prevState.latestTime > newState.latestTime ? prevState : newState" json:"stateMergeExpression"`
	ManageState          *ManageState `json:"manageState,omitempty"`
	// Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`.
	ContentQuery string `json:"contentQuery"`
	// A cron schedule on which to run this job
	CronSchedule *string `default:"0 */12 * * *" json:"cronSchedule"`
	// Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
	Earliest *string `default:"-12h@h" json:"earliest"`
	// Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
	Latest *string `default:"now" json:"latest"`
	// Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// Collector runtime log level
	LogLevel *InputWizLogLevel `default:"info" json:"logLevel"`
	// Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages.
	MaxPages *float64 `default:"0" json:"maxPages"`
}

func (i InputWizContentConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizContentConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"contentType", "contentQuery"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizContentConfig) GetContentType() string {
	if i == nil {
		return ""
	}
	return i.ContentType
}

func (i *InputWizContentConfig) GetContentDescription() *string {
	if i == nil {
		return nil
	}
	return i.ContentDescription
}

func (i *InputWizContentConfig) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *InputWizContentConfig) GetStateTracking() *bool {
	if i == nil {
		return nil
	}
	return i.StateTracking
}

func (i *InputWizContentConfig) GetStateUpdateExpression() *string {
	if i == nil {
		return nil
	}
	return i.StateUpdateExpression
}

func (i *InputWizContentConfig) GetStateMergeExpression() *string {
	if i == nil {
		return nil
	}
	return i.StateMergeExpression
}

func (i *InputWizContentConfig) GetManageState() *ManageState {
	if i == nil {
		return nil
	}
	return i.ManageState
}

func (i *InputWizContentConfig) GetContentQuery() string {
	if i == nil {
		return ""
	}
	return i.ContentQuery
}

func (i *InputWizContentConfig) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

func (i *InputWizContentConfig) GetEarliest() *string {
	if i == nil {
		return nil
	}
	return i.Earliest
}

func (i *InputWizContentConfig) GetLatest() *string {
	if i == nil {
		return nil
	}
	return i.Latest
}

func (i *InputWizContentConfig) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputWizContentConfig) GetLogLevel() *InputWizLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputWizContentConfig) GetMaxPages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxPages
}

type InputWizSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputWizType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
	Endpoint *string `default:"https://api.<region>.app.wiz.io/graphql" json:"endpoint"`
	// The authentication URL to generate an OAuth token
	AuthURL string `json:"authUrl"`
	// The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
	AuthAudienceOverride *string `json:"authAudienceOverride,omitempty"`
	// The client ID of the Wiz application
	ClientID      string                  `json:"clientId"`
	ContentConfig []InputWizContentConfig `json:"contentConfig"`
	// HTTP request inactivity timeout. Use 0 to disable.
	RequestTimeout *float64 `default:"300" json:"requestTimeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// The client secret of the Wiz application
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputWizSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "authUrl", "clientId", "contentConfig"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetType() InputWizType {
	if i == nil {
		return InputWizType("")
	}
	return i.Type
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetAuthURL() string {
	if i == nil {
		return ""
	}
	return i.AuthURL
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetAuthAudienceOverride() *string {
	if i == nil {
		return nil
	}
	return i.AuthAudienceOverride
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetClientID() string {
	if i == nil {
		return ""
	}
	return i.ClientID
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetContentConfig() []InputWizContentConfig {
	if i == nil {
		return []InputWizContentConfig{}
	}
	return i.ContentConfig
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputWizSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputWizUnionType string

const (
	InputWizUnionTypeInputWizSendToRoutesTrueWithConnectionsConstraint  InputWizUnionType = "InputWiz_SendToRoutesTrueWithConnectionsConstraint"
	InputWizUnionTypeInputWizSendToRoutesFalseWithConnectionsConstraint InputWizUnionType = "InputWiz_SendToRoutesFalseWithConnectionsConstraint"
	InputWizUnionTypeInputWizPqEnabledFalseWithPqConstraint             InputWizUnionType = "InputWiz_PqEnabledFalseWithPqConstraint"
	InputWizUnionTypeInputWizPqEnabledTrueWithPqConstraint              InputWizUnionType = "InputWiz_PqEnabledTrueWithPqConstraint"
)

type InputWiz struct {
	InputWizSendToRoutesTrueWithConnectionsConstraint  *InputWizSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputWizSendToRoutesFalseWithConnectionsConstraint *InputWizSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputWizPqEnabledFalseWithPqConstraint             *InputWizPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputWizPqEnabledTrueWithPqConstraint              *InputWizPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputWizUnionType
}

func CreateInputWizInputWizSendToRoutesTrueWithConnectionsConstraint(inputWizSendToRoutesTrueWithConnectionsConstraint InputWizSendToRoutesTrueWithConnectionsConstraint) InputWiz {
	typ := InputWizUnionTypeInputWizSendToRoutesTrueWithConnectionsConstraint

	return InputWiz{
		InputWizSendToRoutesTrueWithConnectionsConstraint: &inputWizSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWizInputWizSendToRoutesFalseWithConnectionsConstraint(inputWizSendToRoutesFalseWithConnectionsConstraint InputWizSendToRoutesFalseWithConnectionsConstraint) InputWiz {
	typ := InputWizUnionTypeInputWizSendToRoutesFalseWithConnectionsConstraint

	return InputWiz{
		InputWizSendToRoutesFalseWithConnectionsConstraint: &inputWizSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWizInputWizPqEnabledFalseWithPqConstraint(inputWizPqEnabledFalseWithPqConstraint InputWizPqEnabledFalseWithPqConstraint) InputWiz {
	typ := InputWizUnionTypeInputWizPqEnabledFalseWithPqConstraint

	return InputWiz{
		InputWizPqEnabledFalseWithPqConstraint: &inputWizPqEnabledFalseWithPqConstraint,
		Type:                                   typ,
	}
}

func CreateInputWizInputWizPqEnabledTrueWithPqConstraint(inputWizPqEnabledTrueWithPqConstraint InputWizPqEnabledTrueWithPqConstraint) InputWiz {
	typ := InputWizUnionTypeInputWizPqEnabledTrueWithPqConstraint

	return InputWiz{
		InputWizPqEnabledTrueWithPqConstraint: &inputWizPqEnabledTrueWithPqConstraint,
		Type:                                  typ,
	}
}

func (u *InputWiz) UnmarshalJSON(data []byte) error {

	var inputWizSendToRoutesTrueWithConnectionsConstraint InputWizSendToRoutesTrueWithConnectionsConstraint = InputWizSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWizSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWizSendToRoutesTrueWithConnectionsConstraint = &inputWizSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputWizUnionTypeInputWizSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputWizSendToRoutesFalseWithConnectionsConstraint InputWizSendToRoutesFalseWithConnectionsConstraint = InputWizSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWizSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWizSendToRoutesFalseWithConnectionsConstraint = &inputWizSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputWizUnionTypeInputWizSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputWizPqEnabledFalseWithPqConstraint InputWizPqEnabledFalseWithPqConstraint = InputWizPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWizPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputWizPqEnabledFalseWithPqConstraint = &inputWizPqEnabledFalseWithPqConstraint
		u.Type = InputWizUnionTypeInputWizPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputWizPqEnabledTrueWithPqConstraint InputWizPqEnabledTrueWithPqConstraint = InputWizPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWizPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputWizPqEnabledTrueWithPqConstraint = &inputWizPqEnabledTrueWithPqConstraint
		u.Type = InputWizUnionTypeInputWizPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputWiz", string(data))
}

func (u InputWiz) MarshalJSON() ([]byte, error) {
	if u.InputWizSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWizSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputWizSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWizSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputWizPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWizPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputWizPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWizPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputWiz: all fields are null")
}

type PqEnabledTrueWithPqConstraintInputJournalFilesType string

const (
	PqEnabledTrueWithPqConstraintInputJournalFilesTypeJournalFiles PqEnabledTrueWithPqConstraintInputJournalFilesType = "journal_files"
)

func (e PqEnabledTrueWithPqConstraintInputJournalFilesType) ToPointer() *PqEnabledTrueWithPqConstraintInputJournalFilesType {
	return &e
}
func (e *PqEnabledTrueWithPqConstraintInputJournalFilesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "journal_files":
		*e = PqEnabledTrueWithPqConstraintInputJournalFilesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PqEnabledTrueWithPqConstraintInputJournalFilesType: %v", v)
	}
}

type PqEnabledTrueWithPqConstraintRule struct {
	// JavaScript expression applied to Journal objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (p PqEnabledTrueWithPqConstraintRule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PqEnabledTrueWithPqConstraintRule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (p *PqEnabledTrueWithPqConstraintRule) GetFilter() string {
	if p == nil {
		return ""
	}
	return p.Filter
}

func (p *PqEnabledTrueWithPqConstraintRule) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

type InputJournalFilesPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                                             `json:"id"`
	Type     PqEnabledTrueWithPqConstraintInputJournalFilesType `json:"type"`
	Disabled *bool                                              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
	Path string `json:"path"`
	// Time, in seconds, between scanning for journals.
	Interval *float64 `default:"10" json:"interval"`
	// The full path of discovered journals are matched against this wildcard list.
	Journals []string `json:"journals"`
	// Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
	Rules []PqEnabledTrueWithPqConstraintRule `json:"rules,omitempty"`
	// Skip log messages that are not part of the current boot session.
	CurrentBoot *bool `default:"false" json:"currentBoot"`
	// The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputJournalFilesPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "path", "journals"}); err != nil {
		return err
	}
	return nil
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetType() PqEnabledTrueWithPqConstraintInputJournalFilesType {
	if i == nil {
		return PqEnabledTrueWithPqConstraintInputJournalFilesType("")
	}
	return i.Type
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetPath() string {
	if i == nil {
		return ""
	}
	return i.Path
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetJournals() []string {
	if i == nil {
		return []string{}
	}
	return i.Journals
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetRules() []PqEnabledTrueWithPqConstraintRule {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetCurrentBoot() *bool {
	if i == nil {
		return nil
	}
	return i.CurrentBoot
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetMaxAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MaxAgeDur
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputJournalFilesPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type PqEnabledFalseWithPqConstraintInputJournalFilesType string

const (
	PqEnabledFalseWithPqConstraintInputJournalFilesTypeJournalFiles PqEnabledFalseWithPqConstraintInputJournalFilesType = "journal_files"
)

func (e PqEnabledFalseWithPqConstraintInputJournalFilesType) ToPointer() *PqEnabledFalseWithPqConstraintInputJournalFilesType {
	return &e
}
func (e *PqEnabledFalseWithPqConstraintInputJournalFilesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "journal_files":
		*e = PqEnabledFalseWithPqConstraintInputJournalFilesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PqEnabledFalseWithPqConstraintInputJournalFilesType: %v", v)
	}
}

type PqEnabledFalseWithPqConstraintRule struct {
	// JavaScript expression applied to Journal objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (p PqEnabledFalseWithPqConstraintRule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PqEnabledFalseWithPqConstraintRule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (p *PqEnabledFalseWithPqConstraintRule) GetFilter() string {
	if p == nil {
		return ""
	}
	return p.Filter
}

func (p *PqEnabledFalseWithPqConstraintRule) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

type InputJournalFilesPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                                              `json:"id"`
	Type     PqEnabledFalseWithPqConstraintInputJournalFilesType `json:"type"`
	Disabled *bool                                               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
	Path string `json:"path"`
	// Time, in seconds, between scanning for journals.
	Interval *float64 `default:"10" json:"interval"`
	// The full path of discovered journals are matched against this wildcard list.
	Journals []string `json:"journals"`
	// Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
	Rules []PqEnabledFalseWithPqConstraintRule `json:"rules,omitempty"`
	// Skip log messages that are not part of the current boot session.
	CurrentBoot *bool `default:"false" json:"currentBoot"`
	// The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputJournalFilesPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "path", "journals"}); err != nil {
		return err
	}
	return nil
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetType() PqEnabledFalseWithPqConstraintInputJournalFilesType {
	if i == nil {
		return PqEnabledFalseWithPqConstraintInputJournalFilesType("")
	}
	return i.Type
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetPath() string {
	if i == nil {
		return ""
	}
	return i.Path
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetJournals() []string {
	if i == nil {
		return []string{}
	}
	return i.Journals
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetRules() []PqEnabledFalseWithPqConstraintRule {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetCurrentBoot() *bool {
	if i == nil {
		return nil
	}
	return i.CurrentBoot
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetMaxAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MaxAgeDur
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputJournalFilesPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType string

const (
	SendToRoutesFalseWithConnectionsConstraintInputJournalFilesTypeJournalFiles SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType = "journal_files"
)

func (e SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType) ToPointer() *SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType {
	return &e
}
func (e *SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "journal_files":
		*e = SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType: %v", v)
	}
}

type SendToRoutesFalseWithConnectionsConstraintRule struct {
	// JavaScript expression applied to Journal objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (s SendToRoutesFalseWithConnectionsConstraintRule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SendToRoutesFalseWithConnectionsConstraintRule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (s *SendToRoutesFalseWithConnectionsConstraintRule) GetFilter() string {
	if s == nil {
		return ""
	}
	return s.Filter
}

func (s *SendToRoutesFalseWithConnectionsConstraintRule) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

type InputJournalFilesSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                                                          `json:"id"`
	Type     SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType `json:"type"`
	Disabled *bool                                                           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
	Path string `json:"path"`
	// Time, in seconds, between scanning for journals.
	Interval *float64 `default:"10" json:"interval"`
	// The full path of discovered journals are matched against this wildcard list.
	Journals []string `json:"journals"`
	// Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
	Rules []SendToRoutesFalseWithConnectionsConstraintRule `json:"rules,omitempty"`
	// Skip log messages that are not part of the current boot session.
	CurrentBoot *bool `default:"false" json:"currentBoot"`
	// The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "path", "journals"}); err != nil {
		return err
	}
	return nil
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetType() SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType {
	if i == nil {
		return SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType("")
	}
	return i.Type
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetPath() string {
	if i == nil {
		return ""
	}
	return i.Path
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetJournals() []string {
	if i == nil {
		return []string{}
	}
	return i.Journals
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetRules() []SendToRoutesFalseWithConnectionsConstraintRule {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetCurrentBoot() *bool {
	if i == nil {
		return nil
	}
	return i.CurrentBoot
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetMaxAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MaxAgeDur
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType string

const (
	SendToRoutesTrueWithConnectionsConstraintInputJournalFilesTypeJournalFiles SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType = "journal_files"
)

func (e SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType) ToPointer() *SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType {
	return &e
}
func (e *SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "journal_files":
		*e = SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType: %v", v)
	}
}

type SendToRoutesTrueWithConnectionsConstraintRule struct {
	// JavaScript expression applied to Journal objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (s SendToRoutesTrueWithConnectionsConstraintRule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SendToRoutesTrueWithConnectionsConstraintRule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (s *SendToRoutesTrueWithConnectionsConstraintRule) GetFilter() string {
	if s == nil {
		return ""
	}
	return s.Filter
}

func (s *SendToRoutesTrueWithConnectionsConstraintRule) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

type InputJournalFilesSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                                                         `json:"id"`
	Type     SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType `json:"type"`
	Disabled *bool                                                          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
	Path string `json:"path"`
	// Time, in seconds, between scanning for journals.
	Interval *float64 `default:"10" json:"interval"`
	// The full path of discovered journals are matched against this wildcard list.
	Journals []string `json:"journals"`
	// Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
	Rules []SendToRoutesTrueWithConnectionsConstraintRule `json:"rules,omitempty"`
	// Skip log messages that are not part of the current boot session.
	CurrentBoot *bool `default:"false" json:"currentBoot"`
	// The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "path", "journals"}); err != nil {
		return err
	}
	return nil
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetType() SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType {
	if i == nil {
		return SendToRoutesTrueWithConnectionsConstraintInputJournalFilesType("")
	}
	return i.Type
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetPath() string {
	if i == nil {
		return ""
	}
	return i.Path
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetJournals() []string {
	if i == nil {
		return []string{}
	}
	return i.Journals
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetRules() []SendToRoutesTrueWithConnectionsConstraintRule {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetCurrentBoot() *bool {
	if i == nil {
		return nil
	}
	return i.CurrentBoot
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetMaxAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MaxAgeDur
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputJournalFilesType string

const (
	InputJournalFilesTypeInputJournalFilesSendToRoutesTrueWithConnectionsConstraint  InputJournalFilesType = "InputJournalFiles_SendToRoutesTrueWithConnectionsConstraint"
	InputJournalFilesTypeInputJournalFilesSendToRoutesFalseWithConnectionsConstraint InputJournalFilesType = "InputJournalFiles_SendToRoutesFalseWithConnectionsConstraint"
	InputJournalFilesTypeInputJournalFilesPqEnabledFalseWithPqConstraint             InputJournalFilesType = "InputJournalFiles_PqEnabledFalseWithPqConstraint"
	InputJournalFilesTypeInputJournalFilesPqEnabledTrueWithPqConstraint              InputJournalFilesType = "InputJournalFiles_PqEnabledTrueWithPqConstraint"
)

type InputJournalFiles struct {
	InputJournalFilesSendToRoutesTrueWithConnectionsConstraint  *InputJournalFilesSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputJournalFilesSendToRoutesFalseWithConnectionsConstraint *InputJournalFilesSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputJournalFilesPqEnabledFalseWithPqConstraint             *InputJournalFilesPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputJournalFilesPqEnabledTrueWithPqConstraint              *InputJournalFilesPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputJournalFilesType
}

func CreateInputJournalFilesInputJournalFilesSendToRoutesTrueWithConnectionsConstraint(inputJournalFilesSendToRoutesTrueWithConnectionsConstraint InputJournalFilesSendToRoutesTrueWithConnectionsConstraint) InputJournalFiles {
	typ := InputJournalFilesTypeInputJournalFilesSendToRoutesTrueWithConnectionsConstraint

	return InputJournalFiles{
		InputJournalFilesSendToRoutesTrueWithConnectionsConstraint: &inputJournalFilesSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputJournalFilesInputJournalFilesSendToRoutesFalseWithConnectionsConstraint(inputJournalFilesSendToRoutesFalseWithConnectionsConstraint InputJournalFilesSendToRoutesFalseWithConnectionsConstraint) InputJournalFiles {
	typ := InputJournalFilesTypeInputJournalFilesSendToRoutesFalseWithConnectionsConstraint

	return InputJournalFiles{
		InputJournalFilesSendToRoutesFalseWithConnectionsConstraint: &inputJournalFilesSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputJournalFilesInputJournalFilesPqEnabledFalseWithPqConstraint(inputJournalFilesPqEnabledFalseWithPqConstraint InputJournalFilesPqEnabledFalseWithPqConstraint) InputJournalFiles {
	typ := InputJournalFilesTypeInputJournalFilesPqEnabledFalseWithPqConstraint

	return InputJournalFiles{
		InputJournalFilesPqEnabledFalseWithPqConstraint: &inputJournalFilesPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputJournalFilesInputJournalFilesPqEnabledTrueWithPqConstraint(inputJournalFilesPqEnabledTrueWithPqConstraint InputJournalFilesPqEnabledTrueWithPqConstraint) InputJournalFiles {
	typ := InputJournalFilesTypeInputJournalFilesPqEnabledTrueWithPqConstraint

	return InputJournalFiles{
		InputJournalFilesPqEnabledTrueWithPqConstraint: &inputJournalFilesPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputJournalFiles) UnmarshalJSON(data []byte) error {

	var inputJournalFilesSendToRoutesTrueWithConnectionsConstraint InputJournalFilesSendToRoutesTrueWithConnectionsConstraint = InputJournalFilesSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputJournalFilesSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputJournalFilesSendToRoutesTrueWithConnectionsConstraint = &inputJournalFilesSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputJournalFilesTypeInputJournalFilesSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputJournalFilesSendToRoutesFalseWithConnectionsConstraint InputJournalFilesSendToRoutesFalseWithConnectionsConstraint = InputJournalFilesSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputJournalFilesSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputJournalFilesSendToRoutesFalseWithConnectionsConstraint = &inputJournalFilesSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputJournalFilesTypeInputJournalFilesSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputJournalFilesPqEnabledFalseWithPqConstraint InputJournalFilesPqEnabledFalseWithPqConstraint = InputJournalFilesPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputJournalFilesPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputJournalFilesPqEnabledFalseWithPqConstraint = &inputJournalFilesPqEnabledFalseWithPqConstraint
		u.Type = InputJournalFilesTypeInputJournalFilesPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputJournalFilesPqEnabledTrueWithPqConstraint InputJournalFilesPqEnabledTrueWithPqConstraint = InputJournalFilesPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputJournalFilesPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputJournalFilesPqEnabledTrueWithPqConstraint = &inputJournalFilesPqEnabledTrueWithPqConstraint
		u.Type = InputJournalFilesTypeInputJournalFilesPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputJournalFiles", string(data))
}

func (u InputJournalFiles) MarshalJSON() ([]byte, error) {
	if u.InputJournalFilesSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputJournalFilesSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputJournalFilesSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputJournalFilesSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputJournalFilesPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputJournalFilesPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputJournalFilesPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputJournalFilesPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputJournalFiles: all fields are null")
}

type InputRawUDPPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string          `json:"id"`
	Type     InputRawUDPType `json:"type"`
	Disabled *bool           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
	SingleMsgUDPPackets *bool `default:"false" json:"singleMsgUdpPackets"`
	// If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
	IngestRawBytes *bool `default:"false" json:"ingestRawBytes"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputRawUDPPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetType() InputRawUDPType {
	if i == nil {
		return InputRawUDPType("")
	}
	return i.Type
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetSingleMsgUDPPackets() *bool {
	if i == nil {
		return nil
	}
	return i.SingleMsgUDPPackets
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetIngestRawBytes() *bool {
	if i == nil {
		return nil
	}
	return i.IngestRawBytes
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputRawUDPPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputRawUDPPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string          `json:"id"`
	Type     InputRawUDPType `json:"type"`
	Disabled *bool           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
	SingleMsgUDPPackets *bool `default:"false" json:"singleMsgUdpPackets"`
	// If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
	IngestRawBytes *bool `default:"false" json:"ingestRawBytes"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputRawUDPPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetType() InputRawUDPType {
	if i == nil {
		return InputRawUDPType("")
	}
	return i.Type
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetSingleMsgUDPPackets() *bool {
	if i == nil {
		return nil
	}
	return i.SingleMsgUDPPackets
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetIngestRawBytes() *bool {
	if i == nil {
		return nil
	}
	return i.IngestRawBytes
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputRawUDPPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputRawUDPSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string          `json:"id"`
	Type     InputRawUDPType `json:"type"`
	Disabled *bool           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
	SingleMsgUDPPackets *bool `default:"false" json:"singleMsgUdpPackets"`
	// If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
	IngestRawBytes *bool `default:"false" json:"ingestRawBytes"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputRawUDPSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetType() InputRawUDPType {
	if i == nil {
		return InputRawUDPType("")
	}
	return i.Type
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetSingleMsgUDPPackets() *bool {
	if i == nil {
		return nil
	}
	return i.SingleMsgUDPPackets
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetIngestRawBytes() *bool {
	if i == nil {
		return nil
	}
	return i.IngestRawBytes
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputRawUDPSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputRawUDPType string

const (
	InputRawUDPTypeRawUDP InputRawUDPType = "raw_udp"
)

func (e InputRawUDPType) ToPointer() *InputRawUDPType {
	return &e
}
func (e *InputRawUDPType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "raw_udp":
		*e = InputRawUDPType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputRawUDPType: %v", v)
	}
}

type InputRawUDPSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string          `json:"id"`
	Type     InputRawUDPType `json:"type"`
	Disabled *bool           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
	SingleMsgUDPPackets *bool `default:"false" json:"singleMsgUdpPackets"`
	// If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
	IngestRawBytes *bool `default:"false" json:"ingestRawBytes"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputRawUDPSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetType() InputRawUDPType {
	if i == nil {
		return InputRawUDPType("")
	}
	return i.Type
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetSingleMsgUDPPackets() *bool {
	if i == nil {
		return nil
	}
	return i.SingleMsgUDPPackets
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetIngestRawBytes() *bool {
	if i == nil {
		return nil
	}
	return i.IngestRawBytes
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputRawUDPSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputRawUDPUnionType string

const (
	InputRawUDPUnionTypeInputRawUDPSendToRoutesTrueWithConnectionsConstraint  InputRawUDPUnionType = "InputRawUdp_SendToRoutesTrueWithConnectionsConstraint"
	InputRawUDPUnionTypeInputRawUDPSendToRoutesFalseWithConnectionsConstraint InputRawUDPUnionType = "InputRawUdp_SendToRoutesFalseWithConnectionsConstraint"
	InputRawUDPUnionTypeInputRawUDPPqEnabledFalseWithPqConstraint             InputRawUDPUnionType = "InputRawUdp_PqEnabledFalseWithPqConstraint"
	InputRawUDPUnionTypeInputRawUDPPqEnabledTrueWithPqConstraint              InputRawUDPUnionType = "InputRawUdp_PqEnabledTrueWithPqConstraint"
)

type InputRawUDP struct {
	InputRawUDPSendToRoutesTrueWithConnectionsConstraint  *InputRawUDPSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputRawUDPSendToRoutesFalseWithConnectionsConstraint *InputRawUDPSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputRawUDPPqEnabledFalseWithPqConstraint             *InputRawUDPPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputRawUDPPqEnabledTrueWithPqConstraint              *InputRawUDPPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputRawUDPUnionType
}

func CreateInputRawUDPInputRawUDPSendToRoutesTrueWithConnectionsConstraint(inputRawUDPSendToRoutesTrueWithConnectionsConstraint InputRawUDPSendToRoutesTrueWithConnectionsConstraint) InputRawUDP {
	typ := InputRawUDPUnionTypeInputRawUDPSendToRoutesTrueWithConnectionsConstraint

	return InputRawUDP{
		InputRawUDPSendToRoutesTrueWithConnectionsConstraint: &inputRawUDPSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputRawUDPInputRawUDPSendToRoutesFalseWithConnectionsConstraint(inputRawUDPSendToRoutesFalseWithConnectionsConstraint InputRawUDPSendToRoutesFalseWithConnectionsConstraint) InputRawUDP {
	typ := InputRawUDPUnionTypeInputRawUDPSendToRoutesFalseWithConnectionsConstraint

	return InputRawUDP{
		InputRawUDPSendToRoutesFalseWithConnectionsConstraint: &inputRawUDPSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputRawUDPInputRawUDPPqEnabledFalseWithPqConstraint(inputRawUDPPqEnabledFalseWithPqConstraint InputRawUDPPqEnabledFalseWithPqConstraint) InputRawUDP {
	typ := InputRawUDPUnionTypeInputRawUDPPqEnabledFalseWithPqConstraint

	return InputRawUDP{
		InputRawUDPPqEnabledFalseWithPqConstraint: &inputRawUDPPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputRawUDPInputRawUDPPqEnabledTrueWithPqConstraint(inputRawUDPPqEnabledTrueWithPqConstraint InputRawUDPPqEnabledTrueWithPqConstraint) InputRawUDP {
	typ := InputRawUDPUnionTypeInputRawUDPPqEnabledTrueWithPqConstraint

	return InputRawUDP{
		InputRawUDPPqEnabledTrueWithPqConstraint: &inputRawUDPPqEnabledTrueWithPqConstraint,
		Type:                                     typ,
	}
}

func (u *InputRawUDP) UnmarshalJSON(data []byte) error {

	var inputRawUDPSendToRoutesTrueWithConnectionsConstraint InputRawUDPSendToRoutesTrueWithConnectionsConstraint = InputRawUDPSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputRawUDPSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputRawUDPSendToRoutesTrueWithConnectionsConstraint = &inputRawUDPSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputRawUDPUnionTypeInputRawUDPSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputRawUDPSendToRoutesFalseWithConnectionsConstraint InputRawUDPSendToRoutesFalseWithConnectionsConstraint = InputRawUDPSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputRawUDPSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputRawUDPSendToRoutesFalseWithConnectionsConstraint = &inputRawUDPSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputRawUDPUnionTypeInputRawUDPSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputRawUDPPqEnabledFalseWithPqConstraint InputRawUDPPqEnabledFalseWithPqConstraint = InputRawUDPPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputRawUDPPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputRawUDPPqEnabledFalseWithPqConstraint = &inputRawUDPPqEnabledFalseWithPqConstraint
		u.Type = InputRawUDPUnionTypeInputRawUDPPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputRawUDPPqEnabledTrueWithPqConstraint InputRawUDPPqEnabledTrueWithPqConstraint = InputRawUDPPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputRawUDPPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputRawUDPPqEnabledTrueWithPqConstraint = &inputRawUDPPqEnabledTrueWithPqConstraint
		u.Type = InputRawUDPUnionTypeInputRawUDPPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputRawUDP", string(data))
}

func (u InputRawUDP) MarshalJSON() ([]byte, error) {
	if u.InputRawUDPSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputRawUDPSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputRawUDPSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputRawUDPSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputRawUDPPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputRawUDPPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputRawUDPPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputRawUDPPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputRawUDP: all fields are null")
}

type InputWinEventLogsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputWinEventLogsType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
	LogNames []string `json:"logNames"`
	// Read all stored and future event logs, or only future events
	ReadMode *ReadMode `default:"newest" json:"readMode"`
	// Format of individual events
	EventFormat *EventFormat `default:"json" json:"eventFormat"`
	// Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
	DisableNativeModule *bool `default:"false" json:"disableNativeModule"`
	// Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
	Interval *float64 `default:"10" json:"interval"`
	// The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
	BatchSize *float64 `default:"500" json:"batchSize"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// The maximum number of bytes in an event before it is flushed to the pipelines
	MaxEventBytes *float64 `default:"51200" json:"maxEventBytes"`
	Description   *string  `json:"description,omitempty"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableJSONRendering *bool `default:"false" json:"disableJsonRendering"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableXMLRendering *bool `default:"true" json:"disableXmlRendering"`
}

func (i InputWinEventLogsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "logNames"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetType() InputWinEventLogsType {
	if i == nil {
		return InputWinEventLogsType("")
	}
	return i.Type
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetLogNames() []string {
	if i == nil {
		return []string{}
	}
	return i.LogNames
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetReadMode() *ReadMode {
	if i == nil {
		return nil
	}
	return i.ReadMode
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetEventFormat() *EventFormat {
	if i == nil {
		return nil
	}
	return i.EventFormat
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetBatchSize() *float64 {
	if i == nil {
		return nil
	}
	return i.BatchSize
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetMaxEventBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxEventBytes
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetDisableJSONRendering() *bool {
	if i == nil {
		return nil
	}
	return i.DisableJSONRendering
}

func (i *InputWinEventLogsPqEnabledTrueWithPqConstraint) GetDisableXMLRendering() *bool {
	if i == nil {
		return nil
	}
	return i.DisableXMLRendering
}

type InputWinEventLogsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputWinEventLogsType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
	LogNames []string `json:"logNames"`
	// Read all stored and future event logs, or only future events
	ReadMode *ReadMode `default:"newest" json:"readMode"`
	// Format of individual events
	EventFormat *EventFormat `default:"json" json:"eventFormat"`
	// Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
	DisableNativeModule *bool `default:"false" json:"disableNativeModule"`
	// Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
	Interval *float64 `default:"10" json:"interval"`
	// The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
	BatchSize *float64 `default:"500" json:"batchSize"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// The maximum number of bytes in an event before it is flushed to the pipelines
	MaxEventBytes *float64 `default:"51200" json:"maxEventBytes"`
	Description   *string  `json:"description,omitempty"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableJSONRendering *bool `default:"false" json:"disableJsonRendering"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableXMLRendering *bool `default:"true" json:"disableXmlRendering"`
}

func (i InputWinEventLogsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "logNames"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetType() InputWinEventLogsType {
	if i == nil {
		return InputWinEventLogsType("")
	}
	return i.Type
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetLogNames() []string {
	if i == nil {
		return []string{}
	}
	return i.LogNames
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetReadMode() *ReadMode {
	if i == nil {
		return nil
	}
	return i.ReadMode
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetEventFormat() *EventFormat {
	if i == nil {
		return nil
	}
	return i.EventFormat
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetBatchSize() *float64 {
	if i == nil {
		return nil
	}
	return i.BatchSize
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetMaxEventBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxEventBytes
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetDisableJSONRendering() *bool {
	if i == nil {
		return nil
	}
	return i.DisableJSONRendering
}

func (i *InputWinEventLogsPqEnabledFalseWithPqConstraint) GetDisableXMLRendering() *bool {
	if i == nil {
		return nil
	}
	return i.DisableXMLRendering
}

type InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputWinEventLogsType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
	LogNames []string `json:"logNames"`
	// Read all stored and future event logs, or only future events
	ReadMode *ReadMode `default:"newest" json:"readMode"`
	// Format of individual events
	EventFormat *EventFormat `default:"json" json:"eventFormat"`
	// Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
	DisableNativeModule *bool `default:"false" json:"disableNativeModule"`
	// Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
	Interval *float64 `default:"10" json:"interval"`
	// The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
	BatchSize *float64 `default:"500" json:"batchSize"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// The maximum number of bytes in an event before it is flushed to the pipelines
	MaxEventBytes *float64 `default:"51200" json:"maxEventBytes"`
	Description   *string  `json:"description,omitempty"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableJSONRendering *bool `default:"false" json:"disableJsonRendering"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableXMLRendering *bool `default:"true" json:"disableXmlRendering"`
}

func (i InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "logNames"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetType() InputWinEventLogsType {
	if i == nil {
		return InputWinEventLogsType("")
	}
	return i.Type
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetLogNames() []string {
	if i == nil {
		return []string{}
	}
	return i.LogNames
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetReadMode() *ReadMode {
	if i == nil {
		return nil
	}
	return i.ReadMode
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetEventFormat() *EventFormat {
	if i == nil {
		return nil
	}
	return i.EventFormat
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetBatchSize() *float64 {
	if i == nil {
		return nil
	}
	return i.BatchSize
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetMaxEventBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxEventBytes
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetDisableJSONRendering() *bool {
	if i == nil {
		return nil
	}
	return i.DisableJSONRendering
}

func (i *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) GetDisableXMLRendering() *bool {
	if i == nil {
		return nil
	}
	return i.DisableXMLRendering
}

type InputWinEventLogsType string

const (
	InputWinEventLogsTypeWinEventLogs InputWinEventLogsType = "win_event_logs"
)

func (e InputWinEventLogsType) ToPointer() *InputWinEventLogsType {
	return &e
}
func (e *InputWinEventLogsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "win_event_logs":
		*e = InputWinEventLogsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWinEventLogsType: %v", v)
	}
}

// ReadMode - Read all stored and future event logs, or only future events
type ReadMode string

const (
	// ReadModeOldest Entire log
	ReadModeOldest ReadMode = "oldest"
	// ReadModeNewest From last entry
	ReadModeNewest ReadMode = "newest"
)

func (e ReadMode) ToPointer() *ReadMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ReadMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "oldest", "newest":
			return true
		}
	}
	return false
}

// EventFormat - Format of individual events
type EventFormat string

const (
	// EventFormatJSON JSON
	EventFormatJSON EventFormat = "json"
	// EventFormatXML XML
	EventFormatXML EventFormat = "xml"
)

func (e EventFormat) ToPointer() *EventFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *EventFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "json", "xml":
			return true
		}
	}
	return false
}

type InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputWinEventLogsType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
	LogNames []string `json:"logNames"`
	// Read all stored and future event logs, or only future events
	ReadMode *ReadMode `default:"newest" json:"readMode"`
	// Format of individual events
	EventFormat *EventFormat `default:"json" json:"eventFormat"`
	// Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
	DisableNativeModule *bool `default:"false" json:"disableNativeModule"`
	// Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
	Interval *float64 `default:"10" json:"interval"`
	// The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
	BatchSize *float64 `default:"500" json:"batchSize"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// The maximum number of bytes in an event before it is flushed to the pipelines
	MaxEventBytes *float64 `default:"51200" json:"maxEventBytes"`
	Description   *string  `json:"description,omitempty"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableJSONRendering *bool `default:"false" json:"disableJsonRendering"`
	// Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
	DisableXMLRendering *bool `default:"true" json:"disableXmlRendering"`
}

func (i InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "logNames"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetType() InputWinEventLogsType {
	if i == nil {
		return InputWinEventLogsType("")
	}
	return i.Type
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetLogNames() []string {
	if i == nil {
		return []string{}
	}
	return i.LogNames
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetReadMode() *ReadMode {
	if i == nil {
		return nil
	}
	return i.ReadMode
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetEventFormat() *EventFormat {
	if i == nil {
		return nil
	}
	return i.EventFormat
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetBatchSize() *float64 {
	if i == nil {
		return nil
	}
	return i.BatchSize
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetMaxEventBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxEventBytes
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetDisableJSONRendering() *bool {
	if i == nil {
		return nil
	}
	return i.DisableJSONRendering
}

func (i *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) GetDisableXMLRendering() *bool {
	if i == nil {
		return nil
	}
	return i.DisableXMLRendering
}

type InputWinEventLogsUnionType string

const (
	InputWinEventLogsUnionTypeInputWinEventLogsSendToRoutesTrueWithConnectionsConstraint  InputWinEventLogsUnionType = "InputWinEventLogs_SendToRoutesTrueWithConnectionsConstraint"
	InputWinEventLogsUnionTypeInputWinEventLogsSendToRoutesFalseWithConnectionsConstraint InputWinEventLogsUnionType = "InputWinEventLogs_SendToRoutesFalseWithConnectionsConstraint"
	InputWinEventLogsUnionTypeInputWinEventLogsPqEnabledFalseWithPqConstraint             InputWinEventLogsUnionType = "InputWinEventLogs_PqEnabledFalseWithPqConstraint"
	InputWinEventLogsUnionTypeInputWinEventLogsPqEnabledTrueWithPqConstraint              InputWinEventLogsUnionType = "InputWinEventLogs_PqEnabledTrueWithPqConstraint"
)

type InputWinEventLogs struct {
	InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint  *InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint *InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputWinEventLogsPqEnabledFalseWithPqConstraint             *InputWinEventLogsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputWinEventLogsPqEnabledTrueWithPqConstraint              *InputWinEventLogsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputWinEventLogsUnionType
}

func CreateInputWinEventLogsInputWinEventLogsSendToRoutesTrueWithConnectionsConstraint(inputWinEventLogsSendToRoutesTrueWithConnectionsConstraint InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint) InputWinEventLogs {
	typ := InputWinEventLogsUnionTypeInputWinEventLogsSendToRoutesTrueWithConnectionsConstraint

	return InputWinEventLogs{
		InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint: &inputWinEventLogsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWinEventLogsInputWinEventLogsSendToRoutesFalseWithConnectionsConstraint(inputWinEventLogsSendToRoutesFalseWithConnectionsConstraint InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint) InputWinEventLogs {
	typ := InputWinEventLogsUnionTypeInputWinEventLogsSendToRoutesFalseWithConnectionsConstraint

	return InputWinEventLogs{
		InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint: &inputWinEventLogsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWinEventLogsInputWinEventLogsPqEnabledFalseWithPqConstraint(inputWinEventLogsPqEnabledFalseWithPqConstraint InputWinEventLogsPqEnabledFalseWithPqConstraint) InputWinEventLogs {
	typ := InputWinEventLogsUnionTypeInputWinEventLogsPqEnabledFalseWithPqConstraint

	return InputWinEventLogs{
		InputWinEventLogsPqEnabledFalseWithPqConstraint: &inputWinEventLogsPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputWinEventLogsInputWinEventLogsPqEnabledTrueWithPqConstraint(inputWinEventLogsPqEnabledTrueWithPqConstraint InputWinEventLogsPqEnabledTrueWithPqConstraint) InputWinEventLogs {
	typ := InputWinEventLogsUnionTypeInputWinEventLogsPqEnabledTrueWithPqConstraint

	return InputWinEventLogs{
		InputWinEventLogsPqEnabledTrueWithPqConstraint: &inputWinEventLogsPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputWinEventLogs) UnmarshalJSON(data []byte) error {

	var inputWinEventLogsSendToRoutesTrueWithConnectionsConstraint InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint = InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWinEventLogsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint = &inputWinEventLogsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputWinEventLogsUnionTypeInputWinEventLogsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputWinEventLogsSendToRoutesFalseWithConnectionsConstraint InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint = InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWinEventLogsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint = &inputWinEventLogsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputWinEventLogsUnionTypeInputWinEventLogsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputWinEventLogsPqEnabledFalseWithPqConstraint InputWinEventLogsPqEnabledFalseWithPqConstraint = InputWinEventLogsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWinEventLogsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputWinEventLogsPqEnabledFalseWithPqConstraint = &inputWinEventLogsPqEnabledFalseWithPqConstraint
		u.Type = InputWinEventLogsUnionTypeInputWinEventLogsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputWinEventLogsPqEnabledTrueWithPqConstraint InputWinEventLogsPqEnabledTrueWithPqConstraint = InputWinEventLogsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWinEventLogsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputWinEventLogsPqEnabledTrueWithPqConstraint = &inputWinEventLogsPqEnabledTrueWithPqConstraint
		u.Type = InputWinEventLogsUnionTypeInputWinEventLogsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputWinEventLogs", string(data))
}

func (u InputWinEventLogs) MarshalJSON() ([]byte, error) {
	if u.InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWinEventLogsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputWinEventLogsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWinEventLogsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputWinEventLogsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWinEventLogsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputWinEventLogs: all fields are null")
}

type InputWefPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputWefType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64 `default:"5986" json:"port"`
	// How to authenticate incoming client connections
	AuthMethod *InputWefAuthenticationMethod `default:"clientCert" json:"authMethod"`
	TLS        *MTLSSettings                 `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"90" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
	CaFingerprint *string `json:"caFingerprint,omitempty"`
	// Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
	Keytab *string `json:"keytab,omitempty"`
	// Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
	Principal *string `json:"principal,omitempty"`
	// Allow events to be ingested even if their MachineID does not match the client certificate CN
	AllowMachineIDMismatch *bool `default:"false" json:"allowMachineIdMismatch"`
	// Subscriptions to events on forwarding endpoints
	Subscriptions []Subscription `json:"subscriptions"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
	LogFingerprintMismatch *bool `default:"false" json:"logFingerprintMismatch"`
}

func (i InputWefPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWefPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "subscriptions"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetType() InputWefType {
	if i == nil {
		return InputWefType("")
	}
	return i.Type
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetAuthMethod() *InputWefAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthMethod
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetTLS() *MTLSSettings {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetCaFingerprint() *string {
	if i == nil {
		return nil
	}
	return i.CaFingerprint
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetKeytab() *string {
	if i == nil {
		return nil
	}
	return i.Keytab
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetPrincipal() *string {
	if i == nil {
		return nil
	}
	return i.Principal
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetAllowMachineIDMismatch() *bool {
	if i == nil {
		return nil
	}
	return i.AllowMachineIDMismatch
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetSubscriptions() []Subscription {
	if i == nil {
		return []Subscription{}
	}
	return i.Subscriptions
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWefPqEnabledTrueWithPqConstraint) GetLogFingerprintMismatch() *bool {
	if i == nil {
		return nil
	}
	return i.LogFingerprintMismatch
}

type InputWefPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputWefType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64 `default:"5986" json:"port"`
	// How to authenticate incoming client connections
	AuthMethod *InputWefAuthenticationMethod `default:"clientCert" json:"authMethod"`
	TLS        *MTLSSettings                 `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"90" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
	CaFingerprint *string `json:"caFingerprint,omitempty"`
	// Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
	Keytab *string `json:"keytab,omitempty"`
	// Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
	Principal *string `json:"principal,omitempty"`
	// Allow events to be ingested even if their MachineID does not match the client certificate CN
	AllowMachineIDMismatch *bool `default:"false" json:"allowMachineIdMismatch"`
	// Subscriptions to events on forwarding endpoints
	Subscriptions []Subscription `json:"subscriptions"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
	LogFingerprintMismatch *bool `default:"false" json:"logFingerprintMismatch"`
}

func (i InputWefPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWefPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "subscriptions"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetType() InputWefType {
	if i == nil {
		return InputWefType("")
	}
	return i.Type
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetAuthMethod() *InputWefAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthMethod
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetTLS() *MTLSSettings {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetCaFingerprint() *string {
	if i == nil {
		return nil
	}
	return i.CaFingerprint
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetKeytab() *string {
	if i == nil {
		return nil
	}
	return i.Keytab
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetPrincipal() *string {
	if i == nil {
		return nil
	}
	return i.Principal
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetAllowMachineIDMismatch() *bool {
	if i == nil {
		return nil
	}
	return i.AllowMachineIDMismatch
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetSubscriptions() []Subscription {
	if i == nil {
		return []Subscription{}
	}
	return i.Subscriptions
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWefPqEnabledFalseWithPqConstraint) GetLogFingerprintMismatch() *bool {
	if i == nil {
		return nil
	}
	return i.LogFingerprintMismatch
}

type InputWefSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputWefType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64 `default:"5986" json:"port"`
	// How to authenticate incoming client connections
	AuthMethod *InputWefAuthenticationMethod `default:"clientCert" json:"authMethod"`
	TLS        *MTLSSettings                 `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"90" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
	CaFingerprint *string `json:"caFingerprint,omitempty"`
	// Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
	Keytab *string `json:"keytab,omitempty"`
	// Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
	Principal *string `json:"principal,omitempty"`
	// Allow events to be ingested even if their MachineID does not match the client certificate CN
	AllowMachineIDMismatch *bool `default:"false" json:"allowMachineIdMismatch"`
	// Subscriptions to events on forwarding endpoints
	Subscriptions []Subscription `json:"subscriptions"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
	LogFingerprintMismatch *bool `default:"false" json:"logFingerprintMismatch"`
}

func (i InputWefSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "subscriptions"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetType() InputWefType {
	if i == nil {
		return InputWefType("")
	}
	return i.Type
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetAuthMethod() *InputWefAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthMethod
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetTLS() *MTLSSettings {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetCaFingerprint() *string {
	if i == nil {
		return nil
	}
	return i.CaFingerprint
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetKeytab() *string {
	if i == nil {
		return nil
	}
	return i.Keytab
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetPrincipal() *string {
	if i == nil {
		return nil
	}
	return i.Principal
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetAllowMachineIDMismatch() *bool {
	if i == nil {
		return nil
	}
	return i.AllowMachineIDMismatch
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetSubscriptions() []Subscription {
	if i == nil {
		return []Subscription{}
	}
	return i.Subscriptions
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWefSendToRoutesFalseWithConnectionsConstraint) GetLogFingerprintMismatch() *bool {
	if i == nil {
		return nil
	}
	return i.LogFingerprintMismatch
}

type InputWefType string

const (
	InputWefTypeWef InputWefType = "wef"
)

func (e InputWefType) ToPointer() *InputWefType {
	return &e
}
func (e *InputWefType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wef":
		*e = InputWefType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefType: %v", v)
	}
}

// InputWefAuthenticationMethod - How to authenticate incoming client connections
type InputWefAuthenticationMethod string

const (
	// InputWefAuthenticationMethodClientCert Client certificate
	InputWefAuthenticationMethodClientCert InputWefAuthenticationMethod = "clientCert"
	// InputWefAuthenticationMethodKerberos Kerberos
	InputWefAuthenticationMethodKerberos InputWefAuthenticationMethod = "kerberos"
)

func (e InputWefAuthenticationMethod) ToPointer() *InputWefAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWefAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "clientCert", "kerberos":
			return true
		}
	}
	return false
}

type MTLSSettings struct {
	// Enable TLS
	Disabled *bool `default:"false" json:"disabled"`
	// Required for WEF certificate authentication
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Required for WEF certificate authentication
	RequestCert *bool `default:"true" json:"requestCert"`
	// Name of the predefined certificate
	CertificateName *string `json:"certificateName,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath string `json:"privKeyPath"`
	// Passphrase to use to decrypt private key
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath string `json:"certPath"`
	// Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
	CaPath string `json:"caPath"`
	// Regex matching allowable common names in peer certificates' subject attribute
	CommonNameRegex *string                                                    `default:"/.*/" json:"commonNameRegex"`
	MinVersion      *components.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS `json:"minVersion,omitempty"`
	MaxVersion      *components.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS `json:"maxVersion,omitempty"`
	// Enable OCSP check of certificate
	OcspCheck *bool `default:"false" json:"ocspCheck"`
	Keytab    any   `json:"keytab,omitempty"`
	Principal any   `json:"principal,omitempty"`
	// If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors.
	OcspCheckFailClose *bool `default:"false" json:"ocspCheckFailClose"`
}

func (m MTLSSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MTLSSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"privKeyPath", "certPath", "caPath"}); err != nil {
		return err
	}
	return nil
}

func (m *MTLSSettings) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

func (m *MTLSSettings) GetRejectUnauthorized() *bool {
	if m == nil {
		return nil
	}
	return m.RejectUnauthorized
}

func (m *MTLSSettings) GetRequestCert() *bool {
	if m == nil {
		return nil
	}
	return m.RequestCert
}

func (m *MTLSSettings) GetCertificateName() *string {
	if m == nil {
		return nil
	}
	return m.CertificateName
}

func (m *MTLSSettings) GetPrivKeyPath() string {
	if m == nil {
		return ""
	}
	return m.PrivKeyPath
}

func (m *MTLSSettings) GetPassphrase() *string {
	if m == nil {
		return nil
	}
	return m.Passphrase
}

func (m *MTLSSettings) GetCertPath() string {
	if m == nil {
		return ""
	}
	return m.CertPath
}

func (m *MTLSSettings) GetCaPath() string {
	if m == nil {
		return ""
	}
	return m.CaPath
}

func (m *MTLSSettings) GetCommonNameRegex() *string {
	if m == nil {
		return nil
	}
	return m.CommonNameRegex
}

func (m *MTLSSettings) GetMinVersion() *components.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS {
	if m == nil {
		return nil
	}
	return m.MinVersion
}

func (m *MTLSSettings) GetMaxVersion() *components.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS {
	if m == nil {
		return nil
	}
	return m.MaxVersion
}

func (m *MTLSSettings) GetOcspCheck() *bool {
	if m == nil {
		return nil
	}
	return m.OcspCheck
}

func (m *MTLSSettings) GetKeytab() any {
	if m == nil {
		return nil
	}
	return m.Keytab
}

func (m *MTLSSettings) GetPrincipal() any {
	if m == nil {
		return nil
	}
	return m.Principal
}

func (m *MTLSSettings) GetOcspCheckFailClose() *bool {
	if m == nil {
		return nil
	}
	return m.OcspCheckFailClose
}

// CreateInputFormat - Content format in which the endpoint should deliver events
type CreateInputFormat string

const (
	CreateInputFormatRaw          CreateInputFormat = "Raw"
	CreateInputFormatRenderedText CreateInputFormat = "RenderedText"
)

func (e CreateInputFormat) ToPointer() *CreateInputFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "Raw", "RenderedText":
			return true
		}
	}
	return false
}

type QueryBuilderMode string

const (
	QueryBuilderModeSimple QueryBuilderMode = "simple"
	QueryBuilderModeXML    QueryBuilderMode = "xml"
)

func (e QueryBuilderMode) ToPointer() *QueryBuilderMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *QueryBuilderMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "simple", "xml":
			return true
		}
	}
	return false
}

type Query struct {
	// The Path attribute from the relevant XML Select element
	Path string `json:"path"`
	// The XPath query inside the relevant XML Select element
	QueryExpression string `json:"queryExpression"`
}

func (q Query) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(q, "", false)
}

func (q *Query) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &q, "", false, []string{"path", "queryExpression"}); err != nil {
		return err
	}
	return nil
}

func (q *Query) GetPath() string {
	if q == nil {
		return ""
	}
	return q.Path
}

func (q *Query) GetQueryExpression() string {
	if q == nil {
		return ""
	}
	return q.QueryExpression
}

type Subscription struct {
	SubscriptionName string `json:"subscriptionName"`
	// Version UUID for this subscription. If any subscription parameters are modified, this value will change.
	Version *string `json:"version,omitempty"`
	// Content format in which the endpoint should deliver events
	ContentFormat *CreateInputFormat `default:"Raw" json:"contentFormat"`
	// Maximum time (in seconds) between endpoint checkins before considering it unavailable
	HeartbeatInterval *float64 `default:"60" json:"heartbeatInterval"`
	// Interval (in seconds) over which the endpoint should collect events before sending them to Stream
	BatchTimeout *float64 `default:"60" json:"batchTimeout"`
	// Newly subscribed endpoints will send previously existing events. Disable to receive new events only.
	ReadExistingEvents *bool `default:"false" json:"readExistingEvents"`
	// Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details.
	SendBookmarks *bool `default:"true" json:"sendBookmarks"`
	// Receive compressed events from the source
	Compress *bool `default:"true" json:"compress"`
	// The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com
	Targets []string `json:"targets"`
	// The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US".
	Locale        *string           `default:"en-US" json:"locale"`
	QuerySelector *QueryBuilderMode `default:"simple" json:"querySelector"`
	// Fields to add to events ingested under this subscription
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Queries  []Query                                    `json:"queries,omitempty"`
	// The XPath query to use for selecting events
	XMLQuery *string `json:"xmlQuery,omitempty"`
}

func (s Subscription) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Subscription) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"subscriptionName", "targets"}); err != nil {
		return err
	}
	return nil
}

func (s *Subscription) GetSubscriptionName() string {
	if s == nil {
		return ""
	}
	return s.SubscriptionName
}

func (s *Subscription) GetVersion() *string {
	if s == nil {
		return nil
	}
	return s.Version
}

func (s *Subscription) GetContentFormat() *CreateInputFormat {
	if s == nil {
		return nil
	}
	return s.ContentFormat
}

func (s *Subscription) GetHeartbeatInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.HeartbeatInterval
}

func (s *Subscription) GetBatchTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.BatchTimeout
}

func (s *Subscription) GetReadExistingEvents() *bool {
	if s == nil {
		return nil
	}
	return s.ReadExistingEvents
}

func (s *Subscription) GetSendBookmarks() *bool {
	if s == nil {
		return nil
	}
	return s.SendBookmarks
}

func (s *Subscription) GetCompress() *bool {
	if s == nil {
		return nil
	}
	return s.Compress
}

func (s *Subscription) GetTargets() []string {
	if s == nil {
		return []string{}
	}
	return s.Targets
}

func (s *Subscription) GetLocale() *string {
	if s == nil {
		return nil
	}
	return s.Locale
}

func (s *Subscription) GetQuerySelector() *QueryBuilderMode {
	if s == nil {
		return nil
	}
	return s.QuerySelector
}

func (s *Subscription) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *Subscription) GetQueries() []Query {
	if s == nil {
		return nil
	}
	return s.Queries
}

func (s *Subscription) GetXMLQuery() *string {
	if s == nil {
		return nil
	}
	return s.XMLQuery
}

type InputWefSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputWefType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64 `default:"5986" json:"port"`
	// How to authenticate incoming client connections
	AuthMethod *InputWefAuthenticationMethod `default:"clientCert" json:"authMethod"`
	TLS        *MTLSSettings                 `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"90" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
	CaFingerprint *string `json:"caFingerprint,omitempty"`
	// Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
	Keytab *string `json:"keytab,omitempty"`
	// Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
	Principal *string `json:"principal,omitempty"`
	// Allow events to be ingested even if their MachineID does not match the client certificate CN
	AllowMachineIDMismatch *bool `default:"false" json:"allowMachineIdMismatch"`
	// Subscriptions to events on forwarding endpoints
	Subscriptions []Subscription `json:"subscriptions"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
	LogFingerprintMismatch *bool `default:"false" json:"logFingerprintMismatch"`
}

func (i InputWefSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "subscriptions"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetType() InputWefType {
	if i == nil {
		return InputWefType("")
	}
	return i.Type
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetAuthMethod() *InputWefAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthMethod
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetTLS() *MTLSSettings {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetCaFingerprint() *string {
	if i == nil {
		return nil
	}
	return i.CaFingerprint
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetKeytab() *string {
	if i == nil {
		return nil
	}
	return i.Keytab
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetPrincipal() *string {
	if i == nil {
		return nil
	}
	return i.Principal
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetAllowMachineIDMismatch() *bool {
	if i == nil {
		return nil
	}
	return i.AllowMachineIDMismatch
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetSubscriptions() []Subscription {
	if i == nil {
		return []Subscription{}
	}
	return i.Subscriptions
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputWefSendToRoutesTrueWithConnectionsConstraint) GetLogFingerprintMismatch() *bool {
	if i == nil {
		return nil
	}
	return i.LogFingerprintMismatch
}

type InputWefUnionType string

const (
	InputWefUnionTypeInputWefSendToRoutesTrueWithConnectionsConstraint  InputWefUnionType = "InputWef_SendToRoutesTrueWithConnectionsConstraint"
	InputWefUnionTypeInputWefSendToRoutesFalseWithConnectionsConstraint InputWefUnionType = "InputWef_SendToRoutesFalseWithConnectionsConstraint"
	InputWefUnionTypeInputWefPqEnabledFalseWithPqConstraint             InputWefUnionType = "InputWef_PqEnabledFalseWithPqConstraint"
	InputWefUnionTypeInputWefPqEnabledTrueWithPqConstraint              InputWefUnionType = "InputWef_PqEnabledTrueWithPqConstraint"
)

type InputWef struct {
	InputWefSendToRoutesTrueWithConnectionsConstraint  *InputWefSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputWefSendToRoutesFalseWithConnectionsConstraint *InputWefSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputWefPqEnabledFalseWithPqConstraint             *InputWefPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputWefPqEnabledTrueWithPqConstraint              *InputWefPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputWefUnionType
}

func CreateInputWefInputWefSendToRoutesTrueWithConnectionsConstraint(inputWefSendToRoutesTrueWithConnectionsConstraint InputWefSendToRoutesTrueWithConnectionsConstraint) InputWef {
	typ := InputWefUnionTypeInputWefSendToRoutesTrueWithConnectionsConstraint

	return InputWef{
		InputWefSendToRoutesTrueWithConnectionsConstraint: &inputWefSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWefInputWefSendToRoutesFalseWithConnectionsConstraint(inputWefSendToRoutesFalseWithConnectionsConstraint InputWefSendToRoutesFalseWithConnectionsConstraint) InputWef {
	typ := InputWefUnionTypeInputWefSendToRoutesFalseWithConnectionsConstraint

	return InputWef{
		InputWefSendToRoutesFalseWithConnectionsConstraint: &inputWefSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWefInputWefPqEnabledFalseWithPqConstraint(inputWefPqEnabledFalseWithPqConstraint InputWefPqEnabledFalseWithPqConstraint) InputWef {
	typ := InputWefUnionTypeInputWefPqEnabledFalseWithPqConstraint

	return InputWef{
		InputWefPqEnabledFalseWithPqConstraint: &inputWefPqEnabledFalseWithPqConstraint,
		Type:                                   typ,
	}
}

func CreateInputWefInputWefPqEnabledTrueWithPqConstraint(inputWefPqEnabledTrueWithPqConstraint InputWefPqEnabledTrueWithPqConstraint) InputWef {
	typ := InputWefUnionTypeInputWefPqEnabledTrueWithPqConstraint

	return InputWef{
		InputWefPqEnabledTrueWithPqConstraint: &inputWefPqEnabledTrueWithPqConstraint,
		Type:                                  typ,
	}
}

func (u *InputWef) UnmarshalJSON(data []byte) error {

	var inputWefSendToRoutesTrueWithConnectionsConstraint InputWefSendToRoutesTrueWithConnectionsConstraint = InputWefSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWefSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWefSendToRoutesTrueWithConnectionsConstraint = &inputWefSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputWefUnionTypeInputWefSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputWefSendToRoutesFalseWithConnectionsConstraint InputWefSendToRoutesFalseWithConnectionsConstraint = InputWefSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWefSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWefSendToRoutesFalseWithConnectionsConstraint = &inputWefSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputWefUnionTypeInputWefSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputWefPqEnabledFalseWithPqConstraint InputWefPqEnabledFalseWithPqConstraint = InputWefPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWefPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputWefPqEnabledFalseWithPqConstraint = &inputWefPqEnabledFalseWithPqConstraint
		u.Type = InputWefUnionTypeInputWefPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputWefPqEnabledTrueWithPqConstraint InputWefPqEnabledTrueWithPqConstraint = InputWefPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWefPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputWefPqEnabledTrueWithPqConstraint = &inputWefPqEnabledTrueWithPqConstraint
		u.Type = InputWefUnionTypeInputWefPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputWef", string(data))
}

func (u InputWef) MarshalJSON() ([]byte, error) {
	if u.InputWefSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWefSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputWefSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWefSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputWefPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWefPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputWefPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWefPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputWef: all fields are null")
}

type InputAppscopePqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputAppscopeType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
	EnableUnixPath *bool                     `default:"false" json:"enableUnixPath"`
	Filter         *InputAppscopeFilter      `json:"filter,omitempty"`
	Persistence    *InputAppscopePersistence `json:"persistence,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	Description *string                                                `json:"description,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `json:"host,omitempty"`
	// Port to listen on
	Port *float64                              `json:"port,omitempty"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Path to the UNIX domain socket to listen on.
	UnixSocketPath *string `default:"$CRIBL_HOME/state/appscope.sock" json:"unixSocketPath"`
	// Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
	UnixSocketPerms *string `json:"unixSocketPerms,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputAppscopePqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetType() InputAppscopeType {
	if i == nil {
		return InputAppscopeType("")
	}
	return i.Type
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetEnableUnixPath() *bool {
	if i == nil {
		return nil
	}
	return i.EnableUnixPath
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetFilter() *InputAppscopeFilter {
	if i == nil {
		return nil
	}
	return i.Filter
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetPersistence() *InputAppscopePersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetUnixSocketPath() *string {
	if i == nil {
		return nil
	}
	return i.UnixSocketPath
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetUnixSocketPerms() *string {
	if i == nil {
		return nil
	}
	return i.UnixSocketPerms
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputAppscopePqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputAppscopePqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputAppscopeType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
	EnableUnixPath *bool                     `default:"false" json:"enableUnixPath"`
	Filter         *InputAppscopeFilter      `json:"filter,omitempty"`
	Persistence    *InputAppscopePersistence `json:"persistence,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	Description *string                                                `json:"description,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `json:"host,omitempty"`
	// Port to listen on
	Port *float64                              `json:"port,omitempty"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Path to the UNIX domain socket to listen on.
	UnixSocketPath *string `default:"$CRIBL_HOME/state/appscope.sock" json:"unixSocketPath"`
	// Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
	UnixSocketPerms *string `json:"unixSocketPerms,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputAppscopePqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetType() InputAppscopeType {
	if i == nil {
		return InputAppscopeType("")
	}
	return i.Type
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetEnableUnixPath() *bool {
	if i == nil {
		return nil
	}
	return i.EnableUnixPath
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetFilter() *InputAppscopeFilter {
	if i == nil {
		return nil
	}
	return i.Filter
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetPersistence() *InputAppscopePersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetUnixSocketPath() *string {
	if i == nil {
		return nil
	}
	return i.UnixSocketPath
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetUnixSocketPerms() *string {
	if i == nil {
		return nil
	}
	return i.UnixSocketPerms
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputAppscopePqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputAppscopeSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputAppscopeType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
	EnableUnixPath *bool                     `default:"false" json:"enableUnixPath"`
	Filter         *InputAppscopeFilter      `json:"filter,omitempty"`
	Persistence    *InputAppscopePersistence `json:"persistence,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	Description *string                                                `json:"description,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `json:"host,omitempty"`
	// Port to listen on
	Port *float64                              `json:"port,omitempty"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Path to the UNIX domain socket to listen on.
	UnixSocketPath *string `default:"$CRIBL_HOME/state/appscope.sock" json:"unixSocketPath"`
	// Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
	UnixSocketPerms *string `json:"unixSocketPerms,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputAppscopeSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetType() InputAppscopeType {
	if i == nil {
		return InputAppscopeType("")
	}
	return i.Type
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetEnableUnixPath() *bool {
	if i == nil {
		return nil
	}
	return i.EnableUnixPath
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetFilter() *InputAppscopeFilter {
	if i == nil {
		return nil
	}
	return i.Filter
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetPersistence() *InputAppscopePersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetUnixSocketPath() *string {
	if i == nil {
		return nil
	}
	return i.UnixSocketPath
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetUnixSocketPerms() *string {
	if i == nil {
		return nil
	}
	return i.UnixSocketPerms
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputAppscopeSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputAppscopeType string

const (
	InputAppscopeTypeAppscope InputAppscopeType = "appscope"
)

func (e InputAppscopeType) ToPointer() *InputAppscopeType {
	return &e
}
func (e *InputAppscopeType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "appscope":
		*e = InputAppscopeType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputAppscopeType: %v", v)
	}
}

type Allow struct {
	// Specify the name of a process or family of processes.
	Procname string `json:"procname"`
	// Specify a string to substring-match against process command-line.
	Arg *string `json:"arg,omitempty"`
	// Choose a config to apply to processes that match the process name and/or argument.
	Config string `json:"config"`
}

func (a Allow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Allow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"procname", "config"}); err != nil {
		return err
	}
	return nil
}

func (a *Allow) GetProcname() string {
	if a == nil {
		return ""
	}
	return a.Procname
}

func (a *Allow) GetArg() *string {
	if a == nil {
		return nil
	}
	return a.Arg
}

func (a *Allow) GetConfig() string {
	if a == nil {
		return ""
	}
	return a.Config
}

type InputAppscopeFilter struct {
	// Specify processes that AppScope should be loaded into, and the config to use.
	Allow []Allow `json:"allow,omitempty"`
	// To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
	TransportURL *string `json:"transportURL,omitempty"`
}

func (i InputAppscopeFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAppscopeFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputAppscopeFilter) GetAllow() []Allow {
	if i == nil {
		return nil
	}
	return i.Allow
}

func (i *InputAppscopeFilter) GetTransportURL() *string {
	if i == nil {
		return nil
	}
	return i.TransportURL
}

type InputAppscopePersistence struct {
	// Spool events and metrics on disk for Cribl Edge and Search
	Enable *bool `default:"false" json:"enable"`
	// Time span for each file bucket
	TimeWindow *string `default:"10m" json:"timeWindow"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `default:"1GB" json:"maxDataSize"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `default:"24h" json:"maxDataTime"`
	Compress    *components.DataCompressionFormatOptionsPersistence `default:"gzip" json:"compress"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope
	DestPath *string `default:"$CRIBL_HOME/state/appscope" json:"destPath"`
}

func (i InputAppscopePersistence) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAppscopePersistence) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputAppscopePersistence) GetEnable() *bool {
	if i == nil {
		return nil
	}
	return i.Enable
}

func (i *InputAppscopePersistence) GetTimeWindow() *string {
	if i == nil {
		return nil
	}
	return i.TimeWindow
}

func (i *InputAppscopePersistence) GetMaxDataSize() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataSize
}

func (i *InputAppscopePersistence) GetMaxDataTime() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataTime
}

func (i *InputAppscopePersistence) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if i == nil {
		return nil
	}
	return i.Compress
}

func (i *InputAppscopePersistence) GetDestPath() *string {
	if i == nil {
		return nil
	}
	return i.DestPath
}

type InputAppscopeSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputAppscopeType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
	EnableUnixPath *bool                     `default:"false" json:"enableUnixPath"`
	Filter         *InputAppscopeFilter      `json:"filter,omitempty"`
	Persistence    *InputAppscopePersistence `json:"persistence,omitempty"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	Description *string                                                `json:"description,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `json:"host,omitempty"`
	// Port to listen on
	Port *float64                              `json:"port,omitempty"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Path to the UNIX domain socket to listen on.
	UnixSocketPath *string `default:"$CRIBL_HOME/state/appscope.sock" json:"unixSocketPath"`
	// Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
	UnixSocketPerms *string `json:"unixSocketPerms,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputAppscopeSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetType() InputAppscopeType {
	if i == nil {
		return InputAppscopeType("")
	}
	return i.Type
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetEnableUnixPath() *bool {
	if i == nil {
		return nil
	}
	return i.EnableUnixPath
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetFilter() *InputAppscopeFilter {
	if i == nil {
		return nil
	}
	return i.Filter
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetPersistence() *InputAppscopePersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetUnixSocketPath() *string {
	if i == nil {
		return nil
	}
	return i.UnixSocketPath
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetUnixSocketPerms() *string {
	if i == nil {
		return nil
	}
	return i.UnixSocketPerms
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputAppscopeSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputAppscopeUnionType string

const (
	InputAppscopeUnionTypeInputAppscopeSendToRoutesTrueWithConnectionsConstraint  InputAppscopeUnionType = "InputAppscope_SendToRoutesTrueWithConnectionsConstraint"
	InputAppscopeUnionTypeInputAppscopeSendToRoutesFalseWithConnectionsConstraint InputAppscopeUnionType = "InputAppscope_SendToRoutesFalseWithConnectionsConstraint"
	InputAppscopeUnionTypeInputAppscopePqEnabledFalseWithPqConstraint             InputAppscopeUnionType = "InputAppscope_PqEnabledFalseWithPqConstraint"
	InputAppscopeUnionTypeInputAppscopePqEnabledTrueWithPqConstraint              InputAppscopeUnionType = "InputAppscope_PqEnabledTrueWithPqConstraint"
)

type InputAppscope struct {
	InputAppscopeSendToRoutesTrueWithConnectionsConstraint  *InputAppscopeSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputAppscopeSendToRoutesFalseWithConnectionsConstraint *InputAppscopeSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputAppscopePqEnabledFalseWithPqConstraint             *InputAppscopePqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputAppscopePqEnabledTrueWithPqConstraint              *InputAppscopePqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputAppscopeUnionType
}

func CreateInputAppscopeInputAppscopeSendToRoutesTrueWithConnectionsConstraint(inputAppscopeSendToRoutesTrueWithConnectionsConstraint InputAppscopeSendToRoutesTrueWithConnectionsConstraint) InputAppscope {
	typ := InputAppscopeUnionTypeInputAppscopeSendToRoutesTrueWithConnectionsConstraint

	return InputAppscope{
		InputAppscopeSendToRoutesTrueWithConnectionsConstraint: &inputAppscopeSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputAppscopeInputAppscopeSendToRoutesFalseWithConnectionsConstraint(inputAppscopeSendToRoutesFalseWithConnectionsConstraint InputAppscopeSendToRoutesFalseWithConnectionsConstraint) InputAppscope {
	typ := InputAppscopeUnionTypeInputAppscopeSendToRoutesFalseWithConnectionsConstraint

	return InputAppscope{
		InputAppscopeSendToRoutesFalseWithConnectionsConstraint: &inputAppscopeSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputAppscopeInputAppscopePqEnabledFalseWithPqConstraint(inputAppscopePqEnabledFalseWithPqConstraint InputAppscopePqEnabledFalseWithPqConstraint) InputAppscope {
	typ := InputAppscopeUnionTypeInputAppscopePqEnabledFalseWithPqConstraint

	return InputAppscope{
		InputAppscopePqEnabledFalseWithPqConstraint: &inputAppscopePqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputAppscopeInputAppscopePqEnabledTrueWithPqConstraint(inputAppscopePqEnabledTrueWithPqConstraint InputAppscopePqEnabledTrueWithPqConstraint) InputAppscope {
	typ := InputAppscopeUnionTypeInputAppscopePqEnabledTrueWithPqConstraint

	return InputAppscope{
		InputAppscopePqEnabledTrueWithPqConstraint: &inputAppscopePqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputAppscope) UnmarshalJSON(data []byte) error {

	var inputAppscopeSendToRoutesTrueWithConnectionsConstraint InputAppscopeSendToRoutesTrueWithConnectionsConstraint = InputAppscopeSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputAppscopeSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputAppscopeSendToRoutesTrueWithConnectionsConstraint = &inputAppscopeSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputAppscopeUnionTypeInputAppscopeSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputAppscopeSendToRoutesFalseWithConnectionsConstraint InputAppscopeSendToRoutesFalseWithConnectionsConstraint = InputAppscopeSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputAppscopeSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputAppscopeSendToRoutesFalseWithConnectionsConstraint = &inputAppscopeSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputAppscopeUnionTypeInputAppscopeSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputAppscopePqEnabledFalseWithPqConstraint InputAppscopePqEnabledFalseWithPqConstraint = InputAppscopePqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputAppscopePqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputAppscopePqEnabledFalseWithPqConstraint = &inputAppscopePqEnabledFalseWithPqConstraint
		u.Type = InputAppscopeUnionTypeInputAppscopePqEnabledFalseWithPqConstraint
		return nil
	}

	var inputAppscopePqEnabledTrueWithPqConstraint InputAppscopePqEnabledTrueWithPqConstraint = InputAppscopePqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputAppscopePqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputAppscopePqEnabledTrueWithPqConstraint = &inputAppscopePqEnabledTrueWithPqConstraint
		u.Type = InputAppscopeUnionTypeInputAppscopePqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputAppscope", string(data))
}

func (u InputAppscope) MarshalJSON() ([]byte, error) {
	if u.InputAppscopeSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputAppscopeSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputAppscopeSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputAppscopeSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputAppscopePqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputAppscopePqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputAppscopePqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputAppscopePqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputAppscope: all fields are null")
}

type InputTCPPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputTCPType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
	EnableHeader *bool                                             `default:"false" json:"enableHeader"`
	Preprocess   *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	Description  *string                                           `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputTCPPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetType() InputTCPType {
	if i == nil {
		return InputTCPType("")
	}
	return i.Type
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetEnableHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHeader
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputTCPPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputTCPPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputTCPType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
	EnableHeader *bool                                             `default:"false" json:"enableHeader"`
	Preprocess   *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	Description  *string                                           `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputTCPPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetType() InputTCPType {
	if i == nil {
		return InputTCPType("")
	}
	return i.Type
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetEnableHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHeader
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputTCPPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputTCPSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputTCPType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
	EnableHeader *bool                                             `default:"false" json:"enableHeader"`
	Preprocess   *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	Description  *string                                           `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputTCPSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetType() InputTCPType {
	if i == nil {
		return InputTCPType("")
	}
	return i.Type
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetEnableHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHeader
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputTCPSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputTCPType string

const (
	InputTCPTypeTCP InputTCPType = "tcp"
)

func (e InputTCPType) ToPointer() *InputTCPType {
	return &e
}
func (e *InputTCPType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		*e = InputTCPType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputTCPType: %v", v)
	}
}

type InputTCPSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputTCPType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
	EnableHeader *bool                                             `default:"false" json:"enableHeader"`
	Preprocess   *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	Description  *string                                           `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputTCPSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetType() InputTCPType {
	if i == nil {
		return InputTCPType("")
	}
	return i.Type
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetEnableHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHeader
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputTCPSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputTCPUnionType string

const (
	InputTCPUnionTypeInputTCPSendToRoutesTrueWithConnectionsConstraint  InputTCPUnionType = "InputTcp_SendToRoutesTrueWithConnectionsConstraint"
	InputTCPUnionTypeInputTCPSendToRoutesFalseWithConnectionsConstraint InputTCPUnionType = "InputTcp_SendToRoutesFalseWithConnectionsConstraint"
	InputTCPUnionTypeInputTCPPqEnabledFalseWithPqConstraint             InputTCPUnionType = "InputTcp_PqEnabledFalseWithPqConstraint"
	InputTCPUnionTypeInputTCPPqEnabledTrueWithPqConstraint              InputTCPUnionType = "InputTcp_PqEnabledTrueWithPqConstraint"
)

type InputTCP struct {
	InputTCPSendToRoutesTrueWithConnectionsConstraint  *InputTCPSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputTCPSendToRoutesFalseWithConnectionsConstraint *InputTCPSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputTCPPqEnabledFalseWithPqConstraint             *InputTCPPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputTCPPqEnabledTrueWithPqConstraint              *InputTCPPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputTCPUnionType
}

func CreateInputTCPInputTCPSendToRoutesTrueWithConnectionsConstraint(inputTCPSendToRoutesTrueWithConnectionsConstraint InputTCPSendToRoutesTrueWithConnectionsConstraint) InputTCP {
	typ := InputTCPUnionTypeInputTCPSendToRoutesTrueWithConnectionsConstraint

	return InputTCP{
		InputTCPSendToRoutesTrueWithConnectionsConstraint: &inputTCPSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputTCPInputTCPSendToRoutesFalseWithConnectionsConstraint(inputTCPSendToRoutesFalseWithConnectionsConstraint InputTCPSendToRoutesFalseWithConnectionsConstraint) InputTCP {
	typ := InputTCPUnionTypeInputTCPSendToRoutesFalseWithConnectionsConstraint

	return InputTCP{
		InputTCPSendToRoutesFalseWithConnectionsConstraint: &inputTCPSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputTCPInputTCPPqEnabledFalseWithPqConstraint(inputTCPPqEnabledFalseWithPqConstraint InputTCPPqEnabledFalseWithPqConstraint) InputTCP {
	typ := InputTCPUnionTypeInputTCPPqEnabledFalseWithPqConstraint

	return InputTCP{
		InputTCPPqEnabledFalseWithPqConstraint: &inputTCPPqEnabledFalseWithPqConstraint,
		Type:                                   typ,
	}
}

func CreateInputTCPInputTCPPqEnabledTrueWithPqConstraint(inputTCPPqEnabledTrueWithPqConstraint InputTCPPqEnabledTrueWithPqConstraint) InputTCP {
	typ := InputTCPUnionTypeInputTCPPqEnabledTrueWithPqConstraint

	return InputTCP{
		InputTCPPqEnabledTrueWithPqConstraint: &inputTCPPqEnabledTrueWithPqConstraint,
		Type:                                  typ,
	}
}

func (u *InputTCP) UnmarshalJSON(data []byte) error {

	var inputTCPSendToRoutesTrueWithConnectionsConstraint InputTCPSendToRoutesTrueWithConnectionsConstraint = InputTCPSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputTCPSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputTCPSendToRoutesTrueWithConnectionsConstraint = &inputTCPSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputTCPUnionTypeInputTCPSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputTCPSendToRoutesFalseWithConnectionsConstraint InputTCPSendToRoutesFalseWithConnectionsConstraint = InputTCPSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputTCPSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputTCPSendToRoutesFalseWithConnectionsConstraint = &inputTCPSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputTCPUnionTypeInputTCPSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputTCPPqEnabledFalseWithPqConstraint InputTCPPqEnabledFalseWithPqConstraint = InputTCPPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputTCPPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputTCPPqEnabledFalseWithPqConstraint = &inputTCPPqEnabledFalseWithPqConstraint
		u.Type = InputTCPUnionTypeInputTCPPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputTCPPqEnabledTrueWithPqConstraint InputTCPPqEnabledTrueWithPqConstraint = InputTCPPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputTCPPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputTCPPqEnabledTrueWithPqConstraint = &inputTCPPqEnabledTrueWithPqConstraint
		u.Type = InputTCPUnionTypeInputTCPPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputTCP", string(data))
}

func (u InputTCP) MarshalJSON() ([]byte, error) {
	if u.InputTCPSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputTCPSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputTCPSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputTCPSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputTCPPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputTCPPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputTCPPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputTCPPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputTCP: all fields are null")
}

type PqEnabledTrueWithPqConstraintInputFileType string

const (
	PqEnabledTrueWithPqConstraintInputFileTypeFile PqEnabledTrueWithPqConstraintInputFileType = "file"
)

func (e PqEnabledTrueWithPqConstraintInputFileType) ToPointer() *PqEnabledTrueWithPqConstraintInputFileType {
	return &e
}
func (e *PqEnabledTrueWithPqConstraintInputFileType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = PqEnabledTrueWithPqConstraintInputFileType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PqEnabledTrueWithPqConstraintInputFileType: %v", v)
	}
}

// PqEnabledTrueWithPqConstraintMode - Choose how to discover files to monitor
type PqEnabledTrueWithPqConstraintMode string

const (
	// PqEnabledTrueWithPqConstraintModeManual Manual
	PqEnabledTrueWithPqConstraintModeManual PqEnabledTrueWithPqConstraintMode = "manual"
	// PqEnabledTrueWithPqConstraintModeAuto Auto
	PqEnabledTrueWithPqConstraintModeAuto PqEnabledTrueWithPqConstraintMode = "auto"
)

func (e PqEnabledTrueWithPqConstraintMode) ToPointer() *PqEnabledTrueWithPqConstraintMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *PqEnabledTrueWithPqConstraintMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "auto":
			return true
		}
	}
	return false
}

type InputFilePqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                                     `json:"id"`
	Type     PqEnabledTrueWithPqConstraintInputFileType `json:"type"`
	Disabled *bool                                      `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Choose how to discover files to monitor
	Mode *PqEnabledTrueWithPqConstraintMode `default:"manual" json:"mode"`
	// Time, in seconds, between scanning for files
	Interval *float64 `default:"10" json:"interval"`
	// The full path of discovered files are matched against this wildcard list
	Filenames []string `json:"filenames,omitempty"`
	// Apply filename allowlist to file entries in archive file types, like tar or zip.
	FilterArchivedFiles *bool `default:"false" json:"filterArchivedFiles"`
	// Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
	TailOnly *bool `default:"true" json:"tailOnly"`
	// Time, in seconds, before an idle file is closed
	IdleTimeout *float64 `default:"300" json:"idleTimeout"`
	// The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
	MinAgeDur *string `json:"minAgeDur,omitempty"`
	// The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Skip files with modification times earlier than the maximum age duration
	CheckFileModTime *bool `default:"false" json:"checkFileModTime"`
	// Forces files containing binary data to be streamed as text
	ForceText *bool `default:"false" json:"forceText"`
	// Length of file header bytes to use in hash for unique file identification
	HashLen *float64 `default:"256" json:"hashLen"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	Description         *string  `json:"description,omitempty"`
	// Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
	Path *string `json:"path,omitempty"`
	// Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
	Depth                     *float64 `json:"depth,omitempty"`
	SuppressMissingPathErrors *bool    `default:"false" json:"suppressMissingPathErrors"`
	// Delete files after they have been collected
	DeleteFiles *bool `default:"false" json:"deleteFiles"`
	// Stream binary files as Base64-encoded chunks.
	IncludeUnidentifiableBinary *bool `default:"false" json:"includeUnidentifiableBinary"`
}

func (i InputFilePqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputFilePqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetType() PqEnabledTrueWithPqConstraintInputFileType {
	if i == nil {
		return PqEnabledTrueWithPqConstraintInputFileType("")
	}
	return i.Type
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetMode() *PqEnabledTrueWithPqConstraintMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetFilenames() []string {
	if i == nil {
		return nil
	}
	return i.Filenames
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetFilterArchivedFiles() *bool {
	if i == nil {
		return nil
	}
	return i.FilterArchivedFiles
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetTailOnly() *bool {
	if i == nil {
		return nil
	}
	return i.TailOnly
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.IdleTimeout
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetMinAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MinAgeDur
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetMaxAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MaxAgeDur
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetCheckFileModTime() *bool {
	if i == nil {
		return nil
	}
	return i.CheckFileModTime
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetForceText() *bool {
	if i == nil {
		return nil
	}
	return i.ForceText
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetHashLen() *float64 {
	if i == nil {
		return nil
	}
	return i.HashLen
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetPath() *string {
	if i == nil {
		return nil
	}
	return i.Path
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetDepth() *float64 {
	if i == nil {
		return nil
	}
	return i.Depth
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetSuppressMissingPathErrors() *bool {
	if i == nil {
		return nil
	}
	return i.SuppressMissingPathErrors
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetDeleteFiles() *bool {
	if i == nil {
		return nil
	}
	return i.DeleteFiles
}

func (i *InputFilePqEnabledTrueWithPqConstraint) GetIncludeUnidentifiableBinary() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeUnidentifiableBinary
}

type PqEnabledFalseWithPqConstraintInputFileType string

const (
	PqEnabledFalseWithPqConstraintInputFileTypeFile PqEnabledFalseWithPqConstraintInputFileType = "file"
)

func (e PqEnabledFalseWithPqConstraintInputFileType) ToPointer() *PqEnabledFalseWithPqConstraintInputFileType {
	return &e
}
func (e *PqEnabledFalseWithPqConstraintInputFileType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = PqEnabledFalseWithPqConstraintInputFileType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PqEnabledFalseWithPqConstraintInputFileType: %v", v)
	}
}

// PqEnabledFalseWithPqConstraintMode - Choose how to discover files to monitor
type PqEnabledFalseWithPqConstraintMode string

const (
	// PqEnabledFalseWithPqConstraintModeManual Manual
	PqEnabledFalseWithPqConstraintModeManual PqEnabledFalseWithPqConstraintMode = "manual"
	// PqEnabledFalseWithPqConstraintModeAuto Auto
	PqEnabledFalseWithPqConstraintModeAuto PqEnabledFalseWithPqConstraintMode = "auto"
)

func (e PqEnabledFalseWithPqConstraintMode) ToPointer() *PqEnabledFalseWithPqConstraintMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *PqEnabledFalseWithPqConstraintMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "auto":
			return true
		}
	}
	return false
}

type InputFilePqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                                      `json:"id"`
	Type     PqEnabledFalseWithPqConstraintInputFileType `json:"type"`
	Disabled *bool                                       `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Choose how to discover files to monitor
	Mode *PqEnabledFalseWithPqConstraintMode `default:"manual" json:"mode"`
	// Time, in seconds, between scanning for files
	Interval *float64 `default:"10" json:"interval"`
	// The full path of discovered files are matched against this wildcard list
	Filenames []string `json:"filenames,omitempty"`
	// Apply filename allowlist to file entries in archive file types, like tar or zip.
	FilterArchivedFiles *bool `default:"false" json:"filterArchivedFiles"`
	// Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
	TailOnly *bool `default:"true" json:"tailOnly"`
	// Time, in seconds, before an idle file is closed
	IdleTimeout *float64 `default:"300" json:"idleTimeout"`
	// The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
	MinAgeDur *string `json:"minAgeDur,omitempty"`
	// The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Skip files with modification times earlier than the maximum age duration
	CheckFileModTime *bool `default:"false" json:"checkFileModTime"`
	// Forces files containing binary data to be streamed as text
	ForceText *bool `default:"false" json:"forceText"`
	// Length of file header bytes to use in hash for unique file identification
	HashLen *float64 `default:"256" json:"hashLen"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	Description         *string  `json:"description,omitempty"`
	// Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
	Path *string `json:"path,omitempty"`
	// Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
	Depth                     *float64 `json:"depth,omitempty"`
	SuppressMissingPathErrors *bool    `default:"false" json:"suppressMissingPathErrors"`
	// Delete files after they have been collected
	DeleteFiles *bool `default:"false" json:"deleteFiles"`
	// Stream binary files as Base64-encoded chunks.
	IncludeUnidentifiableBinary *bool `default:"false" json:"includeUnidentifiableBinary"`
}

func (i InputFilePqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputFilePqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetType() PqEnabledFalseWithPqConstraintInputFileType {
	if i == nil {
		return PqEnabledFalseWithPqConstraintInputFileType("")
	}
	return i.Type
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetMode() *PqEnabledFalseWithPqConstraintMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetFilenames() []string {
	if i == nil {
		return nil
	}
	return i.Filenames
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetFilterArchivedFiles() *bool {
	if i == nil {
		return nil
	}
	return i.FilterArchivedFiles
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetTailOnly() *bool {
	if i == nil {
		return nil
	}
	return i.TailOnly
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.IdleTimeout
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetMinAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MinAgeDur
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetMaxAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MaxAgeDur
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetCheckFileModTime() *bool {
	if i == nil {
		return nil
	}
	return i.CheckFileModTime
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetForceText() *bool {
	if i == nil {
		return nil
	}
	return i.ForceText
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetHashLen() *float64 {
	if i == nil {
		return nil
	}
	return i.HashLen
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetPath() *string {
	if i == nil {
		return nil
	}
	return i.Path
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetDepth() *float64 {
	if i == nil {
		return nil
	}
	return i.Depth
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetSuppressMissingPathErrors() *bool {
	if i == nil {
		return nil
	}
	return i.SuppressMissingPathErrors
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetDeleteFiles() *bool {
	if i == nil {
		return nil
	}
	return i.DeleteFiles
}

func (i *InputFilePqEnabledFalseWithPqConstraint) GetIncludeUnidentifiableBinary() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeUnidentifiableBinary
}

type SendToRoutesFalseWithConnectionsConstraintInputFileType string

const (
	SendToRoutesFalseWithConnectionsConstraintInputFileTypeFile SendToRoutesFalseWithConnectionsConstraintInputFileType = "file"
)

func (e SendToRoutesFalseWithConnectionsConstraintInputFileType) ToPointer() *SendToRoutesFalseWithConnectionsConstraintInputFileType {
	return &e
}
func (e *SendToRoutesFalseWithConnectionsConstraintInputFileType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = SendToRoutesFalseWithConnectionsConstraintInputFileType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SendToRoutesFalseWithConnectionsConstraintInputFileType: %v", v)
	}
}

// SendToRoutesFalseWithConnectionsConstraintMode - Choose how to discover files to monitor
type SendToRoutesFalseWithConnectionsConstraintMode string

const (
	// SendToRoutesFalseWithConnectionsConstraintModeManual Manual
	SendToRoutesFalseWithConnectionsConstraintModeManual SendToRoutesFalseWithConnectionsConstraintMode = "manual"
	// SendToRoutesFalseWithConnectionsConstraintModeAuto Auto
	SendToRoutesFalseWithConnectionsConstraintModeAuto SendToRoutesFalseWithConnectionsConstraintMode = "auto"
)

func (e SendToRoutesFalseWithConnectionsConstraintMode) ToPointer() *SendToRoutesFalseWithConnectionsConstraintMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SendToRoutesFalseWithConnectionsConstraintMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "auto":
			return true
		}
	}
	return false
}

type InputFileSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                                                  `json:"id"`
	Type     SendToRoutesFalseWithConnectionsConstraintInputFileType `json:"type"`
	Disabled *bool                                                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Choose how to discover files to monitor
	Mode *SendToRoutesFalseWithConnectionsConstraintMode `default:"manual" json:"mode"`
	// Time, in seconds, between scanning for files
	Interval *float64 `default:"10" json:"interval"`
	// The full path of discovered files are matched against this wildcard list
	Filenames []string `json:"filenames,omitempty"`
	// Apply filename allowlist to file entries in archive file types, like tar or zip.
	FilterArchivedFiles *bool `default:"false" json:"filterArchivedFiles"`
	// Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
	TailOnly *bool `default:"true" json:"tailOnly"`
	// Time, in seconds, before an idle file is closed
	IdleTimeout *float64 `default:"300" json:"idleTimeout"`
	// The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
	MinAgeDur *string `json:"minAgeDur,omitempty"`
	// The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Skip files with modification times earlier than the maximum age duration
	CheckFileModTime *bool `default:"false" json:"checkFileModTime"`
	// Forces files containing binary data to be streamed as text
	ForceText *bool `default:"false" json:"forceText"`
	// Length of file header bytes to use in hash for unique file identification
	HashLen *float64 `default:"256" json:"hashLen"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	Description         *string  `json:"description,omitempty"`
	// Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
	Path *string `json:"path,omitempty"`
	// Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
	Depth                     *float64 `json:"depth,omitempty"`
	SuppressMissingPathErrors *bool    `default:"false" json:"suppressMissingPathErrors"`
	// Delete files after they have been collected
	DeleteFiles *bool `default:"false" json:"deleteFiles"`
	// Stream binary files as Base64-encoded chunks.
	IncludeUnidentifiableBinary *bool `default:"false" json:"includeUnidentifiableBinary"`
}

func (i InputFileSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetType() SendToRoutesFalseWithConnectionsConstraintInputFileType {
	if i == nil {
		return SendToRoutesFalseWithConnectionsConstraintInputFileType("")
	}
	return i.Type
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetMode() *SendToRoutesFalseWithConnectionsConstraintMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetFilenames() []string {
	if i == nil {
		return nil
	}
	return i.Filenames
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetFilterArchivedFiles() *bool {
	if i == nil {
		return nil
	}
	return i.FilterArchivedFiles
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetTailOnly() *bool {
	if i == nil {
		return nil
	}
	return i.TailOnly
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.IdleTimeout
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetMinAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MinAgeDur
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetMaxAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MaxAgeDur
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetCheckFileModTime() *bool {
	if i == nil {
		return nil
	}
	return i.CheckFileModTime
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetForceText() *bool {
	if i == nil {
		return nil
	}
	return i.ForceText
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetHashLen() *float64 {
	if i == nil {
		return nil
	}
	return i.HashLen
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetPath() *string {
	if i == nil {
		return nil
	}
	return i.Path
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetDepth() *float64 {
	if i == nil {
		return nil
	}
	return i.Depth
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetSuppressMissingPathErrors() *bool {
	if i == nil {
		return nil
	}
	return i.SuppressMissingPathErrors
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetDeleteFiles() *bool {
	if i == nil {
		return nil
	}
	return i.DeleteFiles
}

func (i *InputFileSendToRoutesFalseWithConnectionsConstraint) GetIncludeUnidentifiableBinary() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeUnidentifiableBinary
}

type SendToRoutesTrueWithConnectionsConstraintInputFileType string

const (
	SendToRoutesTrueWithConnectionsConstraintInputFileTypeFile SendToRoutesTrueWithConnectionsConstraintInputFileType = "file"
)

func (e SendToRoutesTrueWithConnectionsConstraintInputFileType) ToPointer() *SendToRoutesTrueWithConnectionsConstraintInputFileType {
	return &e
}
func (e *SendToRoutesTrueWithConnectionsConstraintInputFileType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = SendToRoutesTrueWithConnectionsConstraintInputFileType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SendToRoutesTrueWithConnectionsConstraintInputFileType: %v", v)
	}
}

// SendToRoutesTrueWithConnectionsConstraintMode - Choose how to discover files to monitor
type SendToRoutesTrueWithConnectionsConstraintMode string

const (
	// SendToRoutesTrueWithConnectionsConstraintModeManual Manual
	SendToRoutesTrueWithConnectionsConstraintModeManual SendToRoutesTrueWithConnectionsConstraintMode = "manual"
	// SendToRoutesTrueWithConnectionsConstraintModeAuto Auto
	SendToRoutesTrueWithConnectionsConstraintModeAuto SendToRoutesTrueWithConnectionsConstraintMode = "auto"
)

func (e SendToRoutesTrueWithConnectionsConstraintMode) ToPointer() *SendToRoutesTrueWithConnectionsConstraintMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SendToRoutesTrueWithConnectionsConstraintMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "auto":
			return true
		}
	}
	return false
}

type InputFileSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                                                 `json:"id"`
	Type     SendToRoutesTrueWithConnectionsConstraintInputFileType `json:"type"`
	Disabled *bool                                                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Choose how to discover files to monitor
	Mode *SendToRoutesTrueWithConnectionsConstraintMode `default:"manual" json:"mode"`
	// Time, in seconds, between scanning for files
	Interval *float64 `default:"10" json:"interval"`
	// The full path of discovered files are matched against this wildcard list
	Filenames []string `json:"filenames,omitempty"`
	// Apply filename allowlist to file entries in archive file types, like tar or zip.
	FilterArchivedFiles *bool `default:"false" json:"filterArchivedFiles"`
	// Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
	TailOnly *bool `default:"true" json:"tailOnly"`
	// Time, in seconds, before an idle file is closed
	IdleTimeout *float64 `default:"300" json:"idleTimeout"`
	// The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
	MinAgeDur *string `json:"minAgeDur,omitempty"`
	// The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`
	// Skip files with modification times earlier than the maximum age duration
	CheckFileModTime *bool `default:"false" json:"checkFileModTime"`
	// Forces files containing binary data to be streamed as text
	ForceText *bool `default:"false" json:"forceText"`
	// Length of file header bytes to use in hash for unique file identification
	HashLen *float64 `default:"256" json:"hashLen"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	Description         *string  `json:"description,omitempty"`
	// Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
	Path *string `json:"path,omitempty"`
	// Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
	Depth                     *float64 `json:"depth,omitempty"`
	SuppressMissingPathErrors *bool    `default:"false" json:"suppressMissingPathErrors"`
	// Delete files after they have been collected
	DeleteFiles *bool `default:"false" json:"deleteFiles"`
	// Stream binary files as Base64-encoded chunks.
	IncludeUnidentifiableBinary *bool `default:"false" json:"includeUnidentifiableBinary"`
}

func (i InputFileSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetType() SendToRoutesTrueWithConnectionsConstraintInputFileType {
	if i == nil {
		return SendToRoutesTrueWithConnectionsConstraintInputFileType("")
	}
	return i.Type
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetMode() *SendToRoutesTrueWithConnectionsConstraintMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetFilenames() []string {
	if i == nil {
		return nil
	}
	return i.Filenames
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetFilterArchivedFiles() *bool {
	if i == nil {
		return nil
	}
	return i.FilterArchivedFiles
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetTailOnly() *bool {
	if i == nil {
		return nil
	}
	return i.TailOnly
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.IdleTimeout
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetMinAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MinAgeDur
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetMaxAgeDur() *string {
	if i == nil {
		return nil
	}
	return i.MaxAgeDur
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetCheckFileModTime() *bool {
	if i == nil {
		return nil
	}
	return i.CheckFileModTime
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetForceText() *bool {
	if i == nil {
		return nil
	}
	return i.ForceText
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetHashLen() *float64 {
	if i == nil {
		return nil
	}
	return i.HashLen
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetPath() *string {
	if i == nil {
		return nil
	}
	return i.Path
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetDepth() *float64 {
	if i == nil {
		return nil
	}
	return i.Depth
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetSuppressMissingPathErrors() *bool {
	if i == nil {
		return nil
	}
	return i.SuppressMissingPathErrors
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetDeleteFiles() *bool {
	if i == nil {
		return nil
	}
	return i.DeleteFiles
}

func (i *InputFileSendToRoutesTrueWithConnectionsConstraint) GetIncludeUnidentifiableBinary() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeUnidentifiableBinary
}

type InputFileType string

const (
	InputFileTypeInputFileSendToRoutesTrueWithConnectionsConstraint  InputFileType = "InputFile_SendToRoutesTrueWithConnectionsConstraint"
	InputFileTypeInputFileSendToRoutesFalseWithConnectionsConstraint InputFileType = "InputFile_SendToRoutesFalseWithConnectionsConstraint"
	InputFileTypeInputFilePqEnabledFalseWithPqConstraint             InputFileType = "InputFile_PqEnabledFalseWithPqConstraint"
	InputFileTypeInputFilePqEnabledTrueWithPqConstraint              InputFileType = "InputFile_PqEnabledTrueWithPqConstraint"
)

type InputFile struct {
	InputFileSendToRoutesTrueWithConnectionsConstraint  *InputFileSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputFileSendToRoutesFalseWithConnectionsConstraint *InputFileSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputFilePqEnabledFalseWithPqConstraint             *InputFilePqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputFilePqEnabledTrueWithPqConstraint              *InputFilePqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputFileType
}

func CreateInputFileInputFileSendToRoutesTrueWithConnectionsConstraint(inputFileSendToRoutesTrueWithConnectionsConstraint InputFileSendToRoutesTrueWithConnectionsConstraint) InputFile {
	typ := InputFileTypeInputFileSendToRoutesTrueWithConnectionsConstraint

	return InputFile{
		InputFileSendToRoutesTrueWithConnectionsConstraint: &inputFileSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputFileInputFileSendToRoutesFalseWithConnectionsConstraint(inputFileSendToRoutesFalseWithConnectionsConstraint InputFileSendToRoutesFalseWithConnectionsConstraint) InputFile {
	typ := InputFileTypeInputFileSendToRoutesFalseWithConnectionsConstraint

	return InputFile{
		InputFileSendToRoutesFalseWithConnectionsConstraint: &inputFileSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputFileInputFilePqEnabledFalseWithPqConstraint(inputFilePqEnabledFalseWithPqConstraint InputFilePqEnabledFalseWithPqConstraint) InputFile {
	typ := InputFileTypeInputFilePqEnabledFalseWithPqConstraint

	return InputFile{
		InputFilePqEnabledFalseWithPqConstraint: &inputFilePqEnabledFalseWithPqConstraint,
		Type:                                    typ,
	}
}

func CreateInputFileInputFilePqEnabledTrueWithPqConstraint(inputFilePqEnabledTrueWithPqConstraint InputFilePqEnabledTrueWithPqConstraint) InputFile {
	typ := InputFileTypeInputFilePqEnabledTrueWithPqConstraint

	return InputFile{
		InputFilePqEnabledTrueWithPqConstraint: &inputFilePqEnabledTrueWithPqConstraint,
		Type:                                   typ,
	}
}

func (u *InputFile) UnmarshalJSON(data []byte) error {

	var inputFileSendToRoutesTrueWithConnectionsConstraint InputFileSendToRoutesTrueWithConnectionsConstraint = InputFileSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputFileSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputFileSendToRoutesTrueWithConnectionsConstraint = &inputFileSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputFileTypeInputFileSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputFileSendToRoutesFalseWithConnectionsConstraint InputFileSendToRoutesFalseWithConnectionsConstraint = InputFileSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputFileSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputFileSendToRoutesFalseWithConnectionsConstraint = &inputFileSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputFileTypeInputFileSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputFilePqEnabledFalseWithPqConstraint InputFilePqEnabledFalseWithPqConstraint = InputFilePqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputFilePqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputFilePqEnabledFalseWithPqConstraint = &inputFilePqEnabledFalseWithPqConstraint
		u.Type = InputFileTypeInputFilePqEnabledFalseWithPqConstraint
		return nil
	}

	var inputFilePqEnabledTrueWithPqConstraint InputFilePqEnabledTrueWithPqConstraint = InputFilePqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputFilePqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputFilePqEnabledTrueWithPqConstraint = &inputFilePqEnabledTrueWithPqConstraint
		u.Type = InputFileTypeInputFilePqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputFile", string(data))
}

func (u InputFile) MarshalJSON() ([]byte, error) {
	if u.InputFileSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputFileSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputFileSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputFileSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputFilePqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputFilePqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputFilePqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputFilePqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputFile: all fields are null")
}

type InputSyslogType2 string

const (
	InputSyslogType2Syslog InputSyslogType2 = "syslog"
)

func (e InputSyslogType2) ToPointer() *InputSyslogType2 {
	return &e
}
func (e *InputSyslogType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = InputSyslogType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslogType2: %v", v)
	}
}

type InputSyslogSyslog2 struct {
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputSyslogType2 `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	Pq          *components.PqType                `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort float64 `json:"tcpPort"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Timezone to assign to timestamps without timezone info
	TimestampTimezone *string `default:"local" json:"timestampTimezone"`
	// Treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `default:"false" json:"singleMsgUdpPackets"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Wildcard list of fields to keep from source data; * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting *bool `default:"false" json:"octetCounting"`
	// Enable if we should infer the syslog framing of the incoming messages.
	InferFraming *bool `default:"true" json:"inferFraming"`
	// Enable if we should infer octet counting only if the messages comply with RFC 5424.
	StrictlyInferOctetCounting *bool `default:"true" json:"strictlyInferOctetCounting"`
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `default:"false" json:"allowNonStandardAppName"`
	// Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64                              `default:"0" json:"socketMaxLifespan"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `default:"false" json:"enableLoadBalancing"`
	Description         *string `json:"description,omitempty"`
	// When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
	EnableEnhancedProxyHeaderParsing *bool `json:"enableEnhancedProxyHeaderParsing,omitempty"`
}

func (i InputSyslogSyslog2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSyslogSyslog2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tcpPort"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSyslogSyslog2) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSyslogSyslog2) GetType() InputSyslogType2 {
	if i == nil {
		return InputSyslogType2("")
	}
	return i.Type
}

func (i *InputSyslogSyslog2) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSyslogSyslog2) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSyslogSyslog2) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSyslogSyslog2) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSyslogSyslog2) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSyslogSyslog2) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSyslogSyslog2) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSyslogSyslog2) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSyslogSyslog2) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSyslogSyslog2) GetUDPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPPort
}

func (i *InputSyslogSyslog2) GetTCPPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.TCPPort
}

func (i *InputSyslogSyslog2) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputSyslogSyslog2) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSyslogSyslog2) GetTimestampTimezone() *string {
	if i == nil {
		return nil
	}
	return i.TimestampTimezone
}

func (i *InputSyslogSyslog2) GetSingleMsgUDPPackets() *bool {
	if i == nil {
		return nil
	}
	return i.SingleMsgUDPPackets
}

func (i *InputSyslogSyslog2) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSyslogSyslog2) GetKeepFieldsList() []string {
	if i == nil {
		return nil
	}
	return i.KeepFieldsList
}

func (i *InputSyslogSyslog2) GetOctetCounting() *bool {
	if i == nil {
		return nil
	}
	return i.OctetCounting
}

func (i *InputSyslogSyslog2) GetInferFraming() *bool {
	if i == nil {
		return nil
	}
	return i.InferFraming
}

func (i *InputSyslogSyslog2) GetStrictlyInferOctetCounting() *bool {
	if i == nil {
		return nil
	}
	return i.StrictlyInferOctetCounting
}

func (i *InputSyslogSyslog2) GetAllowNonStandardAppName() *bool {
	if i == nil {
		return nil
	}
	return i.AllowNonStandardAppName
}

func (i *InputSyslogSyslog2) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputSyslogSyslog2) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputSyslogSyslog2) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputSyslogSyslog2) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputSyslogSyslog2) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSyslogSyslog2) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSyslogSyslog2) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputSyslogSyslog2) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputSyslogSyslog2) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSyslogSyslog2) GetEnableEnhancedProxyHeaderParsing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableEnhancedProxyHeaderParsing
}

type InputSyslogType1 string

const (
	InputSyslogType1Syslog InputSyslogType1 = "syslog"
)

func (e InputSyslogType1) ToPointer() *InputSyslogType1 {
	return &e
}
func (e *InputSyslogType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = InputSyslogType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslogType1: %v", v)
	}
}

type InputSyslogSyslog1 struct {
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputSyslogType1 `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	Pq          *components.PqType                `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort float64 `json:"udpPort"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Timezone to assign to timestamps without timezone info
	TimestampTimezone *string `default:"local" json:"timestampTimezone"`
	// Treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `default:"false" json:"singleMsgUdpPackets"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Wildcard list of fields to keep from source data; * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting *bool `default:"false" json:"octetCounting"`
	// Enable if we should infer the syslog framing of the incoming messages.
	InferFraming *bool `default:"true" json:"inferFraming"`
	// Enable if we should infer octet counting only if the messages comply with RFC 5424.
	StrictlyInferOctetCounting *bool `default:"true" json:"strictlyInferOctetCounting"`
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `default:"false" json:"allowNonStandardAppName"`
	// Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64                              `default:"0" json:"socketMaxLifespan"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `default:"false" json:"enableLoadBalancing"`
	Description         *string `json:"description,omitempty"`
	// When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
	EnableEnhancedProxyHeaderParsing *bool `json:"enableEnhancedProxyHeaderParsing,omitempty"`
}

func (i InputSyslogSyslog1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSyslogSyslog1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "udpPort"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSyslogSyslog1) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSyslogSyslog1) GetType() InputSyslogType1 {
	if i == nil {
		return InputSyslogType1("")
	}
	return i.Type
}

func (i *InputSyslogSyslog1) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSyslogSyslog1) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSyslogSyslog1) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSyslogSyslog1) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSyslogSyslog1) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSyslogSyslog1) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSyslogSyslog1) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSyslogSyslog1) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSyslogSyslog1) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSyslogSyslog1) GetUDPPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.UDPPort
}

func (i *InputSyslogSyslog1) GetTCPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.TCPPort
}

func (i *InputSyslogSyslog1) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputSyslogSyslog1) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSyslogSyslog1) GetTimestampTimezone() *string {
	if i == nil {
		return nil
	}
	return i.TimestampTimezone
}

func (i *InputSyslogSyslog1) GetSingleMsgUDPPackets() *bool {
	if i == nil {
		return nil
	}
	return i.SingleMsgUDPPackets
}

func (i *InputSyslogSyslog1) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSyslogSyslog1) GetKeepFieldsList() []string {
	if i == nil {
		return nil
	}
	return i.KeepFieldsList
}

func (i *InputSyslogSyslog1) GetOctetCounting() *bool {
	if i == nil {
		return nil
	}
	return i.OctetCounting
}

func (i *InputSyslogSyslog1) GetInferFraming() *bool {
	if i == nil {
		return nil
	}
	return i.InferFraming
}

func (i *InputSyslogSyslog1) GetStrictlyInferOctetCounting() *bool {
	if i == nil {
		return nil
	}
	return i.StrictlyInferOctetCounting
}

func (i *InputSyslogSyslog1) GetAllowNonStandardAppName() *bool {
	if i == nil {
		return nil
	}
	return i.AllowNonStandardAppName
}

func (i *InputSyslogSyslog1) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputSyslogSyslog1) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputSyslogSyslog1) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputSyslogSyslog1) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputSyslogSyslog1) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSyslogSyslog1) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSyslogSyslog1) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputSyslogSyslog1) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputSyslogSyslog1) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSyslogSyslog1) GetEnableEnhancedProxyHeaderParsing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableEnhancedProxyHeaderParsing
}

type InputSyslogType string

const (
	InputSyslogTypeInputSyslogSyslog1 InputSyslogType = "InputSyslog_Syslog_1"
	InputSyslogTypeInputSyslogSyslog2 InputSyslogType = "InputSyslog_Syslog_2"
)

type InputSyslog struct {
	InputSyslogSyslog1 *InputSyslogSyslog1 `queryParam:"inline" union:"member"`
	InputSyslogSyslog2 *InputSyslogSyslog2 `queryParam:"inline" union:"member"`

	Type InputSyslogType
}

func CreateInputSyslogInputSyslogSyslog1(inputSyslogSyslog1 InputSyslogSyslog1) InputSyslog {
	typ := InputSyslogTypeInputSyslogSyslog1

	return InputSyslog{
		InputSyslogSyslog1: &inputSyslogSyslog1,
		Type:               typ,
	}
}

func CreateInputSyslogInputSyslogSyslog2(inputSyslogSyslog2 InputSyslogSyslog2) InputSyslog {
	typ := InputSyslogTypeInputSyslogSyslog2

	return InputSyslog{
		InputSyslogSyslog2: &inputSyslogSyslog2,
		Type:               typ,
	}
}

func (u *InputSyslog) UnmarshalJSON(data []byte) error {

	var inputSyslogSyslog1 InputSyslogSyslog1 = InputSyslogSyslog1{}
	if err := utils.UnmarshalJSON(data, &inputSyslogSyslog1, "", true, nil); err == nil {
		u.InputSyslogSyslog1 = &inputSyslogSyslog1
		u.Type = InputSyslogTypeInputSyslogSyslog1
		return nil
	}

	var inputSyslogSyslog2 InputSyslogSyslog2 = InputSyslogSyslog2{}
	if err := utils.UnmarshalJSON(data, &inputSyslogSyslog2, "", true, nil); err == nil {
		u.InputSyslogSyslog2 = &inputSyslogSyslog2
		u.Type = InputSyslogTypeInputSyslogSyslog2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSyslog", string(data))
}

func (u InputSyslog) MarshalJSON() ([]byte, error) {
	if u.InputSyslogSyslog1 != nil {
		return utils.MarshalJSON(u.InputSyslogSyslog1, "", true)
	}

	if u.InputSyslogSyslog2 != nil {
		return utils.MarshalJSON(u.InputSyslogSyslog2, "", true)
	}

	return nil, errors.New("could not marshal union type InputSyslog: all fields are null")
}

type InputSqsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputSqsType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// The queue type used (or created)
	QueueType CreateInputQueueType `json:"queueType"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// Create queue if it does not exist
	CreateQueue *bool `default:"false" json:"createQueue"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing SQS requests
	SignatureVersion *components.SignatureVersionOptions3 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access SQS
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"10" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	Description *string  `json:"description,omitempty"`
	AwsAPIKey   *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"3" json:"numReceivers"`
}

func (i InputSqsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName", "queueType"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetType() InputSqsType {
	if i == nil {
		return InputSqsType("")
	}
	return i.Type
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetQueueType() CreateInputQueueType {
	if i == nil {
		return CreateInputQueueType("")
	}
	return i.QueueType
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetCreateQueue() *bool {
	if i == nil {
		return nil
	}
	return i.CreateQueue
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions3 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputSqsPqEnabledTrueWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

type InputSqsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputSqsType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// The queue type used (or created)
	QueueType CreateInputQueueType `json:"queueType"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// Create queue if it does not exist
	CreateQueue *bool `default:"false" json:"createQueue"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing SQS requests
	SignatureVersion *components.SignatureVersionOptions3 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access SQS
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"10" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	Description *string  `json:"description,omitempty"`
	AwsAPIKey   *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"3" json:"numReceivers"`
}

func (i InputSqsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName", "queueType"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetType() InputSqsType {
	if i == nil {
		return InputSqsType("")
	}
	return i.Type
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetQueueType() CreateInputQueueType {
	if i == nil {
		return CreateInputQueueType("")
	}
	return i.QueueType
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetCreateQueue() *bool {
	if i == nil {
		return nil
	}
	return i.CreateQueue
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions3 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputSqsPqEnabledFalseWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

type InputSqsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputSqsType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// The queue type used (or created)
	QueueType CreateInputQueueType `json:"queueType"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// Create queue if it does not exist
	CreateQueue *bool `default:"false" json:"createQueue"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing SQS requests
	SignatureVersion *components.SignatureVersionOptions3 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access SQS
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"10" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	Description *string  `json:"description,omitempty"`
	AwsAPIKey   *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"3" json:"numReceivers"`
}

func (i InputSqsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName", "queueType"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetType() InputSqsType {
	if i == nil {
		return InputSqsType("")
	}
	return i.Type
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetQueueType() CreateInputQueueType {
	if i == nil {
		return CreateInputQueueType("")
	}
	return i.QueueType
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetCreateQueue() *bool {
	if i == nil {
		return nil
	}
	return i.CreateQueue
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions3 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputSqsSendToRoutesFalseWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

type InputSqsType string

const (
	InputSqsTypeSqs InputSqsType = "sqs"
)

func (e InputSqsType) ToPointer() *InputSqsType {
	return &e
}
func (e *InputSqsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sqs":
		*e = InputSqsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSqsType: %v", v)
	}
}

// CreateInputQueueType - The queue type used (or created)
type CreateInputQueueType string

const (
	// CreateInputQueueTypeStandard Standard
	CreateInputQueueTypeStandard CreateInputQueueType = "standard"
	// CreateInputQueueTypeFifo FIFO
	CreateInputQueueTypeFifo CreateInputQueueType = "fifo"
)

func (e CreateInputQueueType) ToPointer() *CreateInputQueueType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputQueueType) IsExact() bool {
	if e != nil {
		switch *e {
		case "standard", "fifo":
			return true
		}
	}
	return false
}

type InputSqsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputSqsType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// The queue type used (or created)
	QueueType CreateInputQueueType `json:"queueType"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// Create queue if it does not exist
	CreateQueue *bool `default:"false" json:"createQueue"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing SQS requests
	SignatureVersion *components.SignatureVersionOptions3 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access SQS
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"10" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	Description *string  `json:"description,omitempty"`
	AwsAPIKey   *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"3" json:"numReceivers"`
}

func (i InputSqsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName", "queueType"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetType() InputSqsType {
	if i == nil {
		return InputSqsType("")
	}
	return i.Type
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetQueueType() CreateInputQueueType {
	if i == nil {
		return CreateInputQueueType("")
	}
	return i.QueueType
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetCreateQueue() *bool {
	if i == nil {
		return nil
	}
	return i.CreateQueue
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions3 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputSqsSendToRoutesTrueWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

type InputSqsUnionType string

const (
	InputSqsUnionTypeInputSqsSendToRoutesTrueWithConnectionsConstraint  InputSqsUnionType = "InputSqs_SendToRoutesTrueWithConnectionsConstraint"
	InputSqsUnionTypeInputSqsSendToRoutesFalseWithConnectionsConstraint InputSqsUnionType = "InputSqs_SendToRoutesFalseWithConnectionsConstraint"
	InputSqsUnionTypeInputSqsPqEnabledFalseWithPqConstraint             InputSqsUnionType = "InputSqs_PqEnabledFalseWithPqConstraint"
	InputSqsUnionTypeInputSqsPqEnabledTrueWithPqConstraint              InputSqsUnionType = "InputSqs_PqEnabledTrueWithPqConstraint"
)

type InputSqs struct {
	InputSqsSendToRoutesTrueWithConnectionsConstraint  *InputSqsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputSqsSendToRoutesFalseWithConnectionsConstraint *InputSqsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputSqsPqEnabledFalseWithPqConstraint             *InputSqsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputSqsPqEnabledTrueWithPqConstraint              *InputSqsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputSqsUnionType
}

func CreateInputSqsInputSqsSendToRoutesTrueWithConnectionsConstraint(inputSqsSendToRoutesTrueWithConnectionsConstraint InputSqsSendToRoutesTrueWithConnectionsConstraint) InputSqs {
	typ := InputSqsUnionTypeInputSqsSendToRoutesTrueWithConnectionsConstraint

	return InputSqs{
		InputSqsSendToRoutesTrueWithConnectionsConstraint: &inputSqsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSqsInputSqsSendToRoutesFalseWithConnectionsConstraint(inputSqsSendToRoutesFalseWithConnectionsConstraint InputSqsSendToRoutesFalseWithConnectionsConstraint) InputSqs {
	typ := InputSqsUnionTypeInputSqsSendToRoutesFalseWithConnectionsConstraint

	return InputSqs{
		InputSqsSendToRoutesFalseWithConnectionsConstraint: &inputSqsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSqsInputSqsPqEnabledFalseWithPqConstraint(inputSqsPqEnabledFalseWithPqConstraint InputSqsPqEnabledFalseWithPqConstraint) InputSqs {
	typ := InputSqsUnionTypeInputSqsPqEnabledFalseWithPqConstraint

	return InputSqs{
		InputSqsPqEnabledFalseWithPqConstraint: &inputSqsPqEnabledFalseWithPqConstraint,
		Type:                                   typ,
	}
}

func CreateInputSqsInputSqsPqEnabledTrueWithPqConstraint(inputSqsPqEnabledTrueWithPqConstraint InputSqsPqEnabledTrueWithPqConstraint) InputSqs {
	typ := InputSqsUnionTypeInputSqsPqEnabledTrueWithPqConstraint

	return InputSqs{
		InputSqsPqEnabledTrueWithPqConstraint: &inputSqsPqEnabledTrueWithPqConstraint,
		Type:                                  typ,
	}
}

func (u *InputSqs) UnmarshalJSON(data []byte) error {

	var inputSqsSendToRoutesTrueWithConnectionsConstraint InputSqsSendToRoutesTrueWithConnectionsConstraint = InputSqsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSqsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSqsSendToRoutesTrueWithConnectionsConstraint = &inputSqsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputSqsUnionTypeInputSqsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputSqsSendToRoutesFalseWithConnectionsConstraint InputSqsSendToRoutesFalseWithConnectionsConstraint = InputSqsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSqsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSqsSendToRoutesFalseWithConnectionsConstraint = &inputSqsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputSqsUnionTypeInputSqsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputSqsPqEnabledFalseWithPqConstraint InputSqsPqEnabledFalseWithPqConstraint = InputSqsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSqsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputSqsPqEnabledFalseWithPqConstraint = &inputSqsPqEnabledFalseWithPqConstraint
		u.Type = InputSqsUnionTypeInputSqsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputSqsPqEnabledTrueWithPqConstraint InputSqsPqEnabledTrueWithPqConstraint = InputSqsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSqsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputSqsPqEnabledTrueWithPqConstraint = &inputSqsPqEnabledTrueWithPqConstraint
		u.Type = InputSqsUnionTypeInputSqsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSqs", string(data))
}

func (u InputSqs) MarshalJSON() ([]byte, error) {
	if u.InputSqsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSqsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputSqsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSqsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputSqsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSqsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputSqsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSqsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputSqs: all fields are null")
}

type InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                        `json:"id"`
	Type     InputModelDrivenTelemetryType `json:"type"`
	Disabled *bool                         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64                              `default:"57000" json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
	ShutdownTimeoutMs *float64 `default:"5000" json:"shutdownTimeoutMs"`
	Description       *string  `json:"description,omitempty"`
}

func (i InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetType() InputModelDrivenTelemetryType {
	if i == nil {
		return InputModelDrivenTelemetryType("")
	}
	return i.Type
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetShutdownTimeoutMs() *float64 {
	if i == nil {
		return nil
	}
	return i.ShutdownTimeoutMs
}

func (i *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                        `json:"id"`
	Type     InputModelDrivenTelemetryType `json:"type"`
	Disabled *bool                         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64                              `default:"57000" json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
	ShutdownTimeoutMs *float64 `default:"5000" json:"shutdownTimeoutMs"`
	Description       *string  `json:"description,omitempty"`
}

func (i InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetType() InputModelDrivenTelemetryType {
	if i == nil {
		return InputModelDrivenTelemetryType("")
	}
	return i.Type
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetShutdownTimeoutMs() *float64 {
	if i == nil {
		return nil
	}
	return i.ShutdownTimeoutMs
}

func (i *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                        `json:"id"`
	Type     InputModelDrivenTelemetryType `json:"type"`
	Disabled *bool                         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64                              `default:"57000" json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
	ShutdownTimeoutMs *float64 `default:"5000" json:"shutdownTimeoutMs"`
	Description       *string  `json:"description,omitempty"`
}

func (i InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetType() InputModelDrivenTelemetryType {
	if i == nil {
		return InputModelDrivenTelemetryType("")
	}
	return i.Type
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetShutdownTimeoutMs() *float64 {
	if i == nil {
		return nil
	}
	return i.ShutdownTimeoutMs
}

func (i *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputModelDrivenTelemetryType string

const (
	InputModelDrivenTelemetryTypeModelDrivenTelemetry InputModelDrivenTelemetryType = "model_driven_telemetry"
)

func (e InputModelDrivenTelemetryType) ToPointer() *InputModelDrivenTelemetryType {
	return &e
}
func (e *InputModelDrivenTelemetryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "model_driven_telemetry":
		*e = InputModelDrivenTelemetryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputModelDrivenTelemetryType: %v", v)
	}
}

type InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                        `json:"id"`
	Type     InputModelDrivenTelemetryType `json:"type"`
	Disabled *bool                         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64                              `default:"57000" json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
	ShutdownTimeoutMs *float64 `default:"5000" json:"shutdownTimeoutMs"`
	Description       *string  `json:"description,omitempty"`
}

func (i InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetType() InputModelDrivenTelemetryType {
	if i == nil {
		return InputModelDrivenTelemetryType("")
	}
	return i.Type
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetShutdownTimeoutMs() *float64 {
	if i == nil {
		return nil
	}
	return i.ShutdownTimeoutMs
}

func (i *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputModelDrivenTelemetryUnionType string

const (
	InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint  InputModelDrivenTelemetryUnionType = "InputModelDrivenTelemetry_SendToRoutesTrueWithConnectionsConstraint"
	InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint InputModelDrivenTelemetryUnionType = "InputModelDrivenTelemetry_SendToRoutesFalseWithConnectionsConstraint"
	InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetryPqEnabledFalseWithPqConstraint             InputModelDrivenTelemetryUnionType = "InputModelDrivenTelemetry_PqEnabledFalseWithPqConstraint"
	InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetryPqEnabledTrueWithPqConstraint              InputModelDrivenTelemetryUnionType = "InputModelDrivenTelemetry_PqEnabledTrueWithPqConstraint"
)

type InputModelDrivenTelemetry struct {
	InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint  *InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint *InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint             *InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint              *InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputModelDrivenTelemetryUnionType
}

func CreateInputModelDrivenTelemetryInputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint(inputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint) InputModelDrivenTelemetry {
	typ := InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint

	return InputModelDrivenTelemetry{
		InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint: &inputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputModelDrivenTelemetryInputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint(inputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint) InputModelDrivenTelemetry {
	typ := InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint

	return InputModelDrivenTelemetry{
		InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint: &inputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputModelDrivenTelemetryInputModelDrivenTelemetryPqEnabledFalseWithPqConstraint(inputModelDrivenTelemetryPqEnabledFalseWithPqConstraint InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint) InputModelDrivenTelemetry {
	typ := InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetryPqEnabledFalseWithPqConstraint

	return InputModelDrivenTelemetry{
		InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint: &inputModelDrivenTelemetryPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputModelDrivenTelemetryInputModelDrivenTelemetryPqEnabledTrueWithPqConstraint(inputModelDrivenTelemetryPqEnabledTrueWithPqConstraint InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint) InputModelDrivenTelemetry {
	typ := InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetryPqEnabledTrueWithPqConstraint

	return InputModelDrivenTelemetry{
		InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint: &inputModelDrivenTelemetryPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputModelDrivenTelemetry) UnmarshalJSON(data []byte) error {

	var inputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint = InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint = &inputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint
		u.Type = InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint = InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint = &inputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint
		u.Type = InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputModelDrivenTelemetryPqEnabledFalseWithPqConstraint InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint = InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputModelDrivenTelemetryPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint = &inputModelDrivenTelemetryPqEnabledFalseWithPqConstraint
		u.Type = InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetryPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputModelDrivenTelemetryPqEnabledTrueWithPqConstraint InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint = InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputModelDrivenTelemetryPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint = &inputModelDrivenTelemetryPqEnabledTrueWithPqConstraint
		u.Type = InputModelDrivenTelemetryUnionTypeInputModelDrivenTelemetryPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputModelDrivenTelemetry", string(data))
}

func (u InputModelDrivenTelemetry) MarshalJSON() ([]byte, error) {
	if u.InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputModelDrivenTelemetrySendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputModelDrivenTelemetryPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputModelDrivenTelemetry: all fields are null")
}

type InputOpenTelemetryPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputOpenTelemetryType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64                              `default:"4317" json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket  *int64 `default:"0" json:"maxRequestsPerSocket"`
	EnableProxyHeader     any    `json:"enableProxyHeader,omitempty"`
	CaptureHeaders        any    `json:"captureHeaders,omitempty"`
	ActivityLogSampleRate any    `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float64 `default:"15" json:"keepAliveTimeout"`
	// Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Select whether to leverage gRPC or HTTP for OpenTelemetry
	Protocol *CreateInputProtocol `default:"grpc" json:"protocol"`
	// Enable to extract each incoming span to a separate event
	ExtractSpans *bool `default:"false" json:"extractSpans"`
	// Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// The version of OTLP Protobuf definitions to use when interpreting received data
	OtlpVersion *CreateInputOTLPVersion `default:"0.10.0" json:"otlpVersion"`
	// OpenTelemetry authentication type
	AuthType *components.AuthenticationTypeOptions `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	Description  *string  `json:"description,omitempty"`
	Username     *string  `json:"username,omitempty"`
	Password     *string  `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
	// Enable to extract each incoming log record to a separate event
	ExtractLogs *bool `default:"false" json:"extractLogs"`
}

func (i InputOpenTelemetryPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetType() InputOpenTelemetryType {
	if i == nil {
		return InputOpenTelemetryType("")
	}
	return i.Type
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() any {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetCaptureHeaders() any {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() any {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetProtocol() *CreateInputProtocol {
	if i == nil {
		return nil
	}
	return i.Protocol
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetExtractSpans() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractSpans
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetOtlpVersion() *CreateInputOTLPVersion {
	if i == nil {
		return nil
	}
	return i.OtlpVersion
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

func (i *InputOpenTelemetryPqEnabledTrueWithPqConstraint) GetExtractLogs() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractLogs
}

type InputOpenTelemetryPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputOpenTelemetryType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64                              `default:"4317" json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket  *int64 `default:"0" json:"maxRequestsPerSocket"`
	EnableProxyHeader     any    `json:"enableProxyHeader,omitempty"`
	CaptureHeaders        any    `json:"captureHeaders,omitempty"`
	ActivityLogSampleRate any    `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float64 `default:"15" json:"keepAliveTimeout"`
	// Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Select whether to leverage gRPC or HTTP for OpenTelemetry
	Protocol *CreateInputProtocol `default:"grpc" json:"protocol"`
	// Enable to extract each incoming span to a separate event
	ExtractSpans *bool `default:"false" json:"extractSpans"`
	// Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// The version of OTLP Protobuf definitions to use when interpreting received data
	OtlpVersion *CreateInputOTLPVersion `default:"0.10.0" json:"otlpVersion"`
	// OpenTelemetry authentication type
	AuthType *components.AuthenticationTypeOptions `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	Description  *string  `json:"description,omitempty"`
	Username     *string  `json:"username,omitempty"`
	Password     *string  `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
	// Enable to extract each incoming log record to a separate event
	ExtractLogs *bool `default:"false" json:"extractLogs"`
}

func (i InputOpenTelemetryPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetType() InputOpenTelemetryType {
	if i == nil {
		return InputOpenTelemetryType("")
	}
	return i.Type
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() any {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetCaptureHeaders() any {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() any {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetProtocol() *CreateInputProtocol {
	if i == nil {
		return nil
	}
	return i.Protocol
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetExtractSpans() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractSpans
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetOtlpVersion() *CreateInputOTLPVersion {
	if i == nil {
		return nil
	}
	return i.OtlpVersion
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

func (i *InputOpenTelemetryPqEnabledFalseWithPqConstraint) GetExtractLogs() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractLogs
}

type InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputOpenTelemetryType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64                              `default:"4317" json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket  *int64 `default:"0" json:"maxRequestsPerSocket"`
	EnableProxyHeader     any    `json:"enableProxyHeader,omitempty"`
	CaptureHeaders        any    `json:"captureHeaders,omitempty"`
	ActivityLogSampleRate any    `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float64 `default:"15" json:"keepAliveTimeout"`
	// Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Select whether to leverage gRPC or HTTP for OpenTelemetry
	Protocol *CreateInputProtocol `default:"grpc" json:"protocol"`
	// Enable to extract each incoming span to a separate event
	ExtractSpans *bool `default:"false" json:"extractSpans"`
	// Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// The version of OTLP Protobuf definitions to use when interpreting received data
	OtlpVersion *CreateInputOTLPVersion `default:"0.10.0" json:"otlpVersion"`
	// OpenTelemetry authentication type
	AuthType *components.AuthenticationTypeOptions `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	Description  *string  `json:"description,omitempty"`
	Username     *string  `json:"username,omitempty"`
	Password     *string  `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
	// Enable to extract each incoming log record to a separate event
	ExtractLogs *bool `default:"false" json:"extractLogs"`
}

func (i InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetType() InputOpenTelemetryType {
	if i == nil {
		return InputOpenTelemetryType("")
	}
	return i.Type
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() any {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() any {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() any {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetProtocol() *CreateInputProtocol {
	if i == nil {
		return nil
	}
	return i.Protocol
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetExtractSpans() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractSpans
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetOtlpVersion() *CreateInputOTLPVersion {
	if i == nil {
		return nil
	}
	return i.OtlpVersion
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

func (i *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) GetExtractLogs() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractLogs
}

type InputOpenTelemetryType string

const (
	InputOpenTelemetryTypeOpenTelemetry InputOpenTelemetryType = "open_telemetry"
)

func (e InputOpenTelemetryType) ToPointer() *InputOpenTelemetryType {
	return &e
}
func (e *InputOpenTelemetryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "open_telemetry":
		*e = InputOpenTelemetryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputOpenTelemetryType: %v", v)
	}
}

// CreateInputProtocol - Select whether to leverage gRPC or HTTP for OpenTelemetry
type CreateInputProtocol string

const (
	// CreateInputProtocolGrpc gRPC
	CreateInputProtocolGrpc CreateInputProtocol = "grpc"
	// CreateInputProtocolHTTP HTTP
	CreateInputProtocolHTTP CreateInputProtocol = "http"
)

func (e CreateInputProtocol) ToPointer() *CreateInputProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "grpc", "http":
			return true
		}
	}
	return false
}

// CreateInputOTLPVersion - The version of OTLP Protobuf definitions to use when interpreting received data
type CreateInputOTLPVersion string

const (
	// CreateInputOTLPVersionZeroDot10Dot0 0.10.0
	CreateInputOTLPVersionZeroDot10Dot0 CreateInputOTLPVersion = "0.10.0"
	// CreateInputOTLPVersionOneDot3Dot1 1.3.1
	CreateInputOTLPVersionOneDot3Dot1 CreateInputOTLPVersion = "1.3.1"
)

func (e CreateInputOTLPVersion) ToPointer() *CreateInputOTLPVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputOTLPVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "0.10.0", "1.3.1":
			return true
		}
	}
	return false
}

type InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputOpenTelemetryType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port *float64                              `default:"4317" json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket  *int64 `default:"0" json:"maxRequestsPerSocket"`
	EnableProxyHeader     any    `json:"enableProxyHeader,omitempty"`
	CaptureHeaders        any    `json:"captureHeaders,omitempty"`
	ActivityLogSampleRate any    `json:"activityLogSampleRate,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float64 `default:"15" json:"keepAliveTimeout"`
	// Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Select whether to leverage gRPC or HTTP for OpenTelemetry
	Protocol *CreateInputProtocol `default:"grpc" json:"protocol"`
	// Enable to extract each incoming span to a separate event
	ExtractSpans *bool `default:"false" json:"extractSpans"`
	// Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// The version of OTLP Protobuf definitions to use when interpreting received data
	OtlpVersion *CreateInputOTLPVersion `default:"0.10.0" json:"otlpVersion"`
	// OpenTelemetry authentication type
	AuthType *components.AuthenticationTypeOptions `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	Description  *string  `json:"description,omitempty"`
	Username     *string  `json:"username,omitempty"`
	Password     *string  `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
	// Enable to extract each incoming log record to a separate event
	ExtractLogs *bool `default:"false" json:"extractLogs"`
}

func (i InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetType() InputOpenTelemetryType {
	if i == nil {
		return InputOpenTelemetryType("")
	}
	return i.Type
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() any {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() any {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() any {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetProtocol() *CreateInputProtocol {
	if i == nil {
		return nil
	}
	return i.Protocol
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetExtractSpans() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractSpans
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetOtlpVersion() *CreateInputOTLPVersion {
	if i == nil {
		return nil
	}
	return i.OtlpVersion
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

func (i *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) GetExtractLogs() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractLogs
}

type InputOpenTelemetryUnionType string

const (
	InputOpenTelemetryUnionTypeInputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint  InputOpenTelemetryUnionType = "InputOpenTelemetry_SendToRoutesTrueWithConnectionsConstraint"
	InputOpenTelemetryUnionTypeInputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint InputOpenTelemetryUnionType = "InputOpenTelemetry_SendToRoutesFalseWithConnectionsConstraint"
	InputOpenTelemetryUnionTypeInputOpenTelemetryPqEnabledFalseWithPqConstraint             InputOpenTelemetryUnionType = "InputOpenTelemetry_PqEnabledFalseWithPqConstraint"
	InputOpenTelemetryUnionTypeInputOpenTelemetryPqEnabledTrueWithPqConstraint              InputOpenTelemetryUnionType = "InputOpenTelemetry_PqEnabledTrueWithPqConstraint"
)

type InputOpenTelemetry struct {
	InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint  *InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint *InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputOpenTelemetryPqEnabledFalseWithPqConstraint             *InputOpenTelemetryPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputOpenTelemetryPqEnabledTrueWithPqConstraint              *InputOpenTelemetryPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputOpenTelemetryUnionType
}

func CreateInputOpenTelemetryInputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint(inputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint) InputOpenTelemetry {
	typ := InputOpenTelemetryUnionTypeInputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint

	return InputOpenTelemetry{
		InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint: &inputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputOpenTelemetryInputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint(inputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint) InputOpenTelemetry {
	typ := InputOpenTelemetryUnionTypeInputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint

	return InputOpenTelemetry{
		InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint: &inputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputOpenTelemetryInputOpenTelemetryPqEnabledFalseWithPqConstraint(inputOpenTelemetryPqEnabledFalseWithPqConstraint InputOpenTelemetryPqEnabledFalseWithPqConstraint) InputOpenTelemetry {
	typ := InputOpenTelemetryUnionTypeInputOpenTelemetryPqEnabledFalseWithPqConstraint

	return InputOpenTelemetry{
		InputOpenTelemetryPqEnabledFalseWithPqConstraint: &inputOpenTelemetryPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputOpenTelemetryInputOpenTelemetryPqEnabledTrueWithPqConstraint(inputOpenTelemetryPqEnabledTrueWithPqConstraint InputOpenTelemetryPqEnabledTrueWithPqConstraint) InputOpenTelemetry {
	typ := InputOpenTelemetryUnionTypeInputOpenTelemetryPqEnabledTrueWithPqConstraint

	return InputOpenTelemetry{
		InputOpenTelemetryPqEnabledTrueWithPqConstraint: &inputOpenTelemetryPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputOpenTelemetry) UnmarshalJSON(data []byte) error {

	var inputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint = InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint = &inputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint
		u.Type = InputOpenTelemetryUnionTypeInputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint = InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint = &inputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint
		u.Type = InputOpenTelemetryUnionTypeInputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputOpenTelemetryPqEnabledFalseWithPqConstraint InputOpenTelemetryPqEnabledFalseWithPqConstraint = InputOpenTelemetryPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOpenTelemetryPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputOpenTelemetryPqEnabledFalseWithPqConstraint = &inputOpenTelemetryPqEnabledFalseWithPqConstraint
		u.Type = InputOpenTelemetryUnionTypeInputOpenTelemetryPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputOpenTelemetryPqEnabledTrueWithPqConstraint InputOpenTelemetryPqEnabledTrueWithPqConstraint = InputOpenTelemetryPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOpenTelemetryPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputOpenTelemetryPqEnabledTrueWithPqConstraint = &inputOpenTelemetryPqEnabledTrueWithPqConstraint
		u.Type = InputOpenTelemetryUnionTypeInputOpenTelemetryPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputOpenTelemetry", string(data))
}

func (u InputOpenTelemetry) MarshalJSON() ([]byte, error) {
	if u.InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputOpenTelemetrySendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputOpenTelemetryPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputOpenTelemetryPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputOpenTelemetryPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputOpenTelemetryPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputOpenTelemetry: all fields are null")
}

type InputSnmpPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputSnmpType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// UDP port to receive SNMP traps on. Defaults to 162.
	Port *float64 `default:"162" json:"port"`
	// Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
	SnmpV3Auth *SNMPv3Authentication `json:"snmpV3Auth,omitempty"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// If enabled, parses varbinds as an array of objects that include OID, value, and type
	VarbindsWithTypes *bool `default:"false" json:"varbindsWithTypes"`
	// If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
	BestEffortParsing *bool   `default:"false" json:"bestEffortParsing"`
	Description       *string `json:"description,omitempty"`
}

func (i InputSnmpPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetType() InputSnmpType {
	if i == nil {
		return InputSnmpType("")
	}
	return i.Type
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetSnmpV3Auth() *SNMPv3Authentication {
	if i == nil {
		return nil
	}
	return i.SnmpV3Auth
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetVarbindsWithTypes() *bool {
	if i == nil {
		return nil
	}
	return i.VarbindsWithTypes
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetBestEffortParsing() *bool {
	if i == nil {
		return nil
	}
	return i.BestEffortParsing
}

func (i *InputSnmpPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSnmpPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputSnmpType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// UDP port to receive SNMP traps on. Defaults to 162.
	Port *float64 `default:"162" json:"port"`
	// Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
	SnmpV3Auth *SNMPv3Authentication `json:"snmpV3Auth,omitempty"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// If enabled, parses varbinds as an array of objects that include OID, value, and type
	VarbindsWithTypes *bool `default:"false" json:"varbindsWithTypes"`
	// If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
	BestEffortParsing *bool   `default:"false" json:"bestEffortParsing"`
	Description       *string `json:"description,omitempty"`
}

func (i InputSnmpPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetType() InputSnmpType {
	if i == nil {
		return InputSnmpType("")
	}
	return i.Type
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetSnmpV3Auth() *SNMPv3Authentication {
	if i == nil {
		return nil
	}
	return i.SnmpV3Auth
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetVarbindsWithTypes() *bool {
	if i == nil {
		return nil
	}
	return i.VarbindsWithTypes
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetBestEffortParsing() *bool {
	if i == nil {
		return nil
	}
	return i.BestEffortParsing
}

func (i *InputSnmpPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSnmpSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputSnmpType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// UDP port to receive SNMP traps on. Defaults to 162.
	Port *float64 `default:"162" json:"port"`
	// Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
	SnmpV3Auth *SNMPv3Authentication `json:"snmpV3Auth,omitempty"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// If enabled, parses varbinds as an array of objects that include OID, value, and type
	VarbindsWithTypes *bool `default:"false" json:"varbindsWithTypes"`
	// If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
	BestEffortParsing *bool   `default:"false" json:"bestEffortParsing"`
	Description       *string `json:"description,omitempty"`
}

func (i InputSnmpSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetType() InputSnmpType {
	if i == nil {
		return InputSnmpType("")
	}
	return i.Type
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetSnmpV3Auth() *SNMPv3Authentication {
	if i == nil {
		return nil
	}
	return i.SnmpV3Auth
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetVarbindsWithTypes() *bool {
	if i == nil {
		return nil
	}
	return i.VarbindsWithTypes
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetBestEffortParsing() *bool {
	if i == nil {
		return nil
	}
	return i.BestEffortParsing
}

func (i *InputSnmpSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSnmpType string

const (
	InputSnmpTypeSnmp InputSnmpType = "snmp"
)

func (e InputSnmpType) ToPointer() *InputSnmpType {
	return &e
}
func (e *InputSnmpType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snmp":
		*e = InputSnmpType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSnmpType: %v", v)
	}
}

type PrivacyProtocol string

const (
	// PrivacyProtocolNone None
	PrivacyProtocolNone PrivacyProtocol = "none"
	// PrivacyProtocolDes DES
	PrivacyProtocolDes PrivacyProtocol = "des"
	// PrivacyProtocolAes AES128
	PrivacyProtocolAes PrivacyProtocol = "aes"
	// PrivacyProtocolAes256b AES256b (Blumenthal)
	PrivacyProtocolAes256b PrivacyProtocol = "aes256b"
	// PrivacyProtocolAes256r AES256r (Reeder)
	PrivacyProtocolAes256r PrivacyProtocol = "aes256r"
)

func (e PrivacyProtocol) ToPointer() *PrivacyProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *PrivacyProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "des", "aes", "aes256b", "aes256r":
			return true
		}
	}
	return false
}

type V3User struct {
	Name         string                                          `json:"name"`
	AuthProtocol *components.AuthenticationProtocolOptionsV3User `default:"none" json:"authProtocol"`
	AuthKey      *string                                         `json:"authKey,omitempty"`
	PrivProtocol *PrivacyProtocol                                `default:"none" json:"privProtocol"`
	PrivKey      *string                                         `json:"privKey,omitempty"`
}

func (v V3User) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *V3User) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, []string{"name"}); err != nil {
		return err
	}
	return nil
}

func (v *V3User) GetName() string {
	if v == nil {
		return ""
	}
	return v.Name
}

func (v *V3User) GetAuthProtocol() *components.AuthenticationProtocolOptionsV3User {
	if v == nil {
		return nil
	}
	return v.AuthProtocol
}

func (v *V3User) GetAuthKey() *string {
	if v == nil {
		return nil
	}
	return v.AuthKey
}

func (v *V3User) GetPrivProtocol() *PrivacyProtocol {
	if v == nil {
		return nil
	}
	return v.PrivProtocol
}

func (v *V3User) GetPrivKey() *string {
	if v == nil {
		return nil
	}
	return v.PrivKey
}

// SNMPv3Authentication - Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
type SNMPv3Authentication struct {
	V3AuthEnabled *bool `default:"false" json:"v3AuthEnabled"`
	// Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps.
	AllowUnmatchedTrap *bool `default:"false" json:"allowUnmatchedTrap"`
	// User credentials for receiving v3 traps
	V3Users []V3User `json:"v3Users,omitempty"`
}

func (s SNMPv3Authentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SNMPv3Authentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SNMPv3Authentication) GetV3AuthEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.V3AuthEnabled
}

func (s *SNMPv3Authentication) GetAllowUnmatchedTrap() *bool {
	if s == nil {
		return nil
	}
	return s.AllowUnmatchedTrap
}

func (s *SNMPv3Authentication) GetV3Users() []V3User {
	if s == nil {
		return nil
	}
	return s.V3Users
}

type InputSnmpSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputSnmpType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// UDP port to receive SNMP traps on. Defaults to 162.
	Port *float64 `default:"162" json:"port"`
	// Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
	SnmpV3Auth *SNMPv3Authentication `json:"snmpV3Auth,omitempty"`
	// Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	// If enabled, parses varbinds as an array of objects that include OID, value, and type
	VarbindsWithTypes *bool `default:"false" json:"varbindsWithTypes"`
	// If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
	BestEffortParsing *bool   `default:"false" json:"bestEffortParsing"`
	Description       *string `json:"description,omitempty"`
}

func (i InputSnmpSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetType() InputSnmpType {
	if i == nil {
		return InputSnmpType("")
	}
	return i.Type
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetPort() *float64 {
	if i == nil {
		return nil
	}
	return i.Port
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetSnmpV3Auth() *SNMPv3Authentication {
	if i == nil {
		return nil
	}
	return i.SnmpV3Auth
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetVarbindsWithTypes() *bool {
	if i == nil {
		return nil
	}
	return i.VarbindsWithTypes
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetBestEffortParsing() *bool {
	if i == nil {
		return nil
	}
	return i.BestEffortParsing
}

func (i *InputSnmpSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSnmpUnionType string

const (
	InputSnmpUnionTypeInputSnmpSendToRoutesTrueWithConnectionsConstraint  InputSnmpUnionType = "InputSnmp_SendToRoutesTrueWithConnectionsConstraint"
	InputSnmpUnionTypeInputSnmpSendToRoutesFalseWithConnectionsConstraint InputSnmpUnionType = "InputSnmp_SendToRoutesFalseWithConnectionsConstraint"
	InputSnmpUnionTypeInputSnmpPqEnabledFalseWithPqConstraint             InputSnmpUnionType = "InputSnmp_PqEnabledFalseWithPqConstraint"
	InputSnmpUnionTypeInputSnmpPqEnabledTrueWithPqConstraint              InputSnmpUnionType = "InputSnmp_PqEnabledTrueWithPqConstraint"
)

type InputSnmp struct {
	InputSnmpSendToRoutesTrueWithConnectionsConstraint  *InputSnmpSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputSnmpSendToRoutesFalseWithConnectionsConstraint *InputSnmpSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputSnmpPqEnabledFalseWithPqConstraint             *InputSnmpPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputSnmpPqEnabledTrueWithPqConstraint              *InputSnmpPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputSnmpUnionType
}

func CreateInputSnmpInputSnmpSendToRoutesTrueWithConnectionsConstraint(inputSnmpSendToRoutesTrueWithConnectionsConstraint InputSnmpSendToRoutesTrueWithConnectionsConstraint) InputSnmp {
	typ := InputSnmpUnionTypeInputSnmpSendToRoutesTrueWithConnectionsConstraint

	return InputSnmp{
		InputSnmpSendToRoutesTrueWithConnectionsConstraint: &inputSnmpSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSnmpInputSnmpSendToRoutesFalseWithConnectionsConstraint(inputSnmpSendToRoutesFalseWithConnectionsConstraint InputSnmpSendToRoutesFalseWithConnectionsConstraint) InputSnmp {
	typ := InputSnmpUnionTypeInputSnmpSendToRoutesFalseWithConnectionsConstraint

	return InputSnmp{
		InputSnmpSendToRoutesFalseWithConnectionsConstraint: &inputSnmpSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSnmpInputSnmpPqEnabledFalseWithPqConstraint(inputSnmpPqEnabledFalseWithPqConstraint InputSnmpPqEnabledFalseWithPqConstraint) InputSnmp {
	typ := InputSnmpUnionTypeInputSnmpPqEnabledFalseWithPqConstraint

	return InputSnmp{
		InputSnmpPqEnabledFalseWithPqConstraint: &inputSnmpPqEnabledFalseWithPqConstraint,
		Type:                                    typ,
	}
}

func CreateInputSnmpInputSnmpPqEnabledTrueWithPqConstraint(inputSnmpPqEnabledTrueWithPqConstraint InputSnmpPqEnabledTrueWithPqConstraint) InputSnmp {
	typ := InputSnmpUnionTypeInputSnmpPqEnabledTrueWithPqConstraint

	return InputSnmp{
		InputSnmpPqEnabledTrueWithPqConstraint: &inputSnmpPqEnabledTrueWithPqConstraint,
		Type:                                   typ,
	}
}

func (u *InputSnmp) UnmarshalJSON(data []byte) error {

	var inputSnmpSendToRoutesTrueWithConnectionsConstraint InputSnmpSendToRoutesTrueWithConnectionsConstraint = InputSnmpSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSnmpSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSnmpSendToRoutesTrueWithConnectionsConstraint = &inputSnmpSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputSnmpUnionTypeInputSnmpSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputSnmpSendToRoutesFalseWithConnectionsConstraint InputSnmpSendToRoutesFalseWithConnectionsConstraint = InputSnmpSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSnmpSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSnmpSendToRoutesFalseWithConnectionsConstraint = &inputSnmpSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputSnmpUnionTypeInputSnmpSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputSnmpPqEnabledFalseWithPqConstraint InputSnmpPqEnabledFalseWithPqConstraint = InputSnmpPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSnmpPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputSnmpPqEnabledFalseWithPqConstraint = &inputSnmpPqEnabledFalseWithPqConstraint
		u.Type = InputSnmpUnionTypeInputSnmpPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputSnmpPqEnabledTrueWithPqConstraint InputSnmpPqEnabledTrueWithPqConstraint = InputSnmpPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSnmpPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputSnmpPqEnabledTrueWithPqConstraint = &inputSnmpPqEnabledTrueWithPqConstraint
		u.Type = InputSnmpUnionTypeInputSnmpPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSnmp", string(data))
}

func (u InputSnmp) MarshalJSON() ([]byte, error) {
	if u.InputSnmpSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSnmpSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputSnmpSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSnmpSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputSnmpPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSnmpPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputSnmpPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSnmpPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputSnmp: all fields are null")
}

type InputS3InventoryPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputS3InventoryType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
	ChecksumSuffix *string `default:"checksum" json:"checksumSuffix"`
	// Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
	MaxManifestSizeKB *int64 `default:"4096" json:"maxManifestSizeKB"`
	// If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
	ValidateInventoryFiles *bool   `default:"false" json:"validateInventoryFiles"`
	Description            *string `json:"description,omitempty"`
	AwsAPIKey              *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputS3InventoryPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetType() InputS3InventoryType {
	if i == nil {
		return InputS3InventoryType("")
	}
	return i.Type
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetChecksumSuffix() *string {
	if i == nil {
		return nil
	}
	return i.ChecksumSuffix
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetMaxManifestSizeKB() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxManifestSizeKB
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetValidateInventoryFiles() *bool {
	if i == nil {
		return nil
	}
	return i.ValidateInventoryFiles
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputS3InventoryPqEnabledTrueWithPqConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputS3InventoryPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputS3InventoryType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
	ChecksumSuffix *string `default:"checksum" json:"checksumSuffix"`
	// Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
	MaxManifestSizeKB *int64 `default:"4096" json:"maxManifestSizeKB"`
	// If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
	ValidateInventoryFiles *bool   `default:"false" json:"validateInventoryFiles"`
	Description            *string `json:"description,omitempty"`
	AwsAPIKey              *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputS3InventoryPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetType() InputS3InventoryType {
	if i == nil {
		return InputS3InventoryType("")
	}
	return i.Type
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetChecksumSuffix() *string {
	if i == nil {
		return nil
	}
	return i.ChecksumSuffix
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetMaxManifestSizeKB() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxManifestSizeKB
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetValidateInventoryFiles() *bool {
	if i == nil {
		return nil
	}
	return i.ValidateInventoryFiles
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputS3InventoryPqEnabledFalseWithPqConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputS3InventorySendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputS3InventoryType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
	ChecksumSuffix *string `default:"checksum" json:"checksumSuffix"`
	// Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
	MaxManifestSizeKB *int64 `default:"4096" json:"maxManifestSizeKB"`
	// If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
	ValidateInventoryFiles *bool   `default:"false" json:"validateInventoryFiles"`
	Description            *string `json:"description,omitempty"`
	AwsAPIKey              *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputS3InventorySendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetType() InputS3InventoryType {
	if i == nil {
		return InputS3InventoryType("")
	}
	return i.Type
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetChecksumSuffix() *string {
	if i == nil {
		return nil
	}
	return i.ChecksumSuffix
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetMaxManifestSizeKB() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxManifestSizeKB
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetValidateInventoryFiles() *bool {
	if i == nil {
		return nil
	}
	return i.ValidateInventoryFiles
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputS3InventorySendToRoutesFalseWithConnectionsConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputS3InventoryType string

const (
	InputS3InventoryTypeS3Inventory InputS3InventoryType = "s3_inventory"
)

func (e InputS3InventoryType) ToPointer() *InputS3InventoryType {
	return &e
}
func (e *InputS3InventoryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3_inventory":
		*e = InputS3InventoryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputS3InventoryType: %v", v)
	}
}

type InputS3InventorySendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputS3InventoryType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
	ChecksumSuffix *string `default:"checksum" json:"checksumSuffix"`
	// Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
	MaxManifestSizeKB *int64 `default:"4096" json:"maxManifestSizeKB"`
	// If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
	ValidateInventoryFiles *bool   `default:"false" json:"validateInventoryFiles"`
	Description            *string `json:"description,omitempty"`
	AwsAPIKey              *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputS3InventorySendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetType() InputS3InventoryType {
	if i == nil {
		return InputS3InventoryType("")
	}
	return i.Type
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetChecksumSuffix() *string {
	if i == nil {
		return nil
	}
	return i.ChecksumSuffix
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetMaxManifestSizeKB() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxManifestSizeKB
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetValidateInventoryFiles() *bool {
	if i == nil {
		return nil
	}
	return i.ValidateInventoryFiles
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputS3InventorySendToRoutesTrueWithConnectionsConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputS3InventoryUnionType string

const (
	InputS3InventoryUnionTypeInputS3InventorySendToRoutesTrueWithConnectionsConstraint  InputS3InventoryUnionType = "InputS3Inventory_SendToRoutesTrueWithConnectionsConstraint"
	InputS3InventoryUnionTypeInputS3InventorySendToRoutesFalseWithConnectionsConstraint InputS3InventoryUnionType = "InputS3Inventory_SendToRoutesFalseWithConnectionsConstraint"
	InputS3InventoryUnionTypeInputS3InventoryPqEnabledFalseWithPqConstraint             InputS3InventoryUnionType = "InputS3Inventory_PqEnabledFalseWithPqConstraint"
	InputS3InventoryUnionTypeInputS3InventoryPqEnabledTrueWithPqConstraint              InputS3InventoryUnionType = "InputS3Inventory_PqEnabledTrueWithPqConstraint"
)

type InputS3Inventory struct {
	InputS3InventorySendToRoutesTrueWithConnectionsConstraint  *InputS3InventorySendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputS3InventorySendToRoutesFalseWithConnectionsConstraint *InputS3InventorySendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputS3InventoryPqEnabledFalseWithPqConstraint             *InputS3InventoryPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputS3InventoryPqEnabledTrueWithPqConstraint              *InputS3InventoryPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputS3InventoryUnionType
}

func CreateInputS3InventoryInputS3InventorySendToRoutesTrueWithConnectionsConstraint(inputS3InventorySendToRoutesTrueWithConnectionsConstraint InputS3InventorySendToRoutesTrueWithConnectionsConstraint) InputS3Inventory {
	typ := InputS3InventoryUnionTypeInputS3InventorySendToRoutesTrueWithConnectionsConstraint

	return InputS3Inventory{
		InputS3InventorySendToRoutesTrueWithConnectionsConstraint: &inputS3InventorySendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputS3InventoryInputS3InventorySendToRoutesFalseWithConnectionsConstraint(inputS3InventorySendToRoutesFalseWithConnectionsConstraint InputS3InventorySendToRoutesFalseWithConnectionsConstraint) InputS3Inventory {
	typ := InputS3InventoryUnionTypeInputS3InventorySendToRoutesFalseWithConnectionsConstraint

	return InputS3Inventory{
		InputS3InventorySendToRoutesFalseWithConnectionsConstraint: &inputS3InventorySendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputS3InventoryInputS3InventoryPqEnabledFalseWithPqConstraint(inputS3InventoryPqEnabledFalseWithPqConstraint InputS3InventoryPqEnabledFalseWithPqConstraint) InputS3Inventory {
	typ := InputS3InventoryUnionTypeInputS3InventoryPqEnabledFalseWithPqConstraint

	return InputS3Inventory{
		InputS3InventoryPqEnabledFalseWithPqConstraint: &inputS3InventoryPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputS3InventoryInputS3InventoryPqEnabledTrueWithPqConstraint(inputS3InventoryPqEnabledTrueWithPqConstraint InputS3InventoryPqEnabledTrueWithPqConstraint) InputS3Inventory {
	typ := InputS3InventoryUnionTypeInputS3InventoryPqEnabledTrueWithPqConstraint

	return InputS3Inventory{
		InputS3InventoryPqEnabledTrueWithPqConstraint: &inputS3InventoryPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputS3Inventory) UnmarshalJSON(data []byte) error {

	var inputS3InventorySendToRoutesTrueWithConnectionsConstraint InputS3InventorySendToRoutesTrueWithConnectionsConstraint = InputS3InventorySendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputS3InventorySendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputS3InventorySendToRoutesTrueWithConnectionsConstraint = &inputS3InventorySendToRoutesTrueWithConnectionsConstraint
		u.Type = InputS3InventoryUnionTypeInputS3InventorySendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputS3InventorySendToRoutesFalseWithConnectionsConstraint InputS3InventorySendToRoutesFalseWithConnectionsConstraint = InputS3InventorySendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputS3InventorySendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputS3InventorySendToRoutesFalseWithConnectionsConstraint = &inputS3InventorySendToRoutesFalseWithConnectionsConstraint
		u.Type = InputS3InventoryUnionTypeInputS3InventorySendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputS3InventoryPqEnabledFalseWithPqConstraint InputS3InventoryPqEnabledFalseWithPqConstraint = InputS3InventoryPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputS3InventoryPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputS3InventoryPqEnabledFalseWithPqConstraint = &inputS3InventoryPqEnabledFalseWithPqConstraint
		u.Type = InputS3InventoryUnionTypeInputS3InventoryPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputS3InventoryPqEnabledTrueWithPqConstraint InputS3InventoryPqEnabledTrueWithPqConstraint = InputS3InventoryPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputS3InventoryPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputS3InventoryPqEnabledTrueWithPqConstraint = &inputS3InventoryPqEnabledTrueWithPqConstraint
		u.Type = InputS3InventoryUnionTypeInputS3InventoryPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputS3Inventory", string(data))
}

func (u InputS3Inventory) MarshalJSON() ([]byte, error) {
	if u.InputS3InventorySendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputS3InventorySendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputS3InventorySendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputS3InventorySendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputS3InventoryPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputS3InventoryPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputS3InventoryPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputS3InventoryPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputS3Inventory: all fields are null")
}

type InputS3PqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string      `json:"id"`
	Type     InputS3Type `json:"type"`
	Disabled *bool       `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
	TagAfterProcessing *bool   `default:"false" json:"tagAfterProcessing"`
	Description        *string `json:"description,omitempty"`
	AwsAPIKey          *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputS3PqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputS3PqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetType() InputS3Type {
	if i == nil {
		return InputS3Type("")
	}
	return i.Type
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetTagAfterProcessing() *bool {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputS3PqEnabledTrueWithPqConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputS3PqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string      `json:"id"`
	Type     InputS3Type `json:"type"`
	Disabled *bool       `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
	TagAfterProcessing *bool   `default:"false" json:"tagAfterProcessing"`
	Description        *string `json:"description,omitempty"`
	AwsAPIKey          *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputS3PqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputS3PqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetType() InputS3Type {
	if i == nil {
		return InputS3Type("")
	}
	return i.Type
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetTagAfterProcessing() *bool {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputS3PqEnabledFalseWithPqConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputS3SendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string      `json:"id"`
	Type     InputS3Type `json:"type"`
	Disabled *bool       `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
	TagAfterProcessing *bool   `default:"false" json:"tagAfterProcessing"`
	Description        *string `json:"description,omitempty"`
	AwsAPIKey          *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputS3SendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetType() InputS3Type {
	if i == nil {
		return InputS3Type("")
	}
	return i.Type
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetTagAfterProcessing() *bool {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputS3SendToRoutesFalseWithConnectionsConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputS3Type string

const (
	InputS3TypeS3 InputS3Type = "s3"
)

func (e InputS3Type) ToPointer() *InputS3Type {
	return &e
}
func (e *InputS3Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3":
		*e = InputS3Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputS3Type: %v", v)
	}
}

type InputS3SendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string      `json:"id"`
	Type     InputS3Type `json:"type"`
	Disabled *bool       `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                      `default:"600" json:"parquetChunkDownloadTimeout"`
	Checkpointing               *components.CheckpointingType `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
	TagAfterProcessing *bool   `default:"false" json:"tagAfterProcessing"`
	Description        *string `json:"description,omitempty"`
	AwsAPIKey          *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputS3SendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetType() InputS3Type {
	if i == nil {
		return InputS3Type("")
	}
	return i.Type
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetTagAfterProcessing() *bool {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputS3SendToRoutesTrueWithConnectionsConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputS3UnionType string

const (
	InputS3UnionTypeInputS3SendToRoutesTrueWithConnectionsConstraint  InputS3UnionType = "InputS3_SendToRoutesTrueWithConnectionsConstraint"
	InputS3UnionTypeInputS3SendToRoutesFalseWithConnectionsConstraint InputS3UnionType = "InputS3_SendToRoutesFalseWithConnectionsConstraint"
	InputS3UnionTypeInputS3PqEnabledFalseWithPqConstraint             InputS3UnionType = "InputS3_PqEnabledFalseWithPqConstraint"
	InputS3UnionTypeInputS3PqEnabledTrueWithPqConstraint              InputS3UnionType = "InputS3_PqEnabledTrueWithPqConstraint"
)

type InputS3 struct {
	InputS3SendToRoutesTrueWithConnectionsConstraint  *InputS3SendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputS3SendToRoutesFalseWithConnectionsConstraint *InputS3SendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputS3PqEnabledFalseWithPqConstraint             *InputS3PqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputS3PqEnabledTrueWithPqConstraint              *InputS3PqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputS3UnionType
}

func CreateInputS3InputS3SendToRoutesTrueWithConnectionsConstraint(inputS3SendToRoutesTrueWithConnectionsConstraint InputS3SendToRoutesTrueWithConnectionsConstraint) InputS3 {
	typ := InputS3UnionTypeInputS3SendToRoutesTrueWithConnectionsConstraint

	return InputS3{
		InputS3SendToRoutesTrueWithConnectionsConstraint: &inputS3SendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputS3InputS3SendToRoutesFalseWithConnectionsConstraint(inputS3SendToRoutesFalseWithConnectionsConstraint InputS3SendToRoutesFalseWithConnectionsConstraint) InputS3 {
	typ := InputS3UnionTypeInputS3SendToRoutesFalseWithConnectionsConstraint

	return InputS3{
		InputS3SendToRoutesFalseWithConnectionsConstraint: &inputS3SendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputS3InputS3PqEnabledFalseWithPqConstraint(inputS3PqEnabledFalseWithPqConstraint InputS3PqEnabledFalseWithPqConstraint) InputS3 {
	typ := InputS3UnionTypeInputS3PqEnabledFalseWithPqConstraint

	return InputS3{
		InputS3PqEnabledFalseWithPqConstraint: &inputS3PqEnabledFalseWithPqConstraint,
		Type:                                  typ,
	}
}

func CreateInputS3InputS3PqEnabledTrueWithPqConstraint(inputS3PqEnabledTrueWithPqConstraint InputS3PqEnabledTrueWithPqConstraint) InputS3 {
	typ := InputS3UnionTypeInputS3PqEnabledTrueWithPqConstraint

	return InputS3{
		InputS3PqEnabledTrueWithPqConstraint: &inputS3PqEnabledTrueWithPqConstraint,
		Type:                                 typ,
	}
}

func (u *InputS3) UnmarshalJSON(data []byte) error {

	var inputS3SendToRoutesTrueWithConnectionsConstraint InputS3SendToRoutesTrueWithConnectionsConstraint = InputS3SendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputS3SendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputS3SendToRoutesTrueWithConnectionsConstraint = &inputS3SendToRoutesTrueWithConnectionsConstraint
		u.Type = InputS3UnionTypeInputS3SendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputS3SendToRoutesFalseWithConnectionsConstraint InputS3SendToRoutesFalseWithConnectionsConstraint = InputS3SendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputS3SendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputS3SendToRoutesFalseWithConnectionsConstraint = &inputS3SendToRoutesFalseWithConnectionsConstraint
		u.Type = InputS3UnionTypeInputS3SendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputS3PqEnabledFalseWithPqConstraint InputS3PqEnabledFalseWithPqConstraint = InputS3PqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputS3PqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputS3PqEnabledFalseWithPqConstraint = &inputS3PqEnabledFalseWithPqConstraint
		u.Type = InputS3UnionTypeInputS3PqEnabledFalseWithPqConstraint
		return nil
	}

	var inputS3PqEnabledTrueWithPqConstraint InputS3PqEnabledTrueWithPqConstraint = InputS3PqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputS3PqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputS3PqEnabledTrueWithPqConstraint = &inputS3PqEnabledTrueWithPqConstraint
		u.Type = InputS3UnionTypeInputS3PqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputS3", string(data))
}

func (u InputS3) MarshalJSON() ([]byte, error) {
	if u.InputS3SendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputS3SendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputS3SendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputS3SendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputS3PqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputS3PqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputS3PqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputS3PqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputS3: all fields are null")
}

type InputMetricsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputMetricsType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool                                 `default:"false" json:"enableProxyHeader"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	Description        *string  `json:"description,omitempty"`
}

func (i InputMetricsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetType() InputMetricsType {
	if i == nil {
		return InputMetricsType("")
	}
	return i.Type
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetUDPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPPort
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetTCPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.TCPPort
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputMetricsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputMetricsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputMetricsType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool                                 `default:"false" json:"enableProxyHeader"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	Description        *string  `json:"description,omitempty"`
}

func (i InputMetricsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetType() InputMetricsType {
	if i == nil {
		return InputMetricsType("")
	}
	return i.Type
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetUDPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPPort
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetTCPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.TCPPort
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputMetricsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputMetricsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputMetricsType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool                                 `default:"false" json:"enableProxyHeader"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	Description        *string  `json:"description,omitempty"`
}

func (i InputMetricsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetType() InputMetricsType {
	if i == nil {
		return InputMetricsType("")
	}
	return i.Type
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetUDPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPPort
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetTCPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.TCPPort
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputMetricsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputMetricsType string

const (
	InputMetricsTypeMetrics InputMetricsType = "metrics"
)

func (e InputMetricsType) ToPointer() *InputMetricsType {
	return &e
}
func (e *InputMetricsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "metrics":
		*e = InputMetricsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMetricsType: %v", v)
	}
}

type InputMetricsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputMetricsType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host *string `default:"0.0.0.0" json:"host"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *float64 `json:"udpPort,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *float64 `json:"tcpPort,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float64 `default:"1000" json:"maxBufferSize"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool                                 `default:"false" json:"enableProxyHeader"`
	TLS               *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UDPSocketRxBufSize *float64 `json:"udpSocketRxBufSize,omitempty"`
	Description        *string  `json:"description,omitempty"`
}

func (i InputMetricsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetType() InputMetricsType {
	if i == nil {
		return InputMetricsType("")
	}
	return i.Type
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetUDPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPPort
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetTCPPort() *float64 {
	if i == nil {
		return nil
	}
	return i.TCPPort
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetMaxBufferSize() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBufferSize
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetUDPSocketRxBufSize() *float64 {
	if i == nil {
		return nil
	}
	return i.UDPSocketRxBufSize
}

func (i *InputMetricsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputMetricsUnionType string

const (
	InputMetricsUnionTypeInputMetricsSendToRoutesTrueWithConnectionsConstraint  InputMetricsUnionType = "InputMetrics_SendToRoutesTrueWithConnectionsConstraint"
	InputMetricsUnionTypeInputMetricsSendToRoutesFalseWithConnectionsConstraint InputMetricsUnionType = "InputMetrics_SendToRoutesFalseWithConnectionsConstraint"
	InputMetricsUnionTypeInputMetricsPqEnabledFalseWithPqConstraint             InputMetricsUnionType = "InputMetrics_PqEnabledFalseWithPqConstraint"
	InputMetricsUnionTypeInputMetricsPqEnabledTrueWithPqConstraint              InputMetricsUnionType = "InputMetrics_PqEnabledTrueWithPqConstraint"
)

type InputMetrics struct {
	InputMetricsSendToRoutesTrueWithConnectionsConstraint  *InputMetricsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputMetricsSendToRoutesFalseWithConnectionsConstraint *InputMetricsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputMetricsPqEnabledFalseWithPqConstraint             *InputMetricsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputMetricsPqEnabledTrueWithPqConstraint              *InputMetricsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputMetricsUnionType
}

func CreateInputMetricsInputMetricsSendToRoutesTrueWithConnectionsConstraint(inputMetricsSendToRoutesTrueWithConnectionsConstraint InputMetricsSendToRoutesTrueWithConnectionsConstraint) InputMetrics {
	typ := InputMetricsUnionTypeInputMetricsSendToRoutesTrueWithConnectionsConstraint

	return InputMetrics{
		InputMetricsSendToRoutesTrueWithConnectionsConstraint: &inputMetricsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputMetricsInputMetricsSendToRoutesFalseWithConnectionsConstraint(inputMetricsSendToRoutesFalseWithConnectionsConstraint InputMetricsSendToRoutesFalseWithConnectionsConstraint) InputMetrics {
	typ := InputMetricsUnionTypeInputMetricsSendToRoutesFalseWithConnectionsConstraint

	return InputMetrics{
		InputMetricsSendToRoutesFalseWithConnectionsConstraint: &inputMetricsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputMetricsInputMetricsPqEnabledFalseWithPqConstraint(inputMetricsPqEnabledFalseWithPqConstraint InputMetricsPqEnabledFalseWithPqConstraint) InputMetrics {
	typ := InputMetricsUnionTypeInputMetricsPqEnabledFalseWithPqConstraint

	return InputMetrics{
		InputMetricsPqEnabledFalseWithPqConstraint: &inputMetricsPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputMetricsInputMetricsPqEnabledTrueWithPqConstraint(inputMetricsPqEnabledTrueWithPqConstraint InputMetricsPqEnabledTrueWithPqConstraint) InputMetrics {
	typ := InputMetricsUnionTypeInputMetricsPqEnabledTrueWithPqConstraint

	return InputMetrics{
		InputMetricsPqEnabledTrueWithPqConstraint: &inputMetricsPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputMetrics) UnmarshalJSON(data []byte) error {

	var inputMetricsSendToRoutesTrueWithConnectionsConstraint InputMetricsSendToRoutesTrueWithConnectionsConstraint = InputMetricsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputMetricsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputMetricsSendToRoutesTrueWithConnectionsConstraint = &inputMetricsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputMetricsUnionTypeInputMetricsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputMetricsSendToRoutesFalseWithConnectionsConstraint InputMetricsSendToRoutesFalseWithConnectionsConstraint = InputMetricsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputMetricsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputMetricsSendToRoutesFalseWithConnectionsConstraint = &inputMetricsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputMetricsUnionTypeInputMetricsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputMetricsPqEnabledFalseWithPqConstraint InputMetricsPqEnabledFalseWithPqConstraint = InputMetricsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputMetricsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputMetricsPqEnabledFalseWithPqConstraint = &inputMetricsPqEnabledFalseWithPqConstraint
		u.Type = InputMetricsUnionTypeInputMetricsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputMetricsPqEnabledTrueWithPqConstraint InputMetricsPqEnabledTrueWithPqConstraint = InputMetricsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputMetricsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputMetricsPqEnabledTrueWithPqConstraint = &inputMetricsPqEnabledTrueWithPqConstraint
		u.Type = InputMetricsUnionTypeInputMetricsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputMetrics", string(data))
}

func (u InputMetrics) MarshalJSON() ([]byte, error) {
	if u.InputMetricsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputMetricsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputMetricsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputMetricsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputMetricsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputMetricsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputMetricsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputMetricsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputMetrics: all fields are null")
}

type InputCriblmetricsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputCriblmetricsType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// A prefix that is applied to the metrics provided by Cribl Stream
	Prefix *string `default:"cribl.logstream." json:"prefix"`
	// Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
	FullFidelity *bool `default:"true" json:"fullFidelity"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblmetricsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetType() InputCriblmetricsType {
	if i == nil {
		return InputCriblmetricsType("")
	}
	return i.Type
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetPrefix() *string {
	if i == nil {
		return nil
	}
	return i.Prefix
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetFullFidelity() *bool {
	if i == nil {
		return nil
	}
	return i.FullFidelity
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblmetricsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblmetricsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputCriblmetricsType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// A prefix that is applied to the metrics provided by Cribl Stream
	Prefix *string `default:"cribl.logstream." json:"prefix"`
	// Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
	FullFidelity *bool `default:"true" json:"fullFidelity"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblmetricsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetType() InputCriblmetricsType {
	if i == nil {
		return InputCriblmetricsType("")
	}
	return i.Type
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetPrefix() *string {
	if i == nil {
		return nil
	}
	return i.Prefix
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetFullFidelity() *bool {
	if i == nil {
		return nil
	}
	return i.FullFidelity
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblmetricsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputCriblmetricsType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// A prefix that is applied to the metrics provided by Cribl Stream
	Prefix *string `default:"cribl.logstream." json:"prefix"`
	// Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
	FullFidelity *bool `default:"true" json:"fullFidelity"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetType() InputCriblmetricsType {
	if i == nil {
		return InputCriblmetricsType("")
	}
	return i.Type
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetPrefix() *string {
	if i == nil {
		return nil
	}
	return i.Prefix
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetFullFidelity() *bool {
	if i == nil {
		return nil
	}
	return i.FullFidelity
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblmetricsType string

const (
	InputCriblmetricsTypeCriblmetrics InputCriblmetricsType = "criblmetrics"
)

func (e InputCriblmetricsType) ToPointer() *InputCriblmetricsType {
	return &e
}
func (e *InputCriblmetricsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "criblmetrics":
		*e = InputCriblmetricsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCriblmetricsType: %v", v)
	}
}

type InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputCriblmetricsType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// A prefix that is applied to the metrics provided by Cribl Stream
	Prefix *string `default:"cribl.logstream." json:"prefix"`
	// Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
	FullFidelity *bool `default:"true" json:"fullFidelity"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetType() InputCriblmetricsType {
	if i == nil {
		return InputCriblmetricsType("")
	}
	return i.Type
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetPrefix() *string {
	if i == nil {
		return nil
	}
	return i.Prefix
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetFullFidelity() *bool {
	if i == nil {
		return nil
	}
	return i.FullFidelity
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblmetricsUnionType string

const (
	InputCriblmetricsUnionTypeInputCriblmetricsSendToRoutesTrueWithConnectionsConstraint  InputCriblmetricsUnionType = "InputCriblmetrics_SendToRoutesTrueWithConnectionsConstraint"
	InputCriblmetricsUnionTypeInputCriblmetricsSendToRoutesFalseWithConnectionsConstraint InputCriblmetricsUnionType = "InputCriblmetrics_SendToRoutesFalseWithConnectionsConstraint"
	InputCriblmetricsUnionTypeInputCriblmetricsPqEnabledFalseWithPqConstraint             InputCriblmetricsUnionType = "InputCriblmetrics_PqEnabledFalseWithPqConstraint"
	InputCriblmetricsUnionTypeInputCriblmetricsPqEnabledTrueWithPqConstraint              InputCriblmetricsUnionType = "InputCriblmetrics_PqEnabledTrueWithPqConstraint"
)

type InputCriblmetrics struct {
	InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint  *InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint *InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputCriblmetricsPqEnabledFalseWithPqConstraint             *InputCriblmetricsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputCriblmetricsPqEnabledTrueWithPqConstraint              *InputCriblmetricsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputCriblmetricsUnionType
}

func CreateInputCriblmetricsInputCriblmetricsSendToRoutesTrueWithConnectionsConstraint(inputCriblmetricsSendToRoutesTrueWithConnectionsConstraint InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint) InputCriblmetrics {
	typ := InputCriblmetricsUnionTypeInputCriblmetricsSendToRoutesTrueWithConnectionsConstraint

	return InputCriblmetrics{
		InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint: &inputCriblmetricsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblmetricsInputCriblmetricsSendToRoutesFalseWithConnectionsConstraint(inputCriblmetricsSendToRoutesFalseWithConnectionsConstraint InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint) InputCriblmetrics {
	typ := InputCriblmetricsUnionTypeInputCriblmetricsSendToRoutesFalseWithConnectionsConstraint

	return InputCriblmetrics{
		InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint: &inputCriblmetricsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblmetricsInputCriblmetricsPqEnabledFalseWithPqConstraint(inputCriblmetricsPqEnabledFalseWithPqConstraint InputCriblmetricsPqEnabledFalseWithPqConstraint) InputCriblmetrics {
	typ := InputCriblmetricsUnionTypeInputCriblmetricsPqEnabledFalseWithPqConstraint

	return InputCriblmetrics{
		InputCriblmetricsPqEnabledFalseWithPqConstraint: &inputCriblmetricsPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputCriblmetricsInputCriblmetricsPqEnabledTrueWithPqConstraint(inputCriblmetricsPqEnabledTrueWithPqConstraint InputCriblmetricsPqEnabledTrueWithPqConstraint) InputCriblmetrics {
	typ := InputCriblmetricsUnionTypeInputCriblmetricsPqEnabledTrueWithPqConstraint

	return InputCriblmetrics{
		InputCriblmetricsPqEnabledTrueWithPqConstraint: &inputCriblmetricsPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputCriblmetrics) UnmarshalJSON(data []byte) error {

	var inputCriblmetricsSendToRoutesTrueWithConnectionsConstraint InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint = InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblmetricsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint = &inputCriblmetricsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputCriblmetricsUnionTypeInputCriblmetricsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputCriblmetricsSendToRoutesFalseWithConnectionsConstraint InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint = InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblmetricsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint = &inputCriblmetricsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputCriblmetricsUnionTypeInputCriblmetricsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputCriblmetricsPqEnabledFalseWithPqConstraint InputCriblmetricsPqEnabledFalseWithPqConstraint = InputCriblmetricsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblmetricsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblmetricsPqEnabledFalseWithPqConstraint = &inputCriblmetricsPqEnabledFalseWithPqConstraint
		u.Type = InputCriblmetricsUnionTypeInputCriblmetricsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputCriblmetricsPqEnabledTrueWithPqConstraint InputCriblmetricsPqEnabledTrueWithPqConstraint = InputCriblmetricsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblmetricsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblmetricsPqEnabledTrueWithPqConstraint = &inputCriblmetricsPqEnabledTrueWithPqConstraint
		u.Type = InputCriblmetricsUnionTypeInputCriblmetricsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputCriblmetrics", string(data))
}

func (u InputCriblmetrics) MarshalJSON() ([]byte, error) {
	if u.InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblmetricsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputCriblmetricsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblmetricsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputCriblmetricsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblmetricsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputCriblmetrics: all fields are null")
}

type InputKinesisPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputKinesisType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *components.SignatureVersionOptions2 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	AwsAPIKey   *string                                    `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesisPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetType() InputKinesisType {
	if i == nil {
		return InputKinesisType("")
	}
	return i.Type
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetStreamName() string {
	if i == nil {
		return ""
	}
	return i.StreamName
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetServiceInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.ServiceInterval
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetShardExpr() *string {
	if i == nil {
		return nil
	}
	return i.ShardExpr
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetShardIteratorType() *ShardIteratorStart {
	if i == nil {
		return nil
	}
	return i.ShardIteratorType
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetPayloadFormat() *RecordDataFormat {
	if i == nil {
		return nil
	}
	return i.PayloadFormat
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetGetRecordsLimit() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimit
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetGetRecordsLimitTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimitTotal
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if i == nil {
		return nil
	}
	return i.LoadBalancingAlgorithm
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions2 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetVerifyKPLCheckSums() *bool {
	if i == nil {
		return nil
	}
	return i.VerifyKPLCheckSums
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAvoidDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.AvoidDuplicates
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputKinesisPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputKinesisType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *components.SignatureVersionOptions2 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	AwsAPIKey   *string                                    `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesisPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetType() InputKinesisType {
	if i == nil {
		return InputKinesisType("")
	}
	return i.Type
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetStreamName() string {
	if i == nil {
		return ""
	}
	return i.StreamName
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetServiceInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.ServiceInterval
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetShardExpr() *string {
	if i == nil {
		return nil
	}
	return i.ShardExpr
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetShardIteratorType() *ShardIteratorStart {
	if i == nil {
		return nil
	}
	return i.ShardIteratorType
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetPayloadFormat() *RecordDataFormat {
	if i == nil {
		return nil
	}
	return i.PayloadFormat
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetGetRecordsLimit() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimit
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetGetRecordsLimitTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimitTotal
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if i == nil {
		return nil
	}
	return i.LoadBalancingAlgorithm
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions2 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetVerifyKPLCheckSums() *bool {
	if i == nil {
		return nil
	}
	return i.VerifyKPLCheckSums
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAvoidDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.AvoidDuplicates
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputKinesisSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputKinesisType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *components.SignatureVersionOptions2 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	AwsAPIKey   *string                                    `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesisSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetType() InputKinesisType {
	if i == nil {
		return InputKinesisType("")
	}
	return i.Type
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetStreamName() string {
	if i == nil {
		return ""
	}
	return i.StreamName
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetServiceInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.ServiceInterval
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetShardExpr() *string {
	if i == nil {
		return nil
	}
	return i.ShardExpr
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetShardIteratorType() *ShardIteratorStart {
	if i == nil {
		return nil
	}
	return i.ShardIteratorType
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetPayloadFormat() *RecordDataFormat {
	if i == nil {
		return nil
	}
	return i.PayloadFormat
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetGetRecordsLimit() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimit
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetGetRecordsLimitTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimitTotal
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if i == nil {
		return nil
	}
	return i.LoadBalancingAlgorithm
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions2 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetVerifyKPLCheckSums() *bool {
	if i == nil {
		return nil
	}
	return i.VerifyKPLCheckSums
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAvoidDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.AvoidDuplicates
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputKinesisType string

const (
	InputKinesisTypeKinesis InputKinesisType = "kinesis"
)

func (e InputKinesisType) ToPointer() *InputKinesisType {
	return &e
}
func (e *InputKinesisType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kinesis":
		*e = InputKinesisType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKinesisType: %v", v)
	}
}

// ShardIteratorStart - Location at which to start reading a shard for the first time
type ShardIteratorStart string

const (
	// ShardIteratorStartTrimHorizon Earliest record
	ShardIteratorStartTrimHorizon ShardIteratorStart = "TRIM_HORIZON"
	// ShardIteratorStartLatest Latest record
	ShardIteratorStartLatest ShardIteratorStart = "LATEST"
)

func (e ShardIteratorStart) ToPointer() *ShardIteratorStart {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ShardIteratorStart) IsExact() bool {
	if e != nil {
		switch *e {
		case "TRIM_HORIZON", "LATEST":
			return true
		}
	}
	return false
}

// RecordDataFormat - Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
type RecordDataFormat string

const (
	// RecordDataFormatCribl Cribl
	RecordDataFormatCribl RecordDataFormat = "cribl"
	// RecordDataFormatNdjson Newline JSON
	RecordDataFormatNdjson RecordDataFormat = "ndjson"
	// RecordDataFormatCloudwatch Cloudwatch Logs
	RecordDataFormatCloudwatch RecordDataFormat = "cloudwatch"
	// RecordDataFormatLine Event per line
	RecordDataFormatLine RecordDataFormat = "line"
)

func (e RecordDataFormat) ToPointer() *RecordDataFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *RecordDataFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "cribl", "ndjson", "cloudwatch", "line":
			return true
		}
	}
	return false
}

// ShardLoadBalancing - The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
type ShardLoadBalancing string

const (
	// ShardLoadBalancingConsistentHashing Consistent Hashing
	ShardLoadBalancingConsistentHashing ShardLoadBalancing = "ConsistentHashing"
	// ShardLoadBalancingRoundRobin Round Robin
	ShardLoadBalancingRoundRobin ShardLoadBalancing = "RoundRobin"
)

func (e ShardLoadBalancing) ToPointer() *ShardLoadBalancing {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ShardLoadBalancing) IsExact() bool {
	if e != nil {
		switch *e {
		case "ConsistentHashing", "RoundRobin":
			return true
		}
	}
	return false
}

type InputKinesisSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputKinesisType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *components.SignatureVersionOptions2 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	AwsAPIKey   *string                                    `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesisSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetType() InputKinesisType {
	if i == nil {
		return InputKinesisType("")
	}
	return i.Type
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetStreamName() string {
	if i == nil {
		return ""
	}
	return i.StreamName
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetServiceInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.ServiceInterval
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetShardExpr() *string {
	if i == nil {
		return nil
	}
	return i.ShardExpr
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetShardIteratorType() *ShardIteratorStart {
	if i == nil {
		return nil
	}
	return i.ShardIteratorType
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetPayloadFormat() *RecordDataFormat {
	if i == nil {
		return nil
	}
	return i.PayloadFormat
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetGetRecordsLimit() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimit
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetGetRecordsLimitTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimitTotal
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if i == nil {
		return nil
	}
	return i.LoadBalancingAlgorithm
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions2 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetVerifyKPLCheckSums() *bool {
	if i == nil {
		return nil
	}
	return i.VerifyKPLCheckSums
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAvoidDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.AvoidDuplicates
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputKinesisUnionType string

const (
	InputKinesisUnionTypeInputKinesisSendToRoutesTrueWithConnectionsConstraint  InputKinesisUnionType = "InputKinesis_SendToRoutesTrueWithConnectionsConstraint"
	InputKinesisUnionTypeInputKinesisSendToRoutesFalseWithConnectionsConstraint InputKinesisUnionType = "InputKinesis_SendToRoutesFalseWithConnectionsConstraint"
	InputKinesisUnionTypeInputKinesisPqEnabledFalseWithPqConstraint             InputKinesisUnionType = "InputKinesis_PqEnabledFalseWithPqConstraint"
	InputKinesisUnionTypeInputKinesisPqEnabledTrueWithPqConstraint              InputKinesisUnionType = "InputKinesis_PqEnabledTrueWithPqConstraint"
)

type InputKinesis struct {
	InputKinesisSendToRoutesTrueWithConnectionsConstraint  *InputKinesisSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputKinesisSendToRoutesFalseWithConnectionsConstraint *InputKinesisSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputKinesisPqEnabledFalseWithPqConstraint             *InputKinesisPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputKinesisPqEnabledTrueWithPqConstraint              *InputKinesisPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputKinesisUnionType
}

func CreateInputKinesisInputKinesisSendToRoutesTrueWithConnectionsConstraint(inputKinesisSendToRoutesTrueWithConnectionsConstraint InputKinesisSendToRoutesTrueWithConnectionsConstraint) InputKinesis {
	typ := InputKinesisUnionTypeInputKinesisSendToRoutesTrueWithConnectionsConstraint

	return InputKinesis{
		InputKinesisSendToRoutesTrueWithConnectionsConstraint: &inputKinesisSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKinesisInputKinesisSendToRoutesFalseWithConnectionsConstraint(inputKinesisSendToRoutesFalseWithConnectionsConstraint InputKinesisSendToRoutesFalseWithConnectionsConstraint) InputKinesis {
	typ := InputKinesisUnionTypeInputKinesisSendToRoutesFalseWithConnectionsConstraint

	return InputKinesis{
		InputKinesisSendToRoutesFalseWithConnectionsConstraint: &inputKinesisSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKinesisInputKinesisPqEnabledFalseWithPqConstraint(inputKinesisPqEnabledFalseWithPqConstraint InputKinesisPqEnabledFalseWithPqConstraint) InputKinesis {
	typ := InputKinesisUnionTypeInputKinesisPqEnabledFalseWithPqConstraint

	return InputKinesis{
		InputKinesisPqEnabledFalseWithPqConstraint: &inputKinesisPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputKinesisInputKinesisPqEnabledTrueWithPqConstraint(inputKinesisPqEnabledTrueWithPqConstraint InputKinesisPqEnabledTrueWithPqConstraint) InputKinesis {
	typ := InputKinesisUnionTypeInputKinesisPqEnabledTrueWithPqConstraint

	return InputKinesis{
		InputKinesisPqEnabledTrueWithPqConstraint: &inputKinesisPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputKinesis) UnmarshalJSON(data []byte) error {

	var inputKinesisSendToRoutesTrueWithConnectionsConstraint InputKinesisSendToRoutesTrueWithConnectionsConstraint = InputKinesisSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKinesisSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKinesisSendToRoutesTrueWithConnectionsConstraint = &inputKinesisSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputKinesisUnionTypeInputKinesisSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputKinesisSendToRoutesFalseWithConnectionsConstraint InputKinesisSendToRoutesFalseWithConnectionsConstraint = InputKinesisSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKinesisSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKinesisSendToRoutesFalseWithConnectionsConstraint = &inputKinesisSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputKinesisUnionTypeInputKinesisSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputKinesisPqEnabledFalseWithPqConstraint InputKinesisPqEnabledFalseWithPqConstraint = InputKinesisPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKinesisPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputKinesisPqEnabledFalseWithPqConstraint = &inputKinesisPqEnabledFalseWithPqConstraint
		u.Type = InputKinesisUnionTypeInputKinesisPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputKinesisPqEnabledTrueWithPqConstraint InputKinesisPqEnabledTrueWithPqConstraint = InputKinesisPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKinesisPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputKinesisPqEnabledTrueWithPqConstraint = &inputKinesisPqEnabledTrueWithPqConstraint
		u.Type = InputKinesisUnionTypeInputKinesisPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputKinesis", string(data))
}

func (u InputKinesis) MarshalJSON() ([]byte, error) {
	if u.InputKinesisSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKinesisSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputKinesisSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKinesisSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputKinesisPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKinesisPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputKinesisPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKinesisPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputKinesis: all fields are null")
}

type InputHTTPRawPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputHTTPRawType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputHTTPRawPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetType() InputHTTPRawType {
	if i == nil {
		return InputHTTPRawType("")
	}
	return i.Type
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetAllowedPaths() []string {
	if i == nil {
		return nil
	}
	return i.AllowedPaths
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetAllowedMethods() []string {
	if i == nil {
		return nil
	}
	return i.AllowedMethods
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputHTTPRawPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputHTTPRawPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputHTTPRawType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputHTTPRawPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetType() InputHTTPRawType {
	if i == nil {
		return InputHTTPRawType("")
	}
	return i.Type
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetAllowedPaths() []string {
	if i == nil {
		return nil
	}
	return i.AllowedPaths
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetAllowedMethods() []string {
	if i == nil {
		return nil
	}
	return i.AllowedMethods
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputHTTPRawPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputHTTPRawSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputHTTPRawType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetType() InputHTTPRawType {
	if i == nil {
		return InputHTTPRawType("")
	}
	return i.Type
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetAllowedPaths() []string {
	if i == nil {
		return nil
	}
	return i.AllowedPaths
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetAllowedMethods() []string {
	if i == nil {
		return nil
	}
	return i.AllowedMethods
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputHTTPRawType string

const (
	InputHTTPRawTypeHTTPRaw InputHTTPRawType = "http_raw"
)

func (e InputHTTPRawType) ToPointer() *InputHTTPRawType {
	return &e
}
func (e *InputHTTPRawType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http_raw":
		*e = InputHTTPRawType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputHTTPRawType: %v", v)
	}
}

type InputHTTPRawSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputHTTPRawType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all.
	AllowedPaths []string `json:"allowedPaths,omitempty"`
	// List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
	AllowedMethods []string `json:"allowedMethods,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetType() InputHTTPRawType {
	if i == nil {
		return InputHTTPRawType("")
	}
	return i.Type
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetAllowedPaths() []string {
	if i == nil {
		return nil
	}
	return i.AllowedPaths
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetAllowedMethods() []string {
	if i == nil {
		return nil
	}
	return i.AllowedMethods
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputHTTPRawUnionType string

const (
	InputHTTPRawUnionTypeInputHTTPRawSendToRoutesTrueWithConnectionsConstraint  InputHTTPRawUnionType = "InputHttpRaw_SendToRoutesTrueWithConnectionsConstraint"
	InputHTTPRawUnionTypeInputHTTPRawSendToRoutesFalseWithConnectionsConstraint InputHTTPRawUnionType = "InputHttpRaw_SendToRoutesFalseWithConnectionsConstraint"
	InputHTTPRawUnionTypeInputHTTPRawPqEnabledFalseWithPqConstraint             InputHTTPRawUnionType = "InputHttpRaw_PqEnabledFalseWithPqConstraint"
	InputHTTPRawUnionTypeInputHTTPRawPqEnabledTrueWithPqConstraint              InputHTTPRawUnionType = "InputHttpRaw_PqEnabledTrueWithPqConstraint"
)

type InputHTTPRaw struct {
	InputHTTPRawSendToRoutesTrueWithConnectionsConstraint  *InputHTTPRawSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputHTTPRawSendToRoutesFalseWithConnectionsConstraint *InputHTTPRawSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputHTTPRawPqEnabledFalseWithPqConstraint             *InputHTTPRawPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputHTTPRawPqEnabledTrueWithPqConstraint              *InputHTTPRawPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputHTTPRawUnionType
}

func CreateInputHTTPRawInputHTTPRawSendToRoutesTrueWithConnectionsConstraint(inputHTTPRawSendToRoutesTrueWithConnectionsConstraint InputHTTPRawSendToRoutesTrueWithConnectionsConstraint) InputHTTPRaw {
	typ := InputHTTPRawUnionTypeInputHTTPRawSendToRoutesTrueWithConnectionsConstraint

	return InputHTTPRaw{
		InputHTTPRawSendToRoutesTrueWithConnectionsConstraint: &inputHTTPRawSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputHTTPRawInputHTTPRawSendToRoutesFalseWithConnectionsConstraint(inputHTTPRawSendToRoutesFalseWithConnectionsConstraint InputHTTPRawSendToRoutesFalseWithConnectionsConstraint) InputHTTPRaw {
	typ := InputHTTPRawUnionTypeInputHTTPRawSendToRoutesFalseWithConnectionsConstraint

	return InputHTTPRaw{
		InputHTTPRawSendToRoutesFalseWithConnectionsConstraint: &inputHTTPRawSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputHTTPRawInputHTTPRawPqEnabledFalseWithPqConstraint(inputHTTPRawPqEnabledFalseWithPqConstraint InputHTTPRawPqEnabledFalseWithPqConstraint) InputHTTPRaw {
	typ := InputHTTPRawUnionTypeInputHTTPRawPqEnabledFalseWithPqConstraint

	return InputHTTPRaw{
		InputHTTPRawPqEnabledFalseWithPqConstraint: &inputHTTPRawPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputHTTPRawInputHTTPRawPqEnabledTrueWithPqConstraint(inputHTTPRawPqEnabledTrueWithPqConstraint InputHTTPRawPqEnabledTrueWithPqConstraint) InputHTTPRaw {
	typ := InputHTTPRawUnionTypeInputHTTPRawPqEnabledTrueWithPqConstraint

	return InputHTTPRaw{
		InputHTTPRawPqEnabledTrueWithPqConstraint: &inputHTTPRawPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputHTTPRaw) UnmarshalJSON(data []byte) error {

	var inputHTTPRawSendToRoutesTrueWithConnectionsConstraint InputHTTPRawSendToRoutesTrueWithConnectionsConstraint = InputHTTPRawSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputHTTPRawSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputHTTPRawSendToRoutesTrueWithConnectionsConstraint = &inputHTTPRawSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputHTTPRawUnionTypeInputHTTPRawSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputHTTPRawSendToRoutesFalseWithConnectionsConstraint InputHTTPRawSendToRoutesFalseWithConnectionsConstraint = InputHTTPRawSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputHTTPRawSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputHTTPRawSendToRoutesFalseWithConnectionsConstraint = &inputHTTPRawSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputHTTPRawUnionTypeInputHTTPRawSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputHTTPRawPqEnabledFalseWithPqConstraint InputHTTPRawPqEnabledFalseWithPqConstraint = InputHTTPRawPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputHTTPRawPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputHTTPRawPqEnabledFalseWithPqConstraint = &inputHTTPRawPqEnabledFalseWithPqConstraint
		u.Type = InputHTTPRawUnionTypeInputHTTPRawPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputHTTPRawPqEnabledTrueWithPqConstraint InputHTTPRawPqEnabledTrueWithPqConstraint = InputHTTPRawPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputHTTPRawPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputHTTPRawPqEnabledTrueWithPqConstraint = &inputHTTPRawPqEnabledTrueWithPqConstraint
		u.Type = InputHTTPRawUnionTypeInputHTTPRawPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputHTTPRaw", string(data))
}

func (u InputHTTPRaw) MarshalJSON() ([]byte, error) {
	if u.InputHTTPRawSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputHTTPRawSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputHTTPRawSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputHTTPRawSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputHTTPRawPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputHTTPRawPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputHTTPRawPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputHTTPRawPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputHTTPRaw: all fields are null")
}

type InputDatagenPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputDatagenType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	Samples     []Sample                          `json:"samples"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputDatagenPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "samples"}); err != nil {
		return err
	}
	return nil
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetType() InputDatagenType {
	if i == nil {
		return InputDatagenType("")
	}
	return i.Type
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetSamples() []Sample {
	if i == nil {
		return []Sample{}
	}
	return i.Samples
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputDatagenPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputDatagenPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputDatagenType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	Samples     []Sample                          `json:"samples"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputDatagenPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "samples"}); err != nil {
		return err
	}
	return nil
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetType() InputDatagenType {
	if i == nil {
		return InputDatagenType("")
	}
	return i.Type
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetSamples() []Sample {
	if i == nil {
		return []Sample{}
	}
	return i.Samples
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputDatagenPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputDatagenSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputDatagenType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	Samples    []Sample           `json:"samples"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputDatagenSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "samples"}); err != nil {
		return err
	}
	return nil
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetType() InputDatagenType {
	if i == nil {
		return InputDatagenType("")
	}
	return i.Type
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetSamples() []Sample {
	if i == nil {
		return []Sample{}
	}
	return i.Samples
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputDatagenSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputDatagenType string

const (
	InputDatagenTypeDatagen InputDatagenType = "datagen"
)

func (e InputDatagenType) ToPointer() *InputDatagenType {
	return &e
}
func (e *InputDatagenType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "datagen":
		*e = InputDatagenType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputDatagenType: %v", v)
	}
}

type Sample struct {
	Sample string `json:"sample"`
	// Maximum number of events to generate per second per Worker Node. Defaults to 10.
	EventsPerSec *float64 `default:"10" json:"eventsPerSec"`
}

func (s Sample) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Sample) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"sample"}); err != nil {
		return err
	}
	return nil
}

func (s *Sample) GetSample() string {
	if s == nil {
		return ""
	}
	return s.Sample
}

func (s *Sample) GetEventsPerSec() *float64 {
	if s == nil {
		return nil
	}
	return s.EventsPerSec
}

type InputDatagenSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputDatagenType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	Samples    []Sample           `json:"samples"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputDatagenSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "samples"}); err != nil {
		return err
	}
	return nil
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetType() InputDatagenType {
	if i == nil {
		return InputDatagenType("")
	}
	return i.Type
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetSamples() []Sample {
	if i == nil {
		return []Sample{}
	}
	return i.Samples
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputDatagenSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputDatagenUnionType string

const (
	InputDatagenUnionTypeInputDatagenSendToRoutesTrueWithConnectionsConstraint  InputDatagenUnionType = "InputDatagen_SendToRoutesTrueWithConnectionsConstraint"
	InputDatagenUnionTypeInputDatagenSendToRoutesFalseWithConnectionsConstraint InputDatagenUnionType = "InputDatagen_SendToRoutesFalseWithConnectionsConstraint"
	InputDatagenUnionTypeInputDatagenPqEnabledFalseWithPqConstraint             InputDatagenUnionType = "InputDatagen_PqEnabledFalseWithPqConstraint"
	InputDatagenUnionTypeInputDatagenPqEnabledTrueWithPqConstraint              InputDatagenUnionType = "InputDatagen_PqEnabledTrueWithPqConstraint"
)

type InputDatagen struct {
	InputDatagenSendToRoutesTrueWithConnectionsConstraint  *InputDatagenSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputDatagenSendToRoutesFalseWithConnectionsConstraint *InputDatagenSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputDatagenPqEnabledFalseWithPqConstraint             *InputDatagenPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputDatagenPqEnabledTrueWithPqConstraint              *InputDatagenPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputDatagenUnionType
}

func CreateInputDatagenInputDatagenSendToRoutesTrueWithConnectionsConstraint(inputDatagenSendToRoutesTrueWithConnectionsConstraint InputDatagenSendToRoutesTrueWithConnectionsConstraint) InputDatagen {
	typ := InputDatagenUnionTypeInputDatagenSendToRoutesTrueWithConnectionsConstraint

	return InputDatagen{
		InputDatagenSendToRoutesTrueWithConnectionsConstraint: &inputDatagenSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputDatagenInputDatagenSendToRoutesFalseWithConnectionsConstraint(inputDatagenSendToRoutesFalseWithConnectionsConstraint InputDatagenSendToRoutesFalseWithConnectionsConstraint) InputDatagen {
	typ := InputDatagenUnionTypeInputDatagenSendToRoutesFalseWithConnectionsConstraint

	return InputDatagen{
		InputDatagenSendToRoutesFalseWithConnectionsConstraint: &inputDatagenSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputDatagenInputDatagenPqEnabledFalseWithPqConstraint(inputDatagenPqEnabledFalseWithPqConstraint InputDatagenPqEnabledFalseWithPqConstraint) InputDatagen {
	typ := InputDatagenUnionTypeInputDatagenPqEnabledFalseWithPqConstraint

	return InputDatagen{
		InputDatagenPqEnabledFalseWithPqConstraint: &inputDatagenPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputDatagenInputDatagenPqEnabledTrueWithPqConstraint(inputDatagenPqEnabledTrueWithPqConstraint InputDatagenPqEnabledTrueWithPqConstraint) InputDatagen {
	typ := InputDatagenUnionTypeInputDatagenPqEnabledTrueWithPqConstraint

	return InputDatagen{
		InputDatagenPqEnabledTrueWithPqConstraint: &inputDatagenPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputDatagen) UnmarshalJSON(data []byte) error {

	var inputDatagenSendToRoutesTrueWithConnectionsConstraint InputDatagenSendToRoutesTrueWithConnectionsConstraint = InputDatagenSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputDatagenSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputDatagenSendToRoutesTrueWithConnectionsConstraint = &inputDatagenSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputDatagenUnionTypeInputDatagenSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputDatagenSendToRoutesFalseWithConnectionsConstraint InputDatagenSendToRoutesFalseWithConnectionsConstraint = InputDatagenSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputDatagenSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputDatagenSendToRoutesFalseWithConnectionsConstraint = &inputDatagenSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputDatagenUnionTypeInputDatagenSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputDatagenPqEnabledFalseWithPqConstraint InputDatagenPqEnabledFalseWithPqConstraint = InputDatagenPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputDatagenPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputDatagenPqEnabledFalseWithPqConstraint = &inputDatagenPqEnabledFalseWithPqConstraint
		u.Type = InputDatagenUnionTypeInputDatagenPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputDatagenPqEnabledTrueWithPqConstraint InputDatagenPqEnabledTrueWithPqConstraint = InputDatagenPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputDatagenPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputDatagenPqEnabledTrueWithPqConstraint = &inputDatagenPqEnabledTrueWithPqConstraint
		u.Type = InputDatagenUnionTypeInputDatagenPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputDatagen", string(data))
}

func (u InputDatagen) MarshalJSON() ([]byte, error) {
	if u.InputDatagenSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputDatagenSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputDatagenSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputDatagenSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputDatagenPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputDatagenPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputDatagenPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputDatagenPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputDatagen: all fields are null")
}

type InputDatadogAgentPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputDatadogAgentType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *InputDatadogAgentProxyMode                `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputDatadogAgentPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetType() InputDatadogAgentType {
	if i == nil {
		return InputDatadogAgentType("")
	}
	return i.Type
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetProxyMode() *InputDatadogAgentProxyMode {
	if i == nil {
		return nil
	}
	return i.ProxyMode
}

func (i *InputDatadogAgentPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputDatadogAgentPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputDatadogAgentType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *InputDatadogAgentProxyMode                `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputDatadogAgentPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetType() InputDatadogAgentType {
	if i == nil {
		return InputDatadogAgentType("")
	}
	return i.Type
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetProxyMode() *InputDatadogAgentProxyMode {
	if i == nil {
		return nil
	}
	return i.ProxyMode
}

func (i *InputDatadogAgentPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputDatadogAgentType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *InputDatadogAgentProxyMode                `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetType() InputDatadogAgentType {
	if i == nil {
		return InputDatadogAgentType("")
	}
	return i.Type
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetProxyMode() *InputDatadogAgentProxyMode {
	if i == nil {
		return nil
	}
	return i.ProxyMode
}

func (i *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputDatadogAgentType string

const (
	InputDatadogAgentTypeDatadogAgent InputDatadogAgentType = "datadog_agent"
)

func (e InputDatadogAgentType) ToPointer() *InputDatadogAgentType {
	return &e
}
func (e *InputDatadogAgentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "datadog_agent":
		*e = InputDatadogAgentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputDatadogAgentType: %v", v)
	}
}

type InputDatadogAgentProxyMode struct {
	// Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid.
	Enabled *bool `default:"false" json:"enabled"`
	// Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
}

func (i InputDatadogAgentProxyMode) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatadogAgentProxyMode) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputDatadogAgentProxyMode) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *InputDatadogAgentProxyMode) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

type InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputDatadogAgentType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *InputDatadogAgentProxyMode                `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetType() InputDatadogAgentType {
	if i == nil {
		return InputDatadogAgentType("")
	}
	return i.Type
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetProxyMode() *InputDatadogAgentProxyMode {
	if i == nil {
		return nil
	}
	return i.ProxyMode
}

func (i *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputDatadogAgentUnionType string

const (
	InputDatadogAgentUnionTypeInputDatadogAgentSendToRoutesTrueWithConnectionsConstraint  InputDatadogAgentUnionType = "InputDatadogAgent_SendToRoutesTrueWithConnectionsConstraint"
	InputDatadogAgentUnionTypeInputDatadogAgentSendToRoutesFalseWithConnectionsConstraint InputDatadogAgentUnionType = "InputDatadogAgent_SendToRoutesFalseWithConnectionsConstraint"
	InputDatadogAgentUnionTypeInputDatadogAgentPqEnabledFalseWithPqConstraint             InputDatadogAgentUnionType = "InputDatadogAgent_PqEnabledFalseWithPqConstraint"
	InputDatadogAgentUnionTypeInputDatadogAgentPqEnabledTrueWithPqConstraint              InputDatadogAgentUnionType = "InputDatadogAgent_PqEnabledTrueWithPqConstraint"
)

type InputDatadogAgent struct {
	InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint  *InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint *InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputDatadogAgentPqEnabledFalseWithPqConstraint             *InputDatadogAgentPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputDatadogAgentPqEnabledTrueWithPqConstraint              *InputDatadogAgentPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputDatadogAgentUnionType
}

func CreateInputDatadogAgentInputDatadogAgentSendToRoutesTrueWithConnectionsConstraint(inputDatadogAgentSendToRoutesTrueWithConnectionsConstraint InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint) InputDatadogAgent {
	typ := InputDatadogAgentUnionTypeInputDatadogAgentSendToRoutesTrueWithConnectionsConstraint

	return InputDatadogAgent{
		InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint: &inputDatadogAgentSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputDatadogAgentInputDatadogAgentSendToRoutesFalseWithConnectionsConstraint(inputDatadogAgentSendToRoutesFalseWithConnectionsConstraint InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint) InputDatadogAgent {
	typ := InputDatadogAgentUnionTypeInputDatadogAgentSendToRoutesFalseWithConnectionsConstraint

	return InputDatadogAgent{
		InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint: &inputDatadogAgentSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputDatadogAgentInputDatadogAgentPqEnabledFalseWithPqConstraint(inputDatadogAgentPqEnabledFalseWithPqConstraint InputDatadogAgentPqEnabledFalseWithPqConstraint) InputDatadogAgent {
	typ := InputDatadogAgentUnionTypeInputDatadogAgentPqEnabledFalseWithPqConstraint

	return InputDatadogAgent{
		InputDatadogAgentPqEnabledFalseWithPqConstraint: &inputDatadogAgentPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputDatadogAgentInputDatadogAgentPqEnabledTrueWithPqConstraint(inputDatadogAgentPqEnabledTrueWithPqConstraint InputDatadogAgentPqEnabledTrueWithPqConstraint) InputDatadogAgent {
	typ := InputDatadogAgentUnionTypeInputDatadogAgentPqEnabledTrueWithPqConstraint

	return InputDatadogAgent{
		InputDatadogAgentPqEnabledTrueWithPqConstraint: &inputDatadogAgentPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputDatadogAgent) UnmarshalJSON(data []byte) error {

	var inputDatadogAgentSendToRoutesTrueWithConnectionsConstraint InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint = InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputDatadogAgentSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint = &inputDatadogAgentSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputDatadogAgentUnionTypeInputDatadogAgentSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputDatadogAgentSendToRoutesFalseWithConnectionsConstraint InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint = InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputDatadogAgentSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint = &inputDatadogAgentSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputDatadogAgentUnionTypeInputDatadogAgentSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputDatadogAgentPqEnabledFalseWithPqConstraint InputDatadogAgentPqEnabledFalseWithPqConstraint = InputDatadogAgentPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputDatadogAgentPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputDatadogAgentPqEnabledFalseWithPqConstraint = &inputDatadogAgentPqEnabledFalseWithPqConstraint
		u.Type = InputDatadogAgentUnionTypeInputDatadogAgentPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputDatadogAgentPqEnabledTrueWithPqConstraint InputDatadogAgentPqEnabledTrueWithPqConstraint = InputDatadogAgentPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputDatadogAgentPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputDatadogAgentPqEnabledTrueWithPqConstraint = &inputDatadogAgentPqEnabledTrueWithPqConstraint
		u.Type = InputDatadogAgentUnionTypeInputDatadogAgentPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputDatadogAgent", string(data))
}

func (u InputDatadogAgent) MarshalJSON() ([]byte, error) {
	if u.InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputDatadogAgentSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputDatadogAgentPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputDatadogAgentPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputDatadogAgentPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputDatadogAgentPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputDatadogAgent: all fields are null")
}

type InputCrowdstrikePqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputCrowdstrikeType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"21600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Checkpointing *components.CheckpointingType              `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputCrowdstrikePqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetType() InputCrowdstrikeType {
	if i == nil {
		return InputCrowdstrikeType("")
	}
	return i.Type
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputCrowdstrikePqEnabledTrueWithPqConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputCrowdstrikePqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputCrowdstrikeType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"21600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Checkpointing *components.CheckpointingType              `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputCrowdstrikePqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetType() InputCrowdstrikeType {
	if i == nil {
		return InputCrowdstrikeType("")
	}
	return i.Type
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputCrowdstrikePqEnabledFalseWithPqConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputCrowdstrikeType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"21600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Checkpointing *components.CheckpointingType              `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetType() InputCrowdstrikeType {
	if i == nil {
		return InputCrowdstrikeType("")
	}
	return i.Type
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputCrowdstrikeType string

const (
	InputCrowdstrikeTypeCrowdstrike InputCrowdstrikeType = "crowdstrike"
)

func (e InputCrowdstrikeType) ToPointer() *InputCrowdstrikeType {
	return &e
}
func (e *InputCrowdstrikeType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "crowdstrike":
		*e = InputCrowdstrikeType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCrowdstrikeType: %v", v)
	}
}

type InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputCrowdstrikeType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountID *string `json:"awsAccountId,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`
	// S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *components.SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float64 `default:"21600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float64 `default:"300" json:"socketTimeout"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Attach SQS notification metadata to a __sqsMetadata field on each event
	IncludeSqsMetadata *bool `default:"false" json:"includeSqsMetadata"`
	// Use Assume Role credentials to access Amazon S3
	EnableAssumeRole *bool `default:"true" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Use Assume Role credentials when accessing Amazon SQS
	EnableSQSAssumeRole *bool                                             `default:"false" json:"enableSQSAssumeRole"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Checkpointing *components.CheckpointingType              `json:"checkpointing,omitempty"`
	// How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float64 `default:"10" json:"pollTimeout"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding    *string `json:"encoding,omitempty"`
	Description *string `json:"description,omitempty"`
	AwsAPIKey   *string `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret          *string                               `json:"awsSecret,omitempty"`
	TagAfterProcessing *components.TagAfterProcessingOptions `json:"tagAfterProcessing,omitempty"`
	// The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagKey *string `json:"processedTagKey,omitempty"`
	// The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
	ProcessedTagValue *string `json:"processedTagValue,omitempty"`
}

func (i InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetType() InputCrowdstrikeType {
	if i == nil {
		return InputCrowdstrikeType("")
	}
	return i.Type
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetAwsAccountID() *string {
	if i == nil {
		return nil
	}
	return i.AwsAccountID
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetIncludeSqsMetadata() *bool {
	if i == nil {
		return nil
	}
	return i.IncludeSqsMetadata
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetEnableSQSAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableSQSAssumeRole
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetCheckpointing() *components.CheckpointingType {
	if i == nil {
		return nil
	}
	return i.Checkpointing
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetPollTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.PollTimeout
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetTagAfterProcessing() *components.TagAfterProcessingOptions {
	if i == nil {
		return nil
	}
	return i.TagAfterProcessing
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetProcessedTagKey() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagKey
}

func (i *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) GetProcessedTagValue() *string {
	if i == nil {
		return nil
	}
	return i.ProcessedTagValue
}

type InputCrowdstrikeUnionType string

const (
	InputCrowdstrikeUnionTypeInputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint  InputCrowdstrikeUnionType = "InputCrowdstrike_SendToRoutesTrueWithConnectionsConstraint"
	InputCrowdstrikeUnionTypeInputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint InputCrowdstrikeUnionType = "InputCrowdstrike_SendToRoutesFalseWithConnectionsConstraint"
	InputCrowdstrikeUnionTypeInputCrowdstrikePqEnabledFalseWithPqConstraint             InputCrowdstrikeUnionType = "InputCrowdstrike_PqEnabledFalseWithPqConstraint"
	InputCrowdstrikeUnionTypeInputCrowdstrikePqEnabledTrueWithPqConstraint              InputCrowdstrikeUnionType = "InputCrowdstrike_PqEnabledTrueWithPqConstraint"
)

type InputCrowdstrike struct {
	InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint  *InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint *InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputCrowdstrikePqEnabledFalseWithPqConstraint             *InputCrowdstrikePqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputCrowdstrikePqEnabledTrueWithPqConstraint              *InputCrowdstrikePqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputCrowdstrikeUnionType
}

func CreateInputCrowdstrikeInputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint(inputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint) InputCrowdstrike {
	typ := InputCrowdstrikeUnionTypeInputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint

	return InputCrowdstrike{
		InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint: &inputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCrowdstrikeInputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint(inputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint) InputCrowdstrike {
	typ := InputCrowdstrikeUnionTypeInputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint

	return InputCrowdstrike{
		InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint: &inputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCrowdstrikeInputCrowdstrikePqEnabledFalseWithPqConstraint(inputCrowdstrikePqEnabledFalseWithPqConstraint InputCrowdstrikePqEnabledFalseWithPqConstraint) InputCrowdstrike {
	typ := InputCrowdstrikeUnionTypeInputCrowdstrikePqEnabledFalseWithPqConstraint

	return InputCrowdstrike{
		InputCrowdstrikePqEnabledFalseWithPqConstraint: &inputCrowdstrikePqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputCrowdstrikeInputCrowdstrikePqEnabledTrueWithPqConstraint(inputCrowdstrikePqEnabledTrueWithPqConstraint InputCrowdstrikePqEnabledTrueWithPqConstraint) InputCrowdstrike {
	typ := InputCrowdstrikeUnionTypeInputCrowdstrikePqEnabledTrueWithPqConstraint

	return InputCrowdstrike{
		InputCrowdstrikePqEnabledTrueWithPqConstraint: &inputCrowdstrikePqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputCrowdstrike) UnmarshalJSON(data []byte) error {

	var inputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint = InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint = &inputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputCrowdstrikeUnionTypeInputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint = InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint = &inputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputCrowdstrikeUnionTypeInputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputCrowdstrikePqEnabledFalseWithPqConstraint InputCrowdstrikePqEnabledFalseWithPqConstraint = InputCrowdstrikePqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCrowdstrikePqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputCrowdstrikePqEnabledFalseWithPqConstraint = &inputCrowdstrikePqEnabledFalseWithPqConstraint
		u.Type = InputCrowdstrikeUnionTypeInputCrowdstrikePqEnabledFalseWithPqConstraint
		return nil
	}

	var inputCrowdstrikePqEnabledTrueWithPqConstraint InputCrowdstrikePqEnabledTrueWithPqConstraint = InputCrowdstrikePqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCrowdstrikePqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputCrowdstrikePqEnabledTrueWithPqConstraint = &inputCrowdstrikePqEnabledTrueWithPqConstraint
		u.Type = InputCrowdstrikeUnionTypeInputCrowdstrikePqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputCrowdstrike", string(data))
}

func (u InputCrowdstrike) MarshalJSON() ([]byte, error) {
	if u.InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCrowdstrikeSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputCrowdstrikePqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCrowdstrikePqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputCrowdstrikePqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCrowdstrikePqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputCrowdstrike: all fields are null")
}

type InputWindowsMetricsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputWindowsMetricsType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                 `default:"10" json:"interval"`
	Host     *InputWindowsMetricsHost `json:"host,omitempty"`
	Process  *components.ProcessType  `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputWindowsMetricsPersistence            `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputWindowsMetricsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetType() InputWindowsMetricsType {
	if i == nil {
		return InputWindowsMetricsType("")
	}
	return i.Type
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetHost() *InputWindowsMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetProcess() *components.ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetPersistence() *InputWindowsMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWindowsMetricsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWindowsMetricsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputWindowsMetricsType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                 `default:"10" json:"interval"`
	Host     *InputWindowsMetricsHost `json:"host,omitempty"`
	Process  *components.ProcessType  `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputWindowsMetricsPersistence            `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputWindowsMetricsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetType() InputWindowsMetricsType {
	if i == nil {
		return InputWindowsMetricsType("")
	}
	return i.Type
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetHost() *InputWindowsMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetProcess() *components.ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetPersistence() *InputWindowsMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWindowsMetricsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputWindowsMetricsType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                 `default:"10" json:"interval"`
	Host     *InputWindowsMetricsHost `json:"host,omitempty"`
	Process  *components.ProcessType  `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputWindowsMetricsPersistence            `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetType() InputWindowsMetricsType {
	if i == nil {
		return InputWindowsMetricsType("")
	}
	return i.Type
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetHost() *InputWindowsMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetProcess() *components.ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetPersistence() *InputWindowsMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWindowsMetricsType string

const (
	InputWindowsMetricsTypeWindowsMetrics InputWindowsMetricsType = "windows_metrics"
)

func (e InputWindowsMetricsType) ToPointer() *InputWindowsMetricsType {
	return &e
}
func (e *InputWindowsMetricsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "windows_metrics":
		*e = InputWindowsMetricsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWindowsMetricsType: %v", v)
	}
}

// InputWindowsMetricsSystemMode - Select the level of details for system metrics
type InputWindowsMetricsSystemMode string

const (
	// InputWindowsMetricsSystemModeBasic Basic
	InputWindowsMetricsSystemModeBasic InputWindowsMetricsSystemMode = "basic"
	// InputWindowsMetricsSystemModeAll All
	InputWindowsMetricsSystemModeAll InputWindowsMetricsSystemMode = "all"
	// InputWindowsMetricsSystemModeCustom Custom
	InputWindowsMetricsSystemModeCustom InputWindowsMetricsSystemMode = "custom"
	// InputWindowsMetricsSystemModeDisabled Disabled
	InputWindowsMetricsSystemModeDisabled InputWindowsMetricsSystemMode = "disabled"
)

func (e InputWindowsMetricsSystemMode) ToPointer() *InputWindowsMetricsSystemMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsSystemMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsSystem struct {
	// Select the level of details for system metrics
	Mode *InputWindowsMetricsSystemMode `default:"basic" json:"mode"`
	// Generate metrics for all system information
	Detail *bool `default:"false" json:"detail"`
}

func (i InputWindowsMetricsSystem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsSystem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsSystem) GetMode() *InputWindowsMetricsSystemMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsSystem) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

// InputWindowsMetricsCPUMode - Select the level of details for CPU metrics
type InputWindowsMetricsCPUMode string

const (
	// InputWindowsMetricsCPUModeBasic Basic
	InputWindowsMetricsCPUModeBasic InputWindowsMetricsCPUMode = "basic"
	// InputWindowsMetricsCPUModeAll All
	InputWindowsMetricsCPUModeAll InputWindowsMetricsCPUMode = "all"
	// InputWindowsMetricsCPUModeCustom Custom
	InputWindowsMetricsCPUModeCustom InputWindowsMetricsCPUMode = "custom"
	// InputWindowsMetricsCPUModeDisabled Disabled
	InputWindowsMetricsCPUModeDisabled InputWindowsMetricsCPUMode = "disabled"
)

func (e InputWindowsMetricsCPUMode) ToPointer() *InputWindowsMetricsCPUMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsCPUMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsCPU struct {
	// Select the level of details for CPU metrics
	Mode *InputWindowsMetricsCPUMode `default:"basic" json:"mode"`
	// Generate metrics for each CPU
	PerCPU *bool `default:"false" json:"perCpu"`
	// Generate metrics for all CPU states
	Detail *bool `default:"false" json:"detail"`
	// Generate raw, monotonic CPU time counters
	Time *bool `default:"false" json:"time"`
}

func (i InputWindowsMetricsCPU) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsCPU) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsCPU) GetMode() *InputWindowsMetricsCPUMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsCPU) GetPerCPU() *bool {
	if i == nil {
		return nil
	}
	return i.PerCPU
}

func (i *InputWindowsMetricsCPU) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputWindowsMetricsCPU) GetTime() *bool {
	if i == nil {
		return nil
	}
	return i.Time
}

// InputWindowsMetricsMemoryMode - Select the level of details for memory metrics
type InputWindowsMetricsMemoryMode string

const (
	// InputWindowsMetricsMemoryModeBasic Basic
	InputWindowsMetricsMemoryModeBasic InputWindowsMetricsMemoryMode = "basic"
	// InputWindowsMetricsMemoryModeAll All
	InputWindowsMetricsMemoryModeAll InputWindowsMetricsMemoryMode = "all"
	// InputWindowsMetricsMemoryModeCustom Custom
	InputWindowsMetricsMemoryModeCustom InputWindowsMetricsMemoryMode = "custom"
	// InputWindowsMetricsMemoryModeDisabled Disabled
	InputWindowsMetricsMemoryModeDisabled InputWindowsMetricsMemoryMode = "disabled"
)

func (e InputWindowsMetricsMemoryMode) ToPointer() *InputWindowsMetricsMemoryMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsMemoryMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsMemory struct {
	// Select the level of details for memory metrics
	Mode *InputWindowsMetricsMemoryMode `default:"basic" json:"mode"`
	// Generate metrics for all memory states
	Detail *bool `default:"false" json:"detail"`
}

func (i InputWindowsMetricsMemory) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsMemory) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsMemory) GetMode() *InputWindowsMetricsMemoryMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsMemory) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

// InputWindowsMetricsNetworkMode - Select the level of details for network metrics
type InputWindowsMetricsNetworkMode string

const (
	// InputWindowsMetricsNetworkModeBasic Basic
	InputWindowsMetricsNetworkModeBasic InputWindowsMetricsNetworkMode = "basic"
	// InputWindowsMetricsNetworkModeAll All
	InputWindowsMetricsNetworkModeAll InputWindowsMetricsNetworkMode = "all"
	// InputWindowsMetricsNetworkModeCustom Custom
	InputWindowsMetricsNetworkModeCustom InputWindowsMetricsNetworkMode = "custom"
	// InputWindowsMetricsNetworkModeDisabled Disabled
	InputWindowsMetricsNetworkModeDisabled InputWindowsMetricsNetworkMode = "disabled"
)

func (e InputWindowsMetricsNetworkMode) ToPointer() *InputWindowsMetricsNetworkMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsNetworkMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsNetwork struct {
	// Select the level of details for network metrics
	Mode *InputWindowsMetricsNetworkMode `default:"basic" json:"mode"`
	// Generate full network metrics
	Detail *bool `default:"false" json:"detail"`
	// Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
	Protocols *bool `default:"false" json:"protocols"`
	// Network interfaces to include/exclude. All interfaces are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Generate separate metrics for each interface
	PerInterface *bool `default:"false" json:"perInterface"`
}

func (i InputWindowsMetricsNetwork) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsNetwork) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsNetwork) GetMode() *InputWindowsMetricsNetworkMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsNetwork) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputWindowsMetricsNetwork) GetProtocols() *bool {
	if i == nil {
		return nil
	}
	return i.Protocols
}

func (i *InputWindowsMetricsNetwork) GetDevices() []string {
	if i == nil {
		return nil
	}
	return i.Devices
}

func (i *InputWindowsMetricsNetwork) GetPerInterface() *bool {
	if i == nil {
		return nil
	}
	return i.PerInterface
}

// InputWindowsMetricsDiskMode - Select the level of details for disk metrics
type InputWindowsMetricsDiskMode string

const (
	// InputWindowsMetricsDiskModeBasic Basic
	InputWindowsMetricsDiskModeBasic InputWindowsMetricsDiskMode = "basic"
	// InputWindowsMetricsDiskModeAll All
	InputWindowsMetricsDiskModeAll InputWindowsMetricsDiskMode = "all"
	// InputWindowsMetricsDiskModeCustom Custom
	InputWindowsMetricsDiskModeCustom InputWindowsMetricsDiskMode = "custom"
	// InputWindowsMetricsDiskModeDisabled Disabled
	InputWindowsMetricsDiskModeDisabled InputWindowsMetricsDiskMode = "disabled"
)

func (e InputWindowsMetricsDiskMode) ToPointer() *InputWindowsMetricsDiskMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsDiskMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsDisk struct {
	// Select the level of details for disk metrics
	Mode *InputWindowsMetricsDiskMode `default:"basic" json:"mode"`
	// Generate separate metrics for each volume
	PerVolume *bool `default:"false" json:"perVolume"`
	// Generate full disk metrics
	Detail *bool `default:"false" json:"detail"`
	// Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
	Volumes []string `json:"volumes,omitempty"`
}

func (i InputWindowsMetricsDisk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsDisk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsDisk) GetMode() *InputWindowsMetricsDiskMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsDisk) GetPerVolume() *bool {
	if i == nil {
		return nil
	}
	return i.PerVolume
}

func (i *InputWindowsMetricsDisk) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputWindowsMetricsDisk) GetVolumes() []string {
	if i == nil {
		return nil
	}
	return i.Volumes
}

type InputWindowsMetricsCustom struct {
	System  *InputWindowsMetricsSystem  `json:"system,omitempty"`
	CPU     *InputWindowsMetricsCPU     `json:"cpu,omitempty"`
	Memory  *InputWindowsMetricsMemory  `json:"memory,omitempty"`
	Network *InputWindowsMetricsNetwork `json:"network,omitempty"`
	Disk    *InputWindowsMetricsDisk    `json:"disk,omitempty"`
}

func (i InputWindowsMetricsCustom) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsCustom) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsCustom) GetSystem() *InputWindowsMetricsSystem {
	if i == nil {
		return nil
	}
	return i.System
}

func (i *InputWindowsMetricsCustom) GetCPU() *InputWindowsMetricsCPU {
	if i == nil {
		return nil
	}
	return i.CPU
}

func (i *InputWindowsMetricsCustom) GetMemory() *InputWindowsMetricsMemory {
	if i == nil {
		return nil
	}
	return i.Memory
}

func (i *InputWindowsMetricsCustom) GetNetwork() *InputWindowsMetricsNetwork {
	if i == nil {
		return nil
	}
	return i.Network
}

func (i *InputWindowsMetricsCustom) GetDisk() *InputWindowsMetricsDisk {
	if i == nil {
		return nil
	}
	return i.Disk
}

type InputWindowsMetricsHost struct {
	// Select level of detail for host metrics
	Mode   *components.ModeOptionsHost `default:"basic" json:"mode"`
	Custom *InputWindowsMetricsCustom  `json:"custom,omitempty"`
}

func (i InputWindowsMetricsHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsHost) GetMode() *components.ModeOptionsHost {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsHost) GetCustom() *InputWindowsMetricsCustom {
	if i == nil {
		return nil
	}
	return i.Custom
}

type InputWindowsMetricsPersistence struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `default:"false" json:"enable"`
	// Time span for each file bucket
	TimeWindow *string `default:"10m" json:"timeWindow"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `default:"1GB" json:"maxDataSize"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `default:"24h" json:"maxDataTime"`
	Compress    *components.DataCompressionFormatOptionsPersistence `default:"gzip" json:"compress"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
	DestPath *string `default:"$CRIBL_HOME/state/windows_metrics" json:"destPath"`
}

func (i InputWindowsMetricsPersistence) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsPersistence) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsPersistence) GetEnable() *bool {
	if i == nil {
		return nil
	}
	return i.Enable
}

func (i *InputWindowsMetricsPersistence) GetTimeWindow() *string {
	if i == nil {
		return nil
	}
	return i.TimeWindow
}

func (i *InputWindowsMetricsPersistence) GetMaxDataSize() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataSize
}

func (i *InputWindowsMetricsPersistence) GetMaxDataTime() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataTime
}

func (i *InputWindowsMetricsPersistence) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if i == nil {
		return nil
	}
	return i.Compress
}

func (i *InputWindowsMetricsPersistence) GetDestPath() *string {
	if i == nil {
		return nil
	}
	return i.DestPath
}

type InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputWindowsMetricsType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                 `default:"10" json:"interval"`
	Host     *InputWindowsMetricsHost `json:"host,omitempty"`
	Process  *components.ProcessType  `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputWindowsMetricsPersistence            `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetType() InputWindowsMetricsType {
	if i == nil {
		return InputWindowsMetricsType("")
	}
	return i.Type
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetHost() *InputWindowsMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetProcess() *components.ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetPersistence() *InputWindowsMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWindowsMetricsUnionType string

const (
	InputWindowsMetricsUnionTypeInputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint  InputWindowsMetricsUnionType = "InputWindowsMetrics_SendToRoutesTrueWithConnectionsConstraint"
	InputWindowsMetricsUnionTypeInputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint InputWindowsMetricsUnionType = "InputWindowsMetrics_SendToRoutesFalseWithConnectionsConstraint"
	InputWindowsMetricsUnionTypeInputWindowsMetricsPqEnabledFalseWithPqConstraint             InputWindowsMetricsUnionType = "InputWindowsMetrics_PqEnabledFalseWithPqConstraint"
	InputWindowsMetricsUnionTypeInputWindowsMetricsPqEnabledTrueWithPqConstraint              InputWindowsMetricsUnionType = "InputWindowsMetrics_PqEnabledTrueWithPqConstraint"
)

type InputWindowsMetrics struct {
	InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint  *InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint *InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputWindowsMetricsPqEnabledFalseWithPqConstraint             *InputWindowsMetricsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputWindowsMetricsPqEnabledTrueWithPqConstraint              *InputWindowsMetricsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputWindowsMetricsUnionType
}

func CreateInputWindowsMetricsInputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint(inputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint) InputWindowsMetrics {
	typ := InputWindowsMetricsUnionTypeInputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint

	return InputWindowsMetrics{
		InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint: &inputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWindowsMetricsInputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint(inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint) InputWindowsMetrics {
	typ := InputWindowsMetricsUnionTypeInputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint

	return InputWindowsMetrics{
		InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint: &inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputWindowsMetricsInputWindowsMetricsPqEnabledFalseWithPqConstraint(inputWindowsMetricsPqEnabledFalseWithPqConstraint InputWindowsMetricsPqEnabledFalseWithPqConstraint) InputWindowsMetrics {
	typ := InputWindowsMetricsUnionTypeInputWindowsMetricsPqEnabledFalseWithPqConstraint

	return InputWindowsMetrics{
		InputWindowsMetricsPqEnabledFalseWithPqConstraint: &inputWindowsMetricsPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputWindowsMetricsInputWindowsMetricsPqEnabledTrueWithPqConstraint(inputWindowsMetricsPqEnabledTrueWithPqConstraint InputWindowsMetricsPqEnabledTrueWithPqConstraint) InputWindowsMetrics {
	typ := InputWindowsMetricsUnionTypeInputWindowsMetricsPqEnabledTrueWithPqConstraint

	return InputWindowsMetrics{
		InputWindowsMetricsPqEnabledTrueWithPqConstraint: &inputWindowsMetricsPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputWindowsMetrics) UnmarshalJSON(data []byte) error {

	var inputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint = InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint = &inputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputWindowsMetricsUnionTypeInputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint = InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint = &inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputWindowsMetricsUnionTypeInputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputWindowsMetricsPqEnabledFalseWithPqConstraint InputWindowsMetricsPqEnabledFalseWithPqConstraint = InputWindowsMetricsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWindowsMetricsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputWindowsMetricsPqEnabledFalseWithPqConstraint = &inputWindowsMetricsPqEnabledFalseWithPqConstraint
		u.Type = InputWindowsMetricsUnionTypeInputWindowsMetricsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputWindowsMetricsPqEnabledTrueWithPqConstraint InputWindowsMetricsPqEnabledTrueWithPqConstraint = InputWindowsMetricsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputWindowsMetricsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputWindowsMetricsPqEnabledTrueWithPqConstraint = &inputWindowsMetricsPqEnabledTrueWithPqConstraint
		u.Type = InputWindowsMetricsUnionTypeInputWindowsMetricsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputWindowsMetrics", string(data))
}

func (u InputWindowsMetrics) MarshalJSON() ([]byte, error) {
	if u.InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWindowsMetricsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputWindowsMetricsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWindowsMetricsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputWindowsMetricsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputWindowsMetricsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputWindowsMetrics: all fields are null")
}

type InputKubeEventsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputKubeEventsType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Filtering on event fields
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKubeEventsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetType() InputKubeEventsType {
	if i == nil {
		return InputKubeEventsType("")
	}
	return i.Type
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetRules() []components.ItemsTypeRules {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeEventsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeEventsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputKubeEventsType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Filtering on event fields
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKubeEventsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetType() InputKubeEventsType {
	if i == nil {
		return InputKubeEventsType("")
	}
	return i.Type
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetRules() []components.ItemsTypeRules {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeEventsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeEventsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputKubeEventsType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Filtering on event fields
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetType() InputKubeEventsType {
	if i == nil {
		return InputKubeEventsType("")
	}
	return i.Type
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetRules() []components.ItemsTypeRules {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeEventsType string

const (
	InputKubeEventsTypeKubeEvents InputKubeEventsType = "kube_events"
)

func (e InputKubeEventsType) ToPointer() *InputKubeEventsType {
	return &e
}
func (e *InputKubeEventsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_events":
		*e = InputKubeEventsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKubeEventsType: %v", v)
	}
}

type InputKubeEventsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputKubeEventsType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Filtering on event fields
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetType() InputKubeEventsType {
	if i == nil {
		return InputKubeEventsType("")
	}
	return i.Type
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetRules() []components.ItemsTypeRules {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeEventsUnionType string

const (
	InputKubeEventsUnionTypeInputKubeEventsSendToRoutesTrueWithConnectionsConstraint  InputKubeEventsUnionType = "InputKubeEvents_SendToRoutesTrueWithConnectionsConstraint"
	InputKubeEventsUnionTypeInputKubeEventsSendToRoutesFalseWithConnectionsConstraint InputKubeEventsUnionType = "InputKubeEvents_SendToRoutesFalseWithConnectionsConstraint"
	InputKubeEventsUnionTypeInputKubeEventsPqEnabledFalseWithPqConstraint             InputKubeEventsUnionType = "InputKubeEvents_PqEnabledFalseWithPqConstraint"
	InputKubeEventsUnionTypeInputKubeEventsPqEnabledTrueWithPqConstraint              InputKubeEventsUnionType = "InputKubeEvents_PqEnabledTrueWithPqConstraint"
)

type InputKubeEvents struct {
	InputKubeEventsSendToRoutesTrueWithConnectionsConstraint  *InputKubeEventsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputKubeEventsSendToRoutesFalseWithConnectionsConstraint *InputKubeEventsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputKubeEventsPqEnabledFalseWithPqConstraint             *InputKubeEventsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputKubeEventsPqEnabledTrueWithPqConstraint              *InputKubeEventsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputKubeEventsUnionType
}

func CreateInputKubeEventsInputKubeEventsSendToRoutesTrueWithConnectionsConstraint(inputKubeEventsSendToRoutesTrueWithConnectionsConstraint InputKubeEventsSendToRoutesTrueWithConnectionsConstraint) InputKubeEvents {
	typ := InputKubeEventsUnionTypeInputKubeEventsSendToRoutesTrueWithConnectionsConstraint

	return InputKubeEvents{
		InputKubeEventsSendToRoutesTrueWithConnectionsConstraint: &inputKubeEventsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKubeEventsInputKubeEventsSendToRoutesFalseWithConnectionsConstraint(inputKubeEventsSendToRoutesFalseWithConnectionsConstraint InputKubeEventsSendToRoutesFalseWithConnectionsConstraint) InputKubeEvents {
	typ := InputKubeEventsUnionTypeInputKubeEventsSendToRoutesFalseWithConnectionsConstraint

	return InputKubeEvents{
		InputKubeEventsSendToRoutesFalseWithConnectionsConstraint: &inputKubeEventsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKubeEventsInputKubeEventsPqEnabledFalseWithPqConstraint(inputKubeEventsPqEnabledFalseWithPqConstraint InputKubeEventsPqEnabledFalseWithPqConstraint) InputKubeEvents {
	typ := InputKubeEventsUnionTypeInputKubeEventsPqEnabledFalseWithPqConstraint

	return InputKubeEvents{
		InputKubeEventsPqEnabledFalseWithPqConstraint: &inputKubeEventsPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputKubeEventsInputKubeEventsPqEnabledTrueWithPqConstraint(inputKubeEventsPqEnabledTrueWithPqConstraint InputKubeEventsPqEnabledTrueWithPqConstraint) InputKubeEvents {
	typ := InputKubeEventsUnionTypeInputKubeEventsPqEnabledTrueWithPqConstraint

	return InputKubeEvents{
		InputKubeEventsPqEnabledTrueWithPqConstraint: &inputKubeEventsPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputKubeEvents) UnmarshalJSON(data []byte) error {

	var inputKubeEventsSendToRoutesTrueWithConnectionsConstraint InputKubeEventsSendToRoutesTrueWithConnectionsConstraint = InputKubeEventsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeEventsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKubeEventsSendToRoutesTrueWithConnectionsConstraint = &inputKubeEventsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputKubeEventsUnionTypeInputKubeEventsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputKubeEventsSendToRoutesFalseWithConnectionsConstraint InputKubeEventsSendToRoutesFalseWithConnectionsConstraint = InputKubeEventsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeEventsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKubeEventsSendToRoutesFalseWithConnectionsConstraint = &inputKubeEventsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputKubeEventsUnionTypeInputKubeEventsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputKubeEventsPqEnabledFalseWithPqConstraint InputKubeEventsPqEnabledFalseWithPqConstraint = InputKubeEventsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeEventsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputKubeEventsPqEnabledFalseWithPqConstraint = &inputKubeEventsPqEnabledFalseWithPqConstraint
		u.Type = InputKubeEventsUnionTypeInputKubeEventsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputKubeEventsPqEnabledTrueWithPqConstraint InputKubeEventsPqEnabledTrueWithPqConstraint = InputKubeEventsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeEventsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputKubeEventsPqEnabledTrueWithPqConstraint = &inputKubeEventsPqEnabledTrueWithPqConstraint
		u.Type = InputKubeEventsUnionTypeInputKubeEventsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputKubeEvents", string(data))
}

func (u InputKubeEvents) MarshalJSON() ([]byte, error) {
	if u.InputKubeEventsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKubeEventsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputKubeEventsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKubeEventsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputKubeEventsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKubeEventsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputKubeEventsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKubeEventsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputKubeEvents: all fields are null")
}

type InputKubeLogsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputKubeLogsType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between checks for new containers. Default is 15 secs.
	Interval *float64 `default:"15" json:"interval"`
	// Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
	Rules []InputKubeLogsRule `json:"rules,omitempty"`
	// For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
	Timestamps *bool `default:"false" json:"timestamps"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *components.DiskSpoolingType               `json:"persistence,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `default:"false" json:"enableLoadBalancing"`
	Description         *string `json:"description,omitempty"`
}

func (i InputKubeLogsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetType() InputKubeLogsType {
	if i == nil {
		return InputKubeLogsType("")
	}
	return i.Type
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetRules() []InputKubeLogsRule {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetTimestamps() *bool {
	if i == nil {
		return nil
	}
	return i.Timestamps
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetPersistence() *components.DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputKubeLogsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeLogsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputKubeLogsType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between checks for new containers. Default is 15 secs.
	Interval *float64 `default:"15" json:"interval"`
	// Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
	Rules []InputKubeLogsRule `json:"rules,omitempty"`
	// For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
	Timestamps *bool `default:"false" json:"timestamps"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *components.DiskSpoolingType               `json:"persistence,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `default:"false" json:"enableLoadBalancing"`
	Description         *string `json:"description,omitempty"`
}

func (i InputKubeLogsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetType() InputKubeLogsType {
	if i == nil {
		return InputKubeLogsType("")
	}
	return i.Type
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetRules() []InputKubeLogsRule {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetTimestamps() *bool {
	if i == nil {
		return nil
	}
	return i.Timestamps
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetPersistence() *components.DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputKubeLogsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeLogsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputKubeLogsType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between checks for new containers. Default is 15 secs.
	Interval *float64 `default:"15" json:"interval"`
	// Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
	Rules []InputKubeLogsRule `json:"rules,omitempty"`
	// For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
	Timestamps *bool `default:"false" json:"timestamps"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *components.DiskSpoolingType               `json:"persistence,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `default:"false" json:"enableLoadBalancing"`
	Description         *string `json:"description,omitempty"`
}

func (i InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetType() InputKubeLogsType {
	if i == nil {
		return InputKubeLogsType("")
	}
	return i.Type
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetRules() []InputKubeLogsRule {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetTimestamps() *bool {
	if i == nil {
		return nil
	}
	return i.Timestamps
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetPersistence() *components.DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeLogsType string

const (
	InputKubeLogsTypeKubeLogs InputKubeLogsType = "kube_logs"
)

func (e InputKubeLogsType) ToPointer() *InputKubeLogsType {
	return &e
}
func (e *InputKubeLogsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_logs":
		*e = InputKubeLogsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKubeLogsType: %v", v)
	}
}

type InputKubeLogsRule struct {
	// JavaScript expression applied to Pod objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (i InputKubeLogsRule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeLogsRule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeLogsRule) GetFilter() string {
	if i == nil {
		return ""
	}
	return i.Filter
}

func (i *InputKubeLogsRule) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeLogsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputKubeLogsType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between checks for new containers. Default is 15 secs.
	Interval *float64 `default:"15" json:"interval"`
	// Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
	Rules []InputKubeLogsRule `json:"rules,omitempty"`
	// For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
	Timestamps *bool `default:"false" json:"timestamps"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *components.DiskSpoolingType               `json:"persistence,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool   `default:"false" json:"enableLoadBalancing"`
	Description         *string `json:"description,omitempty"`
}

func (i InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetType() InputKubeLogsType {
	if i == nil {
		return InputKubeLogsType("")
	}
	return i.Type
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetRules() []InputKubeLogsRule {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetTimestamps() *bool {
	if i == nil {
		return nil
	}
	return i.Timestamps
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetPersistence() *components.DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeLogsUnionType string

const (
	InputKubeLogsUnionTypeInputKubeLogsSendToRoutesTrueWithConnectionsConstraint  InputKubeLogsUnionType = "InputKubeLogs_SendToRoutesTrueWithConnectionsConstraint"
	InputKubeLogsUnionTypeInputKubeLogsSendToRoutesFalseWithConnectionsConstraint InputKubeLogsUnionType = "InputKubeLogs_SendToRoutesFalseWithConnectionsConstraint"
	InputKubeLogsUnionTypeInputKubeLogsPqEnabledFalseWithPqConstraint             InputKubeLogsUnionType = "InputKubeLogs_PqEnabledFalseWithPqConstraint"
	InputKubeLogsUnionTypeInputKubeLogsPqEnabledTrueWithPqConstraint              InputKubeLogsUnionType = "InputKubeLogs_PqEnabledTrueWithPqConstraint"
)

type InputKubeLogs struct {
	InputKubeLogsSendToRoutesTrueWithConnectionsConstraint  *InputKubeLogsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputKubeLogsSendToRoutesFalseWithConnectionsConstraint *InputKubeLogsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputKubeLogsPqEnabledFalseWithPqConstraint             *InputKubeLogsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputKubeLogsPqEnabledTrueWithPqConstraint              *InputKubeLogsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputKubeLogsUnionType
}

func CreateInputKubeLogsInputKubeLogsSendToRoutesTrueWithConnectionsConstraint(inputKubeLogsSendToRoutesTrueWithConnectionsConstraint InputKubeLogsSendToRoutesTrueWithConnectionsConstraint) InputKubeLogs {
	typ := InputKubeLogsUnionTypeInputKubeLogsSendToRoutesTrueWithConnectionsConstraint

	return InputKubeLogs{
		InputKubeLogsSendToRoutesTrueWithConnectionsConstraint: &inputKubeLogsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKubeLogsInputKubeLogsSendToRoutesFalseWithConnectionsConstraint(inputKubeLogsSendToRoutesFalseWithConnectionsConstraint InputKubeLogsSendToRoutesFalseWithConnectionsConstraint) InputKubeLogs {
	typ := InputKubeLogsUnionTypeInputKubeLogsSendToRoutesFalseWithConnectionsConstraint

	return InputKubeLogs{
		InputKubeLogsSendToRoutesFalseWithConnectionsConstraint: &inputKubeLogsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKubeLogsInputKubeLogsPqEnabledFalseWithPqConstraint(inputKubeLogsPqEnabledFalseWithPqConstraint InputKubeLogsPqEnabledFalseWithPqConstraint) InputKubeLogs {
	typ := InputKubeLogsUnionTypeInputKubeLogsPqEnabledFalseWithPqConstraint

	return InputKubeLogs{
		InputKubeLogsPqEnabledFalseWithPqConstraint: &inputKubeLogsPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputKubeLogsInputKubeLogsPqEnabledTrueWithPqConstraint(inputKubeLogsPqEnabledTrueWithPqConstraint InputKubeLogsPqEnabledTrueWithPqConstraint) InputKubeLogs {
	typ := InputKubeLogsUnionTypeInputKubeLogsPqEnabledTrueWithPqConstraint

	return InputKubeLogs{
		InputKubeLogsPqEnabledTrueWithPqConstraint: &inputKubeLogsPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputKubeLogs) UnmarshalJSON(data []byte) error {

	var inputKubeLogsSendToRoutesTrueWithConnectionsConstraint InputKubeLogsSendToRoutesTrueWithConnectionsConstraint = InputKubeLogsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeLogsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKubeLogsSendToRoutesTrueWithConnectionsConstraint = &inputKubeLogsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputKubeLogsUnionTypeInputKubeLogsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputKubeLogsSendToRoutesFalseWithConnectionsConstraint InputKubeLogsSendToRoutesFalseWithConnectionsConstraint = InputKubeLogsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeLogsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKubeLogsSendToRoutesFalseWithConnectionsConstraint = &inputKubeLogsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputKubeLogsUnionTypeInputKubeLogsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputKubeLogsPqEnabledFalseWithPqConstraint InputKubeLogsPqEnabledFalseWithPqConstraint = InputKubeLogsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeLogsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputKubeLogsPqEnabledFalseWithPqConstraint = &inputKubeLogsPqEnabledFalseWithPqConstraint
		u.Type = InputKubeLogsUnionTypeInputKubeLogsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputKubeLogsPqEnabledTrueWithPqConstraint InputKubeLogsPqEnabledTrueWithPqConstraint = InputKubeLogsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeLogsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputKubeLogsPqEnabledTrueWithPqConstraint = &inputKubeLogsPqEnabledTrueWithPqConstraint
		u.Type = InputKubeLogsUnionTypeInputKubeLogsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputKubeLogs", string(data))
}

func (u InputKubeLogs) MarshalJSON() ([]byte, error) {
	if u.InputKubeLogsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKubeLogsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputKubeLogsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKubeLogsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputKubeLogsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKubeLogsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputKubeLogsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKubeLogsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputKubeLogs: all fields are null")
}

type InputKubeMetricsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputKubeMetricsType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive metrics collections. Default is 15 secs.
	Interval *float64 `default:"15" json:"interval"`
	// Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputKubeMetricsPersistence               `json:"persistence,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKubeMetricsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetType() InputKubeMetricsType {
	if i == nil {
		return InputKubeMetricsType("")
	}
	return i.Type
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetRules() []components.ItemsTypeRules {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetPersistence() *InputKubeMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputKubeMetricsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeMetricsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputKubeMetricsType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive metrics collections. Default is 15 secs.
	Interval *float64 `default:"15" json:"interval"`
	// Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputKubeMetricsPersistence               `json:"persistence,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKubeMetricsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetType() InputKubeMetricsType {
	if i == nil {
		return InputKubeMetricsType("")
	}
	return i.Type
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetRules() []components.ItemsTypeRules {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetPersistence() *InputKubeMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputKubeMetricsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputKubeMetricsType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metrics collections. Default is 15 secs.
	Interval *float64 `default:"15" json:"interval"`
	// Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputKubeMetricsPersistence               `json:"persistence,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetType() InputKubeMetricsType {
	if i == nil {
		return InputKubeMetricsType("")
	}
	return i.Type
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetRules() []components.ItemsTypeRules {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetPersistence() *InputKubeMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeMetricsType string

const (
	InputKubeMetricsTypeKubeMetrics InputKubeMetricsType = "kube_metrics"
)

func (e InputKubeMetricsType) ToPointer() *InputKubeMetricsType {
	return &e
}
func (e *InputKubeMetricsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kube_metrics":
		*e = InputKubeMetricsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKubeMetricsType: %v", v)
	}
}

type InputKubeMetricsPersistence struct {
	// Spool metrics on disk for Cribl Search
	Enable *bool `default:"false" json:"enable"`
	// Time span for each file bucket
	TimeWindow *string `default:"10m" json:"timeWindow"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `default:"1GB" json:"maxDataSize"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `default:"24h" json:"maxDataTime"`
	Compress    *components.DataCompressionFormatOptionsPersistence `default:"gzip" json:"compress"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>
	DestPath *string `default:"$CRIBL_HOME/state/kube_metrics" json:"destPath"`
}

func (i InputKubeMetricsPersistence) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeMetricsPersistence) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeMetricsPersistence) GetEnable() *bool {
	if i == nil {
		return nil
	}
	return i.Enable
}

func (i *InputKubeMetricsPersistence) GetTimeWindow() *string {
	if i == nil {
		return nil
	}
	return i.TimeWindow
}

func (i *InputKubeMetricsPersistence) GetMaxDataSize() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataSize
}

func (i *InputKubeMetricsPersistence) GetMaxDataTime() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataTime
}

func (i *InputKubeMetricsPersistence) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if i == nil {
		return nil
	}
	return i.Compress
}

func (i *InputKubeMetricsPersistence) GetDestPath() *string {
	if i == nil {
		return nil
	}
	return i.DestPath
}

type InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputKubeMetricsType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metrics collections. Default is 15 secs.
	Interval *float64 `default:"15" json:"interval"`
	// Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
	Rules []components.ItemsTypeRules `json:"rules,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputKubeMetricsPersistence               `json:"persistence,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetType() InputKubeMetricsType {
	if i == nil {
		return InputKubeMetricsType("")
	}
	return i.Type
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetRules() []components.ItemsTypeRules {
	if i == nil {
		return nil
	}
	return i.Rules
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetPersistence() *InputKubeMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKubeMetricsUnionType string

const (
	InputKubeMetricsUnionTypeInputKubeMetricsSendToRoutesTrueWithConnectionsConstraint  InputKubeMetricsUnionType = "InputKubeMetrics_SendToRoutesTrueWithConnectionsConstraint"
	InputKubeMetricsUnionTypeInputKubeMetricsSendToRoutesFalseWithConnectionsConstraint InputKubeMetricsUnionType = "InputKubeMetrics_SendToRoutesFalseWithConnectionsConstraint"
	InputKubeMetricsUnionTypeInputKubeMetricsPqEnabledFalseWithPqConstraint             InputKubeMetricsUnionType = "InputKubeMetrics_PqEnabledFalseWithPqConstraint"
	InputKubeMetricsUnionTypeInputKubeMetricsPqEnabledTrueWithPqConstraint              InputKubeMetricsUnionType = "InputKubeMetrics_PqEnabledTrueWithPqConstraint"
)

type InputKubeMetrics struct {
	InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint  *InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint *InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputKubeMetricsPqEnabledFalseWithPqConstraint             *InputKubeMetricsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputKubeMetricsPqEnabledTrueWithPqConstraint              *InputKubeMetricsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputKubeMetricsUnionType
}

func CreateInputKubeMetricsInputKubeMetricsSendToRoutesTrueWithConnectionsConstraint(inputKubeMetricsSendToRoutesTrueWithConnectionsConstraint InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint) InputKubeMetrics {
	typ := InputKubeMetricsUnionTypeInputKubeMetricsSendToRoutesTrueWithConnectionsConstraint

	return InputKubeMetrics{
		InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint: &inputKubeMetricsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKubeMetricsInputKubeMetricsSendToRoutesFalseWithConnectionsConstraint(inputKubeMetricsSendToRoutesFalseWithConnectionsConstraint InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint) InputKubeMetrics {
	typ := InputKubeMetricsUnionTypeInputKubeMetricsSendToRoutesFalseWithConnectionsConstraint

	return InputKubeMetrics{
		InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint: &inputKubeMetricsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKubeMetricsInputKubeMetricsPqEnabledFalseWithPqConstraint(inputKubeMetricsPqEnabledFalseWithPqConstraint InputKubeMetricsPqEnabledFalseWithPqConstraint) InputKubeMetrics {
	typ := InputKubeMetricsUnionTypeInputKubeMetricsPqEnabledFalseWithPqConstraint

	return InputKubeMetrics{
		InputKubeMetricsPqEnabledFalseWithPqConstraint: &inputKubeMetricsPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputKubeMetricsInputKubeMetricsPqEnabledTrueWithPqConstraint(inputKubeMetricsPqEnabledTrueWithPqConstraint InputKubeMetricsPqEnabledTrueWithPqConstraint) InputKubeMetrics {
	typ := InputKubeMetricsUnionTypeInputKubeMetricsPqEnabledTrueWithPqConstraint

	return InputKubeMetrics{
		InputKubeMetricsPqEnabledTrueWithPqConstraint: &inputKubeMetricsPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputKubeMetrics) UnmarshalJSON(data []byte) error {

	var inputKubeMetricsSendToRoutesTrueWithConnectionsConstraint InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint = InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeMetricsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint = &inputKubeMetricsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputKubeMetricsUnionTypeInputKubeMetricsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputKubeMetricsSendToRoutesFalseWithConnectionsConstraint InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint = InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeMetricsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint = &inputKubeMetricsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputKubeMetricsUnionTypeInputKubeMetricsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputKubeMetricsPqEnabledFalseWithPqConstraint InputKubeMetricsPqEnabledFalseWithPqConstraint = InputKubeMetricsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeMetricsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputKubeMetricsPqEnabledFalseWithPqConstraint = &inputKubeMetricsPqEnabledFalseWithPqConstraint
		u.Type = InputKubeMetricsUnionTypeInputKubeMetricsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputKubeMetricsPqEnabledTrueWithPqConstraint InputKubeMetricsPqEnabledTrueWithPqConstraint = InputKubeMetricsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKubeMetricsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputKubeMetricsPqEnabledTrueWithPqConstraint = &inputKubeMetricsPqEnabledTrueWithPqConstraint
		u.Type = InputKubeMetricsUnionTypeInputKubeMetricsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputKubeMetrics", string(data))
}

func (u InputKubeMetrics) MarshalJSON() ([]byte, error) {
	if u.InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKubeMetricsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputKubeMetricsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKubeMetricsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputKubeMetricsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKubeMetricsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputKubeMetrics: all fields are null")
}

type InputSystemStatePqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputSystemStateType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
	Interval *float64 `default:"300" json:"interval"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Collectors  *Collectors                                `json:"collectors,omitempty"`
	Persistence *InputSystemStatePersistence               `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputSystemStatePqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetType() InputSystemStateType {
	if i == nil {
		return InputSystemStateType("")
	}
	return i.Type
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetCollectors() *Collectors {
	if i == nil {
		return nil
	}
	return i.Collectors
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetPersistence() *InputSystemStatePersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputSystemStatePqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSystemStatePqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputSystemStateType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
	Interval *float64 `default:"300" json:"interval"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Collectors  *Collectors                                `json:"collectors,omitempty"`
	Persistence *InputSystemStatePersistence               `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputSystemStatePqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetType() InputSystemStateType {
	if i == nil {
		return InputSystemStateType("")
	}
	return i.Type
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetCollectors() *Collectors {
	if i == nil {
		return nil
	}
	return i.Collectors
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetPersistence() *InputSystemStatePersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputSystemStatePqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSystemStateSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputSystemStateType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
	Interval *float64 `default:"300" json:"interval"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Collectors  *Collectors                                `json:"collectors,omitempty"`
	Persistence *InputSystemStatePersistence               `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputSystemStateSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetType() InputSystemStateType {
	if i == nil {
		return InputSystemStateType("")
	}
	return i.Type
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetCollectors() *Collectors {
	if i == nil {
		return nil
	}
	return i.Collectors
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetPersistence() *InputSystemStatePersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputSystemStateSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSystemStateType string

const (
	InputSystemStateTypeSystemState InputSystemStateType = "system_state"
)

func (e InputSystemStateType) ToPointer() *InputSystemStateType {
	return &e
}
func (e *InputSystemStateType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system_state":
		*e = InputSystemStateType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSystemStateType: %v", v)
	}
}

// HostsFile - Creates events based on entries collected from the hosts file
type HostsFile struct {
	Enable *bool `default:"true" json:"enable"`
}

func (h HostsFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(h, "", false)
}

func (h *HostsFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &h, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (h *HostsFile) GetEnable() *bool {
	if h == nil {
		return nil
	}
	return h.Enable
}

// Interfaces - Creates events for each of the hosts network interfaces
type Interfaces struct {
	Enable *bool `default:"true" json:"enable"`
}

func (i Interfaces) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *Interfaces) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *Interfaces) GetEnable() *bool {
	if i == nil {
		return nil
	}
	return i.Enable
}

// DisksAndFileSystems - Creates events for physical disks, partitions, and file systems
type DisksAndFileSystems struct {
	Enable *bool `default:"true" json:"enable"`
}

func (d DisksAndFileSystems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DisksAndFileSystems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DisksAndFileSystems) GetEnable() *bool {
	if d == nil {
		return nil
	}
	return d.Enable
}

// HostInfo - Creates events based on the host systems current state
type HostInfo struct {
	Enable *bool `default:"true" json:"enable"`
}

func (h HostInfo) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(h, "", false)
}

func (h *HostInfo) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &h, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (h *HostInfo) GetEnable() *bool {
	if h == nil {
		return nil
	}
	return h.Enable
}

// Routes - Creates events based on entries collected from the hosts network routes
type Routes struct {
	Enable *bool `default:"true" json:"enable"`
}

func (r Routes) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Routes) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *Routes) GetEnable() *bool {
	if r == nil {
		return nil
	}
	return r.Enable
}

// DNS - Creates events for DNS resolvers and search entries
type DNS struct {
	Enable *bool `default:"true" json:"enable"`
}

func (d DNS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DNS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DNS) GetEnable() *bool {
	if d == nil {
		return nil
	}
	return d.Enable
}

// UsersAndGroups - Creates events for local users and groups
type UsersAndGroups struct {
	Enable *bool `default:"true" json:"enable"`
}

func (u UsersAndGroups) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UsersAndGroups) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (u *UsersAndGroups) GetEnable() *bool {
	if u == nil {
		return nil
	}
	return u.Enable
}

// Firewall - Creates events for Firewall rules entries
type Firewall struct {
	Enable *bool `default:"true" json:"enable"`
}

func (f Firewall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *Firewall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *Firewall) GetEnable() *bool {
	if f == nil {
		return nil
	}
	return f.Enable
}

// Services - Creates events from the list of services
type Services struct {
	Enable *bool `default:"true" json:"enable"`
}

func (s Services) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Services) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *Services) GetEnable() *bool {
	if s == nil {
		return nil
	}
	return s.Enable
}

// ListeningPorts - Creates events from list of listening ports
type ListeningPorts struct {
	Enable *bool `default:"true" json:"enable"`
}

func (l ListeningPorts) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListeningPorts) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *ListeningPorts) GetEnable() *bool {
	if l == nil {
		return nil
	}
	return l.Enable
}

// LoggedInUsers - Creates events from list of logged-in users
type LoggedInUsers struct {
	Enable *bool `default:"true" json:"enable"`
}

func (l LoggedInUsers) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LoggedInUsers) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LoggedInUsers) GetEnable() *bool {
	if l == nil {
		return nil
	}
	return l.Enable
}

type Collectors struct {
	// Creates events based on entries collected from the hosts file
	Hostsfile *HostsFile `json:"hostsfile,omitempty"`
	// Creates events for each of the hosts network interfaces
	Interfaces *Interfaces `json:"interfaces,omitempty"`
	// Creates events for physical disks, partitions, and file systems
	Disk *DisksAndFileSystems `json:"disk,omitempty"`
	// Creates events based on the host systems current state
	Metadata *HostInfo `json:"metadata,omitempty"`
	// Creates events based on entries collected from the hosts network routes
	Routes *Routes `json:"routes,omitempty"`
	// Creates events for DNS resolvers and search entries
	DNS *DNS `json:"dns,omitempty"`
	// Creates events for local users and groups
	User *UsersAndGroups `json:"user,omitempty"`
	// Creates events for Firewall rules entries
	Firewall *Firewall `json:"firewall,omitempty"`
	// Creates events from the list of services
	Services *Services `json:"services,omitempty"`
	// Creates events from list of listening ports
	Ports *ListeningPorts `json:"ports,omitempty"`
	// Creates events from list of logged-in users
	LoginUsers *LoggedInUsers `json:"loginUsers,omitempty"`
}

func (c Collectors) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Collectors) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *Collectors) GetHostsfile() *HostsFile {
	if c == nil {
		return nil
	}
	return c.Hostsfile
}

func (c *Collectors) GetInterfaces() *Interfaces {
	if c == nil {
		return nil
	}
	return c.Interfaces
}

func (c *Collectors) GetDisk() *DisksAndFileSystems {
	if c == nil {
		return nil
	}
	return c.Disk
}

func (c *Collectors) GetMetadata() *HostInfo {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *Collectors) GetRoutes() *Routes {
	if c == nil {
		return nil
	}
	return c.Routes
}

func (c *Collectors) GetDNS() *DNS {
	if c == nil {
		return nil
	}
	return c.DNS
}

func (c *Collectors) GetUser() *UsersAndGroups {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *Collectors) GetFirewall() *Firewall {
	if c == nil {
		return nil
	}
	return c.Firewall
}

func (c *Collectors) GetServices() *Services {
	if c == nil {
		return nil
	}
	return c.Services
}

func (c *Collectors) GetPorts() *ListeningPorts {
	if c == nil {
		return nil
	}
	return c.Ports
}

func (c *Collectors) GetLoginUsers() *LoggedInUsers {
	if c == nil {
		return nil
	}
	return c.LoginUsers
}

type DataCompressionFormat string

const (
	DataCompressionFormatNone DataCompressionFormat = "none"
	DataCompressionFormatGzip DataCompressionFormat = "gzip"
)

func (e DataCompressionFormat) ToPointer() *DataCompressionFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *DataCompressionFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "gzip":
			return true
		}
	}
	return false
}

type InputSystemStatePersistence struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `default:"false" json:"enable"`
	// Time span for each file bucket
	TimeWindow *string `default:"10m" json:"timeWindow"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `default:"1GB" json:"maxDataSize"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                `default:"24h" json:"maxDataTime"`
	Compress    *DataCompressionFormat `default:"none" json:"compress"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state
	DestPath *string `default:"$CRIBL_HOME/state/system_state" json:"destPath"`
}

func (i InputSystemStatePersistence) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemStatePersistence) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemStatePersistence) GetEnable() *bool {
	if i == nil {
		return nil
	}
	return i.Enable
}

func (i *InputSystemStatePersistence) GetTimeWindow() *string {
	if i == nil {
		return nil
	}
	return i.TimeWindow
}

func (i *InputSystemStatePersistence) GetMaxDataSize() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataSize
}

func (i *InputSystemStatePersistence) GetMaxDataTime() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataTime
}

func (i *InputSystemStatePersistence) GetCompress() *DataCompressionFormat {
	if i == nil {
		return nil
	}
	return i.Compress
}

func (i *InputSystemStatePersistence) GetDestPath() *string {
	if i == nil {
		return nil
	}
	return i.DestPath
}

type InputSystemStateSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     InputSystemStateType `json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
	Interval *float64 `default:"300" json:"interval"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Collectors  *Collectors                                `json:"collectors,omitempty"`
	Persistence *InputSystemStatePersistence               `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputSystemStateSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetType() InputSystemStateType {
	if i == nil {
		return InputSystemStateType("")
	}
	return i.Type
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetCollectors() *Collectors {
	if i == nil {
		return nil
	}
	return i.Collectors
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetPersistence() *InputSystemStatePersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputSystemStateSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSystemStateUnionType string

const (
	InputSystemStateUnionTypeInputSystemStateSendToRoutesTrueWithConnectionsConstraint  InputSystemStateUnionType = "InputSystemState_SendToRoutesTrueWithConnectionsConstraint"
	InputSystemStateUnionTypeInputSystemStateSendToRoutesFalseWithConnectionsConstraint InputSystemStateUnionType = "InputSystemState_SendToRoutesFalseWithConnectionsConstraint"
	InputSystemStateUnionTypeInputSystemStatePqEnabledFalseWithPqConstraint             InputSystemStateUnionType = "InputSystemState_PqEnabledFalseWithPqConstraint"
	InputSystemStateUnionTypeInputSystemStatePqEnabledTrueWithPqConstraint              InputSystemStateUnionType = "InputSystemState_PqEnabledTrueWithPqConstraint"
)

type InputSystemState struct {
	InputSystemStateSendToRoutesTrueWithConnectionsConstraint  *InputSystemStateSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputSystemStateSendToRoutesFalseWithConnectionsConstraint *InputSystemStateSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputSystemStatePqEnabledFalseWithPqConstraint             *InputSystemStatePqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputSystemStatePqEnabledTrueWithPqConstraint              *InputSystemStatePqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputSystemStateUnionType
}

func CreateInputSystemStateInputSystemStateSendToRoutesTrueWithConnectionsConstraint(inputSystemStateSendToRoutesTrueWithConnectionsConstraint InputSystemStateSendToRoutesTrueWithConnectionsConstraint) InputSystemState {
	typ := InputSystemStateUnionTypeInputSystemStateSendToRoutesTrueWithConnectionsConstraint

	return InputSystemState{
		InputSystemStateSendToRoutesTrueWithConnectionsConstraint: &inputSystemStateSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSystemStateInputSystemStateSendToRoutesFalseWithConnectionsConstraint(inputSystemStateSendToRoutesFalseWithConnectionsConstraint InputSystemStateSendToRoutesFalseWithConnectionsConstraint) InputSystemState {
	typ := InputSystemStateUnionTypeInputSystemStateSendToRoutesFalseWithConnectionsConstraint

	return InputSystemState{
		InputSystemStateSendToRoutesFalseWithConnectionsConstraint: &inputSystemStateSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSystemStateInputSystemStatePqEnabledFalseWithPqConstraint(inputSystemStatePqEnabledFalseWithPqConstraint InputSystemStatePqEnabledFalseWithPqConstraint) InputSystemState {
	typ := InputSystemStateUnionTypeInputSystemStatePqEnabledFalseWithPqConstraint

	return InputSystemState{
		InputSystemStatePqEnabledFalseWithPqConstraint: &inputSystemStatePqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputSystemStateInputSystemStatePqEnabledTrueWithPqConstraint(inputSystemStatePqEnabledTrueWithPqConstraint InputSystemStatePqEnabledTrueWithPqConstraint) InputSystemState {
	typ := InputSystemStateUnionTypeInputSystemStatePqEnabledTrueWithPqConstraint

	return InputSystemState{
		InputSystemStatePqEnabledTrueWithPqConstraint: &inputSystemStatePqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputSystemState) UnmarshalJSON(data []byte) error {

	var inputSystemStateSendToRoutesTrueWithConnectionsConstraint InputSystemStateSendToRoutesTrueWithConnectionsConstraint = InputSystemStateSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSystemStateSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSystemStateSendToRoutesTrueWithConnectionsConstraint = &inputSystemStateSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputSystemStateUnionTypeInputSystemStateSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputSystemStateSendToRoutesFalseWithConnectionsConstraint InputSystemStateSendToRoutesFalseWithConnectionsConstraint = InputSystemStateSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSystemStateSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSystemStateSendToRoutesFalseWithConnectionsConstraint = &inputSystemStateSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputSystemStateUnionTypeInputSystemStateSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputSystemStatePqEnabledFalseWithPqConstraint InputSystemStatePqEnabledFalseWithPqConstraint = InputSystemStatePqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSystemStatePqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputSystemStatePqEnabledFalseWithPqConstraint = &inputSystemStatePqEnabledFalseWithPqConstraint
		u.Type = InputSystemStateUnionTypeInputSystemStatePqEnabledFalseWithPqConstraint
		return nil
	}

	var inputSystemStatePqEnabledTrueWithPqConstraint InputSystemStatePqEnabledTrueWithPqConstraint = InputSystemStatePqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSystemStatePqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputSystemStatePqEnabledTrueWithPqConstraint = &inputSystemStatePqEnabledTrueWithPqConstraint
		u.Type = InputSystemStateUnionTypeInputSystemStatePqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSystemState", string(data))
}

func (u InputSystemState) MarshalJSON() ([]byte, error) {
	if u.InputSystemStateSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSystemStateSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputSystemStateSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSystemStateSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputSystemStatePqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSystemStatePqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputSystemStatePqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSystemStatePqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputSystemState: all fields are null")
}

type InputSystemMetricsPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputSystemMetricsType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval  *float64                `default:"10" json:"interval"`
	Host      *InputSystemMetricsHost `json:"host,omitempty"`
	Process   *components.ProcessType `json:"process,omitempty"`
	Container *Container              `json:"container,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputSystemMetricsPersistence             `json:"persistence,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputSystemMetricsPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetType() InputSystemMetricsType {
	if i == nil {
		return InputSystemMetricsType("")
	}
	return i.Type
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetHost() *InputSystemMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetProcess() *components.ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetContainer() *Container {
	if i == nil {
		return nil
	}
	return i.Container
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetPersistence() *InputSystemMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputSystemMetricsPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSystemMetricsPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputSystemMetricsType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval  *float64                `default:"10" json:"interval"`
	Host      *InputSystemMetricsHost `json:"host,omitempty"`
	Process   *components.ProcessType `json:"process,omitempty"`
	Container *Container              `json:"container,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputSystemMetricsPersistence             `json:"persistence,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputSystemMetricsPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetType() InputSystemMetricsType {
	if i == nil {
		return InputSystemMetricsType("")
	}
	return i.Type
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetHost() *InputSystemMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetProcess() *components.ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetContainer() *Container {
	if i == nil {
		return nil
	}
	return i.Container
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetPersistence() *InputSystemMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputSystemMetricsPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputSystemMetricsType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval  *float64                `default:"10" json:"interval"`
	Host      *InputSystemMetricsHost `json:"host,omitempty"`
	Process   *components.ProcessType `json:"process,omitempty"`
	Container *Container              `json:"container,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputSystemMetricsPersistence             `json:"persistence,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetType() InputSystemMetricsType {
	if i == nil {
		return InputSystemMetricsType("")
	}
	return i.Type
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetHost() *InputSystemMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetProcess() *components.ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetContainer() *Container {
	if i == nil {
		return nil
	}
	return i.Container
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetPersistence() *InputSystemMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSystemMetricsType string

const (
	InputSystemMetricsTypeSystemMetrics InputSystemMetricsType = "system_metrics"
)

func (e InputSystemMetricsType) ToPointer() *InputSystemMetricsType {
	return &e
}
func (e *InputSystemMetricsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system_metrics":
		*e = InputSystemMetricsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSystemMetricsType: %v", v)
	}
}

// InputSystemMetricsSystemMode - Select the level of detail for system metrics
type InputSystemMetricsSystemMode string

const (
	// InputSystemMetricsSystemModeBasic Basic
	InputSystemMetricsSystemModeBasic InputSystemMetricsSystemMode = "basic"
	// InputSystemMetricsSystemModeAll All
	InputSystemMetricsSystemModeAll InputSystemMetricsSystemMode = "all"
	// InputSystemMetricsSystemModeCustom Custom
	InputSystemMetricsSystemModeCustom InputSystemMetricsSystemMode = "custom"
	// InputSystemMetricsSystemModeDisabled Disabled
	InputSystemMetricsSystemModeDisabled InputSystemMetricsSystemMode = "disabled"
)

func (e InputSystemMetricsSystemMode) ToPointer() *InputSystemMetricsSystemMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSystemMetricsSystemMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputSystemMetricsSystem struct {
	// Select the level of detail for system metrics
	Mode *InputSystemMetricsSystemMode `default:"basic" json:"mode"`
	// Generate metrics for the numbers of processes in various states
	Processes *bool `default:"false" json:"processes"`
}

func (i InputSystemMetricsSystem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsSystem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsSystem) GetMode() *InputSystemMetricsSystemMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputSystemMetricsSystem) GetProcesses() *bool {
	if i == nil {
		return nil
	}
	return i.Processes
}

// InputSystemMetricsCPUMode - Select the level of detail for CPU metrics
type InputSystemMetricsCPUMode string

const (
	// InputSystemMetricsCPUModeBasic Basic
	InputSystemMetricsCPUModeBasic InputSystemMetricsCPUMode = "basic"
	// InputSystemMetricsCPUModeAll All
	InputSystemMetricsCPUModeAll InputSystemMetricsCPUMode = "all"
	// InputSystemMetricsCPUModeCustom Custom
	InputSystemMetricsCPUModeCustom InputSystemMetricsCPUMode = "custom"
	// InputSystemMetricsCPUModeDisabled Disabled
	InputSystemMetricsCPUModeDisabled InputSystemMetricsCPUMode = "disabled"
)

func (e InputSystemMetricsCPUMode) ToPointer() *InputSystemMetricsCPUMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSystemMetricsCPUMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputSystemMetricsCPU struct {
	// Select the level of detail for CPU metrics
	Mode *InputSystemMetricsCPUMode `default:"basic" json:"mode"`
	// Generate metrics for each CPU
	PerCPU *bool `default:"false" json:"perCpu"`
	// Generate metrics for all CPU states
	Detail *bool `default:"false" json:"detail"`
	// Generate raw, monotonic CPU time counters
	Time *bool `default:"false" json:"time"`
}

func (i InputSystemMetricsCPU) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsCPU) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsCPU) GetMode() *InputSystemMetricsCPUMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputSystemMetricsCPU) GetPerCPU() *bool {
	if i == nil {
		return nil
	}
	return i.PerCPU
}

func (i *InputSystemMetricsCPU) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputSystemMetricsCPU) GetTime() *bool {
	if i == nil {
		return nil
	}
	return i.Time
}

// InputSystemMetricsMemoryMode - Select the level of detail for memory metrics
type InputSystemMetricsMemoryMode string

const (
	// InputSystemMetricsMemoryModeBasic Basic
	InputSystemMetricsMemoryModeBasic InputSystemMetricsMemoryMode = "basic"
	// InputSystemMetricsMemoryModeAll All
	InputSystemMetricsMemoryModeAll InputSystemMetricsMemoryMode = "all"
	// InputSystemMetricsMemoryModeCustom Custom
	InputSystemMetricsMemoryModeCustom InputSystemMetricsMemoryMode = "custom"
	// InputSystemMetricsMemoryModeDisabled Disabled
	InputSystemMetricsMemoryModeDisabled InputSystemMetricsMemoryMode = "disabled"
)

func (e InputSystemMetricsMemoryMode) ToPointer() *InputSystemMetricsMemoryMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSystemMetricsMemoryMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputSystemMetricsMemory struct {
	// Select the level of detail for memory metrics
	Mode *InputSystemMetricsMemoryMode `default:"basic" json:"mode"`
	// Generate metrics for all memory states
	Detail *bool `default:"false" json:"detail"`
}

func (i InputSystemMetricsMemory) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsMemory) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsMemory) GetMode() *InputSystemMetricsMemoryMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputSystemMetricsMemory) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

// InputSystemMetricsNetworkMode - Select the level of detail for network metrics
type InputSystemMetricsNetworkMode string

const (
	// InputSystemMetricsNetworkModeBasic Basic
	InputSystemMetricsNetworkModeBasic InputSystemMetricsNetworkMode = "basic"
	// InputSystemMetricsNetworkModeAll All
	InputSystemMetricsNetworkModeAll InputSystemMetricsNetworkMode = "all"
	// InputSystemMetricsNetworkModeCustom Custom
	InputSystemMetricsNetworkModeCustom InputSystemMetricsNetworkMode = "custom"
	// InputSystemMetricsNetworkModeDisabled Disabled
	InputSystemMetricsNetworkModeDisabled InputSystemMetricsNetworkMode = "disabled"
)

func (e InputSystemMetricsNetworkMode) ToPointer() *InputSystemMetricsNetworkMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSystemMetricsNetworkMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputSystemMetricsNetwork struct {
	// Select the level of detail for network metrics
	Mode *InputSystemMetricsNetworkMode `default:"basic" json:"mode"`
	// Generate full network metrics
	Detail *bool `default:"false" json:"detail"`
	// Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
	Protocols *bool `default:"false" json:"protocols"`
	// Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Generate separate metrics for each interface
	PerInterface *bool `default:"false" json:"perInterface"`
}

func (i InputSystemMetricsNetwork) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsNetwork) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsNetwork) GetMode() *InputSystemMetricsNetworkMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputSystemMetricsNetwork) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputSystemMetricsNetwork) GetProtocols() *bool {
	if i == nil {
		return nil
	}
	return i.Protocols
}

func (i *InputSystemMetricsNetwork) GetDevices() []string {
	if i == nil {
		return nil
	}
	return i.Devices
}

func (i *InputSystemMetricsNetwork) GetPerInterface() *bool {
	if i == nil {
		return nil
	}
	return i.PerInterface
}

// InputSystemMetricsDiskMode - Select the level of detail for disk metrics
type InputSystemMetricsDiskMode string

const (
	// InputSystemMetricsDiskModeBasic Basic
	InputSystemMetricsDiskModeBasic InputSystemMetricsDiskMode = "basic"
	// InputSystemMetricsDiskModeAll All
	InputSystemMetricsDiskModeAll InputSystemMetricsDiskMode = "all"
	// InputSystemMetricsDiskModeCustom Custom
	InputSystemMetricsDiskModeCustom InputSystemMetricsDiskMode = "custom"
	// InputSystemMetricsDiskModeDisabled Disabled
	InputSystemMetricsDiskModeDisabled InputSystemMetricsDiskMode = "disabled"
)

func (e InputSystemMetricsDiskMode) ToPointer() *InputSystemMetricsDiskMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSystemMetricsDiskMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputSystemMetricsDisk struct {
	// Select the level of detail for disk metrics
	Mode *InputSystemMetricsDiskMode `default:"basic" json:"mode"`
	// Generate full disk metrics
	Detail *bool `default:"false" json:"detail"`
	// Generate filesystem inode metrics
	Inodes *bool `default:"false" json:"inodes"`
	// Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty.
	Mountpoints []string `json:"mountpoints,omitempty"`
	// Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty.
	Fstypes []string `json:"fstypes,omitempty"`
	// Generate separate metrics for each device
	PerDevice *bool `default:"false" json:"perDevice"`
}

func (i InputSystemMetricsDisk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsDisk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsDisk) GetMode() *InputSystemMetricsDiskMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputSystemMetricsDisk) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputSystemMetricsDisk) GetInodes() *bool {
	if i == nil {
		return nil
	}
	return i.Inodes
}

func (i *InputSystemMetricsDisk) GetDevices() []string {
	if i == nil {
		return nil
	}
	return i.Devices
}

func (i *InputSystemMetricsDisk) GetMountpoints() []string {
	if i == nil {
		return nil
	}
	return i.Mountpoints
}

func (i *InputSystemMetricsDisk) GetFstypes() []string {
	if i == nil {
		return nil
	}
	return i.Fstypes
}

func (i *InputSystemMetricsDisk) GetPerDevice() *bool {
	if i == nil {
		return nil
	}
	return i.PerDevice
}

type InputSystemMetricsCustom struct {
	System  *InputSystemMetricsSystem  `json:"system,omitempty"`
	CPU     *InputSystemMetricsCPU     `json:"cpu,omitempty"`
	Memory  *InputSystemMetricsMemory  `json:"memory,omitempty"`
	Network *InputSystemMetricsNetwork `json:"network,omitempty"`
	Disk    *InputSystemMetricsDisk    `json:"disk,omitempty"`
}

func (i InputSystemMetricsCustom) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsCustom) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsCustom) GetSystem() *InputSystemMetricsSystem {
	if i == nil {
		return nil
	}
	return i.System
}

func (i *InputSystemMetricsCustom) GetCPU() *InputSystemMetricsCPU {
	if i == nil {
		return nil
	}
	return i.CPU
}

func (i *InputSystemMetricsCustom) GetMemory() *InputSystemMetricsMemory {
	if i == nil {
		return nil
	}
	return i.Memory
}

func (i *InputSystemMetricsCustom) GetNetwork() *InputSystemMetricsNetwork {
	if i == nil {
		return nil
	}
	return i.Network
}

func (i *InputSystemMetricsCustom) GetDisk() *InputSystemMetricsDisk {
	if i == nil {
		return nil
	}
	return i.Disk
}

type InputSystemMetricsHost struct {
	// Select level of detail for host metrics
	Mode   *components.ModeOptionsHost `default:"basic" json:"mode"`
	Custom *InputSystemMetricsCustom   `json:"custom,omitempty"`
}

func (i InputSystemMetricsHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsHost) GetMode() *components.ModeOptionsHost {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputSystemMetricsHost) GetCustom() *InputSystemMetricsCustom {
	if i == nil {
		return nil
	}
	return i.Custom
}

// ContainerMode - Select the level of detail for container metrics
type ContainerMode string

const (
	// ContainerModeBasic Basic
	ContainerModeBasic ContainerMode = "basic"
	// ContainerModeAll All
	ContainerModeAll ContainerMode = "all"
	// ContainerModeCustom Custom
	ContainerModeCustom ContainerMode = "custom"
	// ContainerModeDisabled Disabled
	ContainerModeDisabled ContainerMode = "disabled"
)

func (e ContainerMode) ToPointer() *ContainerMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ContainerMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputSystemMetricsFilter struct {
	Expr string `json:"expr"`
}

func (i InputSystemMetricsFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"expr"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsFilter) GetExpr() string {
	if i == nil {
		return ""
	}
	return i.Expr
}

type Container struct {
	// Select the level of detail for container metrics
	Mode *ContainerMode `default:"basic" json:"mode"`
	// Full paths for Docker's UNIX-domain socket
	DockerSocket []string `json:"dockerSocket,omitempty"`
	// Timeout, in seconds, for the Docker API
	DockerTimeout *float64 `default:"5" json:"dockerTimeout"`
	// Containers matching any of these will be included. All are included if no filters are added.
	Filters []InputSystemMetricsFilter `json:"filters,omitempty"`
	// Include stopped and paused containers
	AllContainers *bool `default:"false" json:"allContainers"`
	// Generate separate metrics for each device
	PerDevice *bool `default:"false" json:"perDevice"`
	// Generate full container metrics
	Detail *bool `default:"false" json:"detail"`
}

func (c Container) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Container) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *Container) GetMode() *ContainerMode {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *Container) GetDockerSocket() []string {
	if c == nil {
		return nil
	}
	return c.DockerSocket
}

func (c *Container) GetDockerTimeout() *float64 {
	if c == nil {
		return nil
	}
	return c.DockerTimeout
}

func (c *Container) GetFilters() []InputSystemMetricsFilter {
	if c == nil {
		return nil
	}
	return c.Filters
}

func (c *Container) GetAllContainers() *bool {
	if c == nil {
		return nil
	}
	return c.AllContainers
}

func (c *Container) GetPerDevice() *bool {
	if c == nil {
		return nil
	}
	return c.PerDevice
}

func (c *Container) GetDetail() *bool {
	if c == nil {
		return nil
	}
	return c.Detail
}

type InputSystemMetricsPersistence struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `default:"false" json:"enable"`
	// Time span for each file bucket
	TimeWindow *string `default:"10m" json:"timeWindow"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `default:"1GB" json:"maxDataSize"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                             `default:"24h" json:"maxDataTime"`
	Compress    *components.DataCompressionFormatOptionsPersistence `default:"gzip" json:"compress"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics
	DestPath *string `default:"$CRIBL_HOME/state/system_metrics" json:"destPath"`
}

func (i InputSystemMetricsPersistence) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsPersistence) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsPersistence) GetEnable() *bool {
	if i == nil {
		return nil
	}
	return i.Enable
}

func (i *InputSystemMetricsPersistence) GetTimeWindow() *string {
	if i == nil {
		return nil
	}
	return i.TimeWindow
}

func (i *InputSystemMetricsPersistence) GetMaxDataSize() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataSize
}

func (i *InputSystemMetricsPersistence) GetMaxDataTime() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataTime
}

func (i *InputSystemMetricsPersistence) GetCompress() *components.DataCompressionFormatOptionsPersistence {
	if i == nil {
		return nil
	}
	return i.Compress
}

func (i *InputSystemMetricsPersistence) GetDestPath() *string {
	if i == nil {
		return nil
	}
	return i.DestPath
}

type InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputSystemMetricsType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval  *float64                `default:"10" json:"interval"`
	Host      *InputSystemMetricsHost `json:"host,omitempty"`
	Process   *components.ProcessType `json:"process,omitempty"`
	Container *Container              `json:"container,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputSystemMetricsPersistence             `json:"persistence,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetType() InputSystemMetricsType {
	if i == nil {
		return InputSystemMetricsType("")
	}
	return i.Type
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetHost() *InputSystemMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetProcess() *components.ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetContainer() *Container {
	if i == nil {
		return nil
	}
	return i.Container
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetPersistence() *InputSystemMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSystemMetricsUnionType string

const (
	InputSystemMetricsUnionTypeInputSystemMetricsSendToRoutesTrueWithConnectionsConstraint  InputSystemMetricsUnionType = "InputSystemMetrics_SendToRoutesTrueWithConnectionsConstraint"
	InputSystemMetricsUnionTypeInputSystemMetricsSendToRoutesFalseWithConnectionsConstraint InputSystemMetricsUnionType = "InputSystemMetrics_SendToRoutesFalseWithConnectionsConstraint"
	InputSystemMetricsUnionTypeInputSystemMetricsPqEnabledFalseWithPqConstraint             InputSystemMetricsUnionType = "InputSystemMetrics_PqEnabledFalseWithPqConstraint"
	InputSystemMetricsUnionTypeInputSystemMetricsPqEnabledTrueWithPqConstraint              InputSystemMetricsUnionType = "InputSystemMetrics_PqEnabledTrueWithPqConstraint"
)

type InputSystemMetrics struct {
	InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint  *InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint *InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputSystemMetricsPqEnabledFalseWithPqConstraint             *InputSystemMetricsPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputSystemMetricsPqEnabledTrueWithPqConstraint              *InputSystemMetricsPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputSystemMetricsUnionType
}

func CreateInputSystemMetricsInputSystemMetricsSendToRoutesTrueWithConnectionsConstraint(inputSystemMetricsSendToRoutesTrueWithConnectionsConstraint InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint) InputSystemMetrics {
	typ := InputSystemMetricsUnionTypeInputSystemMetricsSendToRoutesTrueWithConnectionsConstraint

	return InputSystemMetrics{
		InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint: &inputSystemMetricsSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSystemMetricsInputSystemMetricsSendToRoutesFalseWithConnectionsConstraint(inputSystemMetricsSendToRoutesFalseWithConnectionsConstraint InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint) InputSystemMetrics {
	typ := InputSystemMetricsUnionTypeInputSystemMetricsSendToRoutesFalseWithConnectionsConstraint

	return InputSystemMetrics{
		InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint: &inputSystemMetricsSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSystemMetricsInputSystemMetricsPqEnabledFalseWithPqConstraint(inputSystemMetricsPqEnabledFalseWithPqConstraint InputSystemMetricsPqEnabledFalseWithPqConstraint) InputSystemMetrics {
	typ := InputSystemMetricsUnionTypeInputSystemMetricsPqEnabledFalseWithPqConstraint

	return InputSystemMetrics{
		InputSystemMetricsPqEnabledFalseWithPqConstraint: &inputSystemMetricsPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputSystemMetricsInputSystemMetricsPqEnabledTrueWithPqConstraint(inputSystemMetricsPqEnabledTrueWithPqConstraint InputSystemMetricsPqEnabledTrueWithPqConstraint) InputSystemMetrics {
	typ := InputSystemMetricsUnionTypeInputSystemMetricsPqEnabledTrueWithPqConstraint

	return InputSystemMetrics{
		InputSystemMetricsPqEnabledTrueWithPqConstraint: &inputSystemMetricsPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputSystemMetrics) UnmarshalJSON(data []byte) error {

	var inputSystemMetricsSendToRoutesTrueWithConnectionsConstraint InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint = InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSystemMetricsSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint = &inputSystemMetricsSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputSystemMetricsUnionTypeInputSystemMetricsSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputSystemMetricsSendToRoutesFalseWithConnectionsConstraint InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint = InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSystemMetricsSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint = &inputSystemMetricsSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputSystemMetricsUnionTypeInputSystemMetricsSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputSystemMetricsPqEnabledFalseWithPqConstraint InputSystemMetricsPqEnabledFalseWithPqConstraint = InputSystemMetricsPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSystemMetricsPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputSystemMetricsPqEnabledFalseWithPqConstraint = &inputSystemMetricsPqEnabledFalseWithPqConstraint
		u.Type = InputSystemMetricsUnionTypeInputSystemMetricsPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputSystemMetricsPqEnabledTrueWithPqConstraint InputSystemMetricsPqEnabledTrueWithPqConstraint = InputSystemMetricsPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSystemMetricsPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputSystemMetricsPqEnabledTrueWithPqConstraint = &inputSystemMetricsPqEnabledTrueWithPqConstraint
		u.Type = InputSystemMetricsUnionTypeInputSystemMetricsPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSystemMetrics", string(data))
}

func (u InputSystemMetrics) MarshalJSON() ([]byte, error) {
	if u.InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSystemMetricsSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputSystemMetricsPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSystemMetricsPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputSystemMetricsPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSystemMetricsPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputSystemMetrics: all fields are null")
}

type InputTcpjsonPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputTcpjsonType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `default:"false" json:"enableLoadBalancing"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	Description *string                                                `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputTcpjsonPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetType() InputTcpjsonType {
	if i == nil {
		return InputTcpjsonType("")
	}
	return i.Type
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputTcpjsonPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputTcpjsonPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputTcpjsonType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `default:"false" json:"enableLoadBalancing"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	Description *string                                                `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputTcpjsonPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetType() InputTcpjsonType {
	if i == nil {
		return InputTcpjsonType("")
	}
	return i.Type
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputTcpjsonPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputTcpjsonSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputTcpjsonType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `default:"false" json:"enableLoadBalancing"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	Description *string                                                `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetType() InputTcpjsonType {
	if i == nil {
		return InputTcpjsonType("")
	}
	return i.Type
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputTcpjsonType string

const (
	InputTcpjsonTypeTcpjson InputTcpjsonType = "tcpjson"
)

func (e InputTcpjsonType) ToPointer() *InputTcpjsonType {
	return &e
}
func (e *InputTcpjsonType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcpjson":
		*e = InputTcpjsonType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputTcpjsonType: %v", v)
	}
}

type InputTcpjsonSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputTcpjsonType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `default:"false" json:"enableLoadBalancing"`
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType    *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	Description *string                                                `json:"description,omitempty"`
	// Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
	AuthToken *string `default:"" json:"authToken"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetType() InputTcpjsonType {
	if i == nil {
		return InputTcpjsonType("")
	}
	return i.Type
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetAuthToken() *string {
	if i == nil {
		return nil
	}
	return i.AuthToken
}

func (i *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputTcpjsonUnionType string

const (
	InputTcpjsonUnionTypeInputTcpjsonSendToRoutesTrueWithConnectionsConstraint  InputTcpjsonUnionType = "InputTcpjson_SendToRoutesTrueWithConnectionsConstraint"
	InputTcpjsonUnionTypeInputTcpjsonSendToRoutesFalseWithConnectionsConstraint InputTcpjsonUnionType = "InputTcpjson_SendToRoutesFalseWithConnectionsConstraint"
	InputTcpjsonUnionTypeInputTcpjsonPqEnabledFalseWithPqConstraint             InputTcpjsonUnionType = "InputTcpjson_PqEnabledFalseWithPqConstraint"
	InputTcpjsonUnionTypeInputTcpjsonPqEnabledTrueWithPqConstraint              InputTcpjsonUnionType = "InputTcpjson_PqEnabledTrueWithPqConstraint"
)

type InputTcpjson struct {
	InputTcpjsonSendToRoutesTrueWithConnectionsConstraint  *InputTcpjsonSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputTcpjsonSendToRoutesFalseWithConnectionsConstraint *InputTcpjsonSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputTcpjsonPqEnabledFalseWithPqConstraint             *InputTcpjsonPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputTcpjsonPqEnabledTrueWithPqConstraint              *InputTcpjsonPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputTcpjsonUnionType
}

func CreateInputTcpjsonInputTcpjsonSendToRoutesTrueWithConnectionsConstraint(inputTcpjsonSendToRoutesTrueWithConnectionsConstraint InputTcpjsonSendToRoutesTrueWithConnectionsConstraint) InputTcpjson {
	typ := InputTcpjsonUnionTypeInputTcpjsonSendToRoutesTrueWithConnectionsConstraint

	return InputTcpjson{
		InputTcpjsonSendToRoutesTrueWithConnectionsConstraint: &inputTcpjsonSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputTcpjsonInputTcpjsonSendToRoutesFalseWithConnectionsConstraint(inputTcpjsonSendToRoutesFalseWithConnectionsConstraint InputTcpjsonSendToRoutesFalseWithConnectionsConstraint) InputTcpjson {
	typ := InputTcpjsonUnionTypeInputTcpjsonSendToRoutesFalseWithConnectionsConstraint

	return InputTcpjson{
		InputTcpjsonSendToRoutesFalseWithConnectionsConstraint: &inputTcpjsonSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputTcpjsonInputTcpjsonPqEnabledFalseWithPqConstraint(inputTcpjsonPqEnabledFalseWithPqConstraint InputTcpjsonPqEnabledFalseWithPqConstraint) InputTcpjson {
	typ := InputTcpjsonUnionTypeInputTcpjsonPqEnabledFalseWithPqConstraint

	return InputTcpjson{
		InputTcpjsonPqEnabledFalseWithPqConstraint: &inputTcpjsonPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputTcpjsonInputTcpjsonPqEnabledTrueWithPqConstraint(inputTcpjsonPqEnabledTrueWithPqConstraint InputTcpjsonPqEnabledTrueWithPqConstraint) InputTcpjson {
	typ := InputTcpjsonUnionTypeInputTcpjsonPqEnabledTrueWithPqConstraint

	return InputTcpjson{
		InputTcpjsonPqEnabledTrueWithPqConstraint: &inputTcpjsonPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputTcpjson) UnmarshalJSON(data []byte) error {

	var inputTcpjsonSendToRoutesTrueWithConnectionsConstraint InputTcpjsonSendToRoutesTrueWithConnectionsConstraint = InputTcpjsonSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputTcpjsonSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputTcpjsonSendToRoutesTrueWithConnectionsConstraint = &inputTcpjsonSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputTcpjsonUnionTypeInputTcpjsonSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputTcpjsonSendToRoutesFalseWithConnectionsConstraint InputTcpjsonSendToRoutesFalseWithConnectionsConstraint = InputTcpjsonSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputTcpjsonSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputTcpjsonSendToRoutesFalseWithConnectionsConstraint = &inputTcpjsonSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputTcpjsonUnionTypeInputTcpjsonSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputTcpjsonPqEnabledFalseWithPqConstraint InputTcpjsonPqEnabledFalseWithPqConstraint = InputTcpjsonPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputTcpjsonPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputTcpjsonPqEnabledFalseWithPqConstraint = &inputTcpjsonPqEnabledFalseWithPqConstraint
		u.Type = InputTcpjsonUnionTypeInputTcpjsonPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputTcpjsonPqEnabledTrueWithPqConstraint InputTcpjsonPqEnabledTrueWithPqConstraint = InputTcpjsonPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputTcpjsonPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputTcpjsonPqEnabledTrueWithPqConstraint = &inputTcpjsonPqEnabledTrueWithPqConstraint
		u.Type = InputTcpjsonUnionTypeInputTcpjsonPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputTcpjson", string(data))
}

func (u InputTcpjson) MarshalJSON() ([]byte, error) {
	if u.InputTcpjsonSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputTcpjsonSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputTcpjsonSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputTcpjsonSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputTcpjsonPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputTcpjsonPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputTcpjsonPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputTcpjsonPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputTcpjson: all fields are null")
}

type InputCriblLakeHTTPPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputCriblLakeHTTPType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `default:"/cribl" json:"criblAPI"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `default:"/elastic" json:"elasticAPI"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `default:"/services/collector" json:"splunkHecAPI"`
	SplunkHecAcks *bool   `default:"false" json:"splunkHecAcks"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	AuthTokensExt []AuthTokensExt                            `json:"authTokensExt,omitempty"`
	Description   *string                                    `json:"description,omitempty"`
}

func (i InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetType() InputCriblLakeHTTPType {
	if i == nil {
		return InputCriblLakeHTTPType("")
	}
	return i.Type
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetCriblAPI() *string {
	if i == nil {
		return nil
	}
	return i.CriblAPI
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetAuthTokensExt() []AuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblLakeHTTPPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputCriblLakeHTTPType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `default:"/cribl" json:"criblAPI"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `default:"/elastic" json:"elasticAPI"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `default:"/services/collector" json:"splunkHecAPI"`
	SplunkHecAcks *bool   `default:"false" json:"splunkHecAcks"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	AuthTokensExt []AuthTokensExt                            `json:"authTokensExt,omitempty"`
	Description   *string                                    `json:"description,omitempty"`
}

func (i InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetType() InputCriblLakeHTTPType {
	if i == nil {
		return InputCriblLakeHTTPType("")
	}
	return i.Type
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetCriblAPI() *string {
	if i == nil {
		return nil
	}
	return i.CriblAPI
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetAuthTokensExt() []AuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputCriblLakeHTTPType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `default:"/cribl" json:"criblAPI"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `default:"/elastic" json:"elasticAPI"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `default:"/services/collector" json:"splunkHecAPI"`
	SplunkHecAcks *bool   `default:"false" json:"splunkHecAcks"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	AuthTokensExt []AuthTokensExt                            `json:"authTokensExt,omitempty"`
	Description   *string                                    `json:"description,omitempty"`
}

func (i InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetType() InputCriblLakeHTTPType {
	if i == nil {
		return InputCriblLakeHTTPType("")
	}
	return i.Type
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetCriblAPI() *string {
	if i == nil {
		return nil
	}
	return i.CriblAPI
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetAuthTokensExt() []AuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblLakeHTTPType string

const (
	InputCriblLakeHTTPTypeCriblLakeHTTP InputCriblLakeHTTPType = "cribl_lake_http"
)

func (e InputCriblLakeHTTPType) ToPointer() *InputCriblLakeHTTPType {
	return &e
}
func (e *InputCriblLakeHTTPType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_lake_http":
		*e = InputCriblLakeHTTPType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCriblLakeHTTPType: %v", v)
	}
}

type SplunkHecMetadata struct {
	Enabled               *bool    `json:"enabled,omitempty"`
	DefaultDataset        *string  `json:"defaultDataset,omitempty"`
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
}

func (s SplunkHecMetadata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkHecMetadata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkHecMetadata) GetEnabled() *bool {
	if s == nil {
		return nil
	}
	return s.Enabled
}

func (s *SplunkHecMetadata) GetDefaultDataset() *string {
	if s == nil {
		return nil
	}
	return s.DefaultDataset
}

func (s *SplunkHecMetadata) GetAllowedIndexesAtToken() []string {
	if s == nil {
		return nil
	}
	return s.AllowedIndexesAtToken
}

type ElasticsearchMetadata struct {
	Enabled        *bool   `json:"enabled,omitempty"`
	DefaultDataset *string `json:"defaultDataset,omitempty"`
}

func (e ElasticsearchMetadata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ElasticsearchMetadata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *ElasticsearchMetadata) GetEnabled() *bool {
	if e == nil {
		return nil
	}
	return e.Enabled
}

func (e *ElasticsearchMetadata) GetDefaultDataset() *string {
	if e == nil {
		return nil
	}
	return e.DefaultDataset
}

type AuthTokensExt struct {
	Token       string  `json:"token"`
	Description *string `json:"description,omitempty"`
	// Fields to add to events referencing this token
	Metadata              []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	SplunkHecMetadata     *SplunkHecMetadata                         `json:"splunkHecMetadata,omitempty"`
	ElasticsearchMetadata *ElasticsearchMetadata                     `json:"elasticsearchMetadata,omitempty"`
}

func (a AuthTokensExt) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AuthTokensExt) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"token"}); err != nil {
		return err
	}
	return nil
}

func (a *AuthTokensExt) GetToken() string {
	if a == nil {
		return ""
	}
	return a.Token
}

func (a *AuthTokensExt) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *AuthTokensExt) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if a == nil {
		return nil
	}
	return a.Metadata
}

func (a *AuthTokensExt) GetSplunkHecMetadata() *SplunkHecMetadata {
	if a == nil {
		return nil
	}
	return a.SplunkHecMetadata
}

func (a *AuthTokensExt) GetElasticsearchMetadata() *ElasticsearchMetadata {
	if a == nil {
		return nil
	}
	return a.ElasticsearchMetadata
}

type InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputCriblLakeHTTPType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `default:"/cribl" json:"criblAPI"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `default:"/elastic" json:"elasticAPI"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `default:"/services/collector" json:"splunkHecAPI"`
	SplunkHecAcks *bool   `default:"false" json:"splunkHecAcks"`
	// Fields to add to events from this input
	Metadata      []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	AuthTokensExt []AuthTokensExt                            `json:"authTokensExt,omitempty"`
	Description   *string                                    `json:"description,omitempty"`
}

func (i InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetType() InputCriblLakeHTTPType {
	if i == nil {
		return InputCriblLakeHTTPType("")
	}
	return i.Type
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetCriblAPI() *string {
	if i == nil {
		return nil
	}
	return i.CriblAPI
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetAuthTokensExt() []AuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblLakeHTTPUnionType string

const (
	InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint  InputCriblLakeHTTPUnionType = "InputCriblLakeHttp_SendToRoutesTrueWithConnectionsConstraint"
	InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint InputCriblLakeHTTPUnionType = "InputCriblLakeHttp_SendToRoutesFalseWithConnectionsConstraint"
	InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPPqEnabledFalseWithPqConstraint             InputCriblLakeHTTPUnionType = "InputCriblLakeHttp_PqEnabledFalseWithPqConstraint"
	InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPPqEnabledTrueWithPqConstraint              InputCriblLakeHTTPUnionType = "InputCriblLakeHttp_PqEnabledTrueWithPqConstraint"
)

type InputCriblLakeHTTP struct {
	InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint  *InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint *InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputCriblLakeHTTPPqEnabledFalseWithPqConstraint             *InputCriblLakeHTTPPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputCriblLakeHTTPPqEnabledTrueWithPqConstraint              *InputCriblLakeHTTPPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputCriblLakeHTTPUnionType
}

func CreateInputCriblLakeHTTPInputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint(inputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint) InputCriblLakeHTTP {
	typ := InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint

	return InputCriblLakeHTTP{
		InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint: &inputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblLakeHTTPInputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint(inputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint) InputCriblLakeHTTP {
	typ := InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint

	return InputCriblLakeHTTP{
		InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint: &inputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblLakeHTTPInputCriblLakeHTTPPqEnabledFalseWithPqConstraint(inputCriblLakeHTTPPqEnabledFalseWithPqConstraint InputCriblLakeHTTPPqEnabledFalseWithPqConstraint) InputCriblLakeHTTP {
	typ := InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPPqEnabledFalseWithPqConstraint

	return InputCriblLakeHTTP{
		InputCriblLakeHTTPPqEnabledFalseWithPqConstraint: &inputCriblLakeHTTPPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputCriblLakeHTTPInputCriblLakeHTTPPqEnabledTrueWithPqConstraint(inputCriblLakeHTTPPqEnabledTrueWithPqConstraint InputCriblLakeHTTPPqEnabledTrueWithPqConstraint) InputCriblLakeHTTP {
	typ := InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPPqEnabledTrueWithPqConstraint

	return InputCriblLakeHTTP{
		InputCriblLakeHTTPPqEnabledTrueWithPqConstraint: &inputCriblLakeHTTPPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputCriblLakeHTTP) UnmarshalJSON(data []byte) error {

	var inputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint = InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint = &inputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint = InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint = &inputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputCriblLakeHTTPPqEnabledFalseWithPqConstraint InputCriblLakeHTTPPqEnabledFalseWithPqConstraint = InputCriblLakeHTTPPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblLakeHTTPPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblLakeHTTPPqEnabledFalseWithPqConstraint = &inputCriblLakeHTTPPqEnabledFalseWithPqConstraint
		u.Type = InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputCriblLakeHTTPPqEnabledTrueWithPqConstraint InputCriblLakeHTTPPqEnabledTrueWithPqConstraint = InputCriblLakeHTTPPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblLakeHTTPPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblLakeHTTPPqEnabledTrueWithPqConstraint = &inputCriblLakeHTTPPqEnabledTrueWithPqConstraint
		u.Type = InputCriblLakeHTTPUnionTypeInputCriblLakeHTTPPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputCriblLakeHTTP", string(data))
}

func (u InputCriblLakeHTTP) MarshalJSON() ([]byte, error) {
	if u.InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblLakeHTTPSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblLakeHTTPSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputCriblLakeHTTPPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblLakeHTTPPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputCriblLakeHTTPPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblLakeHTTPPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputCriblLakeHTTP: all fields are null")
}

type InputCriblHTTPPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputCriblHTTPType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
	AuthTokens []components.ItemsTypeAuthTokens      `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblHTTPPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetType() InputCriblHTTPType {
	if i == nil {
		return InputCriblHTTPType("")
	}
	return i.Type
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblHTTPPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblHTTPPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputCriblHTTPType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
	AuthTokens []components.ItemsTypeAuthTokens      `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblHTTPPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetType() InputCriblHTTPType {
	if i == nil {
		return InputCriblHTTPType("")
	}
	return i.Type
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblHTTPPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputCriblHTTPType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
	AuthTokens []components.ItemsTypeAuthTokens      `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetType() InputCriblHTTPType {
	if i == nil {
		return InputCriblHTTPType("")
	}
	return i.Type
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblHTTPType string

const (
	InputCriblHTTPTypeCriblHTTP InputCriblHTTPType = "cribl_http"
)

func (e InputCriblHTTPType) ToPointer() *InputCriblHTTPType {
	return &e
}
func (e *InputCriblHTTPType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_http":
		*e = InputCriblHTTPType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCriblHTTPType: %v", v)
	}
}

type InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputCriblHTTPType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
	AuthTokens []components.ItemsTypeAuthTokens      `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetType() InputCriblHTTPType {
	if i == nil {
		return InputCriblHTTPType("")
	}
	return i.Type
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblHTTPUnionType string

const (
	InputCriblHTTPUnionTypeInputCriblHTTPSendToRoutesTrueWithConnectionsConstraint  InputCriblHTTPUnionType = "InputCriblHttp_SendToRoutesTrueWithConnectionsConstraint"
	InputCriblHTTPUnionTypeInputCriblHTTPSendToRoutesFalseWithConnectionsConstraint InputCriblHTTPUnionType = "InputCriblHttp_SendToRoutesFalseWithConnectionsConstraint"
	InputCriblHTTPUnionTypeInputCriblHTTPPqEnabledFalseWithPqConstraint             InputCriblHTTPUnionType = "InputCriblHttp_PqEnabledFalseWithPqConstraint"
	InputCriblHTTPUnionTypeInputCriblHTTPPqEnabledTrueWithPqConstraint              InputCriblHTTPUnionType = "InputCriblHttp_PqEnabledTrueWithPqConstraint"
)

type InputCriblHTTP struct {
	InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint  *InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint *InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputCriblHTTPPqEnabledFalseWithPqConstraint             *InputCriblHTTPPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputCriblHTTPPqEnabledTrueWithPqConstraint              *InputCriblHTTPPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputCriblHTTPUnionType
}

func CreateInputCriblHTTPInputCriblHTTPSendToRoutesTrueWithConnectionsConstraint(inputCriblHTTPSendToRoutesTrueWithConnectionsConstraint InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint) InputCriblHTTP {
	typ := InputCriblHTTPUnionTypeInputCriblHTTPSendToRoutesTrueWithConnectionsConstraint

	return InputCriblHTTP{
		InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint: &inputCriblHTTPSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblHTTPInputCriblHTTPSendToRoutesFalseWithConnectionsConstraint(inputCriblHTTPSendToRoutesFalseWithConnectionsConstraint InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint) InputCriblHTTP {
	typ := InputCriblHTTPUnionTypeInputCriblHTTPSendToRoutesFalseWithConnectionsConstraint

	return InputCriblHTTP{
		InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint: &inputCriblHTTPSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblHTTPInputCriblHTTPPqEnabledFalseWithPqConstraint(inputCriblHTTPPqEnabledFalseWithPqConstraint InputCriblHTTPPqEnabledFalseWithPqConstraint) InputCriblHTTP {
	typ := InputCriblHTTPUnionTypeInputCriblHTTPPqEnabledFalseWithPqConstraint

	return InputCriblHTTP{
		InputCriblHTTPPqEnabledFalseWithPqConstraint: &inputCriblHTTPPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputCriblHTTPInputCriblHTTPPqEnabledTrueWithPqConstraint(inputCriblHTTPPqEnabledTrueWithPqConstraint InputCriblHTTPPqEnabledTrueWithPqConstraint) InputCriblHTTP {
	typ := InputCriblHTTPUnionTypeInputCriblHTTPPqEnabledTrueWithPqConstraint

	return InputCriblHTTP{
		InputCriblHTTPPqEnabledTrueWithPqConstraint: &inputCriblHTTPPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputCriblHTTP) UnmarshalJSON(data []byte) error {

	var inputCriblHTTPSendToRoutesTrueWithConnectionsConstraint InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint = InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblHTTPSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint = &inputCriblHTTPSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputCriblHTTPUnionTypeInputCriblHTTPSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputCriblHTTPSendToRoutesFalseWithConnectionsConstraint InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint = InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblHTTPSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint = &inputCriblHTTPSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputCriblHTTPUnionTypeInputCriblHTTPSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputCriblHTTPPqEnabledFalseWithPqConstraint InputCriblHTTPPqEnabledFalseWithPqConstraint = InputCriblHTTPPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblHTTPPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblHTTPPqEnabledFalseWithPqConstraint = &inputCriblHTTPPqEnabledFalseWithPqConstraint
		u.Type = InputCriblHTTPUnionTypeInputCriblHTTPPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputCriblHTTPPqEnabledTrueWithPqConstraint InputCriblHTTPPqEnabledTrueWithPqConstraint = InputCriblHTTPPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblHTTPPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblHTTPPqEnabledTrueWithPqConstraint = &inputCriblHTTPPqEnabledTrueWithPqConstraint
		u.Type = InputCriblHTTPUnionTypeInputCriblHTTPPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputCriblHTTP", string(data))
}

func (u InputCriblHTTP) MarshalJSON() ([]byte, error) {
	if u.InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblHTTPSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblHTTPSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputCriblHTTPPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblHTTPPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputCriblHTTPPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblHTTPPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputCriblHTTP: all fields are null")
}

type InputCriblTCPPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputCriblTCPType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `default:"false" json:"enableLoadBalancing"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
	AuthTokens  []components.ItemsTypeAuthTokens `json:"authTokens,omitempty"`
	Description *string                          `json:"description,omitempty"`
}

func (i InputCriblTCPPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetType() InputCriblTCPType {
	if i == nil {
		return InputCriblTCPType("")
	}
	return i.Type
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblTCPPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblTCPPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputCriblTCPType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `default:"false" json:"enableLoadBalancing"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
	AuthTokens  []components.ItemsTypeAuthTokens `json:"authTokens,omitempty"`
	Description *string                          `json:"description,omitempty"`
}

func (i InputCriblTCPPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetType() InputCriblTCPType {
	if i == nil {
		return InputCriblTCPType("")
	}
	return i.Type
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblTCPPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblTCPSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputCriblTCPType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `default:"false" json:"enableLoadBalancing"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
	AuthTokens  []components.ItemsTypeAuthTokens `json:"authTokens,omitempty"`
	Description *string                          `json:"description,omitempty"`
}

func (i InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetType() InputCriblTCPType {
	if i == nil {
		return InputCriblTCPType("")
	}
	return i.Type
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblTCPType string

const (
	InputCriblTCPTypeCriblTCP InputCriblTCPType = "cribl_tcp"
)

func (e InputCriblTCPType) ToPointer() *InputCriblTCPType {
	return &e
}
func (e *InputCriblTCPType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl_tcp":
		*e = InputCriblTCPType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCriblTCPType: %v", v)
	}
}

type InputCriblTCPSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputCriblTCPType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `default:"false" json:"enableLoadBalancing"`
	// Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
	AuthTokens  []components.ItemsTypeAuthTokens `json:"authTokens,omitempty"`
	Description *string                          `json:"description,omitempty"`
}

func (i InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetType() InputCriblTCPType {
	if i == nil {
		return InputCriblTCPType("")
	}
	return i.Type
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetEnableLoadBalancing() *bool {
	if i == nil {
		return nil
	}
	return i.EnableLoadBalancing
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []components.ItemsTypeAuthTokens {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblTCPUnionType string

const (
	InputCriblTCPUnionTypeInputCriblTCPSendToRoutesTrueWithConnectionsConstraint  InputCriblTCPUnionType = "InputCriblTcp_SendToRoutesTrueWithConnectionsConstraint"
	InputCriblTCPUnionTypeInputCriblTCPSendToRoutesFalseWithConnectionsConstraint InputCriblTCPUnionType = "InputCriblTcp_SendToRoutesFalseWithConnectionsConstraint"
	InputCriblTCPUnionTypeInputCriblTCPPqEnabledFalseWithPqConstraint             InputCriblTCPUnionType = "InputCriblTcp_PqEnabledFalseWithPqConstraint"
	InputCriblTCPUnionTypeInputCriblTCPPqEnabledTrueWithPqConstraint              InputCriblTCPUnionType = "InputCriblTcp_PqEnabledTrueWithPqConstraint"
)

type InputCriblTCP struct {
	InputCriblTCPSendToRoutesTrueWithConnectionsConstraint  *InputCriblTCPSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputCriblTCPSendToRoutesFalseWithConnectionsConstraint *InputCriblTCPSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputCriblTCPPqEnabledFalseWithPqConstraint             *InputCriblTCPPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputCriblTCPPqEnabledTrueWithPqConstraint              *InputCriblTCPPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputCriblTCPUnionType
}

func CreateInputCriblTCPInputCriblTCPSendToRoutesTrueWithConnectionsConstraint(inputCriblTCPSendToRoutesTrueWithConnectionsConstraint InputCriblTCPSendToRoutesTrueWithConnectionsConstraint) InputCriblTCP {
	typ := InputCriblTCPUnionTypeInputCriblTCPSendToRoutesTrueWithConnectionsConstraint

	return InputCriblTCP{
		InputCriblTCPSendToRoutesTrueWithConnectionsConstraint: &inputCriblTCPSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblTCPInputCriblTCPSendToRoutesFalseWithConnectionsConstraint(inputCriblTCPSendToRoutesFalseWithConnectionsConstraint InputCriblTCPSendToRoutesFalseWithConnectionsConstraint) InputCriblTCP {
	typ := InputCriblTCPUnionTypeInputCriblTCPSendToRoutesFalseWithConnectionsConstraint

	return InputCriblTCP{
		InputCriblTCPSendToRoutesFalseWithConnectionsConstraint: &inputCriblTCPSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblTCPInputCriblTCPPqEnabledFalseWithPqConstraint(inputCriblTCPPqEnabledFalseWithPqConstraint InputCriblTCPPqEnabledFalseWithPqConstraint) InputCriblTCP {
	typ := InputCriblTCPUnionTypeInputCriblTCPPqEnabledFalseWithPqConstraint

	return InputCriblTCP{
		InputCriblTCPPqEnabledFalseWithPqConstraint: &inputCriblTCPPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputCriblTCPInputCriblTCPPqEnabledTrueWithPqConstraint(inputCriblTCPPqEnabledTrueWithPqConstraint InputCriblTCPPqEnabledTrueWithPqConstraint) InputCriblTCP {
	typ := InputCriblTCPUnionTypeInputCriblTCPPqEnabledTrueWithPqConstraint

	return InputCriblTCP{
		InputCriblTCPPqEnabledTrueWithPqConstraint: &inputCriblTCPPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputCriblTCP) UnmarshalJSON(data []byte) error {

	var inputCriblTCPSendToRoutesTrueWithConnectionsConstraint InputCriblTCPSendToRoutesTrueWithConnectionsConstraint = InputCriblTCPSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblTCPSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblTCPSendToRoutesTrueWithConnectionsConstraint = &inputCriblTCPSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputCriblTCPUnionTypeInputCriblTCPSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputCriblTCPSendToRoutesFalseWithConnectionsConstraint InputCriblTCPSendToRoutesFalseWithConnectionsConstraint = InputCriblTCPSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblTCPSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblTCPSendToRoutesFalseWithConnectionsConstraint = &inputCriblTCPSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputCriblTCPUnionTypeInputCriblTCPSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputCriblTCPPqEnabledFalseWithPqConstraint InputCriblTCPPqEnabledFalseWithPqConstraint = InputCriblTCPPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblTCPPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblTCPPqEnabledFalseWithPqConstraint = &inputCriblTCPPqEnabledFalseWithPqConstraint
		u.Type = InputCriblTCPUnionTypeInputCriblTCPPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputCriblTCPPqEnabledTrueWithPqConstraint InputCriblTCPPqEnabledTrueWithPqConstraint = InputCriblTCPPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblTCPPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblTCPPqEnabledTrueWithPqConstraint = &inputCriblTCPPqEnabledTrueWithPqConstraint
		u.Type = InputCriblTCPUnionTypeInputCriblTCPPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputCriblTCP", string(data))
}

func (u InputCriblTCP) MarshalJSON() ([]byte, error) {
	if u.InputCriblTCPSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblTCPSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputCriblTCPSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblTCPSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputCriblTCPPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblTCPPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputCriblTCPPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblTCPPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputCriblTCP: all fields are null")
}

type InputCriblPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string         `json:"id"`
	Type     InputCriblType `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	Filter      *string                           `json:"filter,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetType() InputCriblType {
	if i == nil {
		return InputCriblType("")
	}
	return i.Type
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetFilter() *string {
	if i == nil {
		return nil
	}
	return i.Filter
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string         `json:"id"`
	Type     InputCriblType `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	Filter      *string                           `json:"filter,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetType() InputCriblType {
	if i == nil {
		return InputCriblType("")
	}
	return i.Type
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetFilter() *string {
	if i == nil {
		return nil
	}
	return i.Filter
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string         `json:"id"`
	Type     InputCriblType `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	Filter     *string            `json:"filter,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetType() InputCriblType {
	if i == nil {
		return InputCriblType("")
	}
	return i.Type
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetFilter() *string {
	if i == nil {
		return nil
	}
	return i.Filter
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblType string

const (
	InputCriblTypeCribl InputCriblType = "cribl"
)

func (e InputCriblType) ToPointer() *InputCriblType {
	return &e
}
func (e *InputCriblType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cribl":
		*e = InputCriblType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCriblType: %v", v)
	}
}

type InputCriblSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string         `json:"id"`
	Type     InputCriblType `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	Filter     *string            `json:"filter,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputCriblSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetType() InputCriblType {
	if i == nil {
		return InputCriblType("")
	}
	return i.Type
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetFilter() *string {
	if i == nil {
		return nil
	}
	return i.Filter
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCriblSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputCriblUnionType string

const (
	InputCriblUnionTypeInputCriblSendToRoutesTrueWithConnectionsConstraint  InputCriblUnionType = "InputCribl_SendToRoutesTrueWithConnectionsConstraint"
	InputCriblUnionTypeInputCriblSendToRoutesFalseWithConnectionsConstraint InputCriblUnionType = "InputCribl_SendToRoutesFalseWithConnectionsConstraint"
	InputCriblUnionTypeInputCriblPqEnabledFalseWithPqConstraint             InputCriblUnionType = "InputCribl_PqEnabledFalseWithPqConstraint"
	InputCriblUnionTypeInputCriblPqEnabledTrueWithPqConstraint              InputCriblUnionType = "InputCribl_PqEnabledTrueWithPqConstraint"
)

type InputCribl struct {
	InputCriblSendToRoutesTrueWithConnectionsConstraint  *InputCriblSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputCriblSendToRoutesFalseWithConnectionsConstraint *InputCriblSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputCriblPqEnabledFalseWithPqConstraint             *InputCriblPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputCriblPqEnabledTrueWithPqConstraint              *InputCriblPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputCriblUnionType
}

func CreateInputCriblInputCriblSendToRoutesTrueWithConnectionsConstraint(inputCriblSendToRoutesTrueWithConnectionsConstraint InputCriblSendToRoutesTrueWithConnectionsConstraint) InputCribl {
	typ := InputCriblUnionTypeInputCriblSendToRoutesTrueWithConnectionsConstraint

	return InputCribl{
		InputCriblSendToRoutesTrueWithConnectionsConstraint: &inputCriblSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblInputCriblSendToRoutesFalseWithConnectionsConstraint(inputCriblSendToRoutesFalseWithConnectionsConstraint InputCriblSendToRoutesFalseWithConnectionsConstraint) InputCribl {
	typ := InputCriblUnionTypeInputCriblSendToRoutesFalseWithConnectionsConstraint

	return InputCribl{
		InputCriblSendToRoutesFalseWithConnectionsConstraint: &inputCriblSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCriblInputCriblPqEnabledFalseWithPqConstraint(inputCriblPqEnabledFalseWithPqConstraint InputCriblPqEnabledFalseWithPqConstraint) InputCribl {
	typ := InputCriblUnionTypeInputCriblPqEnabledFalseWithPqConstraint

	return InputCribl{
		InputCriblPqEnabledFalseWithPqConstraint: &inputCriblPqEnabledFalseWithPqConstraint,
		Type:                                     typ,
	}
}

func CreateInputCriblInputCriblPqEnabledTrueWithPqConstraint(inputCriblPqEnabledTrueWithPqConstraint InputCriblPqEnabledTrueWithPqConstraint) InputCribl {
	typ := InputCriblUnionTypeInputCriblPqEnabledTrueWithPqConstraint

	return InputCribl{
		InputCriblPqEnabledTrueWithPqConstraint: &inputCriblPqEnabledTrueWithPqConstraint,
		Type:                                    typ,
	}
}

func (u *InputCribl) UnmarshalJSON(data []byte) error {

	var inputCriblSendToRoutesTrueWithConnectionsConstraint InputCriblSendToRoutesTrueWithConnectionsConstraint = InputCriblSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblSendToRoutesTrueWithConnectionsConstraint = &inputCriblSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputCriblUnionTypeInputCriblSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputCriblSendToRoutesFalseWithConnectionsConstraint InputCriblSendToRoutesFalseWithConnectionsConstraint = InputCriblSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCriblSendToRoutesFalseWithConnectionsConstraint = &inputCriblSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputCriblUnionTypeInputCriblSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputCriblPqEnabledFalseWithPqConstraint InputCriblPqEnabledFalseWithPqConstraint = InputCriblPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblPqEnabledFalseWithPqConstraint = &inputCriblPqEnabledFalseWithPqConstraint
		u.Type = InputCriblUnionTypeInputCriblPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputCriblPqEnabledTrueWithPqConstraint InputCriblPqEnabledTrueWithPqConstraint = InputCriblPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCriblPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputCriblPqEnabledTrueWithPqConstraint = &inputCriblPqEnabledTrueWithPqConstraint
		u.Type = InputCriblUnionTypeInputCriblPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputCribl", string(data))
}

func (u InputCribl) MarshalJSON() ([]byte, error) {
	if u.InputCriblSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputCriblSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCriblSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputCriblPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputCriblPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCriblPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputCribl: all fields are null")
}

type InputGooglePubsubPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputGooglePubsubType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
	TopicName *string `default:"cribl" json:"topicName"`
	// ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
	SubscriptionName string `json:"subscriptionName"`
	// Use when the subscription is not created by this Source and topic is not known
	MonitorSubscription *bool `default:"false" json:"monitorSubscription"`
	// Create topic if it does not exist
	CreateTopic *bool `default:"false" json:"createTopic"`
	// Create subscription if it does not exist
	CreateSubscription *bool `default:"true" json:"createSubscription"`
	// Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
	Region *string `json:"region,omitempty"`
	// Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
	GoogleAuthMethod *components.GoogleAuthenticationMethodOptions `default:"manual" json:"googleAuthMethod"`
	// Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`
	// Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`
	// If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
	MaxBacklog *float64 `default:"1000" json:"maxBacklog"`
	// How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
	Concurrency *float64 `default:"5" json:"concurrency"`
	// Pull request timeout, in milliseconds
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
	OrderedDelivery *bool `default:"false" json:"orderedDelivery"`
}

func (i InputGooglePubsubPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "subscriptionName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetType() InputGooglePubsubType {
	if i == nil {
		return InputGooglePubsubType("")
	}
	return i.Type
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetTopicName() *string {
	if i == nil {
		return nil
	}
	return i.TopicName
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetSubscriptionName() string {
	if i == nil {
		return ""
	}
	return i.SubscriptionName
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetMonitorSubscription() *bool {
	if i == nil {
		return nil
	}
	return i.MonitorSubscription
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetCreateTopic() *bool {
	if i == nil {
		return nil
	}
	return i.CreateTopic
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetCreateSubscription() *bool {
	if i == nil {
		return nil
	}
	return i.CreateSubscription
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetGoogleAuthMethod() *components.GoogleAuthenticationMethodOptions {
	if i == nil {
		return nil
	}
	return i.GoogleAuthMethod
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetServiceAccountCredentials() *string {
	if i == nil {
		return nil
	}
	return i.ServiceAccountCredentials
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetMaxBacklog() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBacklog
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetConcurrency() *float64 {
	if i == nil {
		return nil
	}
	return i.Concurrency
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputGooglePubsubPqEnabledTrueWithPqConstraint) GetOrderedDelivery() *bool {
	if i == nil {
		return nil
	}
	return i.OrderedDelivery
}

type InputGooglePubsubPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputGooglePubsubType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
	TopicName *string `default:"cribl" json:"topicName"`
	// ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
	SubscriptionName string `json:"subscriptionName"`
	// Use when the subscription is not created by this Source and topic is not known
	MonitorSubscription *bool `default:"false" json:"monitorSubscription"`
	// Create topic if it does not exist
	CreateTopic *bool `default:"false" json:"createTopic"`
	// Create subscription if it does not exist
	CreateSubscription *bool `default:"true" json:"createSubscription"`
	// Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
	Region *string `json:"region,omitempty"`
	// Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
	GoogleAuthMethod *components.GoogleAuthenticationMethodOptions `default:"manual" json:"googleAuthMethod"`
	// Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`
	// Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`
	// If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
	MaxBacklog *float64 `default:"1000" json:"maxBacklog"`
	// How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
	Concurrency *float64 `default:"5" json:"concurrency"`
	// Pull request timeout, in milliseconds
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
	OrderedDelivery *bool `default:"false" json:"orderedDelivery"`
}

func (i InputGooglePubsubPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "subscriptionName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetType() InputGooglePubsubType {
	if i == nil {
		return InputGooglePubsubType("")
	}
	return i.Type
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetTopicName() *string {
	if i == nil {
		return nil
	}
	return i.TopicName
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetSubscriptionName() string {
	if i == nil {
		return ""
	}
	return i.SubscriptionName
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetMonitorSubscription() *bool {
	if i == nil {
		return nil
	}
	return i.MonitorSubscription
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetCreateTopic() *bool {
	if i == nil {
		return nil
	}
	return i.CreateTopic
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetCreateSubscription() *bool {
	if i == nil {
		return nil
	}
	return i.CreateSubscription
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetGoogleAuthMethod() *components.GoogleAuthenticationMethodOptions {
	if i == nil {
		return nil
	}
	return i.GoogleAuthMethod
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetServiceAccountCredentials() *string {
	if i == nil {
		return nil
	}
	return i.ServiceAccountCredentials
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetMaxBacklog() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBacklog
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetConcurrency() *float64 {
	if i == nil {
		return nil
	}
	return i.Concurrency
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputGooglePubsubPqEnabledFalseWithPqConstraint) GetOrderedDelivery() *bool {
	if i == nil {
		return nil
	}
	return i.OrderedDelivery
}

type InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputGooglePubsubType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
	TopicName *string `default:"cribl" json:"topicName"`
	// ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
	SubscriptionName string `json:"subscriptionName"`
	// Use when the subscription is not created by this Source and topic is not known
	MonitorSubscription *bool `default:"false" json:"monitorSubscription"`
	// Create topic if it does not exist
	CreateTopic *bool `default:"false" json:"createTopic"`
	// Create subscription if it does not exist
	CreateSubscription *bool `default:"true" json:"createSubscription"`
	// Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
	Region *string `json:"region,omitempty"`
	// Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
	GoogleAuthMethod *components.GoogleAuthenticationMethodOptions `default:"manual" json:"googleAuthMethod"`
	// Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`
	// Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`
	// If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
	MaxBacklog *float64 `default:"1000" json:"maxBacklog"`
	// How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
	Concurrency *float64 `default:"5" json:"concurrency"`
	// Pull request timeout, in milliseconds
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
	OrderedDelivery *bool `default:"false" json:"orderedDelivery"`
}

func (i InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "subscriptionName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetType() InputGooglePubsubType {
	if i == nil {
		return InputGooglePubsubType("")
	}
	return i.Type
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetTopicName() *string {
	if i == nil {
		return nil
	}
	return i.TopicName
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetSubscriptionName() string {
	if i == nil {
		return ""
	}
	return i.SubscriptionName
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetMonitorSubscription() *bool {
	if i == nil {
		return nil
	}
	return i.MonitorSubscription
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetCreateTopic() *bool {
	if i == nil {
		return nil
	}
	return i.CreateTopic
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetCreateSubscription() *bool {
	if i == nil {
		return nil
	}
	return i.CreateSubscription
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetGoogleAuthMethod() *components.GoogleAuthenticationMethodOptions {
	if i == nil {
		return nil
	}
	return i.GoogleAuthMethod
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetServiceAccountCredentials() *string {
	if i == nil {
		return nil
	}
	return i.ServiceAccountCredentials
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetMaxBacklog() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBacklog
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetConcurrency() *float64 {
	if i == nil {
		return nil
	}
	return i.Concurrency
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) GetOrderedDelivery() *bool {
	if i == nil {
		return nil
	}
	return i.OrderedDelivery
}

type InputGooglePubsubType string

const (
	InputGooglePubsubTypeGooglePubsub InputGooglePubsubType = "google_pubsub"
)

func (e InputGooglePubsubType) ToPointer() *InputGooglePubsubType {
	return &e
}
func (e *InputGooglePubsubType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "google_pubsub":
		*e = InputGooglePubsubType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGooglePubsubType: %v", v)
	}
}

type InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputGooglePubsubType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
	TopicName *string `default:"cribl" json:"topicName"`
	// ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
	SubscriptionName string `json:"subscriptionName"`
	// Use when the subscription is not created by this Source and topic is not known
	MonitorSubscription *bool `default:"false" json:"monitorSubscription"`
	// Create topic if it does not exist
	CreateTopic *bool `default:"false" json:"createTopic"`
	// Create subscription if it does not exist
	CreateSubscription *bool `default:"true" json:"createSubscription"`
	// Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
	Region *string `json:"region,omitempty"`
	// Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
	GoogleAuthMethod *components.GoogleAuthenticationMethodOptions `default:"manual" json:"googleAuthMethod"`
	// Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`
	// Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`
	// If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
	MaxBacklog *float64 `default:"1000" json:"maxBacklog"`
	// How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
	Concurrency *float64 `default:"5" json:"concurrency"`
	// Pull request timeout, in milliseconds
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
	OrderedDelivery *bool `default:"false" json:"orderedDelivery"`
}

func (i InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "subscriptionName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetType() InputGooglePubsubType {
	if i == nil {
		return InputGooglePubsubType("")
	}
	return i.Type
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetTopicName() *string {
	if i == nil {
		return nil
	}
	return i.TopicName
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetSubscriptionName() string {
	if i == nil {
		return ""
	}
	return i.SubscriptionName
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetMonitorSubscription() *bool {
	if i == nil {
		return nil
	}
	return i.MonitorSubscription
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetCreateTopic() *bool {
	if i == nil {
		return nil
	}
	return i.CreateTopic
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetCreateSubscription() *bool {
	if i == nil {
		return nil
	}
	return i.CreateSubscription
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetGoogleAuthMethod() *components.GoogleAuthenticationMethodOptions {
	if i == nil {
		return nil
	}
	return i.GoogleAuthMethod
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetServiceAccountCredentials() *string {
	if i == nil {
		return nil
	}
	return i.ServiceAccountCredentials
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetMaxBacklog() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBacklog
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetConcurrency() *float64 {
	if i == nil {
		return nil
	}
	return i.Concurrency
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) GetOrderedDelivery() *bool {
	if i == nil {
		return nil
	}
	return i.OrderedDelivery
}

type InputGooglePubsubUnionType string

const (
	InputGooglePubsubUnionTypeInputGooglePubsubSendToRoutesTrueWithConnectionsConstraint  InputGooglePubsubUnionType = "InputGooglePubsub_SendToRoutesTrueWithConnectionsConstraint"
	InputGooglePubsubUnionTypeInputGooglePubsubSendToRoutesFalseWithConnectionsConstraint InputGooglePubsubUnionType = "InputGooglePubsub_SendToRoutesFalseWithConnectionsConstraint"
	InputGooglePubsubUnionTypeInputGooglePubsubPqEnabledFalseWithPqConstraint             InputGooglePubsubUnionType = "InputGooglePubsub_PqEnabledFalseWithPqConstraint"
	InputGooglePubsubUnionTypeInputGooglePubsubPqEnabledTrueWithPqConstraint              InputGooglePubsubUnionType = "InputGooglePubsub_PqEnabledTrueWithPqConstraint"
)

type InputGooglePubsub struct {
	InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint  *InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint *InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputGooglePubsubPqEnabledFalseWithPqConstraint             *InputGooglePubsubPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputGooglePubsubPqEnabledTrueWithPqConstraint              *InputGooglePubsubPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputGooglePubsubUnionType
}

func CreateInputGooglePubsubInputGooglePubsubSendToRoutesTrueWithConnectionsConstraint(inputGooglePubsubSendToRoutesTrueWithConnectionsConstraint InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint) InputGooglePubsub {
	typ := InputGooglePubsubUnionTypeInputGooglePubsubSendToRoutesTrueWithConnectionsConstraint

	return InputGooglePubsub{
		InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint: &inputGooglePubsubSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputGooglePubsubInputGooglePubsubSendToRoutesFalseWithConnectionsConstraint(inputGooglePubsubSendToRoutesFalseWithConnectionsConstraint InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint) InputGooglePubsub {
	typ := InputGooglePubsubUnionTypeInputGooglePubsubSendToRoutesFalseWithConnectionsConstraint

	return InputGooglePubsub{
		InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint: &inputGooglePubsubSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputGooglePubsubInputGooglePubsubPqEnabledFalseWithPqConstraint(inputGooglePubsubPqEnabledFalseWithPqConstraint InputGooglePubsubPqEnabledFalseWithPqConstraint) InputGooglePubsub {
	typ := InputGooglePubsubUnionTypeInputGooglePubsubPqEnabledFalseWithPqConstraint

	return InputGooglePubsub{
		InputGooglePubsubPqEnabledFalseWithPqConstraint: &inputGooglePubsubPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputGooglePubsubInputGooglePubsubPqEnabledTrueWithPqConstraint(inputGooglePubsubPqEnabledTrueWithPqConstraint InputGooglePubsubPqEnabledTrueWithPqConstraint) InputGooglePubsub {
	typ := InputGooglePubsubUnionTypeInputGooglePubsubPqEnabledTrueWithPqConstraint

	return InputGooglePubsub{
		InputGooglePubsubPqEnabledTrueWithPqConstraint: &inputGooglePubsubPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputGooglePubsub) UnmarshalJSON(data []byte) error {

	var inputGooglePubsubSendToRoutesTrueWithConnectionsConstraint InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint = InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputGooglePubsubSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint = &inputGooglePubsubSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputGooglePubsubUnionTypeInputGooglePubsubSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputGooglePubsubSendToRoutesFalseWithConnectionsConstraint InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint = InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputGooglePubsubSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint = &inputGooglePubsubSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputGooglePubsubUnionTypeInputGooglePubsubSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputGooglePubsubPqEnabledFalseWithPqConstraint InputGooglePubsubPqEnabledFalseWithPqConstraint = InputGooglePubsubPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputGooglePubsubPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputGooglePubsubPqEnabledFalseWithPqConstraint = &inputGooglePubsubPqEnabledFalseWithPqConstraint
		u.Type = InputGooglePubsubUnionTypeInputGooglePubsubPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputGooglePubsubPqEnabledTrueWithPqConstraint InputGooglePubsubPqEnabledTrueWithPqConstraint = InputGooglePubsubPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputGooglePubsubPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputGooglePubsubPqEnabledTrueWithPqConstraint = &inputGooglePubsubPqEnabledTrueWithPqConstraint
		u.Type = InputGooglePubsubUnionTypeInputGooglePubsubPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputGooglePubsub", string(data))
}

func (u InputGooglePubsub) MarshalJSON() ([]byte, error) {
	if u.InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputGooglePubsubSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputGooglePubsubPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputGooglePubsubPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputGooglePubsubPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputGooglePubsubPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputGooglePubsub: all fields are null")
}

type InputFirehosePqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputFirehoseType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputFirehosePqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetType() InputFirehoseType {
	if i == nil {
		return InputFirehoseType("")
	}
	return i.Type
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputFirehosePqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputFirehosePqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputFirehoseType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputFirehosePqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetType() InputFirehoseType {
	if i == nil {
		return InputFirehoseType("")
	}
	return i.Type
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputFirehosePqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputFirehoseSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputFirehoseType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputFirehoseSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetType() InputFirehoseType {
	if i == nil {
		return InputFirehoseType("")
	}
	return i.Type
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputFirehoseSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputFirehoseType string

const (
	InputFirehoseTypeFirehose InputFirehoseType = "firehose"
)

func (e InputFirehoseType) ToPointer() *InputFirehoseType {
	return &e
}
func (e *InputFirehoseType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "firehose":
		*e = InputFirehoseType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputFirehoseType: %v", v)
	}
}

type InputFirehoseSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputFirehoseType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputFirehoseSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetType() InputFirehoseType {
	if i == nil {
		return InputFirehoseType("")
	}
	return i.Type
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputFirehoseSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputFirehoseUnionType string

const (
	InputFirehoseUnionTypeInputFirehoseSendToRoutesTrueWithConnectionsConstraint  InputFirehoseUnionType = "InputFirehose_SendToRoutesTrueWithConnectionsConstraint"
	InputFirehoseUnionTypeInputFirehoseSendToRoutesFalseWithConnectionsConstraint InputFirehoseUnionType = "InputFirehose_SendToRoutesFalseWithConnectionsConstraint"
	InputFirehoseUnionTypeInputFirehosePqEnabledFalseWithPqConstraint             InputFirehoseUnionType = "InputFirehose_PqEnabledFalseWithPqConstraint"
	InputFirehoseUnionTypeInputFirehosePqEnabledTrueWithPqConstraint              InputFirehoseUnionType = "InputFirehose_PqEnabledTrueWithPqConstraint"
)

type InputFirehose struct {
	InputFirehoseSendToRoutesTrueWithConnectionsConstraint  *InputFirehoseSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputFirehoseSendToRoutesFalseWithConnectionsConstraint *InputFirehoseSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputFirehosePqEnabledFalseWithPqConstraint             *InputFirehosePqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputFirehosePqEnabledTrueWithPqConstraint              *InputFirehosePqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputFirehoseUnionType
}

func CreateInputFirehoseInputFirehoseSendToRoutesTrueWithConnectionsConstraint(inputFirehoseSendToRoutesTrueWithConnectionsConstraint InputFirehoseSendToRoutesTrueWithConnectionsConstraint) InputFirehose {
	typ := InputFirehoseUnionTypeInputFirehoseSendToRoutesTrueWithConnectionsConstraint

	return InputFirehose{
		InputFirehoseSendToRoutesTrueWithConnectionsConstraint: &inputFirehoseSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputFirehoseInputFirehoseSendToRoutesFalseWithConnectionsConstraint(inputFirehoseSendToRoutesFalseWithConnectionsConstraint InputFirehoseSendToRoutesFalseWithConnectionsConstraint) InputFirehose {
	typ := InputFirehoseUnionTypeInputFirehoseSendToRoutesFalseWithConnectionsConstraint

	return InputFirehose{
		InputFirehoseSendToRoutesFalseWithConnectionsConstraint: &inputFirehoseSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputFirehoseInputFirehosePqEnabledFalseWithPqConstraint(inputFirehosePqEnabledFalseWithPqConstraint InputFirehosePqEnabledFalseWithPqConstraint) InputFirehose {
	typ := InputFirehoseUnionTypeInputFirehosePqEnabledFalseWithPqConstraint

	return InputFirehose{
		InputFirehosePqEnabledFalseWithPqConstraint: &inputFirehosePqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputFirehoseInputFirehosePqEnabledTrueWithPqConstraint(inputFirehosePqEnabledTrueWithPqConstraint InputFirehosePqEnabledTrueWithPqConstraint) InputFirehose {
	typ := InputFirehoseUnionTypeInputFirehosePqEnabledTrueWithPqConstraint

	return InputFirehose{
		InputFirehosePqEnabledTrueWithPqConstraint: &inputFirehosePqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputFirehose) UnmarshalJSON(data []byte) error {

	var inputFirehoseSendToRoutesTrueWithConnectionsConstraint InputFirehoseSendToRoutesTrueWithConnectionsConstraint = InputFirehoseSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputFirehoseSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputFirehoseSendToRoutesTrueWithConnectionsConstraint = &inputFirehoseSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputFirehoseUnionTypeInputFirehoseSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputFirehoseSendToRoutesFalseWithConnectionsConstraint InputFirehoseSendToRoutesFalseWithConnectionsConstraint = InputFirehoseSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputFirehoseSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputFirehoseSendToRoutesFalseWithConnectionsConstraint = &inputFirehoseSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputFirehoseUnionTypeInputFirehoseSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputFirehosePqEnabledFalseWithPqConstraint InputFirehosePqEnabledFalseWithPqConstraint = InputFirehosePqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputFirehosePqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputFirehosePqEnabledFalseWithPqConstraint = &inputFirehosePqEnabledFalseWithPqConstraint
		u.Type = InputFirehoseUnionTypeInputFirehosePqEnabledFalseWithPqConstraint
		return nil
	}

	var inputFirehosePqEnabledTrueWithPqConstraint InputFirehosePqEnabledTrueWithPqConstraint = InputFirehosePqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputFirehosePqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputFirehosePqEnabledTrueWithPqConstraint = &inputFirehosePqEnabledTrueWithPqConstraint
		u.Type = InputFirehoseUnionTypeInputFirehosePqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputFirehose", string(data))
}

func (u InputFirehose) MarshalJSON() ([]byte, error) {
	if u.InputFirehoseSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputFirehoseSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputFirehoseSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputFirehoseSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputFirehosePqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputFirehosePqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputFirehosePqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputFirehosePqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputFirehose: all fields are null")
}

type PqEnabledTrueWithPqConstraintInputExecType string

const (
	PqEnabledTrueWithPqConstraintInputExecTypeExec PqEnabledTrueWithPqConstraintInputExecType = "exec"
)

func (e PqEnabledTrueWithPqConstraintInputExecType) ToPointer() *PqEnabledTrueWithPqConstraintInputExecType {
	return &e
}
func (e *PqEnabledTrueWithPqConstraintInputExecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = PqEnabledTrueWithPqConstraintInputExecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PqEnabledTrueWithPqConstraintInputExecType: %v", v)
	}
}

// PqEnabledTrueWithPqConstraintScheduleType - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type PqEnabledTrueWithPqConstraintScheduleType string

const (
	PqEnabledTrueWithPqConstraintScheduleTypeInterval     PqEnabledTrueWithPqConstraintScheduleType = "interval"
	PqEnabledTrueWithPqConstraintScheduleTypeCronSchedule PqEnabledTrueWithPqConstraintScheduleType = "cronSchedule"
)

func (e PqEnabledTrueWithPqConstraintScheduleType) ToPointer() *PqEnabledTrueWithPqConstraintScheduleType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *PqEnabledTrueWithPqConstraintScheduleType) IsExact() bool {
	if e != nil {
		switch *e {
		case "interval", "cronSchedule":
			return true
		}
	}
	return false
}

type InputExecPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                                     `json:"id"`
	Type     PqEnabledTrueWithPqConstraintInputExecType `json:"type"`
	Disabled *bool                                      `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *PqEnabledTrueWithPqConstraintScheduleType `default:"interval" json:"scheduleType"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExecPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExecPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetType() PqEnabledTrueWithPqConstraintInputExecType {
	if i == nil {
		return PqEnabledTrueWithPqConstraintInputExecType("")
	}
	return i.Type
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetScheduleType() *PqEnabledTrueWithPqConstraintScheduleType {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExecPqEnabledTrueWithPqConstraint) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type PqEnabledFalseWithPqConstraintInputExecType string

const (
	PqEnabledFalseWithPqConstraintInputExecTypeExec PqEnabledFalseWithPqConstraintInputExecType = "exec"
)

func (e PqEnabledFalseWithPqConstraintInputExecType) ToPointer() *PqEnabledFalseWithPqConstraintInputExecType {
	return &e
}
func (e *PqEnabledFalseWithPqConstraintInputExecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = PqEnabledFalseWithPqConstraintInputExecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PqEnabledFalseWithPqConstraintInputExecType: %v", v)
	}
}

// PqEnabledFalseWithPqConstraintScheduleType - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type PqEnabledFalseWithPqConstraintScheduleType string

const (
	PqEnabledFalseWithPqConstraintScheduleTypeInterval     PqEnabledFalseWithPqConstraintScheduleType = "interval"
	PqEnabledFalseWithPqConstraintScheduleTypeCronSchedule PqEnabledFalseWithPqConstraintScheduleType = "cronSchedule"
)

func (e PqEnabledFalseWithPqConstraintScheduleType) ToPointer() *PqEnabledFalseWithPqConstraintScheduleType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *PqEnabledFalseWithPqConstraintScheduleType) IsExact() bool {
	if e != nil {
		switch *e {
		case "interval", "cronSchedule":
			return true
		}
	}
	return false
}

type InputExecPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                                      `json:"id"`
	Type     PqEnabledFalseWithPqConstraintInputExecType `json:"type"`
	Disabled *bool                                       `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *PqEnabledFalseWithPqConstraintScheduleType `default:"interval" json:"scheduleType"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExecPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExecPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetType() PqEnabledFalseWithPqConstraintInputExecType {
	if i == nil {
		return PqEnabledFalseWithPqConstraintInputExecType("")
	}
	return i.Type
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetScheduleType() *PqEnabledFalseWithPqConstraintScheduleType {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExecPqEnabledFalseWithPqConstraint) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type SendToRoutesFalseWithConnectionsConstraintInputExecType string

const (
	SendToRoutesFalseWithConnectionsConstraintInputExecTypeExec SendToRoutesFalseWithConnectionsConstraintInputExecType = "exec"
)

func (e SendToRoutesFalseWithConnectionsConstraintInputExecType) ToPointer() *SendToRoutesFalseWithConnectionsConstraintInputExecType {
	return &e
}
func (e *SendToRoutesFalseWithConnectionsConstraintInputExecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = SendToRoutesFalseWithConnectionsConstraintInputExecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SendToRoutesFalseWithConnectionsConstraintInputExecType: %v", v)
	}
}

// SendToRoutesFalseWithConnectionsConstraintScheduleType - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type SendToRoutesFalseWithConnectionsConstraintScheduleType string

const (
	SendToRoutesFalseWithConnectionsConstraintScheduleTypeInterval     SendToRoutesFalseWithConnectionsConstraintScheduleType = "interval"
	SendToRoutesFalseWithConnectionsConstraintScheduleTypeCronSchedule SendToRoutesFalseWithConnectionsConstraintScheduleType = "cronSchedule"
)

func (e SendToRoutesFalseWithConnectionsConstraintScheduleType) ToPointer() *SendToRoutesFalseWithConnectionsConstraintScheduleType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SendToRoutesFalseWithConnectionsConstraintScheduleType) IsExact() bool {
	if e != nil {
		switch *e {
		case "interval", "cronSchedule":
			return true
		}
	}
	return false
}

type InputExecSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                                                  `json:"id"`
	Type     SendToRoutesFalseWithConnectionsConstraintInputExecType `json:"type"`
	Disabled *bool                                                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *SendToRoutesFalseWithConnectionsConstraintScheduleType `default:"interval" json:"scheduleType"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExecSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetType() SendToRoutesFalseWithConnectionsConstraintInputExecType {
	if i == nil {
		return SendToRoutesFalseWithConnectionsConstraintInputExecType("")
	}
	return i.Type
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetScheduleType() *SendToRoutesFalseWithConnectionsConstraintScheduleType {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExecSendToRoutesFalseWithConnectionsConstraint) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type SendToRoutesTrueWithConnectionsConstraintInputExecType string

const (
	SendToRoutesTrueWithConnectionsConstraintInputExecTypeExec SendToRoutesTrueWithConnectionsConstraintInputExecType = "exec"
)

func (e SendToRoutesTrueWithConnectionsConstraintInputExecType) ToPointer() *SendToRoutesTrueWithConnectionsConstraintInputExecType {
	return &e
}
func (e *SendToRoutesTrueWithConnectionsConstraintInputExecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = SendToRoutesTrueWithConnectionsConstraintInputExecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SendToRoutesTrueWithConnectionsConstraintInputExecType: %v", v)
	}
}

// SendToRoutesTrueWithConnectionsConstraintScheduleType - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type SendToRoutesTrueWithConnectionsConstraintScheduleType string

const (
	SendToRoutesTrueWithConnectionsConstraintScheduleTypeInterval     SendToRoutesTrueWithConnectionsConstraintScheduleType = "interval"
	SendToRoutesTrueWithConnectionsConstraintScheduleTypeCronSchedule SendToRoutesTrueWithConnectionsConstraintScheduleType = "cronSchedule"
)

func (e SendToRoutesTrueWithConnectionsConstraintScheduleType) ToPointer() *SendToRoutesTrueWithConnectionsConstraintScheduleType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SendToRoutesTrueWithConnectionsConstraintScheduleType) IsExact() bool {
	if e != nil {
		switch *e {
		case "interval", "cronSchedule":
			return true
		}
	}
	return false
}

type InputExecSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                                                 `json:"id"`
	Type     SendToRoutesTrueWithConnectionsConstraintInputExecType `json:"type"`
	Disabled *bool                                                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *SendToRoutesTrueWithConnectionsConstraintScheduleType `default:"interval" json:"scheduleType"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExecSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetType() SendToRoutesTrueWithConnectionsConstraintInputExecType {
	if i == nil {
		return SendToRoutesTrueWithConnectionsConstraintInputExecType("")
	}
	return i.Type
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetScheduleType() *SendToRoutesTrueWithConnectionsConstraintScheduleType {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExecSendToRoutesTrueWithConnectionsConstraint) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type InputExecType string

const (
	InputExecTypeInputExecSendToRoutesTrueWithConnectionsConstraint  InputExecType = "InputExec_SendToRoutesTrueWithConnectionsConstraint"
	InputExecTypeInputExecSendToRoutesFalseWithConnectionsConstraint InputExecType = "InputExec_SendToRoutesFalseWithConnectionsConstraint"
	InputExecTypeInputExecPqEnabledFalseWithPqConstraint             InputExecType = "InputExec_PqEnabledFalseWithPqConstraint"
	InputExecTypeInputExecPqEnabledTrueWithPqConstraint              InputExecType = "InputExec_PqEnabledTrueWithPqConstraint"
)

type InputExec struct {
	InputExecSendToRoutesTrueWithConnectionsConstraint  *InputExecSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputExecSendToRoutesFalseWithConnectionsConstraint *InputExecSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputExecPqEnabledFalseWithPqConstraint             *InputExecPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputExecPqEnabledTrueWithPqConstraint              *InputExecPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputExecType
}

func CreateInputExecInputExecSendToRoutesTrueWithConnectionsConstraint(inputExecSendToRoutesTrueWithConnectionsConstraint InputExecSendToRoutesTrueWithConnectionsConstraint) InputExec {
	typ := InputExecTypeInputExecSendToRoutesTrueWithConnectionsConstraint

	return InputExec{
		InputExecSendToRoutesTrueWithConnectionsConstraint: &inputExecSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputExecInputExecSendToRoutesFalseWithConnectionsConstraint(inputExecSendToRoutesFalseWithConnectionsConstraint InputExecSendToRoutesFalseWithConnectionsConstraint) InputExec {
	typ := InputExecTypeInputExecSendToRoutesFalseWithConnectionsConstraint

	return InputExec{
		InputExecSendToRoutesFalseWithConnectionsConstraint: &inputExecSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputExecInputExecPqEnabledFalseWithPqConstraint(inputExecPqEnabledFalseWithPqConstraint InputExecPqEnabledFalseWithPqConstraint) InputExec {
	typ := InputExecTypeInputExecPqEnabledFalseWithPqConstraint

	return InputExec{
		InputExecPqEnabledFalseWithPqConstraint: &inputExecPqEnabledFalseWithPqConstraint,
		Type:                                    typ,
	}
}

func CreateInputExecInputExecPqEnabledTrueWithPqConstraint(inputExecPqEnabledTrueWithPqConstraint InputExecPqEnabledTrueWithPqConstraint) InputExec {
	typ := InputExecTypeInputExecPqEnabledTrueWithPqConstraint

	return InputExec{
		InputExecPqEnabledTrueWithPqConstraint: &inputExecPqEnabledTrueWithPqConstraint,
		Type:                                   typ,
	}
}

func (u *InputExec) UnmarshalJSON(data []byte) error {

	var inputExecSendToRoutesTrueWithConnectionsConstraint InputExecSendToRoutesTrueWithConnectionsConstraint = InputExecSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputExecSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputExecSendToRoutesTrueWithConnectionsConstraint = &inputExecSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputExecTypeInputExecSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputExecSendToRoutesFalseWithConnectionsConstraint InputExecSendToRoutesFalseWithConnectionsConstraint = InputExecSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputExecSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputExecSendToRoutesFalseWithConnectionsConstraint = &inputExecSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputExecTypeInputExecSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputExecPqEnabledFalseWithPqConstraint InputExecPqEnabledFalseWithPqConstraint = InputExecPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputExecPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputExecPqEnabledFalseWithPqConstraint = &inputExecPqEnabledFalseWithPqConstraint
		u.Type = InputExecTypeInputExecPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputExecPqEnabledTrueWithPqConstraint InputExecPqEnabledTrueWithPqConstraint = InputExecPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputExecPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputExecPqEnabledTrueWithPqConstraint = &inputExecPqEnabledTrueWithPqConstraint
		u.Type = InputExecTypeInputExecPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputExec", string(data))
}

func (u InputExec) MarshalJSON() ([]byte, error) {
	if u.InputExecSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputExecSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputExecSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputExecSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputExecPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputExecPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputExecPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputExecPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputExec: all fields are null")
}

type InputEventhubPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputEventhubType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
	Brokers []string `json:"brokers"`
	// The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
	Topics []string `json:"topics"`
	// The consumer group this instance belongs to. Default is 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Start reading from earliest available data; relevant only during initial subscription
	FromBeginning *bool `default:"true" json:"fromBeginning"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType1       `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideType `json:"tls,omitempty"`
	//       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
	//       Value must be lower than rebalanceTimeout.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Minimize duplicate events by starting only one consumer for each topic partition
	MinimizeDuplicates *bool `default:"false" json:"minimizeDuplicates"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputEventhubPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetType() InputEventhubType {
	if i == nil {
		return InputEventhubType("")
	}
	return i.Type
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetSasl() *components.AuthenticationType1 {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsClientSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetMinimizeDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.MinimizeDuplicates
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEventhubPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputEventhubPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputEventhubType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
	Brokers []string `json:"brokers"`
	// The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
	Topics []string `json:"topics"`
	// The consumer group this instance belongs to. Default is 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Start reading from earliest available data; relevant only during initial subscription
	FromBeginning *bool `default:"true" json:"fromBeginning"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType1       `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideType `json:"tls,omitempty"`
	//       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
	//       Value must be lower than rebalanceTimeout.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Minimize duplicate events by starting only one consumer for each topic partition
	MinimizeDuplicates *bool `default:"false" json:"minimizeDuplicates"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputEventhubPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetType() InputEventhubType {
	if i == nil {
		return InputEventhubType("")
	}
	return i.Type
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetSasl() *components.AuthenticationType1 {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsClientSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetMinimizeDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.MinimizeDuplicates
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEventhubPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputEventhubSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputEventhubType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
	Brokers []string `json:"brokers"`
	// The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
	Topics []string `json:"topics"`
	// The consumer group this instance belongs to. Default is 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Start reading from earliest available data; relevant only during initial subscription
	FromBeginning *bool `default:"true" json:"fromBeginning"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType1       `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideType `json:"tls,omitempty"`
	//       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
	//       Value must be lower than rebalanceTimeout.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Minimize duplicate events by starting only one consumer for each topic partition
	MinimizeDuplicates *bool `default:"false" json:"minimizeDuplicates"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputEventhubSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetType() InputEventhubType {
	if i == nil {
		return InputEventhubType("")
	}
	return i.Type
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetSasl() *components.AuthenticationType1 {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsClientSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetMinimizeDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.MinimizeDuplicates
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEventhubSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputEventhubType string

const (
	InputEventhubTypeEventhub InputEventhubType = "eventhub"
)

func (e InputEventhubType) ToPointer() *InputEventhubType {
	return &e
}
func (e *InputEventhubType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eventhub":
		*e = InputEventhubType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputEventhubType: %v", v)
	}
}

type InputEventhubSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputEventhubType `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
	Brokers []string `json:"brokers"`
	// The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
	Topics []string `json:"topics"`
	// The consumer group this instance belongs to. Default is 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Start reading from earliest available data; relevant only during initial subscription
	FromBeginning *bool `default:"true" json:"fromBeginning"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType1       `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideType `json:"tls,omitempty"`
	//       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
	//       Value must be lower than rebalanceTimeout.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Minimize duplicate events by starting only one consumer for each topic partition
	MinimizeDuplicates *bool `default:"false" json:"minimizeDuplicates"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputEventhubSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetType() InputEventhubType {
	if i == nil {
		return InputEventhubType("")
	}
	return i.Type
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetSasl() *components.AuthenticationType1 {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsClientSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetMinimizeDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.MinimizeDuplicates
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEventhubSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputEventhubUnionType string

const (
	InputEventhubUnionTypeInputEventhubSendToRoutesTrueWithConnectionsConstraint  InputEventhubUnionType = "InputEventhub_SendToRoutesTrueWithConnectionsConstraint"
	InputEventhubUnionTypeInputEventhubSendToRoutesFalseWithConnectionsConstraint InputEventhubUnionType = "InputEventhub_SendToRoutesFalseWithConnectionsConstraint"
	InputEventhubUnionTypeInputEventhubPqEnabledFalseWithPqConstraint             InputEventhubUnionType = "InputEventhub_PqEnabledFalseWithPqConstraint"
	InputEventhubUnionTypeInputEventhubPqEnabledTrueWithPqConstraint              InputEventhubUnionType = "InputEventhub_PqEnabledTrueWithPqConstraint"
)

type InputEventhub struct {
	InputEventhubSendToRoutesTrueWithConnectionsConstraint  *InputEventhubSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputEventhubSendToRoutesFalseWithConnectionsConstraint *InputEventhubSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputEventhubPqEnabledFalseWithPqConstraint             *InputEventhubPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputEventhubPqEnabledTrueWithPqConstraint              *InputEventhubPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputEventhubUnionType
}

func CreateInputEventhubInputEventhubSendToRoutesTrueWithConnectionsConstraint(inputEventhubSendToRoutesTrueWithConnectionsConstraint InputEventhubSendToRoutesTrueWithConnectionsConstraint) InputEventhub {
	typ := InputEventhubUnionTypeInputEventhubSendToRoutesTrueWithConnectionsConstraint

	return InputEventhub{
		InputEventhubSendToRoutesTrueWithConnectionsConstraint: &inputEventhubSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputEventhubInputEventhubSendToRoutesFalseWithConnectionsConstraint(inputEventhubSendToRoutesFalseWithConnectionsConstraint InputEventhubSendToRoutesFalseWithConnectionsConstraint) InputEventhub {
	typ := InputEventhubUnionTypeInputEventhubSendToRoutesFalseWithConnectionsConstraint

	return InputEventhub{
		InputEventhubSendToRoutesFalseWithConnectionsConstraint: &inputEventhubSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputEventhubInputEventhubPqEnabledFalseWithPqConstraint(inputEventhubPqEnabledFalseWithPqConstraint InputEventhubPqEnabledFalseWithPqConstraint) InputEventhub {
	typ := InputEventhubUnionTypeInputEventhubPqEnabledFalseWithPqConstraint

	return InputEventhub{
		InputEventhubPqEnabledFalseWithPqConstraint: &inputEventhubPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputEventhubInputEventhubPqEnabledTrueWithPqConstraint(inputEventhubPqEnabledTrueWithPqConstraint InputEventhubPqEnabledTrueWithPqConstraint) InputEventhub {
	typ := InputEventhubUnionTypeInputEventhubPqEnabledTrueWithPqConstraint

	return InputEventhub{
		InputEventhubPqEnabledTrueWithPqConstraint: &inputEventhubPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputEventhub) UnmarshalJSON(data []byte) error {

	var inputEventhubSendToRoutesTrueWithConnectionsConstraint InputEventhubSendToRoutesTrueWithConnectionsConstraint = InputEventhubSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEventhubSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputEventhubSendToRoutesTrueWithConnectionsConstraint = &inputEventhubSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputEventhubUnionTypeInputEventhubSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputEventhubSendToRoutesFalseWithConnectionsConstraint InputEventhubSendToRoutesFalseWithConnectionsConstraint = InputEventhubSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEventhubSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputEventhubSendToRoutesFalseWithConnectionsConstraint = &inputEventhubSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputEventhubUnionTypeInputEventhubSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputEventhubPqEnabledFalseWithPqConstraint InputEventhubPqEnabledFalseWithPqConstraint = InputEventhubPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEventhubPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputEventhubPqEnabledFalseWithPqConstraint = &inputEventhubPqEnabledFalseWithPqConstraint
		u.Type = InputEventhubUnionTypeInputEventhubPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputEventhubPqEnabledTrueWithPqConstraint InputEventhubPqEnabledTrueWithPqConstraint = InputEventhubPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEventhubPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputEventhubPqEnabledTrueWithPqConstraint = &inputEventhubPqEnabledTrueWithPqConstraint
		u.Type = InputEventhubUnionTypeInputEventhubPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputEventhub", string(data))
}

func (u InputEventhub) MarshalJSON() ([]byte, error) {
	if u.InputEventhubSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputEventhubSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputEventhubSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputEventhubSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputEventhubPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputEventhubPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputEventhubPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputEventhubPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputEventhub: all fields are null")
}

type InputOffice365MsgTracePqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                     `json:"id"`
	Type     InputOffice365MsgTraceType `json:"type"`
	Disabled *bool                      `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// URL to use when retrieving report data.
	URL *string `default:"https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace" json:"url"`
	// How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
	Interval *float64 `default:"60" json:"interval"`
	// Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
	StartDate *string `json:"startDate,omitempty"`
	// Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
	EndDate *string `json:"endDate,omitempty"`
	// HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
	Timeout *float64 `default:"300" json:"timeout"`
	// Disables time filtering of events when a date range is specified.
	DisableTimeFilter *bool `default:"true" json:"disableTimeFilter"`
	// Select authentication method.
	AuthType *InputOffice365MsgTraceAuthenticationMethod `default:"oauth" json:"authType"`
	// Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `default:"true" json:"rescheduleDroppedTasks"`
	// Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float64 `default:"1" json:"maxTaskReschedule"`
	// Log Level (verbosity) for collection runtime behavior.
	LogLevel *InputOffice365MsgTraceLogLevel `default:"info" json:"logLevel"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules  *components.RetryRulesType1                `json:"retryRules,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Username to run Message Trace API call.
	Username *string `json:"username,omitempty"`
	// Password to run Message Trace API call.
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials.
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// client_secret to pass in the OAuth request parameter.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Directory ID (tenant identifier) in Azure Active Directory.
	TenantID *string `json:"tenantId,omitempty"`
	// client_id to pass in the OAuth request parameter.
	ClientID *string `json:"clientId,omitempty"`
	// Resource to pass in the OAuth request parameter.
	Resource *string `default:"https://outlook.office365.com" json:"resource"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Select or create a secret that references your client_secret to pass in the OAuth request parameter.
	TextSecret  *string      `json:"textSecret,omitempty"`
	CertOptions *CertOptions `json:"certOptions,omitempty"`
}

func (i InputOffice365MsgTracePqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetType() InputOffice365MsgTraceType {
	if i == nil {
		return InputOffice365MsgTraceType("")
	}
	return i.Type
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetURL() *string {
	if i == nil {
		return nil
	}
	return i.URL
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetStartDate() *string {
	if i == nil {
		return nil
	}
	return i.StartDate
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetEndDate() *string {
	if i == nil {
		return nil
	}
	return i.EndDate
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetDisableTimeFilter() *bool {
	if i == nil {
		return nil
	}
	return i.DisableTimeFilter
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetAuthType() *InputOffice365MsgTraceAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetRescheduleDroppedTasks() *bool {
	if i == nil {
		return nil
	}
	return i.RescheduleDroppedTasks
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetMaxTaskReschedule() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxTaskReschedule
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetLogLevel() *InputOffice365MsgTraceLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetTenantID() *string {
	if i == nil {
		return nil
	}
	return i.TenantID
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetClientID() *string {
	if i == nil {
		return nil
	}
	return i.ClientID
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetResource() *string {
	if i == nil {
		return nil
	}
	return i.Resource
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputOffice365MsgTracePqEnabledTrueWithPqConstraint) GetCertOptions() *CertOptions {
	if i == nil {
		return nil
	}
	return i.CertOptions
}

type InputOffice365MsgTracePqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                     `json:"id"`
	Type     InputOffice365MsgTraceType `json:"type"`
	Disabled *bool                      `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// URL to use when retrieving report data.
	URL *string `default:"https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace" json:"url"`
	// How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
	Interval *float64 `default:"60" json:"interval"`
	// Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
	StartDate *string `json:"startDate,omitempty"`
	// Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
	EndDate *string `json:"endDate,omitempty"`
	// HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
	Timeout *float64 `default:"300" json:"timeout"`
	// Disables time filtering of events when a date range is specified.
	DisableTimeFilter *bool `default:"true" json:"disableTimeFilter"`
	// Select authentication method.
	AuthType *InputOffice365MsgTraceAuthenticationMethod `default:"oauth" json:"authType"`
	// Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `default:"true" json:"rescheduleDroppedTasks"`
	// Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float64 `default:"1" json:"maxTaskReschedule"`
	// Log Level (verbosity) for collection runtime behavior.
	LogLevel *InputOffice365MsgTraceLogLevel `default:"info" json:"logLevel"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules  *components.RetryRulesType1                `json:"retryRules,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Username to run Message Trace API call.
	Username *string `json:"username,omitempty"`
	// Password to run Message Trace API call.
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials.
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// client_secret to pass in the OAuth request parameter.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Directory ID (tenant identifier) in Azure Active Directory.
	TenantID *string `json:"tenantId,omitempty"`
	// client_id to pass in the OAuth request parameter.
	ClientID *string `json:"clientId,omitempty"`
	// Resource to pass in the OAuth request parameter.
	Resource *string `default:"https://outlook.office365.com" json:"resource"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Select or create a secret that references your client_secret to pass in the OAuth request parameter.
	TextSecret  *string      `json:"textSecret,omitempty"`
	CertOptions *CertOptions `json:"certOptions,omitempty"`
}

func (i InputOffice365MsgTracePqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetType() InputOffice365MsgTraceType {
	if i == nil {
		return InputOffice365MsgTraceType("")
	}
	return i.Type
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetURL() *string {
	if i == nil {
		return nil
	}
	return i.URL
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetStartDate() *string {
	if i == nil {
		return nil
	}
	return i.StartDate
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetEndDate() *string {
	if i == nil {
		return nil
	}
	return i.EndDate
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetDisableTimeFilter() *bool {
	if i == nil {
		return nil
	}
	return i.DisableTimeFilter
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetAuthType() *InputOffice365MsgTraceAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetRescheduleDroppedTasks() *bool {
	if i == nil {
		return nil
	}
	return i.RescheduleDroppedTasks
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetMaxTaskReschedule() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxTaskReschedule
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetLogLevel() *InputOffice365MsgTraceLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetTenantID() *string {
	if i == nil {
		return nil
	}
	return i.TenantID
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetClientID() *string {
	if i == nil {
		return nil
	}
	return i.ClientID
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetResource() *string {
	if i == nil {
		return nil
	}
	return i.Resource
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputOffice365MsgTracePqEnabledFalseWithPqConstraint) GetCertOptions() *CertOptions {
	if i == nil {
		return nil
	}
	return i.CertOptions
}

type InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                     `json:"id"`
	Type     InputOffice365MsgTraceType `json:"type"`
	Disabled *bool                      `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// URL to use when retrieving report data.
	URL *string `default:"https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace" json:"url"`
	// How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
	Interval *float64 `default:"60" json:"interval"`
	// Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
	StartDate *string `json:"startDate,omitempty"`
	// Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
	EndDate *string `json:"endDate,omitempty"`
	// HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
	Timeout *float64 `default:"300" json:"timeout"`
	// Disables time filtering of events when a date range is specified.
	DisableTimeFilter *bool `default:"true" json:"disableTimeFilter"`
	// Select authentication method.
	AuthType *InputOffice365MsgTraceAuthenticationMethod `default:"oauth" json:"authType"`
	// Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `default:"true" json:"rescheduleDroppedTasks"`
	// Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float64 `default:"1" json:"maxTaskReschedule"`
	// Log Level (verbosity) for collection runtime behavior.
	LogLevel *InputOffice365MsgTraceLogLevel `default:"info" json:"logLevel"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules  *components.RetryRulesType1                `json:"retryRules,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Username to run Message Trace API call.
	Username *string `json:"username,omitempty"`
	// Password to run Message Trace API call.
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials.
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// client_secret to pass in the OAuth request parameter.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Directory ID (tenant identifier) in Azure Active Directory.
	TenantID *string `json:"tenantId,omitempty"`
	// client_id to pass in the OAuth request parameter.
	ClientID *string `json:"clientId,omitempty"`
	// Resource to pass in the OAuth request parameter.
	Resource *string `default:"https://outlook.office365.com" json:"resource"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Select or create a secret that references your client_secret to pass in the OAuth request parameter.
	TextSecret  *string      `json:"textSecret,omitempty"`
	CertOptions *CertOptions `json:"certOptions,omitempty"`
}

func (i InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetType() InputOffice365MsgTraceType {
	if i == nil {
		return InputOffice365MsgTraceType("")
	}
	return i.Type
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetURL() *string {
	if i == nil {
		return nil
	}
	return i.URL
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetStartDate() *string {
	if i == nil {
		return nil
	}
	return i.StartDate
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetEndDate() *string {
	if i == nil {
		return nil
	}
	return i.EndDate
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetDisableTimeFilter() *bool {
	if i == nil {
		return nil
	}
	return i.DisableTimeFilter
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *InputOffice365MsgTraceAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetRescheduleDroppedTasks() *bool {
	if i == nil {
		return nil
	}
	return i.RescheduleDroppedTasks
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetMaxTaskReschedule() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxTaskReschedule
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetLogLevel() *InputOffice365MsgTraceLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetTenantID() *string {
	if i == nil {
		return nil
	}
	return i.TenantID
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetClientID() *string {
	if i == nil {
		return nil
	}
	return i.ClientID
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetResource() *string {
	if i == nil {
		return nil
	}
	return i.Resource
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) GetCertOptions() *CertOptions {
	if i == nil {
		return nil
	}
	return i.CertOptions
}

type InputOffice365MsgTraceType string

const (
	InputOffice365MsgTraceTypeOffice365MsgTrace InputOffice365MsgTraceType = "office365_msg_trace"
)

func (e InputOffice365MsgTraceType) ToPointer() *InputOffice365MsgTraceType {
	return &e
}
func (e *InputOffice365MsgTraceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_msg_trace":
		*e = InputOffice365MsgTraceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputOffice365MsgTraceType: %v", v)
	}
}

// InputOffice365MsgTraceAuthenticationMethod - Select authentication method.
type InputOffice365MsgTraceAuthenticationMethod string

const (
	InputOffice365MsgTraceAuthenticationMethodManual      InputOffice365MsgTraceAuthenticationMethod = "manual"
	InputOffice365MsgTraceAuthenticationMethodSecret      InputOffice365MsgTraceAuthenticationMethod = "secret"
	InputOffice365MsgTraceAuthenticationMethodOauth       InputOffice365MsgTraceAuthenticationMethod = "oauth"
	InputOffice365MsgTraceAuthenticationMethodOauthSecret InputOffice365MsgTraceAuthenticationMethod = "oauthSecret"
	InputOffice365MsgTraceAuthenticationMethodOauthCert   InputOffice365MsgTraceAuthenticationMethod = "oauthCert"
)

func (e InputOffice365MsgTraceAuthenticationMethod) ToPointer() *InputOffice365MsgTraceAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputOffice365MsgTraceAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "oauth", "oauthSecret", "oauthCert":
			return true
		}
	}
	return false
}

// InputOffice365MsgTraceLogLevel - Log Level (verbosity) for collection runtime behavior.
type InputOffice365MsgTraceLogLevel string

const (
	InputOffice365MsgTraceLogLevelError InputOffice365MsgTraceLogLevel = "error"
	InputOffice365MsgTraceLogLevelWarn  InputOffice365MsgTraceLogLevel = "warn"
	InputOffice365MsgTraceLogLevelInfo  InputOffice365MsgTraceLogLevel = "info"
	InputOffice365MsgTraceLogLevelDebug InputOffice365MsgTraceLogLevel = "debug"
	InputOffice365MsgTraceLogLevelSilly InputOffice365MsgTraceLogLevel = "silly"
)

func (e InputOffice365MsgTraceLogLevel) ToPointer() *InputOffice365MsgTraceLogLevel {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputOffice365MsgTraceLogLevel) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug", "silly":
			return true
		}
	}
	return false
}

type CertOptions struct {
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	// Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
	PrivKeyPath string `json:"privKeyPath"`
	// Passphrase to use to decrypt the private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
	CertPath string `json:"certPath"`
}

func (c CertOptions) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertOptions) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"privKeyPath", "certPath"}); err != nil {
		return err
	}
	return nil
}

func (c *CertOptions) GetCertificateName() *string {
	if c == nil {
		return nil
	}
	return c.CertificateName
}

func (c *CertOptions) GetPrivKeyPath() string {
	if c == nil {
		return ""
	}
	return c.PrivKeyPath
}

func (c *CertOptions) GetPassphrase() *string {
	if c == nil {
		return nil
	}
	return c.Passphrase
}

func (c *CertOptions) GetCertPath() string {
	if c == nil {
		return ""
	}
	return c.CertPath
}

type InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                     `json:"id"`
	Type     InputOffice365MsgTraceType `json:"type"`
	Disabled *bool                      `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// URL to use when retrieving report data.
	URL *string `default:"https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace" json:"url"`
	// How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
	Interval *float64 `default:"60" json:"interval"`
	// Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
	StartDate *string `json:"startDate,omitempty"`
	// Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
	EndDate *string `json:"endDate,omitempty"`
	// HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
	Timeout *float64 `default:"300" json:"timeout"`
	// Disables time filtering of events when a date range is specified.
	DisableTimeFilter *bool `default:"true" json:"disableTimeFilter"`
	// Select authentication method.
	AuthType *InputOffice365MsgTraceAuthenticationMethod `default:"oauth" json:"authType"`
	// Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `default:"true" json:"rescheduleDroppedTasks"`
	// Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float64 `default:"1" json:"maxTaskReschedule"`
	// Log Level (verbosity) for collection runtime behavior.
	LogLevel *InputOffice365MsgTraceLogLevel `default:"info" json:"logLevel"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules  *components.RetryRulesType1                `json:"retryRules,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	// Username to run Message Trace API call.
	Username *string `json:"username,omitempty"`
	// Password to run Message Trace API call.
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials.
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// client_secret to pass in the OAuth request parameter.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Directory ID (tenant identifier) in Azure Active Directory.
	TenantID *string `json:"tenantId,omitempty"`
	// client_id to pass in the OAuth request parameter.
	ClientID *string `json:"clientId,omitempty"`
	// Resource to pass in the OAuth request parameter.
	Resource *string `default:"https://outlook.office365.com" json:"resource"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Select or create a secret that references your client_secret to pass in the OAuth request parameter.
	TextSecret  *string      `json:"textSecret,omitempty"`
	CertOptions *CertOptions `json:"certOptions,omitempty"`
}

func (i InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetType() InputOffice365MsgTraceType {
	if i == nil {
		return InputOffice365MsgTraceType("")
	}
	return i.Type
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetURL() *string {
	if i == nil {
		return nil
	}
	return i.URL
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetStartDate() *string {
	if i == nil {
		return nil
	}
	return i.StartDate
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetEndDate() *string {
	if i == nil {
		return nil
	}
	return i.EndDate
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetDisableTimeFilter() *bool {
	if i == nil {
		return nil
	}
	return i.DisableTimeFilter
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *InputOffice365MsgTraceAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetRescheduleDroppedTasks() *bool {
	if i == nil {
		return nil
	}
	return i.RescheduleDroppedTasks
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetMaxTaskReschedule() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxTaskReschedule
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetLogLevel() *InputOffice365MsgTraceLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetTenantID() *string {
	if i == nil {
		return nil
	}
	return i.TenantID
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetClientID() *string {
	if i == nil {
		return nil
	}
	return i.ClientID
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetResource() *string {
	if i == nil {
		return nil
	}
	return i.Resource
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) GetCertOptions() *CertOptions {
	if i == nil {
		return nil
	}
	return i.CertOptions
}

type InputOffice365MsgTraceUnionType string

const (
	InputOffice365MsgTraceUnionTypeInputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint  InputOffice365MsgTraceUnionType = "InputOffice365MsgTrace_SendToRoutesTrueWithConnectionsConstraint"
	InputOffice365MsgTraceUnionTypeInputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint InputOffice365MsgTraceUnionType = "InputOffice365MsgTrace_SendToRoutesFalseWithConnectionsConstraint"
	InputOffice365MsgTraceUnionTypeInputOffice365MsgTracePqEnabledFalseWithPqConstraint             InputOffice365MsgTraceUnionType = "InputOffice365MsgTrace_PqEnabledFalseWithPqConstraint"
	InputOffice365MsgTraceUnionTypeInputOffice365MsgTracePqEnabledTrueWithPqConstraint              InputOffice365MsgTraceUnionType = "InputOffice365MsgTrace_PqEnabledTrueWithPqConstraint"
)

type InputOffice365MsgTrace struct {
	InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint  *InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint *InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputOffice365MsgTracePqEnabledFalseWithPqConstraint             *InputOffice365MsgTracePqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputOffice365MsgTracePqEnabledTrueWithPqConstraint              *InputOffice365MsgTracePqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputOffice365MsgTraceUnionType
}

func CreateInputOffice365MsgTraceInputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint(inputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint) InputOffice365MsgTrace {
	typ := InputOffice365MsgTraceUnionTypeInputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint

	return InputOffice365MsgTrace{
		InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint: &inputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputOffice365MsgTraceInputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint(inputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint) InputOffice365MsgTrace {
	typ := InputOffice365MsgTraceUnionTypeInputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint

	return InputOffice365MsgTrace{
		InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint: &inputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputOffice365MsgTraceInputOffice365MsgTracePqEnabledFalseWithPqConstraint(inputOffice365MsgTracePqEnabledFalseWithPqConstraint InputOffice365MsgTracePqEnabledFalseWithPqConstraint) InputOffice365MsgTrace {
	typ := InputOffice365MsgTraceUnionTypeInputOffice365MsgTracePqEnabledFalseWithPqConstraint

	return InputOffice365MsgTrace{
		InputOffice365MsgTracePqEnabledFalseWithPqConstraint: &inputOffice365MsgTracePqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputOffice365MsgTraceInputOffice365MsgTracePqEnabledTrueWithPqConstraint(inputOffice365MsgTracePqEnabledTrueWithPqConstraint InputOffice365MsgTracePqEnabledTrueWithPqConstraint) InputOffice365MsgTrace {
	typ := InputOffice365MsgTraceUnionTypeInputOffice365MsgTracePqEnabledTrueWithPqConstraint

	return InputOffice365MsgTrace{
		InputOffice365MsgTracePqEnabledTrueWithPqConstraint: &inputOffice365MsgTracePqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputOffice365MsgTrace) UnmarshalJSON(data []byte) error {

	var inputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint = InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint = &inputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputOffice365MsgTraceUnionTypeInputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint = InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint = &inputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputOffice365MsgTraceUnionTypeInputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputOffice365MsgTracePqEnabledFalseWithPqConstraint InputOffice365MsgTracePqEnabledFalseWithPqConstraint = InputOffice365MsgTracePqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365MsgTracePqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputOffice365MsgTracePqEnabledFalseWithPqConstraint = &inputOffice365MsgTracePqEnabledFalseWithPqConstraint
		u.Type = InputOffice365MsgTraceUnionTypeInputOffice365MsgTracePqEnabledFalseWithPqConstraint
		return nil
	}

	var inputOffice365MsgTracePqEnabledTrueWithPqConstraint InputOffice365MsgTracePqEnabledTrueWithPqConstraint = InputOffice365MsgTracePqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365MsgTracePqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputOffice365MsgTracePqEnabledTrueWithPqConstraint = &inputOffice365MsgTracePqEnabledTrueWithPqConstraint
		u.Type = InputOffice365MsgTraceUnionTypeInputOffice365MsgTracePqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputOffice365MsgTrace", string(data))
}

func (u InputOffice365MsgTrace) MarshalJSON() ([]byte, error) {
	if u.InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365MsgTraceSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputOffice365MsgTracePqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365MsgTracePqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputOffice365MsgTracePqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365MsgTracePqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputOffice365MsgTrace: all fields are null")
}

type InputOffice365ServicePqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     InputOffice365ServiceType `json:"type"`
	Disabled *bool                     `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `default:"300" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []InputOffice365ServiceContentConfig `json:"contentConfig,omitempty"`
	RetryRules    *components.RetryRulesType1          `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputOffice365ServicePqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetType() InputOffice365ServiceType {
	if i == nil {
		return InputOffice365ServiceType("")
	}
	return i.Type
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetTenantID() string {
	if i == nil {
		return ""
	}
	return i.TenantID
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetAppID() string {
	if i == nil {
		return ""
	}
	return i.AppID
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetContentConfig() []InputOffice365ServiceContentConfig {
	if i == nil {
		return nil
	}
	return i.ContentConfig
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365ServicePqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputOffice365ServicePqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     InputOffice365ServiceType `json:"type"`
	Disabled *bool                     `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `default:"300" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []InputOffice365ServiceContentConfig `json:"contentConfig,omitempty"`
	RetryRules    *components.RetryRulesType1          `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputOffice365ServicePqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetType() InputOffice365ServiceType {
	if i == nil {
		return InputOffice365ServiceType("")
	}
	return i.Type
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetTenantID() string {
	if i == nil {
		return ""
	}
	return i.TenantID
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetAppID() string {
	if i == nil {
		return ""
	}
	return i.AppID
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetContentConfig() []InputOffice365ServiceContentConfig {
	if i == nil {
		return nil
	}
	return i.ContentConfig
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365ServicePqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     InputOffice365ServiceType `json:"type"`
	Disabled *bool                     `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `default:"300" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []InputOffice365ServiceContentConfig `json:"contentConfig,omitempty"`
	RetryRules    *components.RetryRulesType1          `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetType() InputOffice365ServiceType {
	if i == nil {
		return InputOffice365ServiceType("")
	}
	return i.Type
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetTenantID() string {
	if i == nil {
		return ""
	}
	return i.TenantID
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetAppID() string {
	if i == nil {
		return ""
	}
	return i.AppID
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetContentConfig() []InputOffice365ServiceContentConfig {
	if i == nil {
		return nil
	}
	return i.ContentConfig
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputOffice365ServiceType string

const (
	InputOffice365ServiceTypeOffice365Service InputOffice365ServiceType = "office365_service"
)

func (e InputOffice365ServiceType) ToPointer() *InputOffice365ServiceType {
	return &e
}
func (e *InputOffice365ServiceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_service":
		*e = InputOffice365ServiceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputOffice365ServiceType: %v", v)
	}
}

type InputOffice365ServiceContentConfig struct {
	// Office 365 Services API Content Type
	ContentType *string `json:"contentType,omitempty"`
	// If interval type is minutes the value entered must evenly divisible by 60 or save will fail
	Description *string  `json:"description,omitempty"`
	Interval    *float64 `json:"interval,omitempty"`
	// Collector runtime Log Level
	LogLevel *components.LogLevelOptionsContentConfigItems `json:"logLevel,omitempty"`
	Enabled  *bool                                         `json:"enabled,omitempty"`
}

func (i InputOffice365ServiceContentConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365ServiceContentConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365ServiceContentConfig) GetContentType() *string {
	if i == nil {
		return nil
	}
	return i.ContentType
}

func (i *InputOffice365ServiceContentConfig) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365ServiceContentConfig) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputOffice365ServiceContentConfig) GetLogLevel() *components.LogLevelOptionsContentConfigItems {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputOffice365ServiceContentConfig) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

type InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                    `json:"id"`
	Type     InputOffice365ServiceType `json:"type"`
	Disabled *bool                     `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `default:"300" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []InputOffice365ServiceContentConfig `json:"contentConfig,omitempty"`
	RetryRules    *components.RetryRulesType1          `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetType() InputOffice365ServiceType {
	if i == nil {
		return InputOffice365ServiceType("")
	}
	return i.Type
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetTenantID() string {
	if i == nil {
		return ""
	}
	return i.TenantID
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetAppID() string {
	if i == nil {
		return ""
	}
	return i.AppID
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetContentConfig() []InputOffice365ServiceContentConfig {
	if i == nil {
		return nil
	}
	return i.ContentConfig
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputOffice365ServiceUnionType string

const (
	InputOffice365ServiceUnionTypeInputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint  InputOffice365ServiceUnionType = "InputOffice365Service_SendToRoutesTrueWithConnectionsConstraint"
	InputOffice365ServiceUnionTypeInputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint InputOffice365ServiceUnionType = "InputOffice365Service_SendToRoutesFalseWithConnectionsConstraint"
	InputOffice365ServiceUnionTypeInputOffice365ServicePqEnabledFalseWithPqConstraint             InputOffice365ServiceUnionType = "InputOffice365Service_PqEnabledFalseWithPqConstraint"
	InputOffice365ServiceUnionTypeInputOffice365ServicePqEnabledTrueWithPqConstraint              InputOffice365ServiceUnionType = "InputOffice365Service_PqEnabledTrueWithPqConstraint"
)

type InputOffice365Service struct {
	InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint  *InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint *InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputOffice365ServicePqEnabledFalseWithPqConstraint             *InputOffice365ServicePqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputOffice365ServicePqEnabledTrueWithPqConstraint              *InputOffice365ServicePqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputOffice365ServiceUnionType
}

func CreateInputOffice365ServiceInputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint(inputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint) InputOffice365Service {
	typ := InputOffice365ServiceUnionTypeInputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint

	return InputOffice365Service{
		InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint: &inputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputOffice365ServiceInputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint(inputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint) InputOffice365Service {
	typ := InputOffice365ServiceUnionTypeInputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint

	return InputOffice365Service{
		InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint: &inputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputOffice365ServiceInputOffice365ServicePqEnabledFalseWithPqConstraint(inputOffice365ServicePqEnabledFalseWithPqConstraint InputOffice365ServicePqEnabledFalseWithPqConstraint) InputOffice365Service {
	typ := InputOffice365ServiceUnionTypeInputOffice365ServicePqEnabledFalseWithPqConstraint

	return InputOffice365Service{
		InputOffice365ServicePqEnabledFalseWithPqConstraint: &inputOffice365ServicePqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputOffice365ServiceInputOffice365ServicePqEnabledTrueWithPqConstraint(inputOffice365ServicePqEnabledTrueWithPqConstraint InputOffice365ServicePqEnabledTrueWithPqConstraint) InputOffice365Service {
	typ := InputOffice365ServiceUnionTypeInputOffice365ServicePqEnabledTrueWithPqConstraint

	return InputOffice365Service{
		InputOffice365ServicePqEnabledTrueWithPqConstraint: &inputOffice365ServicePqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputOffice365Service) UnmarshalJSON(data []byte) error {

	var inputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint = InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint = &inputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputOffice365ServiceUnionTypeInputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint = InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint = &inputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputOffice365ServiceUnionTypeInputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputOffice365ServicePqEnabledFalseWithPqConstraint InputOffice365ServicePqEnabledFalseWithPqConstraint = InputOffice365ServicePqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365ServicePqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputOffice365ServicePqEnabledFalseWithPqConstraint = &inputOffice365ServicePqEnabledFalseWithPqConstraint
		u.Type = InputOffice365ServiceUnionTypeInputOffice365ServicePqEnabledFalseWithPqConstraint
		return nil
	}

	var inputOffice365ServicePqEnabledTrueWithPqConstraint InputOffice365ServicePqEnabledTrueWithPqConstraint = InputOffice365ServicePqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365ServicePqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputOffice365ServicePqEnabledTrueWithPqConstraint = &inputOffice365ServicePqEnabledTrueWithPqConstraint
		u.Type = InputOffice365ServiceUnionTypeInputOffice365ServicePqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputOffice365Service", string(data))
}

func (u InputOffice365Service) MarshalJSON() ([]byte, error) {
	if u.InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365ServiceSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputOffice365ServicePqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365ServicePqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputOffice365ServicePqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365ServicePqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputOffice365Service: all fields are null")
}

type InputOffice365MgmtPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputOffice365MgmtType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `default:"300" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
	PublisherIdentifier *string `json:"publisherIdentifier,omitempty"`
	// Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []InputOffice365MgmtContentConfig `json:"contentConfig,omitempty"`
	// Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
	IngestionLag *float64                    `default:"0" json:"ingestionLag"`
	RetryRules   *components.RetryRulesType1 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputOffice365MgmtPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetType() InputOffice365MgmtType {
	if i == nil {
		return InputOffice365MgmtType("")
	}
	return i.Type
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetTenantID() string {
	if i == nil {
		return ""
	}
	return i.TenantID
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetAppID() string {
	if i == nil {
		return ""
	}
	return i.AppID
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetPublisherIdentifier() *string {
	if i == nil {
		return nil
	}
	return i.PublisherIdentifier
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetContentConfig() []InputOffice365MgmtContentConfig {
	if i == nil {
		return nil
	}
	return i.ContentConfig
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetIngestionLag() *float64 {
	if i == nil {
		return nil
	}
	return i.IngestionLag
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365MgmtPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputOffice365MgmtPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputOffice365MgmtType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `default:"300" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
	PublisherIdentifier *string `json:"publisherIdentifier,omitempty"`
	// Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []InputOffice365MgmtContentConfig `json:"contentConfig,omitempty"`
	// Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
	IngestionLag *float64                    `default:"0" json:"ingestionLag"`
	RetryRules   *components.RetryRulesType1 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputOffice365MgmtPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetType() InputOffice365MgmtType {
	if i == nil {
		return InputOffice365MgmtType("")
	}
	return i.Type
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetTenantID() string {
	if i == nil {
		return ""
	}
	return i.TenantID
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetAppID() string {
	if i == nil {
		return ""
	}
	return i.AppID
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetPublisherIdentifier() *string {
	if i == nil {
		return nil
	}
	return i.PublisherIdentifier
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetContentConfig() []InputOffice365MgmtContentConfig {
	if i == nil {
		return nil
	}
	return i.ContentConfig
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetIngestionLag() *float64 {
	if i == nil {
		return nil
	}
	return i.IngestionLag
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365MgmtPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputOffice365MgmtType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `default:"300" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
	PublisherIdentifier *string `json:"publisherIdentifier,omitempty"`
	// Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []InputOffice365MgmtContentConfig `json:"contentConfig,omitempty"`
	// Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
	IngestionLag *float64                    `default:"0" json:"ingestionLag"`
	RetryRules   *components.RetryRulesType1 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetType() InputOffice365MgmtType {
	if i == nil {
		return InputOffice365MgmtType("")
	}
	return i.Type
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetTenantID() string {
	if i == nil {
		return ""
	}
	return i.TenantID
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetAppID() string {
	if i == nil {
		return ""
	}
	return i.AppID
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetPublisherIdentifier() *string {
	if i == nil {
		return nil
	}
	return i.PublisherIdentifier
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetContentConfig() []InputOffice365MgmtContentConfig {
	if i == nil {
		return nil
	}
	return i.ContentConfig
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetIngestionLag() *float64 {
	if i == nil {
		return nil
	}
	return i.IngestionLag
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputOffice365MgmtType string

const (
	InputOffice365MgmtTypeOffice365Mgmt InputOffice365MgmtType = "office365_mgmt"
)

func (e InputOffice365MgmtType) ToPointer() *InputOffice365MgmtType {
	return &e
}
func (e *InputOffice365MgmtType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "office365_mgmt":
		*e = InputOffice365MgmtType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputOffice365MgmtType: %v", v)
	}
}

type InputOffice365MgmtContentConfig struct {
	// Office 365 Management Activity API Content Type
	ContentType *string `json:"contentType,omitempty"`
	// If interval type is minutes the value entered must evenly divisible by 60 or save will fail
	Description *string  `json:"description,omitempty"`
	Interval    *float64 `json:"interval,omitempty"`
	// Collector runtime Log Level
	LogLevel *components.LogLevelOptionsContentConfigItems `json:"logLevel,omitempty"`
	Enabled  *bool                                         `json:"enabled,omitempty"`
}

func (i InputOffice365MgmtContentConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MgmtContentConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MgmtContentConfig) GetContentType() *string {
	if i == nil {
		return nil
	}
	return i.ContentType
}

func (i *InputOffice365MgmtContentConfig) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MgmtContentConfig) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputOffice365MgmtContentConfig) GetLogLevel() *components.LogLevelOptionsContentConfigItems {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputOffice365MgmtContentConfig) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

type InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                 `json:"id"`
	Type     InputOffice365MgmtType `json:"type"`
	Disabled *bool                  `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *components.SubscriptionPlanOptions `default:"enterprise_gcc" json:"planType"`
	// Office 365 Azure Tenant ID
	TenantID string `json:"tenantId"`
	// Office 365 Azure Application ID
	AppID string `json:"appId"`
	// HTTP request inactivity timeout, use 0 to disable
	Timeout *float64 `default:"300" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
	PublisherIdentifier *string `json:"publisherIdentifier,omitempty"`
	// Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig []InputOffice365MgmtContentConfig `json:"contentConfig,omitempty"`
	// Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
	IngestionLag *float64                    `default:"0" json:"ingestionLag"`
	RetryRules   *components.RetryRulesType1 `json:"retryRules,omitempty"`
	// Enter client secret directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptions1 `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	// Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

func (i InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "tenantId", "appId"}); err != nil {
		return err
	}
	return nil
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetType() InputOffice365MgmtType {
	if i == nil {
		return InputOffice365MgmtType("")
	}
	return i.Type
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetPlanType() *components.SubscriptionPlanOptions {
	if i == nil {
		return nil
	}
	return i.PlanType
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetTenantID() string {
	if i == nil {
		return ""
	}
	return i.TenantID
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetAppID() string {
	if i == nil {
		return ""
	}
	return i.AppID
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetPublisherIdentifier() *string {
	if i == nil {
		return nil
	}
	return i.PublisherIdentifier
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetContentConfig() []InputOffice365MgmtContentConfig {
	if i == nil {
		return nil
	}
	return i.ContentConfig
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetIngestionLag() *float64 {
	if i == nil {
		return nil
	}
	return i.IngestionLag
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType1 {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptions1 {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetClientSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecret
}

func (i *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

type InputOffice365MgmtUnionType string

const (
	InputOffice365MgmtUnionTypeInputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint  InputOffice365MgmtUnionType = "InputOffice365Mgmt_SendToRoutesTrueWithConnectionsConstraint"
	InputOffice365MgmtUnionTypeInputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint InputOffice365MgmtUnionType = "InputOffice365Mgmt_SendToRoutesFalseWithConnectionsConstraint"
	InputOffice365MgmtUnionTypeInputOffice365MgmtPqEnabledFalseWithPqConstraint             InputOffice365MgmtUnionType = "InputOffice365Mgmt_PqEnabledFalseWithPqConstraint"
	InputOffice365MgmtUnionTypeInputOffice365MgmtPqEnabledTrueWithPqConstraint              InputOffice365MgmtUnionType = "InputOffice365Mgmt_PqEnabledTrueWithPqConstraint"
)

type InputOffice365Mgmt struct {
	InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint  *InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint *InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputOffice365MgmtPqEnabledFalseWithPqConstraint             *InputOffice365MgmtPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputOffice365MgmtPqEnabledTrueWithPqConstraint              *InputOffice365MgmtPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputOffice365MgmtUnionType
}

func CreateInputOffice365MgmtInputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint(inputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint) InputOffice365Mgmt {
	typ := InputOffice365MgmtUnionTypeInputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint

	return InputOffice365Mgmt{
		InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint: &inputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputOffice365MgmtInputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint(inputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint) InputOffice365Mgmt {
	typ := InputOffice365MgmtUnionTypeInputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint

	return InputOffice365Mgmt{
		InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint: &inputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputOffice365MgmtInputOffice365MgmtPqEnabledFalseWithPqConstraint(inputOffice365MgmtPqEnabledFalseWithPqConstraint InputOffice365MgmtPqEnabledFalseWithPqConstraint) InputOffice365Mgmt {
	typ := InputOffice365MgmtUnionTypeInputOffice365MgmtPqEnabledFalseWithPqConstraint

	return InputOffice365Mgmt{
		InputOffice365MgmtPqEnabledFalseWithPqConstraint: &inputOffice365MgmtPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputOffice365MgmtInputOffice365MgmtPqEnabledTrueWithPqConstraint(inputOffice365MgmtPqEnabledTrueWithPqConstraint InputOffice365MgmtPqEnabledTrueWithPqConstraint) InputOffice365Mgmt {
	typ := InputOffice365MgmtUnionTypeInputOffice365MgmtPqEnabledTrueWithPqConstraint

	return InputOffice365Mgmt{
		InputOffice365MgmtPqEnabledTrueWithPqConstraint: &inputOffice365MgmtPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputOffice365Mgmt) UnmarshalJSON(data []byte) error {

	var inputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint = InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint = &inputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputOffice365MgmtUnionTypeInputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint = InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint = &inputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputOffice365MgmtUnionTypeInputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputOffice365MgmtPqEnabledFalseWithPqConstraint InputOffice365MgmtPqEnabledFalseWithPqConstraint = InputOffice365MgmtPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365MgmtPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputOffice365MgmtPqEnabledFalseWithPqConstraint = &inputOffice365MgmtPqEnabledFalseWithPqConstraint
		u.Type = InputOffice365MgmtUnionTypeInputOffice365MgmtPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputOffice365MgmtPqEnabledTrueWithPqConstraint InputOffice365MgmtPqEnabledTrueWithPqConstraint = InputOffice365MgmtPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputOffice365MgmtPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputOffice365MgmtPqEnabledTrueWithPqConstraint = &inputOffice365MgmtPqEnabledTrueWithPqConstraint
		u.Type = InputOffice365MgmtUnionTypeInputOffice365MgmtPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputOffice365Mgmt", string(data))
}

func (u InputOffice365Mgmt) MarshalJSON() ([]byte, error) {
	if u.InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365MgmtSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputOffice365MgmtPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365MgmtPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputOffice365MgmtPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputOffice365MgmtPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputOffice365Mgmt: all fields are null")
}

type InputEdgePrometheusPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputEdgePrometheusType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputEdgePrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval *float64 `default:"15" json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64                     `default:"5000" json:"timeout"`
	Persistence *components.DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *InputEdgePrometheusAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	Targets     []Target                                 `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *components.ProtocolOptionsTargetsItems `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `default:"metadata.annotations['prometheus.io/scheme'] || 'http'" json:"scrapeProtocolExpr"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `default:"metadata.annotations['prometheus.io/port'] || 9090" json:"scrapePortExpr"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `default:"metadata.annotations['prometheus.io/path'] || '/metrics'" json:"scrapePathExpr"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []PodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputEdgePrometheusPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetType() InputEdgePrometheusType {
	if i == nil {
		return InputEdgePrometheusType("")
	}
	return i.Type
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDiscoveryType() *InputEdgePrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPersistence() *components.DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAuthType() *InputEdgePrometheusAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetTargets() []Target {
	if i == nil {
		return nil
	}
	return i.Targets
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetRecordType() *components.RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapeProtocol() *components.ProtocolOptionsTargetsItems {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapeProtocolExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocolExpr
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapePortExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePortExpr
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapePathExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePathExpr
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPodFilter() []PodFilter {
	if i == nil {
		return nil
	}
	return i.PodFilter
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputEdgePrometheusPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputEdgePrometheusType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputEdgePrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval *float64 `default:"15" json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64                     `default:"5000" json:"timeout"`
	Persistence *components.DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *InputEdgePrometheusAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	Targets     []Target                                 `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *components.ProtocolOptionsTargetsItems `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `default:"metadata.annotations['prometheus.io/scheme'] || 'http'" json:"scrapeProtocolExpr"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `default:"metadata.annotations['prometheus.io/port'] || 9090" json:"scrapePortExpr"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `default:"metadata.annotations['prometheus.io/path'] || '/metrics'" json:"scrapePathExpr"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []PodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputEdgePrometheusPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetType() InputEdgePrometheusType {
	if i == nil {
		return InputEdgePrometheusType("")
	}
	return i.Type
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDiscoveryType() *InputEdgePrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPersistence() *components.DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAuthType() *InputEdgePrometheusAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetTargets() []Target {
	if i == nil {
		return nil
	}
	return i.Targets
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetRecordType() *components.RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapeProtocol() *components.ProtocolOptionsTargetsItems {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapeProtocolExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocolExpr
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapePortExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePortExpr
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapePathExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePathExpr
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPodFilter() []PodFilter {
	if i == nil {
		return nil
	}
	return i.PodFilter
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputEdgePrometheusType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputEdgePrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval *float64 `default:"15" json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64                     `default:"5000" json:"timeout"`
	Persistence *components.DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *InputEdgePrometheusAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	Targets     []Target                                 `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *components.ProtocolOptionsTargetsItems `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `default:"metadata.annotations['prometheus.io/scheme'] || 'http'" json:"scrapeProtocolExpr"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `default:"metadata.annotations['prometheus.io/port'] || 9090" json:"scrapePortExpr"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `default:"metadata.annotations['prometheus.io/path'] || '/metrics'" json:"scrapePathExpr"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []PodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetType() InputEdgePrometheusType {
	if i == nil {
		return InputEdgePrometheusType("")
	}
	return i.Type
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDiscoveryType() *InputEdgePrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPersistence() *components.DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *InputEdgePrometheusAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetTargets() []Target {
	if i == nil {
		return nil
	}
	return i.Targets
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetRecordType() *components.RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapeProtocol() *components.ProtocolOptionsTargetsItems {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapeProtocolExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocolExpr
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePortExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePortExpr
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePathExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePathExpr
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPodFilter() []PodFilter {
	if i == nil {
		return nil
	}
	return i.PodFilter
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputEdgePrometheusType string

const (
	InputEdgePrometheusTypeEdgePrometheus InputEdgePrometheusType = "edge_prometheus"
)

func (e InputEdgePrometheusType) ToPointer() *InputEdgePrometheusType {
	return &e
}
func (e *InputEdgePrometheusType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "edge_prometheus":
		*e = InputEdgePrometheusType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputEdgePrometheusType: %v", v)
	}
}

// InputEdgePrometheusDiscoveryType - Target discovery mechanism. Use static to manually enter a list of targets.
type InputEdgePrometheusDiscoveryType string

const (
	// InputEdgePrometheusDiscoveryTypeStatic Static
	InputEdgePrometheusDiscoveryTypeStatic InputEdgePrometheusDiscoveryType = "static"
	// InputEdgePrometheusDiscoveryTypeDNS DNS
	InputEdgePrometheusDiscoveryTypeDNS InputEdgePrometheusDiscoveryType = "dns"
	// InputEdgePrometheusDiscoveryTypeEc2 AWS EC2
	InputEdgePrometheusDiscoveryTypeEc2 InputEdgePrometheusDiscoveryType = "ec2"
	// InputEdgePrometheusDiscoveryTypeK8sNode Kubernetes Node
	InputEdgePrometheusDiscoveryTypeK8sNode InputEdgePrometheusDiscoveryType = "k8s-node"
	// InputEdgePrometheusDiscoveryTypeK8sPods Kubernetes Pods
	InputEdgePrometheusDiscoveryTypeK8sPods InputEdgePrometheusDiscoveryType = "k8s-pods"
)

func (e InputEdgePrometheusDiscoveryType) ToPointer() *InputEdgePrometheusDiscoveryType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputEdgePrometheusDiscoveryType) IsExact() bool {
	if e != nil {
		switch *e {
		case "static", "dns", "ec2", "k8s-node", "k8s-pods":
			return true
		}
	}
	return false
}

// InputEdgePrometheusAuthenticationMethod - Enter credentials directly, or select a stored secret
type InputEdgePrometheusAuthenticationMethod string

const (
	InputEdgePrometheusAuthenticationMethodManual     InputEdgePrometheusAuthenticationMethod = "manual"
	InputEdgePrometheusAuthenticationMethodSecret     InputEdgePrometheusAuthenticationMethod = "secret"
	InputEdgePrometheusAuthenticationMethodKubernetes InputEdgePrometheusAuthenticationMethod = "kubernetes"
)

func (e InputEdgePrometheusAuthenticationMethod) ToPointer() *InputEdgePrometheusAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputEdgePrometheusAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "kubernetes":
			return true
		}
	}
	return false
}

type Target struct {
	// Protocol to use when collecting metrics
	Protocol *components.ProtocolOptionsTargetsItems `default:"http" json:"protocol"`
	// Name of host from which to pull metrics.
	Host string `json:"host"`
	// The port number in the metrics URL for discovered targets.
	Port *float64 `default:"9090" json:"port"`
	// Path to use when collecting metrics from discovered targets
	Path *string `default:"/metrics" json:"path"`
}

func (t Target) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Target) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"host"}); err != nil {
		return err
	}
	return nil
}

func (t *Target) GetProtocol() *components.ProtocolOptionsTargetsItems {
	if t == nil {
		return nil
	}
	return t.Protocol
}

func (t *Target) GetHost() string {
	if t == nil {
		return ""
	}
	return t.Host
}

func (t *Target) GetPort() *float64 {
	if t == nil {
		return nil
	}
	return t.Port
}

func (t *Target) GetPath() *string {
	if t == nil {
		return nil
	}
	return t.Path
}

type PodFilter struct {
	// JavaScript expression applied to pods objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (p PodFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PodFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (p *PodFilter) GetFilter() string {
	if p == nil {
		return ""
	}
	return p.Filter
}

func (p *PodFilter) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

type InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputEdgePrometheusType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputEdgePrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval *float64 `default:"15" json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64                     `default:"5000" json:"timeout"`
	Persistence *components.DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *InputEdgePrometheusAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	Targets     []Target                                 `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *components.ProtocolOptionsTargetsItems `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `default:"metadata.annotations['prometheus.io/scheme'] || 'http'" json:"scrapeProtocolExpr"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `default:"metadata.annotations['prometheus.io/port'] || 9090" json:"scrapePortExpr"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `default:"metadata.annotations['prometheus.io/path'] || '/metrics'" json:"scrapePathExpr"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []PodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetType() InputEdgePrometheusType {
	if i == nil {
		return InputEdgePrometheusType("")
	}
	return i.Type
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDiscoveryType() *InputEdgePrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPersistence() *components.DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *InputEdgePrometheusAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetTargets() []Target {
	if i == nil {
		return nil
	}
	return i.Targets
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetRecordType() *components.RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapeProtocol() *components.ProtocolOptionsTargetsItems {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapeProtocolExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocolExpr
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePortExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePortExpr
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePathExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePathExpr
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPodFilter() []PodFilter {
	if i == nil {
		return nil
	}
	return i.PodFilter
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputEdgePrometheusUnionType string

const (
	InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint  InputEdgePrometheusUnionType = "InputEdgePrometheus_SendToRoutesTrueWithConnectionsConstraint"
	InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint InputEdgePrometheusUnionType = "InputEdgePrometheus_SendToRoutesFalseWithConnectionsConstraint"
	InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledFalseWithPqConstraint             InputEdgePrometheusUnionType = "InputEdgePrometheus_PqEnabledFalseWithPqConstraint"
	InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledTrueWithPqConstraint              InputEdgePrometheusUnionType = "InputEdgePrometheus_PqEnabledTrueWithPqConstraint"
)

type InputEdgePrometheus struct {
	InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint  *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputEdgePrometheusPqEnabledFalseWithPqConstraint             *InputEdgePrometheusPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputEdgePrometheusPqEnabledTrueWithPqConstraint              *InputEdgePrometheusPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputEdgePrometheusUnionType
}

func CreateInputEdgePrometheusInputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint(inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) InputEdgePrometheus {
	typ := InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint

	return InputEdgePrometheus{
		InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint: &inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputEdgePrometheusInputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint(inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) InputEdgePrometheus {
	typ := InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint

	return InputEdgePrometheus{
		InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint: &inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputEdgePrometheusInputEdgePrometheusPqEnabledFalseWithPqConstraint(inputEdgePrometheusPqEnabledFalseWithPqConstraint InputEdgePrometheusPqEnabledFalseWithPqConstraint) InputEdgePrometheus {
	typ := InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledFalseWithPqConstraint

	return InputEdgePrometheus{
		InputEdgePrometheusPqEnabledFalseWithPqConstraint: &inputEdgePrometheusPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputEdgePrometheusInputEdgePrometheusPqEnabledTrueWithPqConstraint(inputEdgePrometheusPqEnabledTrueWithPqConstraint InputEdgePrometheusPqEnabledTrueWithPqConstraint) InputEdgePrometheus {
	typ := InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledTrueWithPqConstraint

	return InputEdgePrometheus{
		InputEdgePrometheusPqEnabledTrueWithPqConstraint: &inputEdgePrometheusPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputEdgePrometheus) UnmarshalJSON(data []byte) error {

	var inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint = InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint = &inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint = InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint = &inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputEdgePrometheusPqEnabledFalseWithPqConstraint InputEdgePrometheusPqEnabledFalseWithPqConstraint = InputEdgePrometheusPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEdgePrometheusPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputEdgePrometheusPqEnabledFalseWithPqConstraint = &inputEdgePrometheusPqEnabledFalseWithPqConstraint
		u.Type = InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputEdgePrometheusPqEnabledTrueWithPqConstraint InputEdgePrometheusPqEnabledTrueWithPqConstraint = InputEdgePrometheusPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEdgePrometheusPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputEdgePrometheusPqEnabledTrueWithPqConstraint = &inputEdgePrometheusPqEnabledTrueWithPqConstraint
		u.Type = InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputEdgePrometheus", string(data))
}

func (u InputEdgePrometheus) MarshalJSON() ([]byte, error) {
	if u.InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputEdgePrometheusPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputEdgePrometheusPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputEdgePrometheusPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputEdgePrometheusPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputEdgePrometheus: all fields are null")
}

type InputPrometheusPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputPrometheusType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval *float64 `default:"15" json:"interval"`
	// Collector runtime log level
	LogLevel *InputPrometheusLogLevel `default:"info" json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `default:"0" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptionsSasl `default:"manual" json:"authType"`
	Description *string                                     `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *MetricsProtocol `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputPrometheusPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetType() InputPrometheusType {
	if i == nil {
		return InputPrometheusType("")
	}
	return i.Type
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDiscoveryType() *InputPrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetLogLevel() *InputPrometheusLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptionsSasl {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetTargetList() []string {
	if i == nil {
		return nil
	}
	return i.TargetList
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetRecordType() *components.RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetScrapeProtocol() *MetricsProtocol {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputPrometheusPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputPrometheusType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval *float64 `default:"15" json:"interval"`
	// Collector runtime log level
	LogLevel *InputPrometheusLogLevel `default:"info" json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `default:"0" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptionsSasl `default:"manual" json:"authType"`
	Description *string                                     `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *MetricsProtocol `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputPrometheusPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetType() InputPrometheusType {
	if i == nil {
		return InputPrometheusType("")
	}
	return i.Type
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDiscoveryType() *InputPrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetLogLevel() *InputPrometheusLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptionsSasl {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetTargetList() []string {
	if i == nil {
		return nil
	}
	return i.TargetList
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetRecordType() *components.RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetScrapeProtocol() *MetricsProtocol {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputPrometheusSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputPrometheusType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval *float64 `default:"15" json:"interval"`
	// Collector runtime log level
	LogLevel *InputPrometheusLogLevel `default:"info" json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `default:"0" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptionsSasl `default:"manual" json:"authType"`
	Description *string                                     `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *MetricsProtocol `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputPrometheusSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetType() InputPrometheusType {
	if i == nil {
		return InputPrometheusType("")
	}
	return i.Type
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDiscoveryType() *InputPrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetLogLevel() *InputPrometheusLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptionsSasl {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetTargetList() []string {
	if i == nil {
		return nil
	}
	return i.TargetList
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetRecordType() *components.RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapeProtocol() *MetricsProtocol {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputPrometheusType string

const (
	InputPrometheusTypePrometheus InputPrometheusType = "prometheus"
)

func (e InputPrometheusType) ToPointer() *InputPrometheusType {
	return &e
}
func (e *InputPrometheusType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prometheus":
		*e = InputPrometheusType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputPrometheusType: %v", v)
	}
}

// InputPrometheusDiscoveryType - Target discovery mechanism. Use static to manually enter a list of targets.
type InputPrometheusDiscoveryType string

const (
	// InputPrometheusDiscoveryTypeStatic Static
	InputPrometheusDiscoveryTypeStatic InputPrometheusDiscoveryType = "static"
	// InputPrometheusDiscoveryTypeDNS DNS
	InputPrometheusDiscoveryTypeDNS InputPrometheusDiscoveryType = "dns"
	// InputPrometheusDiscoveryTypeEc2 AWS EC2
	InputPrometheusDiscoveryTypeEc2 InputPrometheusDiscoveryType = "ec2"
)

func (e InputPrometheusDiscoveryType) ToPointer() *InputPrometheusDiscoveryType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputPrometheusDiscoveryType) IsExact() bool {
	if e != nil {
		switch *e {
		case "static", "dns", "ec2":
			return true
		}
	}
	return false
}

// InputPrometheusLogLevel - Collector runtime log level
type InputPrometheusLogLevel string

const (
	InputPrometheusLogLevelError InputPrometheusLogLevel = "error"
	InputPrometheusLogLevelWarn  InputPrometheusLogLevel = "warn"
	InputPrometheusLogLevelInfo  InputPrometheusLogLevel = "info"
	InputPrometheusLogLevelDebug InputPrometheusLogLevel = "debug"
)

func (e InputPrometheusLogLevel) ToPointer() *InputPrometheusLogLevel {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputPrometheusLogLevel) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug":
			return true
		}
	}
	return false
}

// MetricsProtocol - Protocol to use when collecting metrics
type MetricsProtocol string

const (
	MetricsProtocolHTTP  MetricsProtocol = "http"
	MetricsProtocolHTTPS MetricsProtocol = "https"
)

func (e MetricsProtocol) ToPointer() *MetricsProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *MetricsProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "http", "https":
			return true
		}
	}
	return false
}

type InputPrometheusSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string              `json:"id"`
	Type     InputPrometheusType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval *float64 `default:"15" json:"interval"`
	// Collector runtime log level
	LogLevel *InputPrometheusLogLevel `default:"info" json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `default:"0" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *components.AuthenticationMethodOptionsSasl `default:"manual" json:"authType"`
	Description *string                                     `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *components.RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *MetricsProtocol `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                                `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []components.ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                            `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *components.SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputPrometheusSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetType() InputPrometheusType {
	if i == nil {
		return InputPrometheusType("")
	}
	return i.Type
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDiscoveryType() *InputPrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetLogLevel() *InputPrometheusLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptionsSasl {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetTargetList() []string {
	if i == nil {
		return nil
	}
	return i.TargetList
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetRecordType() *components.RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapeProtocol() *MetricsProtocol {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetSearchFilter() []components.ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputPrometheusUnionType string

const (
	InputPrometheusUnionTypeInputPrometheusSendToRoutesTrueWithConnectionsConstraint  InputPrometheusUnionType = "InputPrometheus_SendToRoutesTrueWithConnectionsConstraint"
	InputPrometheusUnionTypeInputPrometheusSendToRoutesFalseWithConnectionsConstraint InputPrometheusUnionType = "InputPrometheus_SendToRoutesFalseWithConnectionsConstraint"
	InputPrometheusUnionTypeInputPrometheusPqEnabledFalseWithPqConstraint             InputPrometheusUnionType = "InputPrometheus_PqEnabledFalseWithPqConstraint"
	InputPrometheusUnionTypeInputPrometheusPqEnabledTrueWithPqConstraint              InputPrometheusUnionType = "InputPrometheus_PqEnabledTrueWithPqConstraint"
)

type InputPrometheus struct {
	InputPrometheusSendToRoutesTrueWithConnectionsConstraint  *InputPrometheusSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputPrometheusSendToRoutesFalseWithConnectionsConstraint *InputPrometheusSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputPrometheusPqEnabledFalseWithPqConstraint             *InputPrometheusPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputPrometheusPqEnabledTrueWithPqConstraint              *InputPrometheusPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputPrometheusUnionType
}

func CreateInputPrometheusInputPrometheusSendToRoutesTrueWithConnectionsConstraint(inputPrometheusSendToRoutesTrueWithConnectionsConstraint InputPrometheusSendToRoutesTrueWithConnectionsConstraint) InputPrometheus {
	typ := InputPrometheusUnionTypeInputPrometheusSendToRoutesTrueWithConnectionsConstraint

	return InputPrometheus{
		InputPrometheusSendToRoutesTrueWithConnectionsConstraint: &inputPrometheusSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusInputPrometheusSendToRoutesFalseWithConnectionsConstraint(inputPrometheusSendToRoutesFalseWithConnectionsConstraint InputPrometheusSendToRoutesFalseWithConnectionsConstraint) InputPrometheus {
	typ := InputPrometheusUnionTypeInputPrometheusSendToRoutesFalseWithConnectionsConstraint

	return InputPrometheus{
		InputPrometheusSendToRoutesFalseWithConnectionsConstraint: &inputPrometheusSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusInputPrometheusPqEnabledFalseWithPqConstraint(inputPrometheusPqEnabledFalseWithPqConstraint InputPrometheusPqEnabledFalseWithPqConstraint) InputPrometheus {
	typ := InputPrometheusUnionTypeInputPrometheusPqEnabledFalseWithPqConstraint

	return InputPrometheus{
		InputPrometheusPqEnabledFalseWithPqConstraint: &inputPrometheusPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusInputPrometheusPqEnabledTrueWithPqConstraint(inputPrometheusPqEnabledTrueWithPqConstraint InputPrometheusPqEnabledTrueWithPqConstraint) InputPrometheus {
	typ := InputPrometheusUnionTypeInputPrometheusPqEnabledTrueWithPqConstraint

	return InputPrometheus{
		InputPrometheusPqEnabledTrueWithPqConstraint: &inputPrometheusPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputPrometheus) UnmarshalJSON(data []byte) error {

	var inputPrometheusSendToRoutesTrueWithConnectionsConstraint InputPrometheusSendToRoutesTrueWithConnectionsConstraint = InputPrometheusSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputPrometheusSendToRoutesTrueWithConnectionsConstraint = &inputPrometheusSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputPrometheusUnionTypeInputPrometheusSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputPrometheusSendToRoutesFalseWithConnectionsConstraint InputPrometheusSendToRoutesFalseWithConnectionsConstraint = InputPrometheusSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputPrometheusSendToRoutesFalseWithConnectionsConstraint = &inputPrometheusSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputPrometheusUnionTypeInputPrometheusSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputPrometheusPqEnabledFalseWithPqConstraint InputPrometheusPqEnabledFalseWithPqConstraint = InputPrometheusPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputPrometheusPqEnabledFalseWithPqConstraint = &inputPrometheusPqEnabledFalseWithPqConstraint
		u.Type = InputPrometheusUnionTypeInputPrometheusPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputPrometheusPqEnabledTrueWithPqConstraint InputPrometheusPqEnabledTrueWithPqConstraint = InputPrometheusPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputPrometheusPqEnabledTrueWithPqConstraint = &inputPrometheusPqEnabledTrueWithPqConstraint
		u.Type = InputPrometheusUnionTypeInputPrometheusPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputPrometheus", string(data))
}

func (u InputPrometheus) MarshalJSON() ([]byte, error) {
	if u.InputPrometheusSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputPrometheusSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputPrometheusPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputPrometheusPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputPrometheus: all fields are null")
}

type InputPrometheusRwPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputPrometheusRwType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
	PrometheusAPI *string `default:"/write" json:"prometheusAPI"`
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputPrometheusRwPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetType() InputPrometheusRwType {
	if i == nil {
		return InputPrometheusRwType("")
	}
	return i.Type
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetPrometheusAPI() *string {
	if i == nil {
		return nil
	}
	return i.PrometheusAPI
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputPrometheusRwPqEnabledTrueWithPqConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputPrometheusRwPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputPrometheusRwType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
	PrometheusAPI *string `default:"/write" json:"prometheusAPI"`
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputPrometheusRwPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetType() InputPrometheusRwType {
	if i == nil {
		return InputPrometheusRwType("")
	}
	return i.Type
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetPrometheusAPI() *string {
	if i == nil {
		return nil
	}
	return i.PrometheusAPI
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputPrometheusRwPqEnabledFalseWithPqConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputPrometheusRwType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
	PrometheusAPI *string `default:"/write" json:"prometheusAPI"`
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetType() InputPrometheusRwType {
	if i == nil {
		return InputPrometheusRwType("")
	}
	return i.Type
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetPrometheusAPI() *string {
	if i == nil {
		return nil
	}
	return i.PrometheusAPI
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputPrometheusRwType string

const (
	InputPrometheusRwTypePrometheusRw InputPrometheusRwType = "prometheus_rw"
)

func (e InputPrometheusRwType) ToPointer() *InputPrometheusRwType {
	return &e
}
func (e *InputPrometheusRwType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prometheus_rw":
		*e = InputPrometheusRwType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputPrometheusRwType: %v", v)
	}
}

type InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputPrometheusRwType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
	PrometheusAPI *string `default:"/write" json:"prometheusAPI"`
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetType() InputPrometheusRwType {
	if i == nil {
		return InputPrometheusRwType("")
	}
	return i.Type
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetPrometheusAPI() *string {
	if i == nil {
		return nil
	}
	return i.PrometheusAPI
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputPrometheusRwUnionType string

const (
	InputPrometheusRwUnionTypeInputPrometheusRwSendToRoutesTrueWithConnectionsConstraint  InputPrometheusRwUnionType = "InputPrometheusRw_SendToRoutesTrueWithConnectionsConstraint"
	InputPrometheusRwUnionTypeInputPrometheusRwSendToRoutesFalseWithConnectionsConstraint InputPrometheusRwUnionType = "InputPrometheusRw_SendToRoutesFalseWithConnectionsConstraint"
	InputPrometheusRwUnionTypeInputPrometheusRwPqEnabledFalseWithPqConstraint             InputPrometheusRwUnionType = "InputPrometheusRw_PqEnabledFalseWithPqConstraint"
	InputPrometheusRwUnionTypeInputPrometheusRwPqEnabledTrueWithPqConstraint              InputPrometheusRwUnionType = "InputPrometheusRw_PqEnabledTrueWithPqConstraint"
)

type InputPrometheusRw struct {
	InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint  *InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint *InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputPrometheusRwPqEnabledFalseWithPqConstraint             *InputPrometheusRwPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputPrometheusRwPqEnabledTrueWithPqConstraint              *InputPrometheusRwPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputPrometheusRwUnionType
}

func CreateInputPrometheusRwInputPrometheusRwSendToRoutesTrueWithConnectionsConstraint(inputPrometheusRwSendToRoutesTrueWithConnectionsConstraint InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint) InputPrometheusRw {
	typ := InputPrometheusRwUnionTypeInputPrometheusRwSendToRoutesTrueWithConnectionsConstraint

	return InputPrometheusRw{
		InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint: &inputPrometheusRwSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusRwInputPrometheusRwSendToRoutesFalseWithConnectionsConstraint(inputPrometheusRwSendToRoutesFalseWithConnectionsConstraint InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint) InputPrometheusRw {
	typ := InputPrometheusRwUnionTypeInputPrometheusRwSendToRoutesFalseWithConnectionsConstraint

	return InputPrometheusRw{
		InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint: &inputPrometheusRwSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusRwInputPrometheusRwPqEnabledFalseWithPqConstraint(inputPrometheusRwPqEnabledFalseWithPqConstraint InputPrometheusRwPqEnabledFalseWithPqConstraint) InputPrometheusRw {
	typ := InputPrometheusRwUnionTypeInputPrometheusRwPqEnabledFalseWithPqConstraint

	return InputPrometheusRw{
		InputPrometheusRwPqEnabledFalseWithPqConstraint: &inputPrometheusRwPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusRwInputPrometheusRwPqEnabledTrueWithPqConstraint(inputPrometheusRwPqEnabledTrueWithPqConstraint InputPrometheusRwPqEnabledTrueWithPqConstraint) InputPrometheusRw {
	typ := InputPrometheusRwUnionTypeInputPrometheusRwPqEnabledTrueWithPqConstraint

	return InputPrometheusRw{
		InputPrometheusRwPqEnabledTrueWithPqConstraint: &inputPrometheusRwPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputPrometheusRw) UnmarshalJSON(data []byte) error {

	var inputPrometheusRwSendToRoutesTrueWithConnectionsConstraint InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint = InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusRwSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint = &inputPrometheusRwSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputPrometheusRwUnionTypeInputPrometheusRwSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputPrometheusRwSendToRoutesFalseWithConnectionsConstraint InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint = InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusRwSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint = &inputPrometheusRwSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputPrometheusRwUnionTypeInputPrometheusRwSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputPrometheusRwPqEnabledFalseWithPqConstraint InputPrometheusRwPqEnabledFalseWithPqConstraint = InputPrometheusRwPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusRwPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputPrometheusRwPqEnabledFalseWithPqConstraint = &inputPrometheusRwPqEnabledFalseWithPqConstraint
		u.Type = InputPrometheusRwUnionTypeInputPrometheusRwPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputPrometheusRwPqEnabledTrueWithPqConstraint InputPrometheusRwPqEnabledTrueWithPqConstraint = InputPrometheusRwPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusRwPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputPrometheusRwPqEnabledTrueWithPqConstraint = &inputPrometheusRwPqEnabledTrueWithPqConstraint
		u.Type = InputPrometheusRwUnionTypeInputPrometheusRwPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputPrometheusRw", string(data))
}

func (u InputPrometheusRw) MarshalJSON() ([]byte, error) {
	if u.InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusRwSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputPrometheusRwPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusRwPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputPrometheusRwPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusRwPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputPrometheusRw: all fields are null")
}

type InputLokiPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputLokiType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputLokiPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetType() InputLokiType {
	if i == nil {
		return InputLokiType("")
	}
	return i.Type
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiPqEnabledTrueWithPqConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputLokiType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputLokiPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetType() InputLokiType {
	if i == nil {
		return InputLokiType("")
	}
	return i.Type
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiPqEnabledFalseWithPqConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputLokiType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputLokiSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetType() InputLokiType {
	if i == nil {
		return InputLokiType("")
	}
	return i.Type
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiSendToRoutesFalseWithConnectionsConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiType string

const (
	InputLokiTypeLoki InputLokiType = "loki"
)

func (e InputLokiType) ToPointer() *InputLokiType {
	return &e
}
func (e *InputLokiType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "loki":
		*e = InputLokiType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputLokiType: %v", v)
	}
}

type InputLokiSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputLokiType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `default:"none" json:"authType"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputLokiSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetType() InputLokiType {
	if i == nil {
		return InputLokiType("")
	}
	return i.Type
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiSendToRoutesTrueWithConnectionsConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiUnionType string

const (
	InputLokiUnionTypeInputLokiSendToRoutesTrueWithConnectionsConstraint  InputLokiUnionType = "InputLoki_SendToRoutesTrueWithConnectionsConstraint"
	InputLokiUnionTypeInputLokiSendToRoutesFalseWithConnectionsConstraint InputLokiUnionType = "InputLoki_SendToRoutesFalseWithConnectionsConstraint"
	InputLokiUnionTypeInputLokiPqEnabledFalseWithPqConstraint             InputLokiUnionType = "InputLoki_PqEnabledFalseWithPqConstraint"
	InputLokiUnionTypeInputLokiPqEnabledTrueWithPqConstraint              InputLokiUnionType = "InputLoki_PqEnabledTrueWithPqConstraint"
)

type InputLoki struct {
	InputLokiSendToRoutesTrueWithConnectionsConstraint  *InputLokiSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputLokiSendToRoutesFalseWithConnectionsConstraint *InputLokiSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputLokiPqEnabledFalseWithPqConstraint             *InputLokiPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputLokiPqEnabledTrueWithPqConstraint              *InputLokiPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputLokiUnionType
}

func CreateInputLokiInputLokiSendToRoutesTrueWithConnectionsConstraint(inputLokiSendToRoutesTrueWithConnectionsConstraint InputLokiSendToRoutesTrueWithConnectionsConstraint) InputLoki {
	typ := InputLokiUnionTypeInputLokiSendToRoutesTrueWithConnectionsConstraint

	return InputLoki{
		InputLokiSendToRoutesTrueWithConnectionsConstraint: &inputLokiSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputLokiInputLokiSendToRoutesFalseWithConnectionsConstraint(inputLokiSendToRoutesFalseWithConnectionsConstraint InputLokiSendToRoutesFalseWithConnectionsConstraint) InputLoki {
	typ := InputLokiUnionTypeInputLokiSendToRoutesFalseWithConnectionsConstraint

	return InputLoki{
		InputLokiSendToRoutesFalseWithConnectionsConstraint: &inputLokiSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputLokiInputLokiPqEnabledFalseWithPqConstraint(inputLokiPqEnabledFalseWithPqConstraint InputLokiPqEnabledFalseWithPqConstraint) InputLoki {
	typ := InputLokiUnionTypeInputLokiPqEnabledFalseWithPqConstraint

	return InputLoki{
		InputLokiPqEnabledFalseWithPqConstraint: &inputLokiPqEnabledFalseWithPqConstraint,
		Type:                                    typ,
	}
}

func CreateInputLokiInputLokiPqEnabledTrueWithPqConstraint(inputLokiPqEnabledTrueWithPqConstraint InputLokiPqEnabledTrueWithPqConstraint) InputLoki {
	typ := InputLokiUnionTypeInputLokiPqEnabledTrueWithPqConstraint

	return InputLoki{
		InputLokiPqEnabledTrueWithPqConstraint: &inputLokiPqEnabledTrueWithPqConstraint,
		Type:                                   typ,
	}
}

func (u *InputLoki) UnmarshalJSON(data []byte) error {

	var inputLokiSendToRoutesTrueWithConnectionsConstraint InputLokiSendToRoutesTrueWithConnectionsConstraint = InputLokiSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputLokiSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputLokiSendToRoutesTrueWithConnectionsConstraint = &inputLokiSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputLokiUnionTypeInputLokiSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputLokiSendToRoutesFalseWithConnectionsConstraint InputLokiSendToRoutesFalseWithConnectionsConstraint = InputLokiSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputLokiSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputLokiSendToRoutesFalseWithConnectionsConstraint = &inputLokiSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputLokiUnionTypeInputLokiSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputLokiPqEnabledFalseWithPqConstraint InputLokiPqEnabledFalseWithPqConstraint = InputLokiPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputLokiPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputLokiPqEnabledFalseWithPqConstraint = &inputLokiPqEnabledFalseWithPqConstraint
		u.Type = InputLokiUnionTypeInputLokiPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputLokiPqEnabledTrueWithPqConstraint InputLokiPqEnabledTrueWithPqConstraint = InputLokiPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputLokiPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputLokiPqEnabledTrueWithPqConstraint = &inputLokiPqEnabledTrueWithPqConstraint
		u.Type = InputLokiUnionTypeInputLokiPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputLoki", string(data))
}

func (u InputLoki) MarshalJSON() ([]byte, error) {
	if u.InputLokiSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputLokiSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputLokiSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputLokiSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputLokiPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputLokiPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputLokiPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputLokiPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputLoki: all fields are null")
}

type InputGrafanaType2 string

const (
	InputGrafanaType2Grafana InputGrafanaType2 = "grafana"
)

func (e InputGrafanaType2) ToPointer() *InputGrafanaType2 {
	return &e
}
func (e *InputGrafanaType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = InputGrafanaType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafanaType2: %v", v)
	}
}

type PrometheusAuth2 struct {
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `default:"none" json:"authType"`
	Username *string                                             `json:"username,omitempty"`
	Password *string                                             `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (p PrometheusAuth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PrometheusAuth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PrometheusAuth2) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if p == nil {
		return nil
	}
	return p.AuthType
}

func (p *PrometheusAuth2) GetUsername() *string {
	if p == nil {
		return nil
	}
	return p.Username
}

func (p *PrometheusAuth2) GetPassword() *string {
	if p == nil {
		return nil
	}
	return p.Password
}

func (p *PrometheusAuth2) GetToken() *string {
	if p == nil {
		return nil
	}
	return p.Token
}

func (p *PrometheusAuth2) GetCredentialsSecret() *string {
	if p == nil {
		return nil
	}
	return p.CredentialsSecret
}

func (p *PrometheusAuth2) GetTextSecret() *string {
	if p == nil {
		return nil
	}
	return p.TextSecret
}

func (p *PrometheusAuth2) GetLoginURL() *string {
	if p == nil {
		return nil
	}
	return p.LoginURL
}

func (p *PrometheusAuth2) GetSecretParamName() *string {
	if p == nil {
		return nil
	}
	return p.SecretParamName
}

func (p *PrometheusAuth2) GetSecret() *string {
	if p == nil {
		return nil
	}
	return p.Secret
}

func (p *PrometheusAuth2) GetTokenAttributeName() *string {
	if p == nil {
		return nil
	}
	return p.TokenAttributeName
}

func (p *PrometheusAuth2) GetAuthHeaderExpr() *string {
	if p == nil {
		return nil
	}
	return p.AuthHeaderExpr
}

func (p *PrometheusAuth2) GetTokenTimeoutSecs() *float64 {
	if p == nil {
		return nil
	}
	return p.TokenTimeoutSecs
}

func (p *PrometheusAuth2) GetOauthParams() []components.ItemsTypeOauthParams {
	if p == nil {
		return nil
	}
	return p.OauthParams
}

func (p *PrometheusAuth2) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if p == nil {
		return nil
	}
	return p.OauthHeaders
}

type LokiAuth2 struct {
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `default:"none" json:"authType"`
	Username *string                                       `json:"username,omitempty"`
	Password *string                                       `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (l LokiAuth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LokiAuth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LokiAuth2) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if l == nil {
		return nil
	}
	return l.AuthType
}

func (l *LokiAuth2) GetUsername() *string {
	if l == nil {
		return nil
	}
	return l.Username
}

func (l *LokiAuth2) GetPassword() *string {
	if l == nil {
		return nil
	}
	return l.Password
}

func (l *LokiAuth2) GetToken() *string {
	if l == nil {
		return nil
	}
	return l.Token
}

func (l *LokiAuth2) GetCredentialsSecret() *string {
	if l == nil {
		return nil
	}
	return l.CredentialsSecret
}

func (l *LokiAuth2) GetTextSecret() *string {
	if l == nil {
		return nil
	}
	return l.TextSecret
}

func (l *LokiAuth2) GetLoginURL() *string {
	if l == nil {
		return nil
	}
	return l.LoginURL
}

func (l *LokiAuth2) GetSecretParamName() *string {
	if l == nil {
		return nil
	}
	return l.SecretParamName
}

func (l *LokiAuth2) GetSecret() *string {
	if l == nil {
		return nil
	}
	return l.Secret
}

func (l *LokiAuth2) GetTokenAttributeName() *string {
	if l == nil {
		return nil
	}
	return l.TokenAttributeName
}

func (l *LokiAuth2) GetAuthHeaderExpr() *string {
	if l == nil {
		return nil
	}
	return l.AuthHeaderExpr
}

func (l *LokiAuth2) GetTokenTimeoutSecs() *float64 {
	if l == nil {
		return nil
	}
	return l.TokenTimeoutSecs
}

func (l *LokiAuth2) GetOauthParams() []components.ItemsTypeOauthParams {
	if l == nil {
		return nil
	}
	return l.OauthParams
}

func (l *LokiAuth2) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if l == nil {
		return nil
	}
	return l.OauthHeaders
}

type InputGrafanaGrafana2 struct {
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputGrafanaType2 `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	Pq          *components.PqType                `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
	PrometheusAPI *string `default:"/api/prom/push" json:"prometheusAPI"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
	LokiAPI        *string          `default:"/loki/api/v1/push" json:"lokiAPI"`
	PrometheusAuth *PrometheusAuth2 `json:"prometheusAuth,omitempty"`
	LokiAuth       *LokiAuth2       `json:"lokiAuth,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputGrafanaGrafana2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputGrafanaGrafana2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputGrafanaGrafana2) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputGrafanaGrafana2) GetType() InputGrafanaType2 {
	if i == nil {
		return InputGrafanaType2("")
	}
	return i.Type
}

func (i *InputGrafanaGrafana2) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputGrafanaGrafana2) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputGrafanaGrafana2) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputGrafanaGrafana2) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputGrafanaGrafana2) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputGrafanaGrafana2) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputGrafanaGrafana2) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputGrafanaGrafana2) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputGrafanaGrafana2) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputGrafanaGrafana2) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputGrafanaGrafana2) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputGrafanaGrafana2) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputGrafanaGrafana2) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputGrafanaGrafana2) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputGrafanaGrafana2) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputGrafanaGrafana2) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputGrafanaGrafana2) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputGrafanaGrafana2) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputGrafanaGrafana2) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputGrafanaGrafana2) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputGrafanaGrafana2) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputGrafanaGrafana2) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputGrafanaGrafana2) GetPrometheusAPI() *string {
	if i == nil {
		return nil
	}
	return i.PrometheusAPI
}

func (i *InputGrafanaGrafana2) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputGrafanaGrafana2) GetPrometheusAuth() *PrometheusAuth2 {
	if i == nil {
		return nil
	}
	return i.PrometheusAuth
}

func (i *InputGrafanaGrafana2) GetLokiAuth() *LokiAuth2 {
	if i == nil {
		return nil
	}
	return i.LokiAuth
}

func (i *InputGrafanaGrafana2) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputGrafanaGrafana2) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputGrafanaType1 string

const (
	InputGrafanaType1Grafana InputGrafanaType1 = "grafana"
)

func (e InputGrafanaType1) ToPointer() *InputGrafanaType1 {
	return &e
}
func (e *InputGrafanaType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = InputGrafanaType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafanaType1: %v", v)
	}
}

type PrometheusAuth1 struct {
	// Remote Write authentication type
	AuthType *components.AuthenticationTypeOptionsPrometheusAuth `default:"none" json:"authType"`
	Username *string                                             `json:"username,omitempty"`
	Password *string                                             `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (p PrometheusAuth1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PrometheusAuth1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PrometheusAuth1) GetAuthType() *components.AuthenticationTypeOptionsPrometheusAuth {
	if p == nil {
		return nil
	}
	return p.AuthType
}

func (p *PrometheusAuth1) GetUsername() *string {
	if p == nil {
		return nil
	}
	return p.Username
}

func (p *PrometheusAuth1) GetPassword() *string {
	if p == nil {
		return nil
	}
	return p.Password
}

func (p *PrometheusAuth1) GetToken() *string {
	if p == nil {
		return nil
	}
	return p.Token
}

func (p *PrometheusAuth1) GetCredentialsSecret() *string {
	if p == nil {
		return nil
	}
	return p.CredentialsSecret
}

func (p *PrometheusAuth1) GetTextSecret() *string {
	if p == nil {
		return nil
	}
	return p.TextSecret
}

func (p *PrometheusAuth1) GetLoginURL() *string {
	if p == nil {
		return nil
	}
	return p.LoginURL
}

func (p *PrometheusAuth1) GetSecretParamName() *string {
	if p == nil {
		return nil
	}
	return p.SecretParamName
}

func (p *PrometheusAuth1) GetSecret() *string {
	if p == nil {
		return nil
	}
	return p.Secret
}

func (p *PrometheusAuth1) GetTokenAttributeName() *string {
	if p == nil {
		return nil
	}
	return p.TokenAttributeName
}

func (p *PrometheusAuth1) GetAuthHeaderExpr() *string {
	if p == nil {
		return nil
	}
	return p.AuthHeaderExpr
}

func (p *PrometheusAuth1) GetTokenTimeoutSecs() *float64 {
	if p == nil {
		return nil
	}
	return p.TokenTimeoutSecs
}

func (p *PrometheusAuth1) GetOauthParams() []components.ItemsTypeOauthParams {
	if p == nil {
		return nil
	}
	return p.OauthParams
}

func (p *PrometheusAuth1) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if p == nil {
		return nil
	}
	return p.OauthHeaders
}

type LokiAuth1 struct {
	// Loki logs authentication type
	AuthType *components.AuthenticationTypeOptionsLokiAuth `default:"none" json:"authType"`
	Username *string                                       `json:"username,omitempty"`
	Password *string                                       `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (l LokiAuth1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LokiAuth1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LokiAuth1) GetAuthType() *components.AuthenticationTypeOptionsLokiAuth {
	if l == nil {
		return nil
	}
	return l.AuthType
}

func (l *LokiAuth1) GetUsername() *string {
	if l == nil {
		return nil
	}
	return l.Username
}

func (l *LokiAuth1) GetPassword() *string {
	if l == nil {
		return nil
	}
	return l.Password
}

func (l *LokiAuth1) GetToken() *string {
	if l == nil {
		return nil
	}
	return l.Token
}

func (l *LokiAuth1) GetCredentialsSecret() *string {
	if l == nil {
		return nil
	}
	return l.CredentialsSecret
}

func (l *LokiAuth1) GetTextSecret() *string {
	if l == nil {
		return nil
	}
	return l.TextSecret
}

func (l *LokiAuth1) GetLoginURL() *string {
	if l == nil {
		return nil
	}
	return l.LoginURL
}

func (l *LokiAuth1) GetSecretParamName() *string {
	if l == nil {
		return nil
	}
	return l.SecretParamName
}

func (l *LokiAuth1) GetSecret() *string {
	if l == nil {
		return nil
	}
	return l.Secret
}

func (l *LokiAuth1) GetTokenAttributeName() *string {
	if l == nil {
		return nil
	}
	return l.TokenAttributeName
}

func (l *LokiAuth1) GetAuthHeaderExpr() *string {
	if l == nil {
		return nil
	}
	return l.AuthHeaderExpr
}

func (l *LokiAuth1) GetTokenTimeoutSecs() *float64 {
	if l == nil {
		return nil
	}
	return l.TokenTimeoutSecs
}

func (l *LokiAuth1) GetOauthParams() []components.ItemsTypeOauthParams {
	if l == nil {
		return nil
	}
	return l.OauthParams
}

func (l *LokiAuth1) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if l == nil {
		return nil
	}
	return l.OauthHeaders
}

type InputGrafanaGrafana1 struct {
	// Unique ID for this input
	ID       string            `json:"id"`
	Type     InputGrafanaType1 `json:"type"`
	Disabled *bool             `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	Pq          *components.PqType                `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
	PrometheusAPI *string `default:"/api/prom/push" json:"prometheusAPI"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
	LokiAPI        *string          `default:"/loki/api/v1/push" json:"lokiAPI"`
	PrometheusAuth *PrometheusAuth1 `json:"prometheusAuth,omitempty"`
	LokiAuth       *LokiAuth1       `json:"lokiAuth,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputGrafanaGrafana1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputGrafanaGrafana1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputGrafanaGrafana1) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputGrafanaGrafana1) GetType() InputGrafanaType1 {
	if i == nil {
		return InputGrafanaType1("")
	}
	return i.Type
}

func (i *InputGrafanaGrafana1) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputGrafanaGrafana1) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputGrafanaGrafana1) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputGrafanaGrafana1) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputGrafanaGrafana1) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputGrafanaGrafana1) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputGrafanaGrafana1) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputGrafanaGrafana1) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputGrafanaGrafana1) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputGrafanaGrafana1) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputGrafanaGrafana1) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputGrafanaGrafana1) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputGrafanaGrafana1) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputGrafanaGrafana1) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputGrafanaGrafana1) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputGrafanaGrafana1) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputGrafanaGrafana1) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputGrafanaGrafana1) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputGrafanaGrafana1) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputGrafanaGrafana1) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputGrafanaGrafana1) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputGrafanaGrafana1) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputGrafanaGrafana1) GetPrometheusAPI() *string {
	if i == nil {
		return nil
	}
	return i.PrometheusAPI
}

func (i *InputGrafanaGrafana1) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputGrafanaGrafana1) GetPrometheusAuth() *PrometheusAuth1 {
	if i == nil {
		return nil
	}
	return i.PrometheusAuth
}

func (i *InputGrafanaGrafana1) GetLokiAuth() *LokiAuth1 {
	if i == nil {
		return nil
	}
	return i.LokiAuth
}

func (i *InputGrafanaGrafana1) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputGrafanaGrafana1) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputGrafanaType string

const (
	InputGrafanaTypeInputGrafanaGrafana1 InputGrafanaType = "InputGrafana_Grafana_1"
	InputGrafanaTypeInputGrafanaGrafana2 InputGrafanaType = "InputGrafana_Grafana_2"
)

type InputGrafana struct {
	InputGrafanaGrafana1 *InputGrafanaGrafana1 `queryParam:"inline" union:"member"`
	InputGrafanaGrafana2 *InputGrafanaGrafana2 `queryParam:"inline" union:"member"`

	Type InputGrafanaType
}

func CreateInputGrafanaInputGrafanaGrafana1(inputGrafanaGrafana1 InputGrafanaGrafana1) InputGrafana {
	typ := InputGrafanaTypeInputGrafanaGrafana1

	return InputGrafana{
		InputGrafanaGrafana1: &inputGrafanaGrafana1,
		Type:                 typ,
	}
}

func CreateInputGrafanaInputGrafanaGrafana2(inputGrafanaGrafana2 InputGrafanaGrafana2) InputGrafana {
	typ := InputGrafanaTypeInputGrafanaGrafana2

	return InputGrafana{
		InputGrafanaGrafana2: &inputGrafanaGrafana2,
		Type:                 typ,
	}
}

func (u *InputGrafana) UnmarshalJSON(data []byte) error {

	var inputGrafanaGrafana1 InputGrafanaGrafana1 = InputGrafanaGrafana1{}
	if err := utils.UnmarshalJSON(data, &inputGrafanaGrafana1, "", true, nil); err == nil {
		u.InputGrafanaGrafana1 = &inputGrafanaGrafana1
		u.Type = InputGrafanaTypeInputGrafanaGrafana1
		return nil
	}

	var inputGrafanaGrafana2 InputGrafanaGrafana2 = InputGrafanaGrafana2{}
	if err := utils.UnmarshalJSON(data, &inputGrafanaGrafana2, "", true, nil); err == nil {
		u.InputGrafanaGrafana2 = &inputGrafanaGrafana2
		u.Type = InputGrafanaTypeInputGrafanaGrafana2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputGrafana", string(data))
}

func (u InputGrafana) MarshalJSON() ([]byte, error) {
	if u.InputGrafanaGrafana1 != nil {
		return utils.MarshalJSON(u.InputGrafanaGrafana1, "", true)
	}

	if u.InputGrafanaGrafana2 != nil {
		return utils.MarshalJSON(u.InputGrafanaGrafana2, "", true)
	}

	return nil, errors.New("could not marshal union type InputGrafana: all fields are null")
}

type InputConfluentCloudPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputConfluentCloudType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
	Brokers []string                               `json:"brokers"`
	TLS     *components.TLSSettingsClientSideType1 `json:"tls,omitempty"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `default:"true" json:"fromBeginning"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType `json:"sasl,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputConfluentCloudPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetType() InputConfluentCloudType {
	if i == nil {
		return InputConfluentCloudType("")
	}
	return i.Type
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsClientSideType1 {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetSasl() *components.AuthenticationType {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputConfluentCloudPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputConfluentCloudPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputConfluentCloudType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
	Brokers []string                               `json:"brokers"`
	TLS     *components.TLSSettingsClientSideType1 `json:"tls,omitempty"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `default:"true" json:"fromBeginning"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType `json:"sasl,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputConfluentCloudPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetType() InputConfluentCloudType {
	if i == nil {
		return InputConfluentCloudType("")
	}
	return i.Type
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsClientSideType1 {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetSasl() *components.AuthenticationType {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputConfluentCloudPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputConfluentCloudType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
	Brokers []string                               `json:"brokers"`
	TLS     *components.TLSSettingsClientSideType1 `json:"tls,omitempty"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `default:"true" json:"fromBeginning"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType `json:"sasl,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetType() InputConfluentCloudType {
	if i == nil {
		return InputConfluentCloudType("")
	}
	return i.Type
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsClientSideType1 {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetSasl() *components.AuthenticationType {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputConfluentCloudType string

const (
	InputConfluentCloudTypeConfluentCloud InputConfluentCloudType = "confluent_cloud"
)

func (e InputConfluentCloudType) ToPointer() *InputConfluentCloudType {
	return &e
}
func (e *InputConfluentCloudType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "confluent_cloud":
		*e = InputConfluentCloudType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputConfluentCloudType: %v", v)
	}
}

type InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                  `json:"id"`
	Type     InputConfluentCloudType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
	Brokers []string                               `json:"brokers"`
	TLS     *components.TLSSettingsClientSideType1 `json:"tls,omitempty"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `default:"true" json:"fromBeginning"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType `json:"sasl,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetType() InputConfluentCloudType {
	if i == nil {
		return InputConfluentCloudType("")
	}
	return i.Type
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsClientSideType1 {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetSasl() *components.AuthenticationType {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputConfluentCloudUnionType string

const (
	InputConfluentCloudUnionTypeInputConfluentCloudSendToRoutesTrueWithConnectionsConstraint  InputConfluentCloudUnionType = "InputConfluentCloud_SendToRoutesTrueWithConnectionsConstraint"
	InputConfluentCloudUnionTypeInputConfluentCloudSendToRoutesFalseWithConnectionsConstraint InputConfluentCloudUnionType = "InputConfluentCloud_SendToRoutesFalseWithConnectionsConstraint"
	InputConfluentCloudUnionTypeInputConfluentCloudPqEnabledFalseWithPqConstraint             InputConfluentCloudUnionType = "InputConfluentCloud_PqEnabledFalseWithPqConstraint"
	InputConfluentCloudUnionTypeInputConfluentCloudPqEnabledTrueWithPqConstraint              InputConfluentCloudUnionType = "InputConfluentCloud_PqEnabledTrueWithPqConstraint"
)

type InputConfluentCloud struct {
	InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint  *InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint *InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputConfluentCloudPqEnabledFalseWithPqConstraint             *InputConfluentCloudPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputConfluentCloudPqEnabledTrueWithPqConstraint              *InputConfluentCloudPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputConfluentCloudUnionType
}

func CreateInputConfluentCloudInputConfluentCloudSendToRoutesTrueWithConnectionsConstraint(inputConfluentCloudSendToRoutesTrueWithConnectionsConstraint InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint) InputConfluentCloud {
	typ := InputConfluentCloudUnionTypeInputConfluentCloudSendToRoutesTrueWithConnectionsConstraint

	return InputConfluentCloud{
		InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint: &inputConfluentCloudSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputConfluentCloudInputConfluentCloudSendToRoutesFalseWithConnectionsConstraint(inputConfluentCloudSendToRoutesFalseWithConnectionsConstraint InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint) InputConfluentCloud {
	typ := InputConfluentCloudUnionTypeInputConfluentCloudSendToRoutesFalseWithConnectionsConstraint

	return InputConfluentCloud{
		InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint: &inputConfluentCloudSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputConfluentCloudInputConfluentCloudPqEnabledFalseWithPqConstraint(inputConfluentCloudPqEnabledFalseWithPqConstraint InputConfluentCloudPqEnabledFalseWithPqConstraint) InputConfluentCloud {
	typ := InputConfluentCloudUnionTypeInputConfluentCloudPqEnabledFalseWithPqConstraint

	return InputConfluentCloud{
		InputConfluentCloudPqEnabledFalseWithPqConstraint: &inputConfluentCloudPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputConfluentCloudInputConfluentCloudPqEnabledTrueWithPqConstraint(inputConfluentCloudPqEnabledTrueWithPqConstraint InputConfluentCloudPqEnabledTrueWithPqConstraint) InputConfluentCloud {
	typ := InputConfluentCloudUnionTypeInputConfluentCloudPqEnabledTrueWithPqConstraint

	return InputConfluentCloud{
		InputConfluentCloudPqEnabledTrueWithPqConstraint: &inputConfluentCloudPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputConfluentCloud) UnmarshalJSON(data []byte) error {

	var inputConfluentCloudSendToRoutesTrueWithConnectionsConstraint InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint = InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputConfluentCloudSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint = &inputConfluentCloudSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputConfluentCloudUnionTypeInputConfluentCloudSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputConfluentCloudSendToRoutesFalseWithConnectionsConstraint InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint = InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputConfluentCloudSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint = &inputConfluentCloudSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputConfluentCloudUnionTypeInputConfluentCloudSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputConfluentCloudPqEnabledFalseWithPqConstraint InputConfluentCloudPqEnabledFalseWithPqConstraint = InputConfluentCloudPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputConfluentCloudPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputConfluentCloudPqEnabledFalseWithPqConstraint = &inputConfluentCloudPqEnabledFalseWithPqConstraint
		u.Type = InputConfluentCloudUnionTypeInputConfluentCloudPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputConfluentCloudPqEnabledTrueWithPqConstraint InputConfluentCloudPqEnabledTrueWithPqConstraint = InputConfluentCloudPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputConfluentCloudPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputConfluentCloudPqEnabledTrueWithPqConstraint = &inputConfluentCloudPqEnabledTrueWithPqConstraint
		u.Type = InputConfluentCloudUnionTypeInputConfluentCloudPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputConfluentCloud", string(data))
}

func (u InputConfluentCloud) MarshalJSON() ([]byte, error) {
	if u.InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputConfluentCloudSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputConfluentCloudPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputConfluentCloudPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputConfluentCloudPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputConfluentCloudPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputConfluentCloud: all fields are null")
}

type InputElasticPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputElasticType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
	ElasticAPI *string                         `default:"/" json:"elasticAPI"`
	AuthType   *InputElasticAuthenticationType `default:"none" json:"authType"`
	// The API version to use for communicating with the server
	APIVersion *CreateInputAPIVersion `default:"8.3.2" json:"apiVersion"`
	// Headers to add to all events
	ExtraHTTPHeaders []components.ItemsTypeExtraHTTPHeaders `json:"extraHttpHeaders,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *InputElasticProxyMode                     `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Bearer tokens to include in the authorization header
	AuthTokens []string `json:"authTokens,omitempty"`
	// Custom version information to respond to requests
	CustomAPIVersion *string `default:"{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}" json:"customAPIVersion"`
}

func (i InputElasticPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetType() InputElasticType {
	if i == nil {
		return InputElasticType("")
	}
	return i.Type
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetAuthType() *InputElasticAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetAPIVersion() *CreateInputAPIVersion {
	if i == nil {
		return nil
	}
	return i.APIVersion
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetExtraHTTPHeaders() []components.ItemsTypeExtraHTTPHeaders {
	if i == nil {
		return nil
	}
	return i.ExtraHTTPHeaders
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetProxyMode() *InputElasticProxyMode {
	if i == nil {
		return nil
	}
	return i.ProxyMode
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputElasticPqEnabledTrueWithPqConstraint) GetCustomAPIVersion() *string {
	if i == nil {
		return nil
	}
	return i.CustomAPIVersion
}

type InputElasticPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputElasticType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
	ElasticAPI *string                         `default:"/" json:"elasticAPI"`
	AuthType   *InputElasticAuthenticationType `default:"none" json:"authType"`
	// The API version to use for communicating with the server
	APIVersion *CreateInputAPIVersion `default:"8.3.2" json:"apiVersion"`
	// Headers to add to all events
	ExtraHTTPHeaders []components.ItemsTypeExtraHTTPHeaders `json:"extraHttpHeaders,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *InputElasticProxyMode                     `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Bearer tokens to include in the authorization header
	AuthTokens []string `json:"authTokens,omitempty"`
	// Custom version information to respond to requests
	CustomAPIVersion *string `default:"{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}" json:"customAPIVersion"`
}

func (i InputElasticPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetType() InputElasticType {
	if i == nil {
		return InputElasticType("")
	}
	return i.Type
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetAuthType() *InputElasticAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetAPIVersion() *CreateInputAPIVersion {
	if i == nil {
		return nil
	}
	return i.APIVersion
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetExtraHTTPHeaders() []components.ItemsTypeExtraHTTPHeaders {
	if i == nil {
		return nil
	}
	return i.ExtraHTTPHeaders
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetProxyMode() *InputElasticProxyMode {
	if i == nil {
		return nil
	}
	return i.ProxyMode
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputElasticPqEnabledFalseWithPqConstraint) GetCustomAPIVersion() *string {
	if i == nil {
		return nil
	}
	return i.CustomAPIVersion
}

type InputElasticSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputElasticType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
	ElasticAPI *string                         `default:"/" json:"elasticAPI"`
	AuthType   *InputElasticAuthenticationType `default:"none" json:"authType"`
	// The API version to use for communicating with the server
	APIVersion *CreateInputAPIVersion `default:"8.3.2" json:"apiVersion"`
	// Headers to add to all events
	ExtraHTTPHeaders []components.ItemsTypeExtraHTTPHeaders `json:"extraHttpHeaders,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *InputElasticProxyMode                     `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Bearer tokens to include in the authorization header
	AuthTokens []string `json:"authTokens,omitempty"`
	// Custom version information to respond to requests
	CustomAPIVersion *string `default:"{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}" json:"customAPIVersion"`
}

func (i InputElasticSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetType() InputElasticType {
	if i == nil {
		return InputElasticType("")
	}
	return i.Type
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *InputElasticAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetAPIVersion() *CreateInputAPIVersion {
	if i == nil {
		return nil
	}
	return i.APIVersion
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetExtraHTTPHeaders() []components.ItemsTypeExtraHTTPHeaders {
	if i == nil {
		return nil
	}
	return i.ExtraHTTPHeaders
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetProxyMode() *InputElasticProxyMode {
	if i == nil {
		return nil
	}
	return i.ProxyMode
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputElasticSendToRoutesFalseWithConnectionsConstraint) GetCustomAPIVersion() *string {
	if i == nil {
		return nil
	}
	return i.CustomAPIVersion
}

type InputElasticType string

const (
	InputElasticTypeElastic InputElasticType = "elastic"
)

func (e InputElasticType) ToPointer() *InputElasticType {
	return &e
}
func (e *InputElasticType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "elastic":
		*e = InputElasticType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputElasticType: %v", v)
	}
}

type InputElasticAuthenticationType string

const (
	// InputElasticAuthenticationTypeNone None
	InputElasticAuthenticationTypeNone InputElasticAuthenticationType = "none"
	// InputElasticAuthenticationTypeBasic Basic
	InputElasticAuthenticationTypeBasic InputElasticAuthenticationType = "basic"
	// InputElasticAuthenticationTypeCredentialsSecret Basic (credentials secret)
	InputElasticAuthenticationTypeCredentialsSecret InputElasticAuthenticationType = "credentialsSecret"
	// InputElasticAuthenticationTypeAuthTokens Auth Tokens
	InputElasticAuthenticationTypeAuthTokens InputElasticAuthenticationType = "authTokens"
)

func (e InputElasticAuthenticationType) ToPointer() *InputElasticAuthenticationType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputElasticAuthenticationType) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "credentialsSecret", "authTokens":
			return true
		}
	}
	return false
}

// CreateInputAPIVersion - The API version to use for communicating with the server
type CreateInputAPIVersion string

const (
	// CreateInputAPIVersionSixDot8Dot4 6.8.4
	CreateInputAPIVersionSixDot8Dot4 CreateInputAPIVersion = "6.8.4"
	// CreateInputAPIVersionEightDot3Dot2 8.3.2
	CreateInputAPIVersionEightDot3Dot2 CreateInputAPIVersion = "8.3.2"
	// CreateInputAPIVersionCustom Custom
	CreateInputAPIVersionCustom CreateInputAPIVersion = "custom"
)

func (e CreateInputAPIVersion) ToPointer() *CreateInputAPIVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputAPIVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "6.8.4", "8.3.2", "custom":
			return true
		}
	}
	return false
}

// InputElasticAuthenticationMethod - Enter credentials directly, or select a stored secret
type InputElasticAuthenticationMethod string

const (
	InputElasticAuthenticationMethodNone   InputElasticAuthenticationMethod = "none"
	InputElasticAuthenticationMethodManual InputElasticAuthenticationMethod = "manual"
	InputElasticAuthenticationMethodSecret InputElasticAuthenticationMethod = "secret"
)

func (e InputElasticAuthenticationMethod) ToPointer() *InputElasticAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputElasticAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "manual", "secret":
			return true
		}
	}
	return false
}

type InputElasticProxyMode struct {
	// Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details.
	Enabled *bool `default:"false" json:"enabled"`
	// Enter credentials directly, or select a stored secret
	AuthType *InputElasticAuthenticationMethod `default:"none" json:"authType"`
	Username *string                           `json:"username,omitempty"`
	Password *string                           `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200
	URL *string `json:"url,omitempty"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `default:"false" json:"rejectUnauthorized"`
	// List of headers to remove from the request to proxy
	RemoveHeaders []string `json:"removeHeaders,omitempty"`
	// Amount of time, in seconds, to wait for a proxy request to complete before canceling it
	TimeoutSec *float64 `default:"60" json:"timeoutSec"`
}

func (i InputElasticProxyMode) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputElasticProxyMode) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputElasticProxyMode) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *InputElasticProxyMode) GetAuthType() *InputElasticAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputElasticProxyMode) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputElasticProxyMode) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputElasticProxyMode) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputElasticProxyMode) GetURL() *string {
	if i == nil {
		return nil
	}
	return i.URL
}

func (i *InputElasticProxyMode) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputElasticProxyMode) GetRemoveHeaders() []string {
	if i == nil {
		return nil
	}
	return i.RemoveHeaders
}

func (i *InputElasticProxyMode) GetTimeoutSec() *float64 {
	if i == nil {
		return nil
	}
	return i.TimeoutSec
}

type InputElasticSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string           `json:"id"`
	Type     InputElasticType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
	ElasticAPI *string                         `default:"/" json:"elasticAPI"`
	AuthType   *InputElasticAuthenticationType `default:"none" json:"authType"`
	// The API version to use for communicating with the server
	APIVersion *CreateInputAPIVersion `default:"8.3.2" json:"apiVersion"`
	// Headers to add to all events
	ExtraHTTPHeaders []components.ItemsTypeExtraHTTPHeaders `json:"extraHttpHeaders,omitempty"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	ProxyMode   *InputElasticProxyMode                     `json:"proxyMode,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Username    *string                                    `json:"username,omitempty"`
	Password    *string                                    `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Bearer tokens to include in the authorization header
	AuthTokens []string `json:"authTokens,omitempty"`
	// Custom version information to respond to requests
	CustomAPIVersion *string `default:"{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}" json:"customAPIVersion"`
}

func (i InputElasticSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetType() InputElasticType {
	if i == nil {
		return InputElasticType("")
	}
	return i.Type
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *InputElasticAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetAPIVersion() *CreateInputAPIVersion {
	if i == nil {
		return nil
	}
	return i.APIVersion
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetExtraHTTPHeaders() []components.ItemsTypeExtraHTTPHeaders {
	if i == nil {
		return nil
	}
	return i.ExtraHTTPHeaders
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetProxyMode() *InputElasticProxyMode {
	if i == nil {
		return nil
	}
	return i.ProxyMode
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputElasticSendToRoutesTrueWithConnectionsConstraint) GetCustomAPIVersion() *string {
	if i == nil {
		return nil
	}
	return i.CustomAPIVersion
}

type InputElasticUnionType string

const (
	InputElasticUnionTypeInputElasticSendToRoutesTrueWithConnectionsConstraint  InputElasticUnionType = "InputElastic_SendToRoutesTrueWithConnectionsConstraint"
	InputElasticUnionTypeInputElasticSendToRoutesFalseWithConnectionsConstraint InputElasticUnionType = "InputElastic_SendToRoutesFalseWithConnectionsConstraint"
	InputElasticUnionTypeInputElasticPqEnabledFalseWithPqConstraint             InputElasticUnionType = "InputElastic_PqEnabledFalseWithPqConstraint"
	InputElasticUnionTypeInputElasticPqEnabledTrueWithPqConstraint              InputElasticUnionType = "InputElastic_PqEnabledTrueWithPqConstraint"
)

type InputElastic struct {
	InputElasticSendToRoutesTrueWithConnectionsConstraint  *InputElasticSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputElasticSendToRoutesFalseWithConnectionsConstraint *InputElasticSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputElasticPqEnabledFalseWithPqConstraint             *InputElasticPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputElasticPqEnabledTrueWithPqConstraint              *InputElasticPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputElasticUnionType
}

func CreateInputElasticInputElasticSendToRoutesTrueWithConnectionsConstraint(inputElasticSendToRoutesTrueWithConnectionsConstraint InputElasticSendToRoutesTrueWithConnectionsConstraint) InputElastic {
	typ := InputElasticUnionTypeInputElasticSendToRoutesTrueWithConnectionsConstraint

	return InputElastic{
		InputElasticSendToRoutesTrueWithConnectionsConstraint: &inputElasticSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputElasticInputElasticSendToRoutesFalseWithConnectionsConstraint(inputElasticSendToRoutesFalseWithConnectionsConstraint InputElasticSendToRoutesFalseWithConnectionsConstraint) InputElastic {
	typ := InputElasticUnionTypeInputElasticSendToRoutesFalseWithConnectionsConstraint

	return InputElastic{
		InputElasticSendToRoutesFalseWithConnectionsConstraint: &inputElasticSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputElasticInputElasticPqEnabledFalseWithPqConstraint(inputElasticPqEnabledFalseWithPqConstraint InputElasticPqEnabledFalseWithPqConstraint) InputElastic {
	typ := InputElasticUnionTypeInputElasticPqEnabledFalseWithPqConstraint

	return InputElastic{
		InputElasticPqEnabledFalseWithPqConstraint: &inputElasticPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputElasticInputElasticPqEnabledTrueWithPqConstraint(inputElasticPqEnabledTrueWithPqConstraint InputElasticPqEnabledTrueWithPqConstraint) InputElastic {
	typ := InputElasticUnionTypeInputElasticPqEnabledTrueWithPqConstraint

	return InputElastic{
		InputElasticPqEnabledTrueWithPqConstraint: &inputElasticPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputElastic) UnmarshalJSON(data []byte) error {

	var inputElasticSendToRoutesTrueWithConnectionsConstraint InputElasticSendToRoutesTrueWithConnectionsConstraint = InputElasticSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputElasticSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputElasticSendToRoutesTrueWithConnectionsConstraint = &inputElasticSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputElasticUnionTypeInputElasticSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputElasticSendToRoutesFalseWithConnectionsConstraint InputElasticSendToRoutesFalseWithConnectionsConstraint = InputElasticSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputElasticSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputElasticSendToRoutesFalseWithConnectionsConstraint = &inputElasticSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputElasticUnionTypeInputElasticSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputElasticPqEnabledFalseWithPqConstraint InputElasticPqEnabledFalseWithPqConstraint = InputElasticPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputElasticPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputElasticPqEnabledFalseWithPqConstraint = &inputElasticPqEnabledFalseWithPqConstraint
		u.Type = InputElasticUnionTypeInputElasticPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputElasticPqEnabledTrueWithPqConstraint InputElasticPqEnabledTrueWithPqConstraint = InputElasticPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputElasticPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputElasticPqEnabledTrueWithPqConstraint = &inputElasticPqEnabledTrueWithPqConstraint
		u.Type = InputElasticUnionTypeInputElasticPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputElastic", string(data))
}

func (u InputElastic) MarshalJSON() ([]byte, error) {
	if u.InputElasticSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputElasticSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputElasticSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputElasticSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputElasticPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputElasticPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputElasticPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputElasticPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputElastic: all fields are null")
}

type InputAzureBlobPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputAzureBlobType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// The duration (in seconds) which pollers should be validated and restarted if exited
	ServicePeriodSecs *float64 `default:"5" json:"servicePeriodSecs"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                                `default:"600" json:"parquetChunkDownloadTimeout"`
	AuthType                    *components.AuthenticationMethodOptions `default:"manual" json:"authType"`
	Description                 *string                                 `json:"description,omitempty"`
	// Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// The name of your Azure storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`
	// The service principal's tenant ID
	TenantID *string `json:"tenantId,omitempty"`
	// The service principal's client ID
	ClientID *string `json:"clientId,omitempty"`
	// The Azure cloud to use. Defaults to Azure Public Cloud.
	AzureCloud *string `json:"azureCloud,omitempty"`
	// Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
	EndpointSuffix *string `json:"endpointSuffix,omitempty"`
	// Select or create a stored text secret
	ClientTextSecret *string                                                `json:"clientTextSecret,omitempty"`
	Certificate      *components.CertificateTypeAzureBlobAuthTypeClientCert `json:"certificate,omitempty"`
}

func (i InputAzureBlobPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetType() InputAzureBlobType {
	if i == nil {
		return InputAzureBlobType("")
	}
	return i.Type
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetServicePeriodSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.ServicePeriodSecs
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetConnectionString() *string {
	if i == nil {
		return nil
	}
	return i.ConnectionString
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetStorageAccountName() *string {
	if i == nil {
		return nil
	}
	return i.StorageAccountName
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetTenantID() *string {
	if i == nil {
		return nil
	}
	return i.TenantID
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetClientID() *string {
	if i == nil {
		return nil
	}
	return i.ClientID
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetAzureCloud() *string {
	if i == nil {
		return nil
	}
	return i.AzureCloud
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetEndpointSuffix() *string {
	if i == nil {
		return nil
	}
	return i.EndpointSuffix
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetClientTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientTextSecret
}

func (i *InputAzureBlobPqEnabledTrueWithPqConstraint) GetCertificate() *components.CertificateTypeAzureBlobAuthTypeClientCert {
	if i == nil {
		return nil
	}
	return i.Certificate
}

type InputAzureBlobPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputAzureBlobType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// The duration (in seconds) which pollers should be validated and restarted if exited
	ServicePeriodSecs *float64 `default:"5" json:"servicePeriodSecs"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                                `default:"600" json:"parquetChunkDownloadTimeout"`
	AuthType                    *components.AuthenticationMethodOptions `default:"manual" json:"authType"`
	Description                 *string                                 `json:"description,omitempty"`
	// Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// The name of your Azure storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`
	// The service principal's tenant ID
	TenantID *string `json:"tenantId,omitempty"`
	// The service principal's client ID
	ClientID *string `json:"clientId,omitempty"`
	// The Azure cloud to use. Defaults to Azure Public Cloud.
	AzureCloud *string `json:"azureCloud,omitempty"`
	// Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
	EndpointSuffix *string `json:"endpointSuffix,omitempty"`
	// Select or create a stored text secret
	ClientTextSecret *string                                                `json:"clientTextSecret,omitempty"`
	Certificate      *components.CertificateTypeAzureBlobAuthTypeClientCert `json:"certificate,omitempty"`
}

func (i InputAzureBlobPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetType() InputAzureBlobType {
	if i == nil {
		return InputAzureBlobType("")
	}
	return i.Type
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetServicePeriodSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.ServicePeriodSecs
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetAuthType() *components.AuthenticationMethodOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetConnectionString() *string {
	if i == nil {
		return nil
	}
	return i.ConnectionString
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetStorageAccountName() *string {
	if i == nil {
		return nil
	}
	return i.StorageAccountName
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetTenantID() *string {
	if i == nil {
		return nil
	}
	return i.TenantID
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetClientID() *string {
	if i == nil {
		return nil
	}
	return i.ClientID
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetAzureCloud() *string {
	if i == nil {
		return nil
	}
	return i.AzureCloud
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetEndpointSuffix() *string {
	if i == nil {
		return nil
	}
	return i.EndpointSuffix
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetClientTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientTextSecret
}

func (i *InputAzureBlobPqEnabledFalseWithPqConstraint) GetCertificate() *components.CertificateTypeAzureBlobAuthTypeClientCert {
	if i == nil {
		return nil
	}
	return i.Certificate
}

type InputAzureBlobSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputAzureBlobType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// The duration (in seconds) which pollers should be validated and restarted if exited
	ServicePeriodSecs *float64 `default:"5" json:"servicePeriodSecs"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                                `default:"600" json:"parquetChunkDownloadTimeout"`
	AuthType                    *components.AuthenticationMethodOptions `default:"manual" json:"authType"`
	Description                 *string                                 `json:"description,omitempty"`
	// Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// The name of your Azure storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`
	// The service principal's tenant ID
	TenantID *string `json:"tenantId,omitempty"`
	// The service principal's client ID
	ClientID *string `json:"clientId,omitempty"`
	// The Azure cloud to use. Defaults to Azure Public Cloud.
	AzureCloud *string `json:"azureCloud,omitempty"`
	// Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
	EndpointSuffix *string `json:"endpointSuffix,omitempty"`
	// Select or create a stored text secret
	ClientTextSecret *string                                                `json:"clientTextSecret,omitempty"`
	Certificate      *components.CertificateTypeAzureBlobAuthTypeClientCert `json:"certificate,omitempty"`
}

func (i InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetType() InputAzureBlobType {
	if i == nil {
		return InputAzureBlobType("")
	}
	return i.Type
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetServicePeriodSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.ServicePeriodSecs
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetConnectionString() *string {
	if i == nil {
		return nil
	}
	return i.ConnectionString
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetStorageAccountName() *string {
	if i == nil {
		return nil
	}
	return i.StorageAccountName
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetTenantID() *string {
	if i == nil {
		return nil
	}
	return i.TenantID
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetClientID() *string {
	if i == nil {
		return nil
	}
	return i.ClientID
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetAzureCloud() *string {
	if i == nil {
		return nil
	}
	return i.AzureCloud
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetEndpointSuffix() *string {
	if i == nil {
		return nil
	}
	return i.EndpointSuffix
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetClientTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientTextSecret
}

func (i *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) GetCertificate() *components.CertificateTypeAzureBlobAuthTypeClientCert {
	if i == nil {
		return nil
	}
	return i.Certificate
}

type InputAzureBlobType string

const (
	InputAzureBlobTypeAzureBlob InputAzureBlobType = "azure_blob"
)

func (e InputAzureBlobType) ToPointer() *InputAzureBlobType {
	return &e
}
func (e *InputAzureBlobType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azure_blob":
		*e = InputAzureBlobType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputAzureBlobType: %v", v)
	}
}

type InputAzureBlobSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputAzureBlobType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
	QueueName string `json:"queueName"`
	// Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `default:"/.*/" json:"fileFilter"`
	// The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
	VisibilityTimeout *float64 `default:"600" json:"visibilityTimeout"`
	// How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
	NumReceivers *float64 `default:"1" json:"numReceivers"`
	// The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
	MaxMessages *float64 `default:"1" json:"maxMessages"`
	// The duration (in seconds) which pollers should be validated and restarted if exited
	ServicePeriodSecs *float64 `default:"5" json:"servicePeriodSecs"`
	// Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
	SkipOnError *bool `default:"false" json:"skipOnError"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64                                `default:"600" json:"parquetChunkDownloadTimeout"`
	AuthType                    *components.AuthenticationMethodOptions `default:"manual" json:"authType"`
	Description                 *string                                 `json:"description,omitempty"`
	// Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString *string `json:"connectionString,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// The name of your Azure storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`
	// The service principal's tenant ID
	TenantID *string `json:"tenantId,omitempty"`
	// The service principal's client ID
	ClientID *string `json:"clientId,omitempty"`
	// The Azure cloud to use. Defaults to Azure Public Cloud.
	AzureCloud *string `json:"azureCloud,omitempty"`
	// Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
	EndpointSuffix *string `json:"endpointSuffix,omitempty"`
	// Select or create a stored text secret
	ClientTextSecret *string                                                `json:"clientTextSecret,omitempty"`
	Certificate      *components.CertificateTypeAzureBlobAuthTypeClientCert `json:"certificate,omitempty"`
}

func (i InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "queueName"}); err != nil {
		return err
	}
	return nil
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetType() InputAzureBlobType {
	if i == nil {
		return InputAzureBlobType("")
	}
	return i.Type
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetQueueName() string {
	if i == nil {
		return ""
	}
	return i.QueueName
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetFileFilter() *string {
	if i == nil {
		return nil
	}
	return i.FileFilter
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetVisibilityTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.VisibilityTimeout
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetNumReceivers() *float64 {
	if i == nil {
		return nil
	}
	return i.NumReceivers
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetMaxMessages() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMessages
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetServicePeriodSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.ServicePeriodSecs
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetSkipOnError() *bool {
	if i == nil {
		return nil
	}
	return i.SkipOnError
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetParquetChunkSizeMB() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkSizeMB
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetParquetChunkDownloadTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ParquetChunkDownloadTimeout
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *components.AuthenticationMethodOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetConnectionString() *string {
	if i == nil {
		return nil
	}
	return i.ConnectionString
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetStorageAccountName() *string {
	if i == nil {
		return nil
	}
	return i.StorageAccountName
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetTenantID() *string {
	if i == nil {
		return nil
	}
	return i.TenantID
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetClientID() *string {
	if i == nil {
		return nil
	}
	return i.ClientID
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetAzureCloud() *string {
	if i == nil {
		return nil
	}
	return i.AzureCloud
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetEndpointSuffix() *string {
	if i == nil {
		return nil
	}
	return i.EndpointSuffix
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetClientTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.ClientTextSecret
}

func (i *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) GetCertificate() *components.CertificateTypeAzureBlobAuthTypeClientCert {
	if i == nil {
		return nil
	}
	return i.Certificate
}

type InputAzureBlobUnionType string

const (
	InputAzureBlobUnionTypeInputAzureBlobSendToRoutesTrueWithConnectionsConstraint  InputAzureBlobUnionType = "InputAzureBlob_SendToRoutesTrueWithConnectionsConstraint"
	InputAzureBlobUnionTypeInputAzureBlobSendToRoutesFalseWithConnectionsConstraint InputAzureBlobUnionType = "InputAzureBlob_SendToRoutesFalseWithConnectionsConstraint"
	InputAzureBlobUnionTypeInputAzureBlobPqEnabledFalseWithPqConstraint             InputAzureBlobUnionType = "InputAzureBlob_PqEnabledFalseWithPqConstraint"
	InputAzureBlobUnionTypeInputAzureBlobPqEnabledTrueWithPqConstraint              InputAzureBlobUnionType = "InputAzureBlob_PqEnabledTrueWithPqConstraint"
)

type InputAzureBlob struct {
	InputAzureBlobSendToRoutesTrueWithConnectionsConstraint  *InputAzureBlobSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputAzureBlobSendToRoutesFalseWithConnectionsConstraint *InputAzureBlobSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputAzureBlobPqEnabledFalseWithPqConstraint             *InputAzureBlobPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputAzureBlobPqEnabledTrueWithPqConstraint              *InputAzureBlobPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputAzureBlobUnionType
}

func CreateInputAzureBlobInputAzureBlobSendToRoutesTrueWithConnectionsConstraint(inputAzureBlobSendToRoutesTrueWithConnectionsConstraint InputAzureBlobSendToRoutesTrueWithConnectionsConstraint) InputAzureBlob {
	typ := InputAzureBlobUnionTypeInputAzureBlobSendToRoutesTrueWithConnectionsConstraint

	return InputAzureBlob{
		InputAzureBlobSendToRoutesTrueWithConnectionsConstraint: &inputAzureBlobSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputAzureBlobInputAzureBlobSendToRoutesFalseWithConnectionsConstraint(inputAzureBlobSendToRoutesFalseWithConnectionsConstraint InputAzureBlobSendToRoutesFalseWithConnectionsConstraint) InputAzureBlob {
	typ := InputAzureBlobUnionTypeInputAzureBlobSendToRoutesFalseWithConnectionsConstraint

	return InputAzureBlob{
		InputAzureBlobSendToRoutesFalseWithConnectionsConstraint: &inputAzureBlobSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputAzureBlobInputAzureBlobPqEnabledFalseWithPqConstraint(inputAzureBlobPqEnabledFalseWithPqConstraint InputAzureBlobPqEnabledFalseWithPqConstraint) InputAzureBlob {
	typ := InputAzureBlobUnionTypeInputAzureBlobPqEnabledFalseWithPqConstraint

	return InputAzureBlob{
		InputAzureBlobPqEnabledFalseWithPqConstraint: &inputAzureBlobPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputAzureBlobInputAzureBlobPqEnabledTrueWithPqConstraint(inputAzureBlobPqEnabledTrueWithPqConstraint InputAzureBlobPqEnabledTrueWithPqConstraint) InputAzureBlob {
	typ := InputAzureBlobUnionTypeInputAzureBlobPqEnabledTrueWithPqConstraint

	return InputAzureBlob{
		InputAzureBlobPqEnabledTrueWithPqConstraint: &inputAzureBlobPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputAzureBlob) UnmarshalJSON(data []byte) error {

	var inputAzureBlobSendToRoutesTrueWithConnectionsConstraint InputAzureBlobSendToRoutesTrueWithConnectionsConstraint = InputAzureBlobSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputAzureBlobSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputAzureBlobSendToRoutesTrueWithConnectionsConstraint = &inputAzureBlobSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputAzureBlobUnionTypeInputAzureBlobSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputAzureBlobSendToRoutesFalseWithConnectionsConstraint InputAzureBlobSendToRoutesFalseWithConnectionsConstraint = InputAzureBlobSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputAzureBlobSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputAzureBlobSendToRoutesFalseWithConnectionsConstraint = &inputAzureBlobSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputAzureBlobUnionTypeInputAzureBlobSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputAzureBlobPqEnabledFalseWithPqConstraint InputAzureBlobPqEnabledFalseWithPqConstraint = InputAzureBlobPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputAzureBlobPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputAzureBlobPqEnabledFalseWithPqConstraint = &inputAzureBlobPqEnabledFalseWithPqConstraint
		u.Type = InputAzureBlobUnionTypeInputAzureBlobPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputAzureBlobPqEnabledTrueWithPqConstraint InputAzureBlobPqEnabledTrueWithPqConstraint = InputAzureBlobPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputAzureBlobPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputAzureBlobPqEnabledTrueWithPqConstraint = &inputAzureBlobPqEnabledTrueWithPqConstraint
		u.Type = InputAzureBlobUnionTypeInputAzureBlobPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputAzureBlob", string(data))
}

func (u InputAzureBlob) MarshalJSON() ([]byte, error) {
	if u.InputAzureBlobSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputAzureBlobSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputAzureBlobSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputAzureBlobSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputAzureBlobPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputAzureBlobPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputAzureBlobPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputAzureBlobPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputAzureBlob: all fields are null")
}

type InputSplunkHecPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputSplunkHecType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputSplunkHecAuthToken             `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
	SplunkHecAPI *string `default:"/services/collector" json:"splunkHecAPI"`
	// Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Enable Splunk HEC acknowledgements
	SplunkHecAcks *bool `default:"false" json:"splunkHecAcks"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `default:"true" json:"useFwdTimezone"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `default:"true" json:"dropControlFields"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputSplunkHecPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetType() InputSplunkHecType {
	if i == nil {
		return InputSplunkHecType("")
	}
	return i.Type
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetAuthTokens() []InputSplunkHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetUseFwdTimezone() *bool {
	if i == nil {
		return nil
	}
	return i.UseFwdTimezone
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetDropControlFields() *bool {
	if i == nil {
		return nil
	}
	return i.DropControlFields
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputSplunkHecPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSplunkHecPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputSplunkHecType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputSplunkHecAuthToken             `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
	SplunkHecAPI *string `default:"/services/collector" json:"splunkHecAPI"`
	// Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Enable Splunk HEC acknowledgements
	SplunkHecAcks *bool `default:"false" json:"splunkHecAcks"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `default:"true" json:"useFwdTimezone"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `default:"true" json:"dropControlFields"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputSplunkHecPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetType() InputSplunkHecType {
	if i == nil {
		return InputSplunkHecType("")
	}
	return i.Type
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetAuthTokens() []InputSplunkHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetUseFwdTimezone() *bool {
	if i == nil {
		return nil
	}
	return i.UseFwdTimezone
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetDropControlFields() *bool {
	if i == nil {
		return nil
	}
	return i.DropControlFields
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputSplunkHecPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSplunkHecSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputSplunkHecType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputSplunkHecAuthToken             `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
	SplunkHecAPI *string `default:"/services/collector" json:"splunkHecAPI"`
	// Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Enable Splunk HEC acknowledgements
	SplunkHecAcks *bool `default:"false" json:"splunkHecAcks"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `default:"true" json:"useFwdTimezone"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `default:"true" json:"dropControlFields"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetType() InputSplunkHecType {
	if i == nil {
		return InputSplunkHecType("")
	}
	return i.Type
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []InputSplunkHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetUseFwdTimezone() *bool {
	if i == nil {
		return nil
	}
	return i.UseFwdTimezone
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetDropControlFields() *bool {
	if i == nil {
		return nil
	}
	return i.DropControlFields
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSplunkHecType string

const (
	InputSplunkHecTypeSplunkHec InputSplunkHecType = "splunk_hec"
)

func (e InputSplunkHecType) ToPointer() *InputSplunkHecType {
	return &e
}
func (e *InputSplunkHecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_hec":
		*e = InputSplunkHecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSplunkHecType: %v", v)
	}
}

type InputSplunkHecAuthToken struct {
	// Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
	AuthType *components.AuthenticationMethodOptionsAuthTokensItems `default:"manual" json:"authType"`
	// Select or create a stored text secret
	TokenSecret *string `json:"tokenSecret,omitempty"`
	// Shared secret to be provided by any client (Authorization: <token>)
	Token   string `json:"token"`
	Enabled *bool  `default:"true" json:"enabled"`
	// Optional token description
	Description *string `json:"description,omitempty"`
	// Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
	AllowedIndexesAtToken []string `json:"allowedIndexesAtToken,omitempty"`
	// Fields to add to events referencing this token
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
}

func (i InputSplunkHecAuthToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkHecAuthToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"token"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkHecAuthToken) GetAuthType() *components.AuthenticationMethodOptionsAuthTokensItems {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputSplunkHecAuthToken) GetTokenSecret() *string {
	if i == nil {
		return nil
	}
	return i.TokenSecret
}

func (i *InputSplunkHecAuthToken) GetToken() string {
	if i == nil {
		return ""
	}
	return i.Token
}

func (i *InputSplunkHecAuthToken) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *InputSplunkHecAuthToken) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkHecAuthToken) GetAllowedIndexesAtToken() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexesAtToken
}

func (i *InputSplunkHecAuthToken) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

type InputSplunkHecSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string             `json:"id"`
	Type     InputSplunkHecType `json:"type"`
	Disabled *bool              `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []InputSplunkHecAuthToken             `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout  *float64 `default:"5" json:"keepAliveTimeout"`
	EnableHealthCheck any      `json:"enableHealthCheck,omitempty"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
	SplunkHecAPI *string `default:"/services/collector" json:"splunkHecAPI"`
	// Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes []string `json:"allowedIndexes,omitempty"`
	// Enable Splunk HEC acknowledgements
	SplunkHecAcks *bool `default:"false" json:"splunkHecAcks"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `default:"true" json:"useFwdTimezone"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `default:"true" json:"dropControlFields"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin []string `json:"accessControlAllowOrigin,omitempty"`
	// Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders []string `json:"accessControlAllowHeaders,omitempty"`
	// Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics *bool   `default:"false" json:"emitTokenMetrics"`
	Description      *string `json:"description,omitempty"`
}

func (i InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetType() InputSplunkHecType {
	if i == nil {
		return InputSplunkHecType("")
	}
	return i.Type
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []InputSplunkHecAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() any {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetAllowedIndexes() []string {
	if i == nil {
		return nil
	}
	return i.AllowedIndexes
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetUseFwdTimezone() *bool {
	if i == nil {
		return nil
	}
	return i.UseFwdTimezone
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetDropControlFields() *bool {
	if i == nil {
		return nil
	}
	return i.DropControlFields
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetAccessControlAllowOrigin() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowOrigin
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetAccessControlAllowHeaders() []string {
	if i == nil {
		return nil
	}
	return i.AccessControlAllowHeaders
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetEmitTokenMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.EmitTokenMetrics
}

func (i *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputSplunkHecUnionType string

const (
	InputSplunkHecUnionTypeInputSplunkHecSendToRoutesTrueWithConnectionsConstraint  InputSplunkHecUnionType = "InputSplunkHec_SendToRoutesTrueWithConnectionsConstraint"
	InputSplunkHecUnionTypeInputSplunkHecSendToRoutesFalseWithConnectionsConstraint InputSplunkHecUnionType = "InputSplunkHec_SendToRoutesFalseWithConnectionsConstraint"
	InputSplunkHecUnionTypeInputSplunkHecPqEnabledFalseWithPqConstraint             InputSplunkHecUnionType = "InputSplunkHec_PqEnabledFalseWithPqConstraint"
	InputSplunkHecUnionTypeInputSplunkHecPqEnabledTrueWithPqConstraint              InputSplunkHecUnionType = "InputSplunkHec_PqEnabledTrueWithPqConstraint"
)

type InputSplunkHec struct {
	InputSplunkHecSendToRoutesTrueWithConnectionsConstraint  *InputSplunkHecSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputSplunkHecSendToRoutesFalseWithConnectionsConstraint *InputSplunkHecSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputSplunkHecPqEnabledFalseWithPqConstraint             *InputSplunkHecPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputSplunkHecPqEnabledTrueWithPqConstraint              *InputSplunkHecPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputSplunkHecUnionType
}

func CreateInputSplunkHecInputSplunkHecSendToRoutesTrueWithConnectionsConstraint(inputSplunkHecSendToRoutesTrueWithConnectionsConstraint InputSplunkHecSendToRoutesTrueWithConnectionsConstraint) InputSplunkHec {
	typ := InputSplunkHecUnionTypeInputSplunkHecSendToRoutesTrueWithConnectionsConstraint

	return InputSplunkHec{
		InputSplunkHecSendToRoutesTrueWithConnectionsConstraint: &inputSplunkHecSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSplunkHecInputSplunkHecSendToRoutesFalseWithConnectionsConstraint(inputSplunkHecSendToRoutesFalseWithConnectionsConstraint InputSplunkHecSendToRoutesFalseWithConnectionsConstraint) InputSplunkHec {
	typ := InputSplunkHecUnionTypeInputSplunkHecSendToRoutesFalseWithConnectionsConstraint

	return InputSplunkHec{
		InputSplunkHecSendToRoutesFalseWithConnectionsConstraint: &inputSplunkHecSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSplunkHecInputSplunkHecPqEnabledFalseWithPqConstraint(inputSplunkHecPqEnabledFalseWithPqConstraint InputSplunkHecPqEnabledFalseWithPqConstraint) InputSplunkHec {
	typ := InputSplunkHecUnionTypeInputSplunkHecPqEnabledFalseWithPqConstraint

	return InputSplunkHec{
		InputSplunkHecPqEnabledFalseWithPqConstraint: &inputSplunkHecPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputSplunkHecInputSplunkHecPqEnabledTrueWithPqConstraint(inputSplunkHecPqEnabledTrueWithPqConstraint InputSplunkHecPqEnabledTrueWithPqConstraint) InputSplunkHec {
	typ := InputSplunkHecUnionTypeInputSplunkHecPqEnabledTrueWithPqConstraint

	return InputSplunkHec{
		InputSplunkHecPqEnabledTrueWithPqConstraint: &inputSplunkHecPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputSplunkHec) UnmarshalJSON(data []byte) error {

	var inputSplunkHecSendToRoutesTrueWithConnectionsConstraint InputSplunkHecSendToRoutesTrueWithConnectionsConstraint = InputSplunkHecSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkHecSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSplunkHecSendToRoutesTrueWithConnectionsConstraint = &inputSplunkHecSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputSplunkHecUnionTypeInputSplunkHecSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputSplunkHecSendToRoutesFalseWithConnectionsConstraint InputSplunkHecSendToRoutesFalseWithConnectionsConstraint = InputSplunkHecSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkHecSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSplunkHecSendToRoutesFalseWithConnectionsConstraint = &inputSplunkHecSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputSplunkHecUnionTypeInputSplunkHecSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputSplunkHecPqEnabledFalseWithPqConstraint InputSplunkHecPqEnabledFalseWithPqConstraint = InputSplunkHecPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkHecPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputSplunkHecPqEnabledFalseWithPqConstraint = &inputSplunkHecPqEnabledFalseWithPqConstraint
		u.Type = InputSplunkHecUnionTypeInputSplunkHecPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputSplunkHecPqEnabledTrueWithPqConstraint InputSplunkHecPqEnabledTrueWithPqConstraint = InputSplunkHecPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkHecPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputSplunkHecPqEnabledTrueWithPqConstraint = &inputSplunkHecPqEnabledTrueWithPqConstraint
		u.Type = InputSplunkHecUnionTypeInputSplunkHecPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSplunkHec", string(data))
}

func (u InputSplunkHec) MarshalJSON() ([]byte, error) {
	if u.InputSplunkHecSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkHecSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputSplunkHecSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkHecSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputSplunkHecPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkHecPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputSplunkHecPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkHecPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputSplunkHec: all fields are null")
}

type InputSplunkSearchPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputSplunkSearchType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead *string `default:"https://localhost:8089" json:"searchHead"`
	// Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `default:"-16m@m" json:"earliest"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `default:"-1m@m" json:"latest"`
	// A cron schedule on which to run this job
	CronSchedule *string `default:"*/15 * * * *" json:"cronSchedule"`
	// REST API used to create a search
	Endpoint *string `default:"/services/search/v2/jobs/export" json:"endpoint"`
	// Format of the returned output
	OutputMode *components.OutputModeOptionsSplunkCollectorConf `default:"json" json:"outputMode"`
	// Optional request parameters to send to the endpoint
	EndpointParams []EndpointParam `json:"endpointParams,omitempty"`
	// Optional request headers to send to the endpoint
	EndpointHeaders []EndpointHeader `json:"endpointHeaders,omitempty"`
	// Collector runtime log level (verbosity)
	LogLevel *InputSplunkSearchLogLevel `json:"logLevel,omitempty"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
	UseRoundRobinDNS *bool `default:"false" json:"useRoundRobinDns"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `default:"false" json:"rejectUnauthorized"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Splunk Search authentication type
	AuthType    *InputSplunkSearchAuthenticationType `default:"basic" json:"authType"`
	Description *string                              `json:"description,omitempty"`
	Username    *string                              `json:"username,omitempty"`
	Password    *string                              `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputSplunkSearchPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "search"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetType() InputSplunkSearchType {
	if i == nil {
		return InputSplunkSearchType("")
	}
	return i.Type
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetSearchHead() *string {
	if i == nil {
		return nil
	}
	return i.SearchHead
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetSearch() string {
	if i == nil {
		return ""
	}
	return i.Search
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetEarliest() *string {
	if i == nil {
		return nil
	}
	return i.Earliest
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetLatest() *string {
	if i == nil {
		return nil
	}
	return i.Latest
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetOutputMode() *components.OutputModeOptionsSplunkCollectorConf {
	if i == nil {
		return nil
	}
	return i.OutputMode
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetEndpointParams() []EndpointParam {
	if i == nil {
		return nil
	}
	return i.EndpointParams
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetEndpointHeaders() []EndpointHeader {
	if i == nil {
		return nil
	}
	return i.EndpointHeaders
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetLogLevel() *InputSplunkSearchLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetUseRoundRobinDNS() *bool {
	if i == nil {
		return nil
	}
	return i.UseRoundRobinDNS
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetRetryRules() *components.RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetAuthType() *InputSplunkSearchAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputSplunkSearchPqEnabledTrueWithPqConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputSplunkSearchPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputSplunkSearchType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead *string `default:"https://localhost:8089" json:"searchHead"`
	// Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `default:"-16m@m" json:"earliest"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `default:"-1m@m" json:"latest"`
	// A cron schedule on which to run this job
	CronSchedule *string `default:"*/15 * * * *" json:"cronSchedule"`
	// REST API used to create a search
	Endpoint *string `default:"/services/search/v2/jobs/export" json:"endpoint"`
	// Format of the returned output
	OutputMode *components.OutputModeOptionsSplunkCollectorConf `default:"json" json:"outputMode"`
	// Optional request parameters to send to the endpoint
	EndpointParams []EndpointParam `json:"endpointParams,omitempty"`
	// Optional request headers to send to the endpoint
	EndpointHeaders []EndpointHeader `json:"endpointHeaders,omitempty"`
	// Collector runtime log level (verbosity)
	LogLevel *InputSplunkSearchLogLevel `json:"logLevel,omitempty"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
	UseRoundRobinDNS *bool `default:"false" json:"useRoundRobinDns"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `default:"false" json:"rejectUnauthorized"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Splunk Search authentication type
	AuthType    *InputSplunkSearchAuthenticationType `default:"basic" json:"authType"`
	Description *string                              `json:"description,omitempty"`
	Username    *string                              `json:"username,omitempty"`
	Password    *string                              `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputSplunkSearchPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "search"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetType() InputSplunkSearchType {
	if i == nil {
		return InputSplunkSearchType("")
	}
	return i.Type
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetSearchHead() *string {
	if i == nil {
		return nil
	}
	return i.SearchHead
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetSearch() string {
	if i == nil {
		return ""
	}
	return i.Search
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetEarliest() *string {
	if i == nil {
		return nil
	}
	return i.Earliest
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetLatest() *string {
	if i == nil {
		return nil
	}
	return i.Latest
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetOutputMode() *components.OutputModeOptionsSplunkCollectorConf {
	if i == nil {
		return nil
	}
	return i.OutputMode
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetEndpointParams() []EndpointParam {
	if i == nil {
		return nil
	}
	return i.EndpointParams
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetEndpointHeaders() []EndpointHeader {
	if i == nil {
		return nil
	}
	return i.EndpointHeaders
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetLogLevel() *InputSplunkSearchLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetUseRoundRobinDNS() *bool {
	if i == nil {
		return nil
	}
	return i.UseRoundRobinDNS
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetRetryRules() *components.RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetAuthType() *InputSplunkSearchAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputSplunkSearchPqEnabledFalseWithPqConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputSplunkSearchType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead *string `default:"https://localhost:8089" json:"searchHead"`
	// Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `default:"-16m@m" json:"earliest"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `default:"-1m@m" json:"latest"`
	// A cron schedule on which to run this job
	CronSchedule *string `default:"*/15 * * * *" json:"cronSchedule"`
	// REST API used to create a search
	Endpoint *string `default:"/services/search/v2/jobs/export" json:"endpoint"`
	// Format of the returned output
	OutputMode *components.OutputModeOptionsSplunkCollectorConf `default:"json" json:"outputMode"`
	// Optional request parameters to send to the endpoint
	EndpointParams []EndpointParam `json:"endpointParams,omitempty"`
	// Optional request headers to send to the endpoint
	EndpointHeaders []EndpointHeader `json:"endpointHeaders,omitempty"`
	// Collector runtime log level (verbosity)
	LogLevel *InputSplunkSearchLogLevel `json:"logLevel,omitempty"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
	UseRoundRobinDNS *bool `default:"false" json:"useRoundRobinDns"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `default:"false" json:"rejectUnauthorized"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Splunk Search authentication type
	AuthType    *InputSplunkSearchAuthenticationType `default:"basic" json:"authType"`
	Description *string                              `json:"description,omitempty"`
	Username    *string                              `json:"username,omitempty"`
	Password    *string                              `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "search"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetType() InputSplunkSearchType {
	if i == nil {
		return InputSplunkSearchType("")
	}
	return i.Type
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetSearchHead() *string {
	if i == nil {
		return nil
	}
	return i.SearchHead
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetSearch() string {
	if i == nil {
		return ""
	}
	return i.Search
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetEarliest() *string {
	if i == nil {
		return nil
	}
	return i.Earliest
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetLatest() *string {
	if i == nil {
		return nil
	}
	return i.Latest
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetOutputMode() *components.OutputModeOptionsSplunkCollectorConf {
	if i == nil {
		return nil
	}
	return i.OutputMode
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetEndpointParams() []EndpointParam {
	if i == nil {
		return nil
	}
	return i.EndpointParams
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetEndpointHeaders() []EndpointHeader {
	if i == nil {
		return nil
	}
	return i.EndpointHeaders
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetLogLevel() *InputSplunkSearchLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetUseRoundRobinDNS() *bool {
	if i == nil {
		return nil
	}
	return i.UseRoundRobinDNS
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *InputSplunkSearchAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputSplunkSearchType string

const (
	InputSplunkSearchTypeSplunkSearch InputSplunkSearchType = "splunk_search"
)

func (e InputSplunkSearchType) ToPointer() *InputSplunkSearchType {
	return &e
}
func (e *InputSplunkSearchType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_search":
		*e = InputSplunkSearchType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSplunkSearchType: %v", v)
	}
}

type EndpointParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (e EndpointParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EndpointParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"name", "value"}); err != nil {
		return err
	}
	return nil
}

func (e *EndpointParam) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EndpointParam) GetValue() string {
	if e == nil {
		return ""
	}
	return e.Value
}

type EndpointHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (e EndpointHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EndpointHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"name", "value"}); err != nil {
		return err
	}
	return nil
}

func (e *EndpointHeader) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EndpointHeader) GetValue() string {
	if e == nil {
		return ""
	}
	return e.Value
}

// InputSplunkSearchLogLevel - Collector runtime log level (verbosity)
type InputSplunkSearchLogLevel string

const (
	InputSplunkSearchLogLevelError InputSplunkSearchLogLevel = "error"
	InputSplunkSearchLogLevelWarn  InputSplunkSearchLogLevel = "warn"
	InputSplunkSearchLogLevelInfo  InputSplunkSearchLogLevel = "info"
	InputSplunkSearchLogLevelDebug InputSplunkSearchLogLevel = "debug"
)

func (e InputSplunkSearchLogLevel) ToPointer() *InputSplunkSearchLogLevel {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSplunkSearchLogLevel) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug":
			return true
		}
	}
	return false
}

// InputSplunkSearchAuthenticationType - Splunk Search authentication type
type InputSplunkSearchAuthenticationType string

const (
	InputSplunkSearchAuthenticationTypeNone              InputSplunkSearchAuthenticationType = "none"
	InputSplunkSearchAuthenticationTypeBasic             InputSplunkSearchAuthenticationType = "basic"
	InputSplunkSearchAuthenticationTypeCredentialsSecret InputSplunkSearchAuthenticationType = "credentialsSecret"
	InputSplunkSearchAuthenticationTypeToken             InputSplunkSearchAuthenticationType = "token"
	InputSplunkSearchAuthenticationTypeTextSecret        InputSplunkSearchAuthenticationType = "textSecret"
	InputSplunkSearchAuthenticationTypeOauth             InputSplunkSearchAuthenticationType = "oauth"
)

func (e InputSplunkSearchAuthenticationType) ToPointer() *InputSplunkSearchAuthenticationType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSplunkSearchAuthenticationType) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "credentialsSecret", "token", "textSecret", "oauth":
			return true
		}
	}
	return false
}

type InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string                `json:"id"`
	Type     InputSplunkSearchType `json:"type"`
	Disabled *bool                 `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead *string `default:"https://localhost:8089" json:"searchHead"`
	// Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `default:"-16m@m" json:"earliest"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `default:"-1m@m" json:"latest"`
	// A cron schedule on which to run this job
	CronSchedule *string `default:"*/15 * * * *" json:"cronSchedule"`
	// REST API used to create a search
	Endpoint *string `default:"/services/search/v2/jobs/export" json:"endpoint"`
	// Format of the returned output
	OutputMode *components.OutputModeOptionsSplunkCollectorConf `default:"json" json:"outputMode"`
	// Optional request parameters to send to the endpoint
	EndpointParams []EndpointParam `json:"endpointParams,omitempty"`
	// Optional request headers to send to the endpoint
	EndpointHeaders []EndpointHeader `json:"endpointHeaders,omitempty"`
	// Collector runtime log level (verbosity)
	LogLevel *InputSplunkSearchLogLevel `json:"logLevel,omitempty"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
	UseRoundRobinDNS *bool `default:"false" json:"useRoundRobinDns"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `default:"false" json:"rejectUnauthorized"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata   []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	RetryRules *components.RetryRulesType                 `json:"retryRules,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Splunk Search authentication type
	AuthType    *InputSplunkSearchAuthenticationType `default:"basic" json:"authType"`
	Description *string                              `json:"description,omitempty"`
	Username    *string                              `json:"username,omitempty"`
	Password    *string                              `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string "default:\"`Bearer ${token}`\" json:\"authHeaderExpr\""
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []components.ItemsTypeOauthParams `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []components.ItemsTypeOauthHeaders `json:"oauthHeaders,omitempty"`
}

func (i InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "search"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetType() InputSplunkSearchType {
	if i == nil {
		return InputSplunkSearchType("")
	}
	return i.Type
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetSearchHead() *string {
	if i == nil {
		return nil
	}
	return i.SearchHead
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetSearch() string {
	if i == nil {
		return ""
	}
	return i.Search
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetEarliest() *string {
	if i == nil {
		return nil
	}
	return i.Earliest
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetLatest() *string {
	if i == nil {
		return nil
	}
	return i.Latest
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetOutputMode() *components.OutputModeOptionsSplunkCollectorConf {
	if i == nil {
		return nil
	}
	return i.OutputMode
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetEndpointParams() []EndpointParam {
	if i == nil {
		return nil
	}
	return i.EndpointParams
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetEndpointHeaders() []EndpointHeader {
	if i == nil {
		return nil
	}
	return i.EndpointHeaders
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetLogLevel() *InputSplunkSearchLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetUseRoundRobinDNS() *bool {
	if i == nil {
		return nil
	}
	return i.UseRoundRobinDNS
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetRetryRules() *components.RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *InputSplunkSearchAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetOauthParams() []components.ItemsTypeOauthParams {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) GetOauthHeaders() []components.ItemsTypeOauthHeaders {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputSplunkSearchUnionType string

const (
	InputSplunkSearchUnionTypeInputSplunkSearchSendToRoutesTrueWithConnectionsConstraint  InputSplunkSearchUnionType = "InputSplunkSearch_SendToRoutesTrueWithConnectionsConstraint"
	InputSplunkSearchUnionTypeInputSplunkSearchSendToRoutesFalseWithConnectionsConstraint InputSplunkSearchUnionType = "InputSplunkSearch_SendToRoutesFalseWithConnectionsConstraint"
	InputSplunkSearchUnionTypeInputSplunkSearchPqEnabledFalseWithPqConstraint             InputSplunkSearchUnionType = "InputSplunkSearch_PqEnabledFalseWithPqConstraint"
	InputSplunkSearchUnionTypeInputSplunkSearchPqEnabledTrueWithPqConstraint              InputSplunkSearchUnionType = "InputSplunkSearch_PqEnabledTrueWithPqConstraint"
)

type InputSplunkSearch struct {
	InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint  *InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint *InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputSplunkSearchPqEnabledFalseWithPqConstraint             *InputSplunkSearchPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputSplunkSearchPqEnabledTrueWithPqConstraint              *InputSplunkSearchPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputSplunkSearchUnionType
}

func CreateInputSplunkSearchInputSplunkSearchSendToRoutesTrueWithConnectionsConstraint(inputSplunkSearchSendToRoutesTrueWithConnectionsConstraint InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint) InputSplunkSearch {
	typ := InputSplunkSearchUnionTypeInputSplunkSearchSendToRoutesTrueWithConnectionsConstraint

	return InputSplunkSearch{
		InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint: &inputSplunkSearchSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSplunkSearchInputSplunkSearchSendToRoutesFalseWithConnectionsConstraint(inputSplunkSearchSendToRoutesFalseWithConnectionsConstraint InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint) InputSplunkSearch {
	typ := InputSplunkSearchUnionTypeInputSplunkSearchSendToRoutesFalseWithConnectionsConstraint

	return InputSplunkSearch{
		InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint: &inputSplunkSearchSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSplunkSearchInputSplunkSearchPqEnabledFalseWithPqConstraint(inputSplunkSearchPqEnabledFalseWithPqConstraint InputSplunkSearchPqEnabledFalseWithPqConstraint) InputSplunkSearch {
	typ := InputSplunkSearchUnionTypeInputSplunkSearchPqEnabledFalseWithPqConstraint

	return InputSplunkSearch{
		InputSplunkSearchPqEnabledFalseWithPqConstraint: &inputSplunkSearchPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputSplunkSearchInputSplunkSearchPqEnabledTrueWithPqConstraint(inputSplunkSearchPqEnabledTrueWithPqConstraint InputSplunkSearchPqEnabledTrueWithPqConstraint) InputSplunkSearch {
	typ := InputSplunkSearchUnionTypeInputSplunkSearchPqEnabledTrueWithPqConstraint

	return InputSplunkSearch{
		InputSplunkSearchPqEnabledTrueWithPqConstraint: &inputSplunkSearchPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputSplunkSearch) UnmarshalJSON(data []byte) error {

	var inputSplunkSearchSendToRoutesTrueWithConnectionsConstraint InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint = InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkSearchSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint = &inputSplunkSearchSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputSplunkSearchUnionTypeInputSplunkSearchSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputSplunkSearchSendToRoutesFalseWithConnectionsConstraint InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint = InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkSearchSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint = &inputSplunkSearchSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputSplunkSearchUnionTypeInputSplunkSearchSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputSplunkSearchPqEnabledFalseWithPqConstraint InputSplunkSearchPqEnabledFalseWithPqConstraint = InputSplunkSearchPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkSearchPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputSplunkSearchPqEnabledFalseWithPqConstraint = &inputSplunkSearchPqEnabledFalseWithPqConstraint
		u.Type = InputSplunkSearchUnionTypeInputSplunkSearchPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputSplunkSearchPqEnabledTrueWithPqConstraint InputSplunkSearchPqEnabledTrueWithPqConstraint = InputSplunkSearchPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkSearchPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputSplunkSearchPqEnabledTrueWithPqConstraint = &inputSplunkSearchPqEnabledTrueWithPqConstraint
		u.Type = InputSplunkSearchUnionTypeInputSplunkSearchPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSplunkSearch", string(data))
}

func (u InputSplunkSearch) MarshalJSON() ([]byte, error) {
	if u.InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkSearchSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputSplunkSearchPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkSearchPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputSplunkSearchPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkSearchPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputSplunkSearch: all fields are null")
}

type InputSplunkPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string          `json:"id"`
	Type     InputSplunkType `json:"type"`
	Disabled *bool           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	AuthTokens []InputSplunkAuthToken `json:"authTokens,omitempty"`
	// The highest S2S protocol version to advertise during handshake
	MaxS2Sversion *MaxS2SVersion `default:"v3" json:"maxS2Sversion"`
	Description   *string        `json:"description,omitempty"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `default:"true" json:"useFwdTimezone"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `default:"true" json:"dropControlFields"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
	Compress *CreateInputCompression `default:"disabled" json:"compress"`
}

func (i InputSplunkPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetType() InputSplunkType {
	if i == nil {
		return InputSplunkType("")
	}
	return i.Type
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetAuthTokens() []InputSplunkAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetMaxS2Sversion() *MaxS2SVersion {
	if i == nil {
		return nil
	}
	return i.MaxS2Sversion
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetUseFwdTimezone() *bool {
	if i == nil {
		return nil
	}
	return i.UseFwdTimezone
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetDropControlFields() *bool {
	if i == nil {
		return nil
	}
	return i.DropControlFields
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputSplunkPqEnabledTrueWithPqConstraint) GetCompress() *CreateInputCompression {
	if i == nil {
		return nil
	}
	return i.Compress
}

type InputSplunkPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string          `json:"id"`
	Type     InputSplunkType `json:"type"`
	Disabled *bool           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	AuthTokens []InputSplunkAuthToken `json:"authTokens,omitempty"`
	// The highest S2S protocol version to advertise during handshake
	MaxS2Sversion *MaxS2SVersion `default:"v3" json:"maxS2Sversion"`
	Description   *string        `json:"description,omitempty"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `default:"true" json:"useFwdTimezone"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `default:"true" json:"dropControlFields"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
	Compress *CreateInputCompression `default:"disabled" json:"compress"`
}

func (i InputSplunkPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetType() InputSplunkType {
	if i == nil {
		return InputSplunkType("")
	}
	return i.Type
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetAuthTokens() []InputSplunkAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetMaxS2Sversion() *MaxS2SVersion {
	if i == nil {
		return nil
	}
	return i.MaxS2Sversion
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetUseFwdTimezone() *bool {
	if i == nil {
		return nil
	}
	return i.UseFwdTimezone
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetDropControlFields() *bool {
	if i == nil {
		return nil
	}
	return i.DropControlFields
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputSplunkPqEnabledFalseWithPqConstraint) GetCompress() *CreateInputCompression {
	if i == nil {
		return nil
	}
	return i.Compress
}

type InputSplunkSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string          `json:"id"`
	Type     InputSplunkType `json:"type"`
	Disabled *bool           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	AuthTokens []InputSplunkAuthToken `json:"authTokens,omitempty"`
	// The highest S2S protocol version to advertise during handshake
	MaxS2Sversion *MaxS2SVersion `default:"v3" json:"maxS2Sversion"`
	Description   *string        `json:"description,omitempty"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `default:"true" json:"useFwdTimezone"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `default:"true" json:"dropControlFields"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
	Compress *CreateInputCompression `default:"disabled" json:"compress"`
}

func (i InputSplunkSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetType() InputSplunkType {
	if i == nil {
		return InputSplunkType("")
	}
	return i.Type
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []InputSplunkAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetMaxS2Sversion() *MaxS2SVersion {
	if i == nil {
		return nil
	}
	return i.MaxS2Sversion
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetUseFwdTimezone() *bool {
	if i == nil {
		return nil
	}
	return i.UseFwdTimezone
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetDropControlFields() *bool {
	if i == nil {
		return nil
	}
	return i.DropControlFields
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputSplunkSendToRoutesFalseWithConnectionsConstraint) GetCompress() *CreateInputCompression {
	if i == nil {
		return nil
	}
	return i.Compress
}

type InputSplunkType string

const (
	InputSplunkTypeSplunk InputSplunkType = "splunk"
)

func (e InputSplunkType) ToPointer() *InputSplunkType {
	return &e
}
func (e *InputSplunkType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk":
		*e = InputSplunkType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSplunkType: %v", v)
	}
}

type InputSplunkAuthToken struct {
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	Token       string  `json:"token"`
	Description *string `json:"description,omitempty"`
}

func (i InputSplunkAuthToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkAuthToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"token"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkAuthToken) GetToken() string {
	if i == nil {
		return ""
	}
	return i.Token
}

func (i *InputSplunkAuthToken) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

// MaxS2SVersion - The highest S2S protocol version to advertise during handshake
type MaxS2SVersion string

const (
	// MaxS2SVersionV3 v3
	MaxS2SVersionV3 MaxS2SVersion = "v3"
	// MaxS2SVersionV4 v4
	MaxS2SVersionV4 MaxS2SVersion = "v4"
)

func (e MaxS2SVersion) ToPointer() *MaxS2SVersion {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *MaxS2SVersion) IsExact() bool {
	if e != nil {
		switch *e {
		case "v3", "v4":
			return true
		}
	}
	return false
}

// CreateInputCompression - Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
type CreateInputCompression string

const (
	// CreateInputCompressionDisabled Disabled
	CreateInputCompressionDisabled CreateInputCompression = "disabled"
	// CreateInputCompressionAuto Automatic
	CreateInputCompressionAuto CreateInputCompression = "auto"
	// CreateInputCompressionAlways Always
	CreateInputCompressionAlways CreateInputCompression = "always"
)

func (e CreateInputCompression) ToPointer() *CreateInputCompression {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *CreateInputCompression) IsExact() bool {
	if e != nil {
		switch *e {
		case "disabled", "auto", "always":
			return true
		}
	}
	return false
}

type InputSplunkSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string          `json:"id"`
	Type     InputSplunkType `json:"type"`
	Disabled *bool           `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64                               `json:"port"`
	TLS  *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Regex matching IP addresses that are allowed to establish a connection
	IPWhitelistRegex *string `default:"/.*/" json:"ipWhitelistRegex"`
	// Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float64 `default:"1000" json:"maxActiveCxn"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float64 `default:"0" json:"socketIdleTimeout"`
	// How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float64 `default:"30" json:"socketEndingMaxWait"`
	// The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float64 `default:"0" json:"socketMaxLifespan"`
	// Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted.
	AuthTokens []InputSplunkAuthToken `json:"authTokens,omitempty"`
	// The highest S2S protocol version to advertise during handshake
	MaxS2Sversion *MaxS2SVersion `default:"v3" json:"maxS2Sversion"`
	Description   *string        `json:"description,omitempty"`
	// Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
	UseFwdTimezone *bool `default:"true" json:"useFwdTimezone"`
	// Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `default:"true" json:"dropControlFields"`
	// Extract and process Splunk-generated metrics as Cribl metrics
	ExtractMetrics *bool `default:"false" json:"extractMetrics"`
	// Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
	Compress *CreateInputCompression `default:"disabled" json:"compress"`
}

func (i InputSplunkSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetType() InputSplunkType {
	if i == nil {
		return InputSplunkType("")
	}
	return i.Type
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetIPWhitelistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPWhitelistRegex
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveCxn() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveCxn
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetSocketIdleTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketIdleTimeout
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetSocketEndingMaxWait() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketEndingMaxWait
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetSocketMaxLifespan() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketMaxLifespan
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []InputSplunkAuthToken {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetMaxS2Sversion() *MaxS2SVersion {
	if i == nil {
		return nil
	}
	return i.MaxS2Sversion
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetUseFwdTimezone() *bool {
	if i == nil {
		return nil
	}
	return i.UseFwdTimezone
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetDropControlFields() *bool {
	if i == nil {
		return nil
	}
	return i.DropControlFields
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetExtractMetrics() *bool {
	if i == nil {
		return nil
	}
	return i.ExtractMetrics
}

func (i *InputSplunkSendToRoutesTrueWithConnectionsConstraint) GetCompress() *CreateInputCompression {
	if i == nil {
		return nil
	}
	return i.Compress
}

type InputSplunkUnionType string

const (
	InputSplunkUnionTypeInputSplunkSendToRoutesTrueWithConnectionsConstraint  InputSplunkUnionType = "InputSplunk_SendToRoutesTrueWithConnectionsConstraint"
	InputSplunkUnionTypeInputSplunkSendToRoutesFalseWithConnectionsConstraint InputSplunkUnionType = "InputSplunk_SendToRoutesFalseWithConnectionsConstraint"
	InputSplunkUnionTypeInputSplunkPqEnabledFalseWithPqConstraint             InputSplunkUnionType = "InputSplunk_PqEnabledFalseWithPqConstraint"
	InputSplunkUnionTypeInputSplunkPqEnabledTrueWithPqConstraint              InputSplunkUnionType = "InputSplunk_PqEnabledTrueWithPqConstraint"
)

type InputSplunk struct {
	InputSplunkSendToRoutesTrueWithConnectionsConstraint  *InputSplunkSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputSplunkSendToRoutesFalseWithConnectionsConstraint *InputSplunkSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputSplunkPqEnabledFalseWithPqConstraint             *InputSplunkPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputSplunkPqEnabledTrueWithPqConstraint              *InputSplunkPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputSplunkUnionType
}

func CreateInputSplunkInputSplunkSendToRoutesTrueWithConnectionsConstraint(inputSplunkSendToRoutesTrueWithConnectionsConstraint InputSplunkSendToRoutesTrueWithConnectionsConstraint) InputSplunk {
	typ := InputSplunkUnionTypeInputSplunkSendToRoutesTrueWithConnectionsConstraint

	return InputSplunk{
		InputSplunkSendToRoutesTrueWithConnectionsConstraint: &inputSplunkSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSplunkInputSplunkSendToRoutesFalseWithConnectionsConstraint(inputSplunkSendToRoutesFalseWithConnectionsConstraint InputSplunkSendToRoutesFalseWithConnectionsConstraint) InputSplunk {
	typ := InputSplunkUnionTypeInputSplunkSendToRoutesFalseWithConnectionsConstraint

	return InputSplunk{
		InputSplunkSendToRoutesFalseWithConnectionsConstraint: &inputSplunkSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputSplunkInputSplunkPqEnabledFalseWithPqConstraint(inputSplunkPqEnabledFalseWithPqConstraint InputSplunkPqEnabledFalseWithPqConstraint) InputSplunk {
	typ := InputSplunkUnionTypeInputSplunkPqEnabledFalseWithPqConstraint

	return InputSplunk{
		InputSplunkPqEnabledFalseWithPqConstraint: &inputSplunkPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputSplunkInputSplunkPqEnabledTrueWithPqConstraint(inputSplunkPqEnabledTrueWithPqConstraint InputSplunkPqEnabledTrueWithPqConstraint) InputSplunk {
	typ := InputSplunkUnionTypeInputSplunkPqEnabledTrueWithPqConstraint

	return InputSplunk{
		InputSplunkPqEnabledTrueWithPqConstraint: &inputSplunkPqEnabledTrueWithPqConstraint,
		Type:                                     typ,
	}
}

func (u *InputSplunk) UnmarshalJSON(data []byte) error {

	var inputSplunkSendToRoutesTrueWithConnectionsConstraint InputSplunkSendToRoutesTrueWithConnectionsConstraint = InputSplunkSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSplunkSendToRoutesTrueWithConnectionsConstraint = &inputSplunkSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputSplunkUnionTypeInputSplunkSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputSplunkSendToRoutesFalseWithConnectionsConstraint InputSplunkSendToRoutesFalseWithConnectionsConstraint = InputSplunkSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputSplunkSendToRoutesFalseWithConnectionsConstraint = &inputSplunkSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputSplunkUnionTypeInputSplunkSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputSplunkPqEnabledFalseWithPqConstraint InputSplunkPqEnabledFalseWithPqConstraint = InputSplunkPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputSplunkPqEnabledFalseWithPqConstraint = &inputSplunkPqEnabledFalseWithPqConstraint
		u.Type = InputSplunkUnionTypeInputSplunkPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputSplunkPqEnabledTrueWithPqConstraint InputSplunkPqEnabledTrueWithPqConstraint = InputSplunkPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputSplunkPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputSplunkPqEnabledTrueWithPqConstraint = &inputSplunkPqEnabledTrueWithPqConstraint
		u.Type = InputSplunkUnionTypeInputSplunkPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputSplunk", string(data))
}

func (u InputSplunk) MarshalJSON() ([]byte, error) {
	if u.InputSplunkSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputSplunkSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputSplunkPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputSplunkPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputSplunkPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputSplunk: all fields are null")
}

type InputHTTPPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputHTTPType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `default:"/cribl" json:"criblAPI"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `default:"/elastic" json:"elasticAPI"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `default:"/services/collector" json:"splunkHecAPI"`
	SplunkHecAcks *bool   `default:"false" json:"splunkHecAcks"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputHTTPPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetType() InputHTTPType {
	if i == nil {
		return InputHTTPType("")
	}
	return i.Type
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetCriblAPI() *string {
	if i == nil {
		return nil
	}
	return i.CriblAPI
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputHTTPPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputHTTPPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputHTTPType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `default:"/cribl" json:"criblAPI"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `default:"/elastic" json:"elasticAPI"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `default:"/services/collector" json:"splunkHecAPI"`
	SplunkHecAcks *bool   `default:"false" json:"splunkHecAcks"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputHTTPPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetType() InputHTTPType {
	if i == nil {
		return InputHTTPType("")
	}
	return i.Type
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetCriblAPI() *string {
	if i == nil {
		return nil
	}
	return i.CriblAPI
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputHTTPPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputHTTPSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputHTTPType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `default:"/cribl" json:"criblAPI"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `default:"/elastic" json:"elasticAPI"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `default:"/services/collector" json:"splunkHecAPI"`
	SplunkHecAcks *bool   `default:"false" json:"splunkHecAcks"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputHTTPSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetType() InputHTTPType {
	if i == nil {
		return InputHTTPType("")
	}
	return i.Type
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetCriblAPI() *string {
	if i == nil {
		return nil
	}
	return i.CriblAPI
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputHTTPSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputHTTPType string

const (
	InputHTTPTypeHTTP InputHTTPType = "http"
)

func (e InputHTTPType) ToPointer() *InputHTTPType {
	return &e
}
func (e *InputHTTPType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = InputHTTPType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputHTTPType: %v", v)
	}
}

type InputHTTPSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string        `json:"id"`
	Type     InputHTTPType `json:"type"`
	Disabled *bool         `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64 `json:"port"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens []string                              `json:"authTokens,omitempty"`
	TLS        *components.TLSSettingsServerSideType `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI *string `default:"/cribl" json:"criblAPI"`
	// Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `default:"/elastic" json:"elasticAPI"`
	// Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `default:"/services/collector" json:"splunkHecAPI"`
	SplunkHecAcks *bool   `default:"false" json:"splunkHecAcks"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt []components.ItemsTypeAuthTokensExt `json:"authTokensExt,omitempty"`
	Description   *string                             `json:"description,omitempty"`
}

func (i InputHTTPSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetType() InputHTTPType {
	if i == nil {
		return InputHTTPType("")
	}
	return i.Type
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetAuthTokens() []string {
	if i == nil {
		return nil
	}
	return i.AuthTokens
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsServerSideType {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetCriblAPI() *string {
	if i == nil {
		return nil
	}
	return i.CriblAPI
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetElasticAPI() *string {
	if i == nil {
		return nil
	}
	return i.ElasticAPI
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetSplunkHecAPI() *string {
	if i == nil {
		return nil
	}
	return i.SplunkHecAPI
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetSplunkHecAcks() *bool {
	if i == nil {
		return nil
	}
	return i.SplunkHecAcks
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetAuthTokensExt() []components.ItemsTypeAuthTokensExt {
	if i == nil {
		return nil
	}
	return i.AuthTokensExt
}

func (i *InputHTTPSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputHTTPUnionType string

const (
	InputHTTPUnionTypeInputHTTPSendToRoutesTrueWithConnectionsConstraint  InputHTTPUnionType = "InputHttp_SendToRoutesTrueWithConnectionsConstraint"
	InputHTTPUnionTypeInputHTTPSendToRoutesFalseWithConnectionsConstraint InputHTTPUnionType = "InputHttp_SendToRoutesFalseWithConnectionsConstraint"
	InputHTTPUnionTypeInputHTTPPqEnabledFalseWithPqConstraint             InputHTTPUnionType = "InputHttp_PqEnabledFalseWithPqConstraint"
	InputHTTPUnionTypeInputHTTPPqEnabledTrueWithPqConstraint              InputHTTPUnionType = "InputHttp_PqEnabledTrueWithPqConstraint"
)

type InputHTTP struct {
	InputHTTPSendToRoutesTrueWithConnectionsConstraint  *InputHTTPSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputHTTPSendToRoutesFalseWithConnectionsConstraint *InputHTTPSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputHTTPPqEnabledFalseWithPqConstraint             *InputHTTPPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputHTTPPqEnabledTrueWithPqConstraint              *InputHTTPPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputHTTPUnionType
}

func CreateInputHTTPInputHTTPSendToRoutesTrueWithConnectionsConstraint(inputHTTPSendToRoutesTrueWithConnectionsConstraint InputHTTPSendToRoutesTrueWithConnectionsConstraint) InputHTTP {
	typ := InputHTTPUnionTypeInputHTTPSendToRoutesTrueWithConnectionsConstraint

	return InputHTTP{
		InputHTTPSendToRoutesTrueWithConnectionsConstraint: &inputHTTPSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputHTTPInputHTTPSendToRoutesFalseWithConnectionsConstraint(inputHTTPSendToRoutesFalseWithConnectionsConstraint InputHTTPSendToRoutesFalseWithConnectionsConstraint) InputHTTP {
	typ := InputHTTPUnionTypeInputHTTPSendToRoutesFalseWithConnectionsConstraint

	return InputHTTP{
		InputHTTPSendToRoutesFalseWithConnectionsConstraint: &inputHTTPSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputHTTPInputHTTPPqEnabledFalseWithPqConstraint(inputHTTPPqEnabledFalseWithPqConstraint InputHTTPPqEnabledFalseWithPqConstraint) InputHTTP {
	typ := InputHTTPUnionTypeInputHTTPPqEnabledFalseWithPqConstraint

	return InputHTTP{
		InputHTTPPqEnabledFalseWithPqConstraint: &inputHTTPPqEnabledFalseWithPqConstraint,
		Type:                                    typ,
	}
}

func CreateInputHTTPInputHTTPPqEnabledTrueWithPqConstraint(inputHTTPPqEnabledTrueWithPqConstraint InputHTTPPqEnabledTrueWithPqConstraint) InputHTTP {
	typ := InputHTTPUnionTypeInputHTTPPqEnabledTrueWithPqConstraint

	return InputHTTP{
		InputHTTPPqEnabledTrueWithPqConstraint: &inputHTTPPqEnabledTrueWithPqConstraint,
		Type:                                   typ,
	}
}

func (u *InputHTTP) UnmarshalJSON(data []byte) error {

	var inputHTTPSendToRoutesTrueWithConnectionsConstraint InputHTTPSendToRoutesTrueWithConnectionsConstraint = InputHTTPSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputHTTPSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputHTTPSendToRoutesTrueWithConnectionsConstraint = &inputHTTPSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputHTTPUnionTypeInputHTTPSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputHTTPSendToRoutesFalseWithConnectionsConstraint InputHTTPSendToRoutesFalseWithConnectionsConstraint = InputHTTPSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputHTTPSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputHTTPSendToRoutesFalseWithConnectionsConstraint = &inputHTTPSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputHTTPUnionTypeInputHTTPSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputHTTPPqEnabledFalseWithPqConstraint InputHTTPPqEnabledFalseWithPqConstraint = InputHTTPPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputHTTPPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputHTTPPqEnabledFalseWithPqConstraint = &inputHTTPPqEnabledFalseWithPqConstraint
		u.Type = InputHTTPUnionTypeInputHTTPPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputHTTPPqEnabledTrueWithPqConstraint InputHTTPPqEnabledTrueWithPqConstraint = InputHTTPPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputHTTPPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputHTTPPqEnabledTrueWithPqConstraint = &inputHTTPPqEnabledTrueWithPqConstraint
		u.Type = InputHTTPUnionTypeInputHTTPPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputHTTP", string(data))
}

func (u InputHTTP) MarshalJSON() ([]byte, error) {
	if u.InputHTTPSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputHTTPSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputHTTPSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputHTTPSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputHTTPPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputHTTPPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputHTTPPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputHTTPPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputHTTP: all fields are null")
}

type InputMskPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputMskType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `default:"true" json:"fromBeginning"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// Fields to add to events from this input
	Metadata            []components.ItemsTypeNotificationMetadata        `json:"metadata,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the MSK cluster is located
	Region string `json:"region"`
	// MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing MSK cluster requests
	SignatureVersion *components.SignatureVersionOptions `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64                               `default:"3600" json:"durationSeconds"`
	TLS             *components.TLSSettingsClientSideType1 `json:"tls,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	Description     *string  `json:"description,omitempty"`
	AwsAPIKey       *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputMskPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputMskPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetType() InputMskType {
	if i == nil {
		return InputMskType("")
	}
	return i.Type
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsClientSideType1 {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputMskPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputMskPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputMskType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `default:"true" json:"fromBeginning"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// Fields to add to events from this input
	Metadata            []components.ItemsTypeNotificationMetadata        `json:"metadata,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the MSK cluster is located
	Region string `json:"region"`
	// MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing MSK cluster requests
	SignatureVersion *components.SignatureVersionOptions `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64                               `default:"3600" json:"durationSeconds"`
	TLS             *components.TLSSettingsClientSideType1 `json:"tls,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	Description     *string  `json:"description,omitempty"`
	AwsAPIKey       *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputMskPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputMskPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetType() InputMskType {
	if i == nil {
		return InputMskType("")
	}
	return i.Type
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetSignatureVersion() *components.SignatureVersionOptions {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsClientSideType1 {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputMskPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputMskSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputMskType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `default:"true" json:"fromBeginning"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// Fields to add to events from this input
	Metadata            []components.ItemsTypeNotificationMetadata        `json:"metadata,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the MSK cluster is located
	Region string `json:"region"`
	// MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing MSK cluster requests
	SignatureVersion *components.SignatureVersionOptions `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64                               `default:"3600" json:"durationSeconds"`
	TLS             *components.TLSSettingsClientSideType1 `json:"tls,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	Description     *string  `json:"description,omitempty"`
	AwsAPIKey       *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputMskSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetType() InputMskType {
	if i == nil {
		return InputMskType("")
	}
	return i.Type
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsClientSideType1 {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputMskSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputMskType string

const (
	InputMskTypeMsk InputMskType = "msk"
)

func (e InputMskType) ToPointer() *InputMskType {
	return &e
}
func (e *InputMskType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "msk":
		*e = InputMskType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskType: %v", v)
	}
}

type InputMskSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string       `json:"id"`
	Type     InputMskType `json:"type"`
	Disabled *bool        `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `default:"true" json:"fromBeginning"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// Fields to add to events from this input
	Metadata            []components.ItemsTypeNotificationMetadata        `json:"metadata,omitempty"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *components.AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                                `json:"awsSecretKey,omitempty"`
	// Region where the MSK cluster is located
	Region string `json:"region"`
	// MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing MSK cluster requests
	SignatureVersion *components.SignatureVersionOptions `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64                               `default:"3600" json:"durationSeconds"`
	TLS             *components.TLSSettingsClientSideType1 `json:"tls,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	Description     *string  `json:"description,omitempty"`
	AwsAPIKey       *string  `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputMskSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetType() InputMskType {
	if i == nil {
		return InputMskType("")
	}
	return i.Type
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *components.AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *components.SignatureVersionOptions {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsClientSideType1 {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputMskSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputMskUnionType string

const (
	InputMskUnionTypeInputMskSendToRoutesTrueWithConnectionsConstraint  InputMskUnionType = "InputMsk_SendToRoutesTrueWithConnectionsConstraint"
	InputMskUnionTypeInputMskSendToRoutesFalseWithConnectionsConstraint InputMskUnionType = "InputMsk_SendToRoutesFalseWithConnectionsConstraint"
	InputMskUnionTypeInputMskPqEnabledFalseWithPqConstraint             InputMskUnionType = "InputMsk_PqEnabledFalseWithPqConstraint"
	InputMskUnionTypeInputMskPqEnabledTrueWithPqConstraint              InputMskUnionType = "InputMsk_PqEnabledTrueWithPqConstraint"
)

type InputMsk struct {
	InputMskSendToRoutesTrueWithConnectionsConstraint  *InputMskSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputMskSendToRoutesFalseWithConnectionsConstraint *InputMskSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputMskPqEnabledFalseWithPqConstraint             *InputMskPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputMskPqEnabledTrueWithPqConstraint              *InputMskPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputMskUnionType
}

func CreateInputMskInputMskSendToRoutesTrueWithConnectionsConstraint(inputMskSendToRoutesTrueWithConnectionsConstraint InputMskSendToRoutesTrueWithConnectionsConstraint) InputMsk {
	typ := InputMskUnionTypeInputMskSendToRoutesTrueWithConnectionsConstraint

	return InputMsk{
		InputMskSendToRoutesTrueWithConnectionsConstraint: &inputMskSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputMskInputMskSendToRoutesFalseWithConnectionsConstraint(inputMskSendToRoutesFalseWithConnectionsConstraint InputMskSendToRoutesFalseWithConnectionsConstraint) InputMsk {
	typ := InputMskUnionTypeInputMskSendToRoutesFalseWithConnectionsConstraint

	return InputMsk{
		InputMskSendToRoutesFalseWithConnectionsConstraint: &inputMskSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputMskInputMskPqEnabledFalseWithPqConstraint(inputMskPqEnabledFalseWithPqConstraint InputMskPqEnabledFalseWithPqConstraint) InputMsk {
	typ := InputMskUnionTypeInputMskPqEnabledFalseWithPqConstraint

	return InputMsk{
		InputMskPqEnabledFalseWithPqConstraint: &inputMskPqEnabledFalseWithPqConstraint,
		Type:                                   typ,
	}
}

func CreateInputMskInputMskPqEnabledTrueWithPqConstraint(inputMskPqEnabledTrueWithPqConstraint InputMskPqEnabledTrueWithPqConstraint) InputMsk {
	typ := InputMskUnionTypeInputMskPqEnabledTrueWithPqConstraint

	return InputMsk{
		InputMskPqEnabledTrueWithPqConstraint: &inputMskPqEnabledTrueWithPqConstraint,
		Type:                                  typ,
	}
}

func (u *InputMsk) UnmarshalJSON(data []byte) error {

	var inputMskSendToRoutesTrueWithConnectionsConstraint InputMskSendToRoutesTrueWithConnectionsConstraint = InputMskSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputMskSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputMskSendToRoutesTrueWithConnectionsConstraint = &inputMskSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputMskUnionTypeInputMskSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputMskSendToRoutesFalseWithConnectionsConstraint InputMskSendToRoutesFalseWithConnectionsConstraint = InputMskSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputMskSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputMskSendToRoutesFalseWithConnectionsConstraint = &inputMskSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputMskUnionTypeInputMskSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputMskPqEnabledFalseWithPqConstraint InputMskPqEnabledFalseWithPqConstraint = InputMskPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputMskPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputMskPqEnabledFalseWithPqConstraint = &inputMskPqEnabledFalseWithPqConstraint
		u.Type = InputMskUnionTypeInputMskPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputMskPqEnabledTrueWithPqConstraint InputMskPqEnabledTrueWithPqConstraint = InputMskPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputMskPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputMskPqEnabledTrueWithPqConstraint = &inputMskPqEnabledTrueWithPqConstraint
		u.Type = InputMskUnionTypeInputMskPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputMsk", string(data))
}

func (u InputMsk) MarshalJSON() ([]byte, error) {
	if u.InputMskSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputMskSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputMskSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputMskSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputMskPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputMskPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputMskPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputMskPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputMsk: all fields are null")
}

type InputKafkaPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string         `json:"id"`
	Type     InputKafkaType `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `default:"true" json:"fromBeginning"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType                           `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKafkaPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetType() InputKafkaType {
	if i == nil {
		return InputKafkaType("")
	}
	return i.Type
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetSasl() *components.AuthenticationType {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKafkaPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKafkaPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string         `json:"id"`
	Type     InputKafkaType `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `default:"true" json:"fromBeginning"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType                           `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKafkaPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetType() InputKafkaType {
	if i == nil {
		return InputKafkaType("")
	}
	return i.Type
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetSasl() *components.AuthenticationType {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKafkaPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKafkaSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string         `json:"id"`
	Type     InputKafkaType `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `default:"true" json:"fromBeginning"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType                           `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKafkaSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetType() InputKafkaType {
	if i == nil {
		return InputKafkaType("")
	}
	return i.Type
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetSasl() *components.AuthenticationType {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKafkaSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKafkaType string

const (
	InputKafkaTypeKafka InputKafkaType = "kafka"
)

func (e InputKafkaType) ToPointer() *InputKafkaType {
	return &e
}
func (e *InputKafkaType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kafka":
		*e = InputKafkaType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKafkaType: %v", v)
	}
}

type InputKafkaSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string         `json:"id"`
	Type     InputKafkaType `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
	Topics []string `json:"topics"`
	// The consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `default:"Cribl" json:"groupId"`
	// Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning       *bool                                             `default:"true" json:"fromBeginning"`
	KafkaSchemaRegistry *components.KafkaSchemaRegistryAuthenticationType `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float64 `default:"10000" json:"connectionTimeout"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float64 `default:"60000" json:"requestTimeout"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
	MaxRetries *float64 `default:"5" json:"maxRetries"`
	// The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float64 `default:"30000" json:"maxBackOff"`
	// Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float64 `default:"300" json:"initialBackoff"`
	// Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float64 `default:"2" json:"backoffRate"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float64 `default:"10000" json:"authenticationTimeout"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
	ReauthenticationThreshold *float64 `default:"10000" json:"reauthenticationThreshold"`
	// Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *components.AuthenticationType                           `json:"sasl,omitempty"`
	TLS  *components.TLSSettingsClientSideTypeKafkaSchemaRegistry `json:"tls,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group-management facilities.
	//       If the client sends no heartbeats to the broker before the timeout expires,
	//       the broker will remove the client from the group and initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
	SessionTimeout *float64 `default:"30000" json:"sessionTimeout"`
	//       Maximum allowed time for each worker to join the group after a rebalance begins.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
	RebalanceTimeout *float64 `default:"60000" json:"rebalanceTimeout"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
	//       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
	//       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
	HeartbeatInterval *float64 `default:"3000" json:"heartbeatInterval"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float64 `json:"autoCommitThreshold,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float64 `default:"1048576" json:"maxBytesPerPartition"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float64 `default:"10485760" json:"maxBytes"`
	// Maximum number of network errors before the consumer re-creates a socket
	MaxSocketErrors *float64 `default:"0" json:"maxSocketErrors"`
	// Fields to add to events from this input
	Metadata    []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                                    `json:"description,omitempty"`
}

func (i InputKafkaSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id", "type", "brokers", "topics"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetType() InputKafkaType {
	if i == nil {
		return InputKafkaType("")
	}
	return i.Type
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetBrokers() []string {
	if i == nil {
		return []string{}
	}
	return i.Brokers
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetTopics() []string {
	if i == nil {
		return []string{}
	}
	return i.Topics
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetGroupID() *string {
	if i == nil {
		return nil
	}
	return i.GroupID
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetFromBeginning() *bool {
	if i == nil {
		return nil
	}
	return i.FromBeginning
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetKafkaSchemaRegistry() *components.KafkaSchemaRegistryAuthenticationType {
	if i == nil {
		return nil
	}
	return i.KafkaSchemaRegistry
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetConnectionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.ConnectionTimeout
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetMaxRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxRetries
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetMaxBackOff() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBackOff
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetInitialBackoff() *float64 {
	if i == nil {
		return nil
	}
	return i.InitialBackoff
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetBackoffRate() *float64 {
	if i == nil {
		return nil
	}
	return i.BackoffRate
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetAuthenticationTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.AuthenticationTimeout
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetReauthenticationThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.ReauthenticationThreshold
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetSasl() *components.AuthenticationType {
	if i == nil {
		return nil
	}
	return i.Sasl
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetTLS() *components.TLSSettingsClientSideTypeKafkaSchemaRegistry {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetSessionTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SessionTimeout
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetRebalanceTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RebalanceTimeout
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetHeartbeatInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.HeartbeatInterval
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetAutoCommitInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitInterval
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetAutoCommitThreshold() *float64 {
	if i == nil {
		return nil
	}
	return i.AutoCommitThreshold
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetMaxBytesPerPartition() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytesPerPartition
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetMaxBytes() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxBytes
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetMaxSocketErrors() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxSocketErrors
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKafkaSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputKafkaUnionType string

const (
	InputKafkaUnionTypeInputKafkaSendToRoutesTrueWithConnectionsConstraint  InputKafkaUnionType = "InputKafka_SendToRoutesTrueWithConnectionsConstraint"
	InputKafkaUnionTypeInputKafkaSendToRoutesFalseWithConnectionsConstraint InputKafkaUnionType = "InputKafka_SendToRoutesFalseWithConnectionsConstraint"
	InputKafkaUnionTypeInputKafkaPqEnabledFalseWithPqConstraint             InputKafkaUnionType = "InputKafka_PqEnabledFalseWithPqConstraint"
	InputKafkaUnionTypeInputKafkaPqEnabledTrueWithPqConstraint              InputKafkaUnionType = "InputKafka_PqEnabledTrueWithPqConstraint"
)

type InputKafka struct {
	InputKafkaSendToRoutesTrueWithConnectionsConstraint  *InputKafkaSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputKafkaSendToRoutesFalseWithConnectionsConstraint *InputKafkaSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputKafkaPqEnabledFalseWithPqConstraint             *InputKafkaPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputKafkaPqEnabledTrueWithPqConstraint              *InputKafkaPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputKafkaUnionType
}

func CreateInputKafkaInputKafkaSendToRoutesTrueWithConnectionsConstraint(inputKafkaSendToRoutesTrueWithConnectionsConstraint InputKafkaSendToRoutesTrueWithConnectionsConstraint) InputKafka {
	typ := InputKafkaUnionTypeInputKafkaSendToRoutesTrueWithConnectionsConstraint

	return InputKafka{
		InputKafkaSendToRoutesTrueWithConnectionsConstraint: &inputKafkaSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKafkaInputKafkaSendToRoutesFalseWithConnectionsConstraint(inputKafkaSendToRoutesFalseWithConnectionsConstraint InputKafkaSendToRoutesFalseWithConnectionsConstraint) InputKafka {
	typ := InputKafkaUnionTypeInputKafkaSendToRoutesFalseWithConnectionsConstraint

	return InputKafka{
		InputKafkaSendToRoutesFalseWithConnectionsConstraint: &inputKafkaSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKafkaInputKafkaPqEnabledFalseWithPqConstraint(inputKafkaPqEnabledFalseWithPqConstraint InputKafkaPqEnabledFalseWithPqConstraint) InputKafka {
	typ := InputKafkaUnionTypeInputKafkaPqEnabledFalseWithPqConstraint

	return InputKafka{
		InputKafkaPqEnabledFalseWithPqConstraint: &inputKafkaPqEnabledFalseWithPqConstraint,
		Type:                                     typ,
	}
}

func CreateInputKafkaInputKafkaPqEnabledTrueWithPqConstraint(inputKafkaPqEnabledTrueWithPqConstraint InputKafkaPqEnabledTrueWithPqConstraint) InputKafka {
	typ := InputKafkaUnionTypeInputKafkaPqEnabledTrueWithPqConstraint

	return InputKafka{
		InputKafkaPqEnabledTrueWithPqConstraint: &inputKafkaPqEnabledTrueWithPqConstraint,
		Type:                                    typ,
	}
}

func (u *InputKafka) UnmarshalJSON(data []byte) error {

	var inputKafkaSendToRoutesTrueWithConnectionsConstraint InputKafkaSendToRoutesTrueWithConnectionsConstraint = InputKafkaSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKafkaSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKafkaSendToRoutesTrueWithConnectionsConstraint = &inputKafkaSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputKafkaUnionTypeInputKafkaSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputKafkaSendToRoutesFalseWithConnectionsConstraint InputKafkaSendToRoutesFalseWithConnectionsConstraint = InputKafkaSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKafkaSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKafkaSendToRoutesFalseWithConnectionsConstraint = &inputKafkaSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputKafkaUnionTypeInputKafkaSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputKafkaPqEnabledFalseWithPqConstraint InputKafkaPqEnabledFalseWithPqConstraint = InputKafkaPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKafkaPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputKafkaPqEnabledFalseWithPqConstraint = &inputKafkaPqEnabledFalseWithPqConstraint
		u.Type = InputKafkaUnionTypeInputKafkaPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputKafkaPqEnabledTrueWithPqConstraint InputKafkaPqEnabledTrueWithPqConstraint = InputKafkaPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKafkaPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputKafkaPqEnabledTrueWithPqConstraint = &inputKafkaPqEnabledTrueWithPqConstraint
		u.Type = InputKafkaUnionTypeInputKafkaPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputKafka", string(data))
}

func (u InputKafka) MarshalJSON() ([]byte, error) {
	if u.InputKafkaSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKafkaSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputKafkaSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKafkaSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputKafkaPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKafkaPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputKafkaPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKafkaPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputKafka: all fields are null")
}

type InputCollectionPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     *InputCollectionType `default:"collection" json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process results
	Pipeline *string `json:"pipeline,omitempty"`
	// Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64                                          `default:"10000" json:"staleChannelFlushMs"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `default:"0" json:"throttleRatePerSec"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Destination to send results to
	Output *string `json:"output,omitempty"`
}

func (i InputCollectionPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetType() *InputCollectionType {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetThrottleRatePerSec() *string {
	if i == nil {
		return nil
	}
	return i.ThrottleRatePerSec
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCollectionPqEnabledTrueWithPqConstraint) GetOutput() *string {
	if i == nil {
		return nil
	}
	return i.Output
}

type InputCollectionPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool              `default:"false" json:"pqEnabled"`
	Pq        *components.PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     *InputCollectionType `default:"collection" json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process results
	Pipeline *string `json:"pipeline,omitempty"`
	// Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64                                          `default:"10000" json:"staleChannelFlushMs"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `default:"0" json:"throttleRatePerSec"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Destination to send results to
	Output *string `json:"output,omitempty"`
}

func (i InputCollectionPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetType() *InputCollectionType {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetThrottleRatePerSec() *string {
	if i == nil {
		return nil
	}
	return i.ThrottleRatePerSec
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCollectionPqEnabledFalseWithPqConstraint) GetOutput() *string {
	if i == nil {
		return nil
	}
	return i.Output
}

type InputCollectionSendToRoutesFalseWithConnectionsConstraint struct {
	// Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     *InputCollectionType `default:"collection" json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process results
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64                                          `default:"10000" json:"staleChannelFlushMs"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `default:"0" json:"throttleRatePerSec"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Destination to send results to
	Output *string `json:"output,omitempty"`
}

func (i InputCollectionSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetType() *InputCollectionType {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetThrottleRatePerSec() *string {
	if i == nil {
		return nil
	}
	return i.ThrottleRatePerSec
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCollectionSendToRoutesFalseWithConnectionsConstraint) GetOutput() *string {
	if i == nil {
		return nil
	}
	return i.Output
}

type InputCollectionType string

const (
	InputCollectionTypeCollection InputCollectionType = "collection"
)

func (e InputCollectionType) ToPointer() *InputCollectionType {
	return &e
}
func (e *InputCollectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "collection":
		*e = InputCollectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectionType: %v", v)
	}
}

type InputCollectionSendToRoutesTrueWithConnectionsConstraint struct {
	// Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []components.ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       string               `json:"id"`
	Type     *InputCollectionType `default:"collection" json:"type"`
	Disabled *bool                `default:"false" json:"disabled"`
	// Pipeline to process results
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string           `json:"streamtags,omitempty"`
	Pq         *components.PqType `json:"pq,omitempty"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64                                          `default:"10000" json:"staleChannelFlushMs"`
	Preprocess          *components.PreprocessTypeSavedJobCollectionInput `json:"preprocess,omitempty"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `default:"0" json:"throttleRatePerSec"`
	// Fields to add to events from this input
	Metadata []components.ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Destination to send results to
	Output *string `json:"output,omitempty"`
}

func (i InputCollectionSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetConnections() []components.ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetType() *InputCollectionType {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetPq() *components.PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetPreprocess() *components.PreprocessTypeSavedJobCollectionInput {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetThrottleRatePerSec() *string {
	if i == nil {
		return nil
	}
	return i.ThrottleRatePerSec
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []components.ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCollectionSendToRoutesTrueWithConnectionsConstraint) GetOutput() *string {
	if i == nil {
		return nil
	}
	return i.Output
}

type InputCollectionUnionType string

const (
	InputCollectionUnionTypeInputCollectionSendToRoutesTrueWithConnectionsConstraint  InputCollectionUnionType = "InputCollection_SendToRoutesTrueWithConnectionsConstraint"
	InputCollectionUnionTypeInputCollectionSendToRoutesFalseWithConnectionsConstraint InputCollectionUnionType = "InputCollection_SendToRoutesFalseWithConnectionsConstraint"
	InputCollectionUnionTypeInputCollectionPqEnabledFalseWithPqConstraint             InputCollectionUnionType = "InputCollection_PqEnabledFalseWithPqConstraint"
	InputCollectionUnionTypeInputCollectionPqEnabledTrueWithPqConstraint              InputCollectionUnionType = "InputCollection_PqEnabledTrueWithPqConstraint"
)

type InputCollection struct {
	InputCollectionSendToRoutesTrueWithConnectionsConstraint  *InputCollectionSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputCollectionSendToRoutesFalseWithConnectionsConstraint *InputCollectionSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputCollectionPqEnabledFalseWithPqConstraint             *InputCollectionPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputCollectionPqEnabledTrueWithPqConstraint              *InputCollectionPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputCollectionUnionType
}

func CreateInputCollectionInputCollectionSendToRoutesTrueWithConnectionsConstraint(inputCollectionSendToRoutesTrueWithConnectionsConstraint InputCollectionSendToRoutesTrueWithConnectionsConstraint) InputCollection {
	typ := InputCollectionUnionTypeInputCollectionSendToRoutesTrueWithConnectionsConstraint

	return InputCollection{
		InputCollectionSendToRoutesTrueWithConnectionsConstraint: &inputCollectionSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCollectionInputCollectionSendToRoutesFalseWithConnectionsConstraint(inputCollectionSendToRoutesFalseWithConnectionsConstraint InputCollectionSendToRoutesFalseWithConnectionsConstraint) InputCollection {
	typ := InputCollectionUnionTypeInputCollectionSendToRoutesFalseWithConnectionsConstraint

	return InputCollection{
		InputCollectionSendToRoutesFalseWithConnectionsConstraint: &inputCollectionSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputCollectionInputCollectionPqEnabledFalseWithPqConstraint(inputCollectionPqEnabledFalseWithPqConstraint InputCollectionPqEnabledFalseWithPqConstraint) InputCollection {
	typ := InputCollectionUnionTypeInputCollectionPqEnabledFalseWithPqConstraint

	return InputCollection{
		InputCollectionPqEnabledFalseWithPqConstraint: &inputCollectionPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputCollectionInputCollectionPqEnabledTrueWithPqConstraint(inputCollectionPqEnabledTrueWithPqConstraint InputCollectionPqEnabledTrueWithPqConstraint) InputCollection {
	typ := InputCollectionUnionTypeInputCollectionPqEnabledTrueWithPqConstraint

	return InputCollection{
		InputCollectionPqEnabledTrueWithPqConstraint: &inputCollectionPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputCollection) UnmarshalJSON(data []byte) error {

	var inputCollectionSendToRoutesTrueWithConnectionsConstraint InputCollectionSendToRoutesTrueWithConnectionsConstraint = InputCollectionSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCollectionSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCollectionSendToRoutesTrueWithConnectionsConstraint = &inputCollectionSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputCollectionUnionTypeInputCollectionSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputCollectionSendToRoutesFalseWithConnectionsConstraint InputCollectionSendToRoutesFalseWithConnectionsConstraint = InputCollectionSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCollectionSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputCollectionSendToRoutesFalseWithConnectionsConstraint = &inputCollectionSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputCollectionUnionTypeInputCollectionSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputCollectionPqEnabledFalseWithPqConstraint InputCollectionPqEnabledFalseWithPqConstraint = InputCollectionPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCollectionPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputCollectionPqEnabledFalseWithPqConstraint = &inputCollectionPqEnabledFalseWithPqConstraint
		u.Type = InputCollectionUnionTypeInputCollectionPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputCollectionPqEnabledTrueWithPqConstraint InputCollectionPqEnabledTrueWithPqConstraint = InputCollectionPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputCollectionPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputCollectionPqEnabledTrueWithPqConstraint = &inputCollectionPqEnabledTrueWithPqConstraint
		u.Type = InputCollectionUnionTypeInputCollectionPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputCollection", string(data))
}

func (u InputCollection) MarshalJSON() ([]byte, error) {
	if u.InputCollectionSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCollectionSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputCollectionSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputCollectionSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputCollectionPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCollectionPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputCollectionPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputCollectionPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputCollection: all fields are null")
}

type CreateInputRequestType string

const (
	CreateInputRequestTypeCollection           CreateInputRequestType = "collection"
	CreateInputRequestTypeKafka                CreateInputRequestType = "kafka"
	CreateInputRequestTypeMsk                  CreateInputRequestType = "msk"
	CreateInputRequestTypeHTTP                 CreateInputRequestType = "http"
	CreateInputRequestTypeSplunk               CreateInputRequestType = "splunk"
	CreateInputRequestTypeSplunkSearch         CreateInputRequestType = "splunk_search"
	CreateInputRequestTypeSplunkHec            CreateInputRequestType = "splunk_hec"
	CreateInputRequestTypeAzureBlob            CreateInputRequestType = "azure_blob"
	CreateInputRequestTypeElastic              CreateInputRequestType = "elastic"
	CreateInputRequestTypeConfluentCloud       CreateInputRequestType = "confluent_cloud"
	CreateInputRequestTypeGrafana              CreateInputRequestType = "grafana"
	CreateInputRequestTypeLoki                 CreateInputRequestType = "loki"
	CreateInputRequestTypePrometheusRw         CreateInputRequestType = "prometheus_rw"
	CreateInputRequestTypePrometheus           CreateInputRequestType = "prometheus"
	CreateInputRequestTypeEdgePrometheus       CreateInputRequestType = "edge_prometheus"
	CreateInputRequestTypeOffice365Mgmt        CreateInputRequestType = "office365_mgmt"
	CreateInputRequestTypeOffice365Service     CreateInputRequestType = "office365_service"
	CreateInputRequestTypeOffice365MsgTrace    CreateInputRequestType = "office365_msg_trace"
	CreateInputRequestTypeEventhub             CreateInputRequestType = "eventhub"
	CreateInputRequestTypeExec                 CreateInputRequestType = "exec"
	CreateInputRequestTypeFirehose             CreateInputRequestType = "firehose"
	CreateInputRequestTypeGooglePubsub         CreateInputRequestType = "google_pubsub"
	CreateInputRequestTypeCribl                CreateInputRequestType = "cribl"
	CreateInputRequestTypeCriblTCP             CreateInputRequestType = "cribl_tcp"
	CreateInputRequestTypeCriblHTTP            CreateInputRequestType = "cribl_http"
	CreateInputRequestTypeCriblLakeHTTP        CreateInputRequestType = "cribl_lake_http"
	CreateInputRequestTypeTcpjson              CreateInputRequestType = "tcpjson"
	CreateInputRequestTypeSystemMetrics        CreateInputRequestType = "system_metrics"
	CreateInputRequestTypeSystemState          CreateInputRequestType = "system_state"
	CreateInputRequestTypeKubeMetrics          CreateInputRequestType = "kube_metrics"
	CreateInputRequestTypeKubeLogs             CreateInputRequestType = "kube_logs"
	CreateInputRequestTypeKubeEvents           CreateInputRequestType = "kube_events"
	CreateInputRequestTypeWindowsMetrics       CreateInputRequestType = "windows_metrics"
	CreateInputRequestTypeCrowdstrike          CreateInputRequestType = "crowdstrike"
	CreateInputRequestTypeDatadogAgent         CreateInputRequestType = "datadog_agent"
	CreateInputRequestTypeDatagen              CreateInputRequestType = "datagen"
	CreateInputRequestTypeHTTPRaw              CreateInputRequestType = "http_raw"
	CreateInputRequestTypeKinesis              CreateInputRequestType = "kinesis"
	CreateInputRequestTypeCriblmetrics         CreateInputRequestType = "criblmetrics"
	CreateInputRequestTypeMetrics              CreateInputRequestType = "metrics"
	CreateInputRequestTypeS3                   CreateInputRequestType = "s3"
	CreateInputRequestTypeS3Inventory          CreateInputRequestType = "s3_inventory"
	CreateInputRequestTypeSnmp                 CreateInputRequestType = "snmp"
	CreateInputRequestTypeOpenTelemetry        CreateInputRequestType = "open_telemetry"
	CreateInputRequestTypeModelDrivenTelemetry CreateInputRequestType = "model_driven_telemetry"
	CreateInputRequestTypeSqs                  CreateInputRequestType = "sqs"
	CreateInputRequestTypeSyslog               CreateInputRequestType = "syslog"
	CreateInputRequestTypeFile                 CreateInputRequestType = "file"
	CreateInputRequestTypeTCP                  CreateInputRequestType = "tcp"
	CreateInputRequestTypeAppscope             CreateInputRequestType = "appscope"
	CreateInputRequestTypeWef                  CreateInputRequestType = "wef"
	CreateInputRequestTypeWinEventLogs         CreateInputRequestType = "win_event_logs"
	CreateInputRequestTypeRawUDP               CreateInputRequestType = "raw_udp"
	CreateInputRequestTypeJournalFiles         CreateInputRequestType = "journal_files"
	CreateInputRequestTypeWiz                  CreateInputRequestType = "wiz"
	CreateInputRequestTypeWizWebhook           CreateInputRequestType = "wiz_webhook"
	CreateInputRequestTypeNetflow              CreateInputRequestType = "netflow"
	CreateInputRequestTypeSecurityLake         CreateInputRequestType = "security_lake"
	CreateInputRequestTypeZscalerHec           CreateInputRequestType = "zscaler_hec"
	CreateInputRequestTypeCloudflareHec        CreateInputRequestType = "cloudflare_hec"
)

// CreateInputRequest - Input object
type CreateInputRequest struct {
	InputCollection           *InputCollection           `queryParam:"inline" union:"member"`
	InputKafka                *InputKafka                `queryParam:"inline" union:"member"`
	InputMsk                  *InputMsk                  `queryParam:"inline" union:"member"`
	InputHTTP                 *InputHTTP                 `queryParam:"inline" union:"member"`
	InputSplunk               *InputSplunk               `queryParam:"inline" union:"member"`
	InputSplunkSearch         *InputSplunkSearch         `queryParam:"inline" union:"member"`
	InputSplunkHec            *InputSplunkHec            `queryParam:"inline" union:"member"`
	InputAzureBlob            *InputAzureBlob            `queryParam:"inline" union:"member"`
	InputElastic              *InputElastic              `queryParam:"inline" union:"member"`
	InputConfluentCloud       *InputConfluentCloud       `queryParam:"inline" union:"member"`
	InputGrafana              *InputGrafana              `queryParam:"inline" union:"member"`
	InputLoki                 *InputLoki                 `queryParam:"inline" union:"member"`
	InputPrometheusRw         *InputPrometheusRw         `queryParam:"inline" union:"member"`
	InputPrometheus           *InputPrometheus           `queryParam:"inline" union:"member"`
	InputEdgePrometheus       *InputEdgePrometheus       `queryParam:"inline" union:"member"`
	InputOffice365Mgmt        *InputOffice365Mgmt        `queryParam:"inline" union:"member"`
	InputOffice365Service     *InputOffice365Service     `queryParam:"inline" union:"member"`
	InputOffice365MsgTrace    *InputOffice365MsgTrace    `queryParam:"inline" union:"member"`
	InputEventhub             *InputEventhub             `queryParam:"inline" union:"member"`
	InputExec                 *InputExec                 `queryParam:"inline" union:"member"`
	InputFirehose             *InputFirehose             `queryParam:"inline" union:"member"`
	InputGooglePubsub         *InputGooglePubsub         `queryParam:"inline" union:"member"`
	InputCribl                *InputCribl                `queryParam:"inline" union:"member"`
	InputCriblTCP             *InputCriblTCP             `queryParam:"inline" union:"member"`
	InputCriblHTTP            *InputCriblHTTP            `queryParam:"inline" union:"member"`
	InputCriblLakeHTTP        *InputCriblLakeHTTP        `queryParam:"inline" union:"member"`
	InputTcpjson              *InputTcpjson              `queryParam:"inline" union:"member"`
	InputSystemMetrics        *InputSystemMetrics        `queryParam:"inline" union:"member"`
	InputSystemState          *InputSystemState          `queryParam:"inline" union:"member"`
	InputKubeMetrics          *InputKubeMetrics          `queryParam:"inline" union:"member"`
	InputKubeLogs             *InputKubeLogs             `queryParam:"inline" union:"member"`
	InputKubeEvents           *InputKubeEvents           `queryParam:"inline" union:"member"`
	InputWindowsMetrics       *InputWindowsMetrics       `queryParam:"inline" union:"member"`
	InputCrowdstrike          *InputCrowdstrike          `queryParam:"inline" union:"member"`
	InputDatadogAgent         *InputDatadogAgent         `queryParam:"inline" union:"member"`
	InputDatagen              *InputDatagen              `queryParam:"inline" union:"member"`
	InputHTTPRaw              *InputHTTPRaw              `queryParam:"inline" union:"member"`
	InputKinesis              *InputKinesis              `queryParam:"inline" union:"member"`
	InputCriblmetrics         *InputCriblmetrics         `queryParam:"inline" union:"member"`
	InputMetrics              *InputMetrics              `queryParam:"inline" union:"member"`
	InputS3                   *InputS3                   `queryParam:"inline" union:"member"`
	InputS3Inventory          *InputS3Inventory          `queryParam:"inline" union:"member"`
	InputSnmp                 *InputSnmp                 `queryParam:"inline" union:"member"`
	InputOpenTelemetry        *InputOpenTelemetry        `queryParam:"inline" union:"member"`
	InputModelDrivenTelemetry *InputModelDrivenTelemetry `queryParam:"inline" union:"member"`
	InputSqs                  *InputSqs                  `queryParam:"inline" union:"member"`
	InputSyslog               *InputSyslog               `queryParam:"inline" union:"member"`
	InputFile                 *InputFile                 `queryParam:"inline" union:"member"`
	InputTCP                  *InputTCP                  `queryParam:"inline" union:"member"`
	InputAppscope             *InputAppscope             `queryParam:"inline" union:"member"`
	InputWef                  *InputWef                  `queryParam:"inline" union:"member"`
	InputWinEventLogs         *InputWinEventLogs         `queryParam:"inline" union:"member"`
	InputRawUDP               *InputRawUDP               `queryParam:"inline" union:"member"`
	InputJournalFiles         *InputJournalFiles         `queryParam:"inline" union:"member"`
	InputWiz                  *InputWiz                  `queryParam:"inline" union:"member"`
	InputWizWebhook           *InputWizWebhook           `queryParam:"inline" union:"member"`
	InputNetflow              *InputNetflow              `queryParam:"inline" union:"member"`
	InputSecurityLake         *InputSecurityLake         `queryParam:"inline" union:"member"`
	InputZscalerHec           *InputZscalerHec           `queryParam:"inline" union:"member"`
	InputCloudflareHec        *InputCloudflareHec        `queryParam:"inline" union:"member"`

	Type CreateInputRequestType
}

func CreateCreateInputRequestCollection(collection InputCollection) CreateInputRequest {
	typ := CreateInputRequestTypeCollection

	return CreateInputRequest{
		InputCollection: &collection,
		Type:            typ,
	}
}

func CreateCreateInputRequestKafka(kafka InputKafka) CreateInputRequest {
	typ := CreateInputRequestTypeKafka

	return CreateInputRequest{
		InputKafka: &kafka,
		Type:       typ,
	}
}

func CreateCreateInputRequestMsk(msk InputMsk) CreateInputRequest {
	typ := CreateInputRequestTypeMsk

	return CreateInputRequest{
		InputMsk: &msk,
		Type:     typ,
	}
}

func CreateCreateInputRequestHTTP(http InputHTTP) CreateInputRequest {
	typ := CreateInputRequestTypeHTTP

	return CreateInputRequest{
		InputHTTP: &http,
		Type:      typ,
	}
}

func CreateCreateInputRequestSplunk(splunk InputSplunk) CreateInputRequest {
	typ := CreateInputRequestTypeSplunk

	return CreateInputRequest{
		InputSplunk: &splunk,
		Type:        typ,
	}
}

func CreateCreateInputRequestSplunkSearch(splunkSearch InputSplunkSearch) CreateInputRequest {
	typ := CreateInputRequestTypeSplunkSearch

	return CreateInputRequest{
		InputSplunkSearch: &splunkSearch,
		Type:              typ,
	}
}

func CreateCreateInputRequestSplunkHec(splunkHec InputSplunkHec) CreateInputRequest {
	typ := CreateInputRequestTypeSplunkHec

	return CreateInputRequest{
		InputSplunkHec: &splunkHec,
		Type:           typ,
	}
}

func CreateCreateInputRequestAzureBlob(azureBlob InputAzureBlob) CreateInputRequest {
	typ := CreateInputRequestTypeAzureBlob

	return CreateInputRequest{
		InputAzureBlob: &azureBlob,
		Type:           typ,
	}
}

func CreateCreateInputRequestElastic(elastic InputElastic) CreateInputRequest {
	typ := CreateInputRequestTypeElastic

	return CreateInputRequest{
		InputElastic: &elastic,
		Type:         typ,
	}
}

func CreateCreateInputRequestConfluentCloud(confluentCloud InputConfluentCloud) CreateInputRequest {
	typ := CreateInputRequestTypeConfluentCloud

	return CreateInputRequest{
		InputConfluentCloud: &confluentCloud,
		Type:                typ,
	}
}

func CreateCreateInputRequestGrafana(grafana InputGrafana) CreateInputRequest {
	typ := CreateInputRequestTypeGrafana

	return CreateInputRequest{
		InputGrafana: &grafana,
		Type:         typ,
	}
}

func CreateCreateInputRequestLoki(loki InputLoki) CreateInputRequest {
	typ := CreateInputRequestTypeLoki

	return CreateInputRequest{
		InputLoki: &loki,
		Type:      typ,
	}
}

func CreateCreateInputRequestPrometheusRw(prometheusRw InputPrometheusRw) CreateInputRequest {
	typ := CreateInputRequestTypePrometheusRw

	return CreateInputRequest{
		InputPrometheusRw: &prometheusRw,
		Type:              typ,
	}
}

func CreateCreateInputRequestPrometheus(prometheus InputPrometheus) CreateInputRequest {
	typ := CreateInputRequestTypePrometheus

	return CreateInputRequest{
		InputPrometheus: &prometheus,
		Type:            typ,
	}
}

func CreateCreateInputRequestEdgePrometheus(edgePrometheus InputEdgePrometheus) CreateInputRequest {
	typ := CreateInputRequestTypeEdgePrometheus

	return CreateInputRequest{
		InputEdgePrometheus: &edgePrometheus,
		Type:                typ,
	}
}

func CreateCreateInputRequestOffice365Mgmt(office365Mgmt InputOffice365Mgmt) CreateInputRequest {
	typ := CreateInputRequestTypeOffice365Mgmt

	return CreateInputRequest{
		InputOffice365Mgmt: &office365Mgmt,
		Type:               typ,
	}
}

func CreateCreateInputRequestOffice365Service(office365Service InputOffice365Service) CreateInputRequest {
	typ := CreateInputRequestTypeOffice365Service

	return CreateInputRequest{
		InputOffice365Service: &office365Service,
		Type:                  typ,
	}
}

func CreateCreateInputRequestOffice365MsgTrace(office365MsgTrace InputOffice365MsgTrace) CreateInputRequest {
	typ := CreateInputRequestTypeOffice365MsgTrace

	return CreateInputRequest{
		InputOffice365MsgTrace: &office365MsgTrace,
		Type:                   typ,
	}
}

func CreateCreateInputRequestEventhub(eventhub InputEventhub) CreateInputRequest {
	typ := CreateInputRequestTypeEventhub

	return CreateInputRequest{
		InputEventhub: &eventhub,
		Type:          typ,
	}
}

func CreateCreateInputRequestExec(exec InputExec) CreateInputRequest {
	typ := CreateInputRequestTypeExec

	return CreateInputRequest{
		InputExec: &exec,
		Type:      typ,
	}
}

func CreateCreateInputRequestFirehose(firehose InputFirehose) CreateInputRequest {
	typ := CreateInputRequestTypeFirehose

	return CreateInputRequest{
		InputFirehose: &firehose,
		Type:          typ,
	}
}

func CreateCreateInputRequestGooglePubsub(googlePubsub InputGooglePubsub) CreateInputRequest {
	typ := CreateInputRequestTypeGooglePubsub

	return CreateInputRequest{
		InputGooglePubsub: &googlePubsub,
		Type:              typ,
	}
}

func CreateCreateInputRequestCribl(cribl InputCribl) CreateInputRequest {
	typ := CreateInputRequestTypeCribl

	return CreateInputRequest{
		InputCribl: &cribl,
		Type:       typ,
	}
}

func CreateCreateInputRequestCriblTCP(criblTCP InputCriblTCP) CreateInputRequest {
	typ := CreateInputRequestTypeCriblTCP

	return CreateInputRequest{
		InputCriblTCP: &criblTCP,
		Type:          typ,
	}
}

func CreateCreateInputRequestCriblHTTP(criblHTTP InputCriblHTTP) CreateInputRequest {
	typ := CreateInputRequestTypeCriblHTTP

	return CreateInputRequest{
		InputCriblHTTP: &criblHTTP,
		Type:           typ,
	}
}

func CreateCreateInputRequestCriblLakeHTTP(criblLakeHTTP InputCriblLakeHTTP) CreateInputRequest {
	typ := CreateInputRequestTypeCriblLakeHTTP

	return CreateInputRequest{
		InputCriblLakeHTTP: &criblLakeHTTP,
		Type:               typ,
	}
}

func CreateCreateInputRequestTcpjson(tcpjson InputTcpjson) CreateInputRequest {
	typ := CreateInputRequestTypeTcpjson

	return CreateInputRequest{
		InputTcpjson: &tcpjson,
		Type:         typ,
	}
}

func CreateCreateInputRequestSystemMetrics(systemMetrics InputSystemMetrics) CreateInputRequest {
	typ := CreateInputRequestTypeSystemMetrics

	return CreateInputRequest{
		InputSystemMetrics: &systemMetrics,
		Type:               typ,
	}
}

func CreateCreateInputRequestSystemState(systemState InputSystemState) CreateInputRequest {
	typ := CreateInputRequestTypeSystemState

	return CreateInputRequest{
		InputSystemState: &systemState,
		Type:             typ,
	}
}

func CreateCreateInputRequestKubeMetrics(kubeMetrics InputKubeMetrics) CreateInputRequest {
	typ := CreateInputRequestTypeKubeMetrics

	return CreateInputRequest{
		InputKubeMetrics: &kubeMetrics,
		Type:             typ,
	}
}

func CreateCreateInputRequestKubeLogs(kubeLogs InputKubeLogs) CreateInputRequest {
	typ := CreateInputRequestTypeKubeLogs

	return CreateInputRequest{
		InputKubeLogs: &kubeLogs,
		Type:          typ,
	}
}

func CreateCreateInputRequestKubeEvents(kubeEvents InputKubeEvents) CreateInputRequest {
	typ := CreateInputRequestTypeKubeEvents

	return CreateInputRequest{
		InputKubeEvents: &kubeEvents,
		Type:            typ,
	}
}

func CreateCreateInputRequestWindowsMetrics(windowsMetrics InputWindowsMetrics) CreateInputRequest {
	typ := CreateInputRequestTypeWindowsMetrics

	return CreateInputRequest{
		InputWindowsMetrics: &windowsMetrics,
		Type:                typ,
	}
}

func CreateCreateInputRequestCrowdstrike(crowdstrike InputCrowdstrike) CreateInputRequest {
	typ := CreateInputRequestTypeCrowdstrike

	return CreateInputRequest{
		InputCrowdstrike: &crowdstrike,
		Type:             typ,
	}
}

func CreateCreateInputRequestDatadogAgent(datadogAgent InputDatadogAgent) CreateInputRequest {
	typ := CreateInputRequestTypeDatadogAgent

	return CreateInputRequest{
		InputDatadogAgent: &datadogAgent,
		Type:              typ,
	}
}

func CreateCreateInputRequestDatagen(datagen InputDatagen) CreateInputRequest {
	typ := CreateInputRequestTypeDatagen

	return CreateInputRequest{
		InputDatagen: &datagen,
		Type:         typ,
	}
}

func CreateCreateInputRequestHTTPRaw(httpRaw InputHTTPRaw) CreateInputRequest {
	typ := CreateInputRequestTypeHTTPRaw

	return CreateInputRequest{
		InputHTTPRaw: &httpRaw,
		Type:         typ,
	}
}

func CreateCreateInputRequestKinesis(kinesis InputKinesis) CreateInputRequest {
	typ := CreateInputRequestTypeKinesis

	return CreateInputRequest{
		InputKinesis: &kinesis,
		Type:         typ,
	}
}

func CreateCreateInputRequestCriblmetrics(criblmetrics InputCriblmetrics) CreateInputRequest {
	typ := CreateInputRequestTypeCriblmetrics

	return CreateInputRequest{
		InputCriblmetrics: &criblmetrics,
		Type:              typ,
	}
}

func CreateCreateInputRequestMetrics(metrics InputMetrics) CreateInputRequest {
	typ := CreateInputRequestTypeMetrics

	return CreateInputRequest{
		InputMetrics: &metrics,
		Type:         typ,
	}
}

func CreateCreateInputRequestS3(s3 InputS3) CreateInputRequest {
	typ := CreateInputRequestTypeS3

	return CreateInputRequest{
		InputS3: &s3,
		Type:    typ,
	}
}

func CreateCreateInputRequestS3Inventory(s3Inventory InputS3Inventory) CreateInputRequest {
	typ := CreateInputRequestTypeS3Inventory

	return CreateInputRequest{
		InputS3Inventory: &s3Inventory,
		Type:             typ,
	}
}

func CreateCreateInputRequestSnmp(snmp InputSnmp) CreateInputRequest {
	typ := CreateInputRequestTypeSnmp

	return CreateInputRequest{
		InputSnmp: &snmp,
		Type:      typ,
	}
}

func CreateCreateInputRequestOpenTelemetry(openTelemetry InputOpenTelemetry) CreateInputRequest {
	typ := CreateInputRequestTypeOpenTelemetry

	return CreateInputRequest{
		InputOpenTelemetry: &openTelemetry,
		Type:               typ,
	}
}

func CreateCreateInputRequestModelDrivenTelemetry(modelDrivenTelemetry InputModelDrivenTelemetry) CreateInputRequest {
	typ := CreateInputRequestTypeModelDrivenTelemetry

	return CreateInputRequest{
		InputModelDrivenTelemetry: &modelDrivenTelemetry,
		Type:                      typ,
	}
}

func CreateCreateInputRequestSqs(sqs InputSqs) CreateInputRequest {
	typ := CreateInputRequestTypeSqs

	return CreateInputRequest{
		InputSqs: &sqs,
		Type:     typ,
	}
}

func CreateCreateInputRequestSyslog(syslog InputSyslog) CreateInputRequest {
	typ := CreateInputRequestTypeSyslog

	return CreateInputRequest{
		InputSyslog: &syslog,
		Type:        typ,
	}
}

func CreateCreateInputRequestFile(file InputFile) CreateInputRequest {
	typ := CreateInputRequestTypeFile

	return CreateInputRequest{
		InputFile: &file,
		Type:      typ,
	}
}

func CreateCreateInputRequestTCP(tcp InputTCP) CreateInputRequest {
	typ := CreateInputRequestTypeTCP

	return CreateInputRequest{
		InputTCP: &tcp,
		Type:     typ,
	}
}

func CreateCreateInputRequestAppscope(appscope InputAppscope) CreateInputRequest {
	typ := CreateInputRequestTypeAppscope

	return CreateInputRequest{
		InputAppscope: &appscope,
		Type:          typ,
	}
}

func CreateCreateInputRequestWef(wef InputWef) CreateInputRequest {
	typ := CreateInputRequestTypeWef

	return CreateInputRequest{
		InputWef: &wef,
		Type:     typ,
	}
}

func CreateCreateInputRequestWinEventLogs(winEventLogs InputWinEventLogs) CreateInputRequest {
	typ := CreateInputRequestTypeWinEventLogs

	return CreateInputRequest{
		InputWinEventLogs: &winEventLogs,
		Type:              typ,
	}
}

func CreateCreateInputRequestRawUDP(rawUDP InputRawUDP) CreateInputRequest {
	typ := CreateInputRequestTypeRawUDP

	return CreateInputRequest{
		InputRawUDP: &rawUDP,
		Type:        typ,
	}
}

func CreateCreateInputRequestJournalFiles(journalFiles InputJournalFiles) CreateInputRequest {
	typ := CreateInputRequestTypeJournalFiles

	return CreateInputRequest{
		InputJournalFiles: &journalFiles,
		Type:              typ,
	}
}

func CreateCreateInputRequestWiz(wiz InputWiz) CreateInputRequest {
	typ := CreateInputRequestTypeWiz

	return CreateInputRequest{
		InputWiz: &wiz,
		Type:     typ,
	}
}

func CreateCreateInputRequestWizWebhook(wizWebhook InputWizWebhook) CreateInputRequest {
	typ := CreateInputRequestTypeWizWebhook

	return CreateInputRequest{
		InputWizWebhook: &wizWebhook,
		Type:            typ,
	}
}

func CreateCreateInputRequestNetflow(netflow InputNetflow) CreateInputRequest {
	typ := CreateInputRequestTypeNetflow

	return CreateInputRequest{
		InputNetflow: &netflow,
		Type:         typ,
	}
}

func CreateCreateInputRequestSecurityLake(securityLake InputSecurityLake) CreateInputRequest {
	typ := CreateInputRequestTypeSecurityLake

	return CreateInputRequest{
		InputSecurityLake: &securityLake,
		Type:              typ,
	}
}

func CreateCreateInputRequestZscalerHec(zscalerHec InputZscalerHec) CreateInputRequest {
	typ := CreateInputRequestTypeZscalerHec

	return CreateInputRequest{
		InputZscalerHec: &zscalerHec,
		Type:            typ,
	}
}

func CreateCreateInputRequestCloudflareHec(cloudflareHec InputCloudflareHec) CreateInputRequest {
	typ := CreateInputRequestTypeCloudflareHec

	return CreateInputRequest{
		InputCloudflareHec: &cloudflareHec,
		Type:               typ,
	}
}

func (u *CreateInputRequest) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "collection":
		inputCollection := new(InputCollection)
		if err := utils.UnmarshalJSON(data, &inputCollection, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == collection) type InputCollection within CreateInputRequest: %w", string(data), err)
		}

		u.InputCollection = inputCollection
		u.Type = CreateInputRequestTypeCollection
		return nil
	case "kafka":
		inputKafka := new(InputKafka)
		if err := utils.UnmarshalJSON(data, &inputKafka, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kafka) type InputKafka within CreateInputRequest: %w", string(data), err)
		}

		u.InputKafka = inputKafka
		u.Type = CreateInputRequestTypeKafka
		return nil
	case "msk":
		inputMsk := new(InputMsk)
		if err := utils.UnmarshalJSON(data, &inputMsk, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == msk) type InputMsk within CreateInputRequest: %w", string(data), err)
		}

		u.InputMsk = inputMsk
		u.Type = CreateInputRequestTypeMsk
		return nil
	case "http":
		inputHTTP := new(InputHTTP)
		if err := utils.UnmarshalJSON(data, &inputHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http) type InputHTTP within CreateInputRequest: %w", string(data), err)
		}

		u.InputHTTP = inputHTTP
		u.Type = CreateInputRequestTypeHTTP
		return nil
	case "splunk":
		inputSplunk := new(InputSplunk)
		if err := utils.UnmarshalJSON(data, &inputSplunk, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk) type InputSplunk within CreateInputRequest: %w", string(data), err)
		}

		u.InputSplunk = inputSplunk
		u.Type = CreateInputRequestTypeSplunk
		return nil
	case "splunk_search":
		inputSplunkSearch := new(InputSplunkSearch)
		if err := utils.UnmarshalJSON(data, &inputSplunkSearch, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk_search) type InputSplunkSearch within CreateInputRequest: %w", string(data), err)
		}

		u.InputSplunkSearch = inputSplunkSearch
		u.Type = CreateInputRequestTypeSplunkSearch
		return nil
	case "splunk_hec":
		inputSplunkHec := new(InputSplunkHec)
		if err := utils.UnmarshalJSON(data, &inputSplunkHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk_hec) type InputSplunkHec within CreateInputRequest: %w", string(data), err)
		}

		u.InputSplunkHec = inputSplunkHec
		u.Type = CreateInputRequestTypeSplunkHec
		return nil
	case "azure_blob":
		inputAzureBlob := new(InputAzureBlob)
		if err := utils.UnmarshalJSON(data, &inputAzureBlob, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == azure_blob) type InputAzureBlob within CreateInputRequest: %w", string(data), err)
		}

		u.InputAzureBlob = inputAzureBlob
		u.Type = CreateInputRequestTypeAzureBlob
		return nil
	case "elastic":
		inputElastic := new(InputElastic)
		if err := utils.UnmarshalJSON(data, &inputElastic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == elastic) type InputElastic within CreateInputRequest: %w", string(data), err)
		}

		u.InputElastic = inputElastic
		u.Type = CreateInputRequestTypeElastic
		return nil
	case "confluent_cloud":
		inputConfluentCloud := new(InputConfluentCloud)
		if err := utils.UnmarshalJSON(data, &inputConfluentCloud, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == confluent_cloud) type InputConfluentCloud within CreateInputRequest: %w", string(data), err)
		}

		u.InputConfluentCloud = inputConfluentCloud
		u.Type = CreateInputRequestTypeConfluentCloud
		return nil
	case "grafana":
		inputGrafana := new(InputGrafana)
		if err := utils.UnmarshalJSON(data, &inputGrafana, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == grafana) type InputGrafana within CreateInputRequest: %w", string(data), err)
		}

		u.InputGrafana = inputGrafana
		u.Type = CreateInputRequestTypeGrafana
		return nil
	case "loki":
		inputLoki := new(InputLoki)
		if err := utils.UnmarshalJSON(data, &inputLoki, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == loki) type InputLoki within CreateInputRequest: %w", string(data), err)
		}

		u.InputLoki = inputLoki
		u.Type = CreateInputRequestTypeLoki
		return nil
	case "prometheus_rw":
		inputPrometheusRw := new(InputPrometheusRw)
		if err := utils.UnmarshalJSON(data, &inputPrometheusRw, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == prometheus_rw) type InputPrometheusRw within CreateInputRequest: %w", string(data), err)
		}

		u.InputPrometheusRw = inputPrometheusRw
		u.Type = CreateInputRequestTypePrometheusRw
		return nil
	case "prometheus":
		inputPrometheus := new(InputPrometheus)
		if err := utils.UnmarshalJSON(data, &inputPrometheus, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == prometheus) type InputPrometheus within CreateInputRequest: %w", string(data), err)
		}

		u.InputPrometheus = inputPrometheus
		u.Type = CreateInputRequestTypePrometheus
		return nil
	case "edge_prometheus":
		inputEdgePrometheus := new(InputEdgePrometheus)
		if err := utils.UnmarshalJSON(data, &inputEdgePrometheus, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == edge_prometheus) type InputEdgePrometheus within CreateInputRequest: %w", string(data), err)
		}

		u.InputEdgePrometheus = inputEdgePrometheus
		u.Type = CreateInputRequestTypeEdgePrometheus
		return nil
	case "office365_mgmt":
		inputOffice365Mgmt := new(InputOffice365Mgmt)
		if err := utils.UnmarshalJSON(data, &inputOffice365Mgmt, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_mgmt) type InputOffice365Mgmt within CreateInputRequest: %w", string(data), err)
		}

		u.InputOffice365Mgmt = inputOffice365Mgmt
		u.Type = CreateInputRequestTypeOffice365Mgmt
		return nil
	case "office365_service":
		inputOffice365Service := new(InputOffice365Service)
		if err := utils.UnmarshalJSON(data, &inputOffice365Service, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_service) type InputOffice365Service within CreateInputRequest: %w", string(data), err)
		}

		u.InputOffice365Service = inputOffice365Service
		u.Type = CreateInputRequestTypeOffice365Service
		return nil
	case "office365_msg_trace":
		inputOffice365MsgTrace := new(InputOffice365MsgTrace)
		if err := utils.UnmarshalJSON(data, &inputOffice365MsgTrace, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_msg_trace) type InputOffice365MsgTrace within CreateInputRequest: %w", string(data), err)
		}

		u.InputOffice365MsgTrace = inputOffice365MsgTrace
		u.Type = CreateInputRequestTypeOffice365MsgTrace
		return nil
	case "eventhub":
		inputEventhub := new(InputEventhub)
		if err := utils.UnmarshalJSON(data, &inputEventhub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == eventhub) type InputEventhub within CreateInputRequest: %w", string(data), err)
		}

		u.InputEventhub = inputEventhub
		u.Type = CreateInputRequestTypeEventhub
		return nil
	case "exec":
		inputExec := new(InputExec)
		if err := utils.UnmarshalJSON(data, &inputExec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == exec) type InputExec within CreateInputRequest: %w", string(data), err)
		}

		u.InputExec = inputExec
		u.Type = CreateInputRequestTypeExec
		return nil
	case "firehose":
		inputFirehose := new(InputFirehose)
		if err := utils.UnmarshalJSON(data, &inputFirehose, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == firehose) type InputFirehose within CreateInputRequest: %w", string(data), err)
		}

		u.InputFirehose = inputFirehose
		u.Type = CreateInputRequestTypeFirehose
		return nil
	case "google_pubsub":
		inputGooglePubsub := new(InputGooglePubsub)
		if err := utils.UnmarshalJSON(data, &inputGooglePubsub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == google_pubsub) type InputGooglePubsub within CreateInputRequest: %w", string(data), err)
		}

		u.InputGooglePubsub = inputGooglePubsub
		u.Type = CreateInputRequestTypeGooglePubsub
		return nil
	case "cribl":
		inputCribl := new(InputCribl)
		if err := utils.UnmarshalJSON(data, &inputCribl, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl) type InputCribl within CreateInputRequest: %w", string(data), err)
		}

		u.InputCribl = inputCribl
		u.Type = CreateInputRequestTypeCribl
		return nil
	case "cribl_tcp":
		inputCriblTCP := new(InputCriblTCP)
		if err := utils.UnmarshalJSON(data, &inputCriblTCP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_tcp) type InputCriblTCP within CreateInputRequest: %w", string(data), err)
		}

		u.InputCriblTCP = inputCriblTCP
		u.Type = CreateInputRequestTypeCriblTCP
		return nil
	case "cribl_http":
		inputCriblHTTP := new(InputCriblHTTP)
		if err := utils.UnmarshalJSON(data, &inputCriblHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_http) type InputCriblHTTP within CreateInputRequest: %w", string(data), err)
		}

		u.InputCriblHTTP = inputCriblHTTP
		u.Type = CreateInputRequestTypeCriblHTTP
		return nil
	case "cribl_lake_http":
		inputCriblLakeHTTP := new(InputCriblLakeHTTP)
		if err := utils.UnmarshalJSON(data, &inputCriblLakeHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_lake_http) type InputCriblLakeHTTP within CreateInputRequest: %w", string(data), err)
		}

		u.InputCriblLakeHTTP = inputCriblLakeHTTP
		u.Type = CreateInputRequestTypeCriblLakeHTTP
		return nil
	case "tcpjson":
		inputTcpjson := new(InputTcpjson)
		if err := utils.UnmarshalJSON(data, &inputTcpjson, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == tcpjson) type InputTcpjson within CreateInputRequest: %w", string(data), err)
		}

		u.InputTcpjson = inputTcpjson
		u.Type = CreateInputRequestTypeTcpjson
		return nil
	case "system_metrics":
		inputSystemMetrics := new(InputSystemMetrics)
		if err := utils.UnmarshalJSON(data, &inputSystemMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == system_metrics) type InputSystemMetrics within CreateInputRequest: %w", string(data), err)
		}

		u.InputSystemMetrics = inputSystemMetrics
		u.Type = CreateInputRequestTypeSystemMetrics
		return nil
	case "system_state":
		inputSystemState := new(InputSystemState)
		if err := utils.UnmarshalJSON(data, &inputSystemState, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == system_state) type InputSystemState within CreateInputRequest: %w", string(data), err)
		}

		u.InputSystemState = inputSystemState
		u.Type = CreateInputRequestTypeSystemState
		return nil
	case "kube_metrics":
		inputKubeMetrics := new(InputKubeMetrics)
		if err := utils.UnmarshalJSON(data, &inputKubeMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_metrics) type InputKubeMetrics within CreateInputRequest: %w", string(data), err)
		}

		u.InputKubeMetrics = inputKubeMetrics
		u.Type = CreateInputRequestTypeKubeMetrics
		return nil
	case "kube_logs":
		inputKubeLogs := new(InputKubeLogs)
		if err := utils.UnmarshalJSON(data, &inputKubeLogs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_logs) type InputKubeLogs within CreateInputRequest: %w", string(data), err)
		}

		u.InputKubeLogs = inputKubeLogs
		u.Type = CreateInputRequestTypeKubeLogs
		return nil
	case "kube_events":
		inputKubeEvents := new(InputKubeEvents)
		if err := utils.UnmarshalJSON(data, &inputKubeEvents, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_events) type InputKubeEvents within CreateInputRequest: %w", string(data), err)
		}

		u.InputKubeEvents = inputKubeEvents
		u.Type = CreateInputRequestTypeKubeEvents
		return nil
	case "windows_metrics":
		inputWindowsMetrics := new(InputWindowsMetrics)
		if err := utils.UnmarshalJSON(data, &inputWindowsMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == windows_metrics) type InputWindowsMetrics within CreateInputRequest: %w", string(data), err)
		}

		u.InputWindowsMetrics = inputWindowsMetrics
		u.Type = CreateInputRequestTypeWindowsMetrics
		return nil
	case "crowdstrike":
		inputCrowdstrike := new(InputCrowdstrike)
		if err := utils.UnmarshalJSON(data, &inputCrowdstrike, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == crowdstrike) type InputCrowdstrike within CreateInputRequest: %w", string(data), err)
		}

		u.InputCrowdstrike = inputCrowdstrike
		u.Type = CreateInputRequestTypeCrowdstrike
		return nil
	case "datadog_agent":
		inputDatadogAgent := new(InputDatadogAgent)
		if err := utils.UnmarshalJSON(data, &inputDatadogAgent, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == datadog_agent) type InputDatadogAgent within CreateInputRequest: %w", string(data), err)
		}

		u.InputDatadogAgent = inputDatadogAgent
		u.Type = CreateInputRequestTypeDatadogAgent
		return nil
	case "datagen":
		inputDatagen := new(InputDatagen)
		if err := utils.UnmarshalJSON(data, &inputDatagen, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == datagen) type InputDatagen within CreateInputRequest: %w", string(data), err)
		}

		u.InputDatagen = inputDatagen
		u.Type = CreateInputRequestTypeDatagen
		return nil
	case "http_raw":
		inputHTTPRaw := new(InputHTTPRaw)
		if err := utils.UnmarshalJSON(data, &inputHTTPRaw, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http_raw) type InputHTTPRaw within CreateInputRequest: %w", string(data), err)
		}

		u.InputHTTPRaw = inputHTTPRaw
		u.Type = CreateInputRequestTypeHTTPRaw
		return nil
	case "kinesis":
		inputKinesis := new(InputKinesis)
		if err := utils.UnmarshalJSON(data, &inputKinesis, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kinesis) type InputKinesis within CreateInputRequest: %w", string(data), err)
		}

		u.InputKinesis = inputKinesis
		u.Type = CreateInputRequestTypeKinesis
		return nil
	case "criblmetrics":
		inputCriblmetrics := new(InputCriblmetrics)
		if err := utils.UnmarshalJSON(data, &inputCriblmetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == criblmetrics) type InputCriblmetrics within CreateInputRequest: %w", string(data), err)
		}

		u.InputCriblmetrics = inputCriblmetrics
		u.Type = CreateInputRequestTypeCriblmetrics
		return nil
	case "metrics":
		inputMetrics := new(InputMetrics)
		if err := utils.UnmarshalJSON(data, &inputMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == metrics) type InputMetrics within CreateInputRequest: %w", string(data), err)
		}

		u.InputMetrics = inputMetrics
		u.Type = CreateInputRequestTypeMetrics
		return nil
	case "s3":
		inputS3 := new(InputS3)
		if err := utils.UnmarshalJSON(data, &inputS3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == s3) type InputS3 within CreateInputRequest: %w", string(data), err)
		}

		u.InputS3 = inputS3
		u.Type = CreateInputRequestTypeS3
		return nil
	case "s3_inventory":
		inputS3Inventory := new(InputS3Inventory)
		if err := utils.UnmarshalJSON(data, &inputS3Inventory, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == s3_inventory) type InputS3Inventory within CreateInputRequest: %w", string(data), err)
		}

		u.InputS3Inventory = inputS3Inventory
		u.Type = CreateInputRequestTypeS3Inventory
		return nil
	case "snmp":
		inputSnmp := new(InputSnmp)
		if err := utils.UnmarshalJSON(data, &inputSnmp, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == snmp) type InputSnmp within CreateInputRequest: %w", string(data), err)
		}

		u.InputSnmp = inputSnmp
		u.Type = CreateInputRequestTypeSnmp
		return nil
	case "open_telemetry":
		inputOpenTelemetry := new(InputOpenTelemetry)
		if err := utils.UnmarshalJSON(data, &inputOpenTelemetry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == open_telemetry) type InputOpenTelemetry within CreateInputRequest: %w", string(data), err)
		}

		u.InputOpenTelemetry = inputOpenTelemetry
		u.Type = CreateInputRequestTypeOpenTelemetry
		return nil
	case "model_driven_telemetry":
		inputModelDrivenTelemetry := new(InputModelDrivenTelemetry)
		if err := utils.UnmarshalJSON(data, &inputModelDrivenTelemetry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == model_driven_telemetry) type InputModelDrivenTelemetry within CreateInputRequest: %w", string(data), err)
		}

		u.InputModelDrivenTelemetry = inputModelDrivenTelemetry
		u.Type = CreateInputRequestTypeModelDrivenTelemetry
		return nil
	case "sqs":
		inputSqs := new(InputSqs)
		if err := utils.UnmarshalJSON(data, &inputSqs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == sqs) type InputSqs within CreateInputRequest: %w", string(data), err)
		}

		u.InputSqs = inputSqs
		u.Type = CreateInputRequestTypeSqs
		return nil
	case "syslog":
		inputSyslog := new(InputSyslog)
		if err := utils.UnmarshalJSON(data, &inputSyslog, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == syslog) type InputSyslog within CreateInputRequest: %w", string(data), err)
		}

		u.InputSyslog = inputSyslog
		u.Type = CreateInputRequestTypeSyslog
		return nil
	case "file":
		inputFile := new(InputFile)
		if err := utils.UnmarshalJSON(data, &inputFile, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == file) type InputFile within CreateInputRequest: %w", string(data), err)
		}

		u.InputFile = inputFile
		u.Type = CreateInputRequestTypeFile
		return nil
	case "tcp":
		inputTCP := new(InputTCP)
		if err := utils.UnmarshalJSON(data, &inputTCP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == tcp) type InputTCP within CreateInputRequest: %w", string(data), err)
		}

		u.InputTCP = inputTCP
		u.Type = CreateInputRequestTypeTCP
		return nil
	case "appscope":
		inputAppscope := new(InputAppscope)
		if err := utils.UnmarshalJSON(data, &inputAppscope, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == appscope) type InputAppscope within CreateInputRequest: %w", string(data), err)
		}

		u.InputAppscope = inputAppscope
		u.Type = CreateInputRequestTypeAppscope
		return nil
	case "wef":
		inputWef := new(InputWef)
		if err := utils.UnmarshalJSON(data, &inputWef, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wef) type InputWef within CreateInputRequest: %w", string(data), err)
		}

		u.InputWef = inputWef
		u.Type = CreateInputRequestTypeWef
		return nil
	case "win_event_logs":
		inputWinEventLogs := new(InputWinEventLogs)
		if err := utils.UnmarshalJSON(data, &inputWinEventLogs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == win_event_logs) type InputWinEventLogs within CreateInputRequest: %w", string(data), err)
		}

		u.InputWinEventLogs = inputWinEventLogs
		u.Type = CreateInputRequestTypeWinEventLogs
		return nil
	case "raw_udp":
		inputRawUDP := new(InputRawUDP)
		if err := utils.UnmarshalJSON(data, &inputRawUDP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == raw_udp) type InputRawUDP within CreateInputRequest: %w", string(data), err)
		}

		u.InputRawUDP = inputRawUDP
		u.Type = CreateInputRequestTypeRawUDP
		return nil
	case "journal_files":
		inputJournalFiles := new(InputJournalFiles)
		if err := utils.UnmarshalJSON(data, &inputJournalFiles, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == journal_files) type InputJournalFiles within CreateInputRequest: %w", string(data), err)
		}

		u.InputJournalFiles = inputJournalFiles
		u.Type = CreateInputRequestTypeJournalFiles
		return nil
	case "wiz":
		inputWiz := new(InputWiz)
		if err := utils.UnmarshalJSON(data, &inputWiz, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wiz) type InputWiz within CreateInputRequest: %w", string(data), err)
		}

		u.InputWiz = inputWiz
		u.Type = CreateInputRequestTypeWiz
		return nil
	case "wiz_webhook":
		inputWizWebhook := new(InputWizWebhook)
		if err := utils.UnmarshalJSON(data, &inputWizWebhook, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wiz_webhook) type InputWizWebhook within CreateInputRequest: %w", string(data), err)
		}

		u.InputWizWebhook = inputWizWebhook
		u.Type = CreateInputRequestTypeWizWebhook
		return nil
	case "netflow":
		inputNetflow := new(InputNetflow)
		if err := utils.UnmarshalJSON(data, &inputNetflow, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == netflow) type InputNetflow within CreateInputRequest: %w", string(data), err)
		}

		u.InputNetflow = inputNetflow
		u.Type = CreateInputRequestTypeNetflow
		return nil
	case "security_lake":
		inputSecurityLake := new(InputSecurityLake)
		if err := utils.UnmarshalJSON(data, &inputSecurityLake, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == security_lake) type InputSecurityLake within CreateInputRequest: %w", string(data), err)
		}

		u.InputSecurityLake = inputSecurityLake
		u.Type = CreateInputRequestTypeSecurityLake
		return nil
	case "zscaler_hec":
		inputZscalerHec := new(InputZscalerHec)
		if err := utils.UnmarshalJSON(data, &inputZscalerHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == zscaler_hec) type InputZscalerHec within CreateInputRequest: %w", string(data), err)
		}

		u.InputZscalerHec = inputZscalerHec
		u.Type = CreateInputRequestTypeZscalerHec
		return nil
	case "cloudflare_hec":
		inputCloudflareHec := new(InputCloudflareHec)
		if err := utils.UnmarshalJSON(data, &inputCloudflareHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cloudflare_hec) type InputCloudflareHec within CreateInputRequest: %w", string(data), err)
		}

		u.InputCloudflareHec = inputCloudflareHec
		u.Type = CreateInputRequestTypeCloudflareHec
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateInputRequest", string(data))
}

func (u CreateInputRequest) MarshalJSON() ([]byte, error) {
	if u.InputCollection != nil {
		return utils.MarshalJSON(u.InputCollection, "", true)
	}

	if u.InputKafka != nil {
		return utils.MarshalJSON(u.InputKafka, "", true)
	}

	if u.InputMsk != nil {
		return utils.MarshalJSON(u.InputMsk, "", true)
	}

	if u.InputHTTP != nil {
		return utils.MarshalJSON(u.InputHTTP, "", true)
	}

	if u.InputSplunk != nil {
		return utils.MarshalJSON(u.InputSplunk, "", true)
	}

	if u.InputSplunkSearch != nil {
		return utils.MarshalJSON(u.InputSplunkSearch, "", true)
	}

	if u.InputSplunkHec != nil {
		return utils.MarshalJSON(u.InputSplunkHec, "", true)
	}

	if u.InputAzureBlob != nil {
		return utils.MarshalJSON(u.InputAzureBlob, "", true)
	}

	if u.InputElastic != nil {
		return utils.MarshalJSON(u.InputElastic, "", true)
	}

	if u.InputConfluentCloud != nil {
		return utils.MarshalJSON(u.InputConfluentCloud, "", true)
	}

	if u.InputGrafana != nil {
		return utils.MarshalJSON(u.InputGrafana, "", true)
	}

	if u.InputLoki != nil {
		return utils.MarshalJSON(u.InputLoki, "", true)
	}

	if u.InputPrometheusRw != nil {
		return utils.MarshalJSON(u.InputPrometheusRw, "", true)
	}

	if u.InputPrometheus != nil {
		return utils.MarshalJSON(u.InputPrometheus, "", true)
	}

	if u.InputEdgePrometheus != nil {
		return utils.MarshalJSON(u.InputEdgePrometheus, "", true)
	}

	if u.InputOffice365Mgmt != nil {
		return utils.MarshalJSON(u.InputOffice365Mgmt, "", true)
	}

	if u.InputOffice365Service != nil {
		return utils.MarshalJSON(u.InputOffice365Service, "", true)
	}

	if u.InputOffice365MsgTrace != nil {
		return utils.MarshalJSON(u.InputOffice365MsgTrace, "", true)
	}

	if u.InputEventhub != nil {
		return utils.MarshalJSON(u.InputEventhub, "", true)
	}

	if u.InputExec != nil {
		return utils.MarshalJSON(u.InputExec, "", true)
	}

	if u.InputFirehose != nil {
		return utils.MarshalJSON(u.InputFirehose, "", true)
	}

	if u.InputGooglePubsub != nil {
		return utils.MarshalJSON(u.InputGooglePubsub, "", true)
	}

	if u.InputCribl != nil {
		return utils.MarshalJSON(u.InputCribl, "", true)
	}

	if u.InputCriblTCP != nil {
		return utils.MarshalJSON(u.InputCriblTCP, "", true)
	}

	if u.InputCriblHTTP != nil {
		return utils.MarshalJSON(u.InputCriblHTTP, "", true)
	}

	if u.InputCriblLakeHTTP != nil {
		return utils.MarshalJSON(u.InputCriblLakeHTTP, "", true)
	}

	if u.InputTcpjson != nil {
		return utils.MarshalJSON(u.InputTcpjson, "", true)
	}

	if u.InputSystemMetrics != nil {
		return utils.MarshalJSON(u.InputSystemMetrics, "", true)
	}

	if u.InputSystemState != nil {
		return utils.MarshalJSON(u.InputSystemState, "", true)
	}

	if u.InputKubeMetrics != nil {
		return utils.MarshalJSON(u.InputKubeMetrics, "", true)
	}

	if u.InputKubeLogs != nil {
		return utils.MarshalJSON(u.InputKubeLogs, "", true)
	}

	if u.InputKubeEvents != nil {
		return utils.MarshalJSON(u.InputKubeEvents, "", true)
	}

	if u.InputWindowsMetrics != nil {
		return utils.MarshalJSON(u.InputWindowsMetrics, "", true)
	}

	if u.InputCrowdstrike != nil {
		return utils.MarshalJSON(u.InputCrowdstrike, "", true)
	}

	if u.InputDatadogAgent != nil {
		return utils.MarshalJSON(u.InputDatadogAgent, "", true)
	}

	if u.InputDatagen != nil {
		return utils.MarshalJSON(u.InputDatagen, "", true)
	}

	if u.InputHTTPRaw != nil {
		return utils.MarshalJSON(u.InputHTTPRaw, "", true)
	}

	if u.InputKinesis != nil {
		return utils.MarshalJSON(u.InputKinesis, "", true)
	}

	if u.InputCriblmetrics != nil {
		return utils.MarshalJSON(u.InputCriblmetrics, "", true)
	}

	if u.InputMetrics != nil {
		return utils.MarshalJSON(u.InputMetrics, "", true)
	}

	if u.InputS3 != nil {
		return utils.MarshalJSON(u.InputS3, "", true)
	}

	if u.InputS3Inventory != nil {
		return utils.MarshalJSON(u.InputS3Inventory, "", true)
	}

	if u.InputSnmp != nil {
		return utils.MarshalJSON(u.InputSnmp, "", true)
	}

	if u.InputOpenTelemetry != nil {
		return utils.MarshalJSON(u.InputOpenTelemetry, "", true)
	}

	if u.InputModelDrivenTelemetry != nil {
		return utils.MarshalJSON(u.InputModelDrivenTelemetry, "", true)
	}

	if u.InputSqs != nil {
		return utils.MarshalJSON(u.InputSqs, "", true)
	}

	if u.InputSyslog != nil {
		return utils.MarshalJSON(u.InputSyslog, "", true)
	}

	if u.InputFile != nil {
		return utils.MarshalJSON(u.InputFile, "", true)
	}

	if u.InputTCP != nil {
		return utils.MarshalJSON(u.InputTCP, "", true)
	}

	if u.InputAppscope != nil {
		return utils.MarshalJSON(u.InputAppscope, "", true)
	}

	if u.InputWef != nil {
		return utils.MarshalJSON(u.InputWef, "", true)
	}

	if u.InputWinEventLogs != nil {
		return utils.MarshalJSON(u.InputWinEventLogs, "", true)
	}

	if u.InputRawUDP != nil {
		return utils.MarshalJSON(u.InputRawUDP, "", true)
	}

	if u.InputJournalFiles != nil {
		return utils.MarshalJSON(u.InputJournalFiles, "", true)
	}

	if u.InputWiz != nil {
		return utils.MarshalJSON(u.InputWiz, "", true)
	}

	if u.InputWizWebhook != nil {
		return utils.MarshalJSON(u.InputWizWebhook, "", true)
	}

	if u.InputNetflow != nil {
		return utils.MarshalJSON(u.InputNetflow, "", true)
	}

	if u.InputSecurityLake != nil {
		return utils.MarshalJSON(u.InputSecurityLake, "", true)
	}

	if u.InputZscalerHec != nil {
		return utils.MarshalJSON(u.InputZscalerHec, "", true)
	}

	if u.InputCloudflareHec != nil {
		return utils.MarshalJSON(u.InputCloudflareHec, "", true)
	}

	return nil, errors.New("could not marshal union type CreateInputRequest: all fields are null")
}

type CreateInputResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// a list of Source objects
	CountedInput *components.CountedInput
}

func (c *CreateInputResponse) GetHTTPMeta() components.HTTPMetadata {
	if c == nil {
		return components.HTTPMetadata{}
	}
	return c.HTTPMeta
}

func (c *CreateInputResponse) GetCountedInput() *components.CountedInput {
	if c == nil {
		return nil
	}
	return c.CountedInput
}
