// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type InputPrometheusPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool   `default:"false" json:"pqEnabled"`
	Pq        *PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       *string             `json:"id,omitempty"`
	Type     InputPrometheusType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval *float64 `default:"15" json:"interval"`
	// Collector runtime log level
	LogLevel *InputPrometheusLogLevel `default:"info" json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `default:"0" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *AuthenticationMethodOptionsSasl `default:"manual" json:"authType"`
	Description *string                          `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *MetricsProtocol `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                     `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                 `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputPrometheusPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetType() InputPrometheusType {
	if i == nil {
		return InputPrometheusType("")
	}
	return i.Type
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDiscoveryType() *InputPrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetLogLevel() *InputPrometheusLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAuthType() *AuthenticationMethodOptionsSasl {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetTargetList() []string {
	if i == nil {
		return nil
	}
	return i.TargetList
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetRecordType() *RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetScrapeProtocol() *MetricsProtocol {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetSearchFilter() []ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetSignatureVersion() *SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputPrometheusPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool   `default:"false" json:"pqEnabled"`
	Pq        *PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       *string             `json:"id,omitempty"`
	Type     InputPrometheusType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval *float64 `default:"15" json:"interval"`
	// Collector runtime log level
	LogLevel *InputPrometheusLogLevel `default:"info" json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `default:"0" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *AuthenticationMethodOptionsSasl `default:"manual" json:"authType"`
	Description *string                          `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *MetricsProtocol `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                     `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                 `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputPrometheusPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetType() InputPrometheusType {
	if i == nil {
		return InputPrometheusType("")
	}
	return i.Type
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDiscoveryType() *InputPrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetLogLevel() *InputPrometheusLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAuthType() *AuthenticationMethodOptionsSasl {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetTargetList() []string {
	if i == nil {
		return nil
	}
	return i.TargetList
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetRecordType() *RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetScrapeProtocol() *MetricsProtocol {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetSearchFilter() []ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetSignatureVersion() *SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputPrometheusSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       *string             `json:"id,omitempty"`
	Type     InputPrometheusType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	Pq         *PqType  `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval *float64 `default:"15" json:"interval"`
	// Collector runtime log level
	LogLevel *InputPrometheusLogLevel `default:"info" json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `default:"0" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *AuthenticationMethodOptionsSasl `default:"manual" json:"authType"`
	Description *string                          `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *MetricsProtocol `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                     `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                 `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputPrometheusSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetType() InputPrometheusType {
	if i == nil {
		return InputPrometheusType("")
	}
	return i.Type
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDiscoveryType() *InputPrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetLogLevel() *InputPrometheusLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *AuthenticationMethodOptionsSasl {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetTargetList() []string {
	if i == nil {
		return nil
	}
	return i.TargetList
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetRecordType() *RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapeProtocol() *MetricsProtocol {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetSearchFilter() []ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputPrometheusType string

const (
	InputPrometheusTypePrometheus InputPrometheusType = "prometheus"
)

func (e InputPrometheusType) ToPointer() *InputPrometheusType {
	return &e
}
func (e *InputPrometheusType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prometheus":
		*e = InputPrometheusType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputPrometheusType: %v", v)
	}
}

// InputPrometheusDiscoveryType - Target discovery mechanism. Use static to manually enter a list of targets.
type InputPrometheusDiscoveryType string

const (
	// InputPrometheusDiscoveryTypeStatic Static
	InputPrometheusDiscoveryTypeStatic InputPrometheusDiscoveryType = "static"
	// InputPrometheusDiscoveryTypeDNS DNS
	InputPrometheusDiscoveryTypeDNS InputPrometheusDiscoveryType = "dns"
	// InputPrometheusDiscoveryTypeEc2 AWS EC2
	InputPrometheusDiscoveryTypeEc2 InputPrometheusDiscoveryType = "ec2"
)

func (e InputPrometheusDiscoveryType) ToPointer() *InputPrometheusDiscoveryType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputPrometheusDiscoveryType) IsExact() bool {
	if e != nil {
		switch *e {
		case "static", "dns", "ec2":
			return true
		}
	}
	return false
}

// InputPrometheusLogLevel - Collector runtime log level
type InputPrometheusLogLevel string

const (
	InputPrometheusLogLevelError InputPrometheusLogLevel = "error"
	InputPrometheusLogLevelWarn  InputPrometheusLogLevel = "warn"
	InputPrometheusLogLevelInfo  InputPrometheusLogLevel = "info"
	InputPrometheusLogLevelDebug InputPrometheusLogLevel = "debug"
)

func (e InputPrometheusLogLevel) ToPointer() *InputPrometheusLogLevel {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputPrometheusLogLevel) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug":
			return true
		}
	}
	return false
}

// MetricsProtocol - Protocol to use when collecting metrics
type MetricsProtocol string

const (
	MetricsProtocolHTTP  MetricsProtocol = "http"
	MetricsProtocolHTTPS MetricsProtocol = "https"
)

func (e MetricsProtocol) ToPointer() *MetricsProtocol {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *MetricsProtocol) IsExact() bool {
	if e != nil {
		switch *e {
		case "http", "https":
			return true
		}
	}
	return false
}

type InputPrometheusSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       *string             `json:"id,omitempty"`
	Type     InputPrometheusType `json:"type"`
	Disabled *bool               `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	Pq         *PqType  `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
	Interval *float64 `default:"15" json:"interval"`
	// Collector runtime log level
	LogLevel *InputPrometheusLogLevel `default:"info" json:"logLevel"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
	Timeout *float64 `default:"0" json:"timeout"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `default:"30" json:"keepAliveTime"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `default:"3" json:"maxMissedKeepAlives"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `default:"4h" json:"ttl"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `default:"false" json:"ignoreGroupJobsLimit"`
	// Fields to add to events from this input
	Metadata []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *AuthenticationMethodOptionsSasl `default:"manual" json:"authType"`
	Description *string                          `json:"description,omitempty"`
	// List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList []string `json:"targetList,omitempty"`
	// DNS record type to resolve
	RecordType *RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *MetricsProtocol `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                     `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                 `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputPrometheusSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetType() InputPrometheusType {
	if i == nil {
		return InputPrometheusType("")
	}
	return i.Type
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDiscoveryType() *InputPrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetLogLevel() *InputPrometheusLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *AuthenticationMethodOptionsSasl {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetTargetList() []string {
	if i == nil {
		return nil
	}
	return i.TargetList
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetRecordType() *RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapeProtocol() *MetricsProtocol {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetSearchFilter() []ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputPrometheusSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputPrometheusUnionType string

const (
	InputPrometheusUnionTypeInputPrometheusSendToRoutesTrueWithConnectionsConstraint  InputPrometheusUnionType = "InputPrometheus_SendToRoutesTrueWithConnectionsConstraint"
	InputPrometheusUnionTypeInputPrometheusSendToRoutesFalseWithConnectionsConstraint InputPrometheusUnionType = "InputPrometheus_SendToRoutesFalseWithConnectionsConstraint"
	InputPrometheusUnionTypeInputPrometheusPqEnabledFalseWithPqConstraint             InputPrometheusUnionType = "InputPrometheus_PqEnabledFalseWithPqConstraint"
	InputPrometheusUnionTypeInputPrometheusPqEnabledTrueWithPqConstraint              InputPrometheusUnionType = "InputPrometheus_PqEnabledTrueWithPqConstraint"
)

type InputPrometheus struct {
	InputPrometheusSendToRoutesTrueWithConnectionsConstraint  *InputPrometheusSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputPrometheusSendToRoutesFalseWithConnectionsConstraint *InputPrometheusSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputPrometheusPqEnabledFalseWithPqConstraint             *InputPrometheusPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputPrometheusPqEnabledTrueWithPqConstraint              *InputPrometheusPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputPrometheusUnionType
}

func CreateInputPrometheusInputPrometheusSendToRoutesTrueWithConnectionsConstraint(inputPrometheusSendToRoutesTrueWithConnectionsConstraint InputPrometheusSendToRoutesTrueWithConnectionsConstraint) InputPrometheus {
	typ := InputPrometheusUnionTypeInputPrometheusSendToRoutesTrueWithConnectionsConstraint

	return InputPrometheus{
		InputPrometheusSendToRoutesTrueWithConnectionsConstraint: &inputPrometheusSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusInputPrometheusSendToRoutesFalseWithConnectionsConstraint(inputPrometheusSendToRoutesFalseWithConnectionsConstraint InputPrometheusSendToRoutesFalseWithConnectionsConstraint) InputPrometheus {
	typ := InputPrometheusUnionTypeInputPrometheusSendToRoutesFalseWithConnectionsConstraint

	return InputPrometheus{
		InputPrometheusSendToRoutesFalseWithConnectionsConstraint: &inputPrometheusSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusInputPrometheusPqEnabledFalseWithPqConstraint(inputPrometheusPqEnabledFalseWithPqConstraint InputPrometheusPqEnabledFalseWithPqConstraint) InputPrometheus {
	typ := InputPrometheusUnionTypeInputPrometheusPqEnabledFalseWithPqConstraint

	return InputPrometheus{
		InputPrometheusPqEnabledFalseWithPqConstraint: &inputPrometheusPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputPrometheusInputPrometheusPqEnabledTrueWithPqConstraint(inputPrometheusPqEnabledTrueWithPqConstraint InputPrometheusPqEnabledTrueWithPqConstraint) InputPrometheus {
	typ := InputPrometheusUnionTypeInputPrometheusPqEnabledTrueWithPqConstraint

	return InputPrometheus{
		InputPrometheusPqEnabledTrueWithPqConstraint: &inputPrometheusPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputPrometheus) UnmarshalJSON(data []byte) error {

	var inputPrometheusSendToRoutesTrueWithConnectionsConstraint InputPrometheusSendToRoutesTrueWithConnectionsConstraint = InputPrometheusSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputPrometheusSendToRoutesTrueWithConnectionsConstraint = &inputPrometheusSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputPrometheusUnionTypeInputPrometheusSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputPrometheusSendToRoutesFalseWithConnectionsConstraint InputPrometheusSendToRoutesFalseWithConnectionsConstraint = InputPrometheusSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputPrometheusSendToRoutesFalseWithConnectionsConstraint = &inputPrometheusSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputPrometheusUnionTypeInputPrometheusSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputPrometheusPqEnabledFalseWithPqConstraint InputPrometheusPqEnabledFalseWithPqConstraint = InputPrometheusPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputPrometheusPqEnabledFalseWithPqConstraint = &inputPrometheusPqEnabledFalseWithPqConstraint
		u.Type = InputPrometheusUnionTypeInputPrometheusPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputPrometheusPqEnabledTrueWithPqConstraint InputPrometheusPqEnabledTrueWithPqConstraint = InputPrometheusPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputPrometheusPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputPrometheusPqEnabledTrueWithPqConstraint = &inputPrometheusPqEnabledTrueWithPqConstraint
		u.Type = InputPrometheusUnionTypeInputPrometheusPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputPrometheus", string(data))
}

func (u InputPrometheus) MarshalJSON() ([]byte, error) {
	if u.InputPrometheusSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputPrometheusSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputPrometheusPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputPrometheusPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputPrometheusPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputPrometheus: all fields are null")
}
