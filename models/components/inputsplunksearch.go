// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type InputSplunkSearchType string

const (
	InputSplunkSearchTypeSplunkSearch InputSplunkSearchType = "splunk_search"
)

func (e InputSplunkSearchType) ToPointer() *InputSplunkSearchType {
	return &e
}
func (e *InputSplunkSearchType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_search":
		*e = InputSplunkSearchType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSplunkSearchType: %v", v)
	}
}

type EndpointParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (e EndpointParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EndpointParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EndpointParam) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EndpointParam) GetValue() string {
	if e == nil {
		return ""
	}
	return e.Value
}

type EndpointHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (e EndpointHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EndpointHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EndpointHeader) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EndpointHeader) GetValue() string {
	if e == nil {
		return ""
	}
	return e.Value
}

// InputSplunkSearchLogLevel - Collector runtime log level (verbosity)
type InputSplunkSearchLogLevel string

const (
	InputSplunkSearchLogLevelError InputSplunkSearchLogLevel = "error"
	InputSplunkSearchLogLevelWarn  InputSplunkSearchLogLevel = "warn"
	InputSplunkSearchLogLevelInfo  InputSplunkSearchLogLevel = "info"
	InputSplunkSearchLogLevelDebug InputSplunkSearchLogLevel = "debug"
)

func (e InputSplunkSearchLogLevel) ToPointer() *InputSplunkSearchLogLevel {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSplunkSearchLogLevel) IsExact() bool {
	if e != nil {
		switch *e {
		case "error", "warn", "info", "debug":
			return true
		}
	}
	return false
}

// InputSplunkSearchAuthenticationType - Splunk Search authentication type
type InputSplunkSearchAuthenticationType string

const (
	// InputSplunkSearchAuthenticationTypeNone None
	InputSplunkSearchAuthenticationTypeNone InputSplunkSearchAuthenticationType = "none"
	// InputSplunkSearchAuthenticationTypeBasic Basic
	InputSplunkSearchAuthenticationTypeBasic InputSplunkSearchAuthenticationType = "basic"
	// InputSplunkSearchAuthenticationTypeCredentialsSecret Basic (credentials secret)
	InputSplunkSearchAuthenticationTypeCredentialsSecret InputSplunkSearchAuthenticationType = "credentialsSecret"
	// InputSplunkSearchAuthenticationTypeToken Token
	InputSplunkSearchAuthenticationTypeToken InputSplunkSearchAuthenticationType = "token"
	// InputSplunkSearchAuthenticationTypeTextSecret Token (text secret)
	InputSplunkSearchAuthenticationTypeTextSecret InputSplunkSearchAuthenticationType = "textSecret"
)

func (e InputSplunkSearchAuthenticationType) ToPointer() *InputSplunkSearchAuthenticationType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputSplunkSearchAuthenticationType) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "credentialsSecret", "token", "textSecret":
			return true
		}
	}
	return false
}

type InputSplunkSearch struct {
	// Unique ID for this input
	ID       *string               `json:"id,omitzero"`
	Type     InputSplunkSearchType `json:"type"`
	Disabled *bool                 `json:"disabled,omitzero"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitzero"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitzero"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitzero"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `json:"pqEnabled,omitzero"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitzero"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnectionsOptional `json:"connections,omitzero"`
	Pq          *PqType                        `json:"pq,omitzero"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// A cron schedule on which to run this job
	CronSchedule string `json:"cronSchedule"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional request parameters to send to the endpoint
	EndpointParams []EndpointParam `json:"endpointParams,omitzero"`
	// Optional request headers to send to the endpoint
	EndpointHeaders []EndpointHeader `json:"endpointHeaders,omitzero"`
	// Collector runtime log level (verbosity)
	LogLevel *InputSplunkSearchLogLevel `json:"logLevel,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	RequestTimeout *float64 `json:"requestTimeout,omitzero"`
	// When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitzero"`
	// How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float64 `json:"keepAliveTime,omitzero"`
	// Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitzero"`
	// The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float64 `json:"maxMissedKeepAlives,omitzero"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitzero"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitzero"`
	// Fields to add to events from this input
	Metadata   []ItemsTypeMetadata `json:"metadata,omitzero"`
	RetryRules *RetryRulesType     `json:"retryRules,omitzero"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitzero"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `json:"staleChannelFlushMs,omitzero"`
	// Splunk Search authentication type
	AuthType    *InputSplunkSearchAuthenticationType `json:"authType,omitzero"`
	Description *string                              `json:"description,omitzero"`
	Username    *string                              `json:"username,omitzero"`
	Password    *string                              `json:"password,omitzero"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitzero"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitzero"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitzero"`
}

func (i InputSplunkSearch) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputSplunkSearch) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputSplunkSearch) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputSplunkSearch) GetType() InputSplunkSearchType {
	if i == nil {
		return InputSplunkSearchType("")
	}
	return i.Type
}

func (i *InputSplunkSearch) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputSplunkSearch) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputSplunkSearch) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputSplunkSearch) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputSplunkSearch) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputSplunkSearch) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputSplunkSearch) GetConnections() []ItemsTypeConnectionsOptional {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputSplunkSearch) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputSplunkSearch) GetSearchHead() string {
	if i == nil {
		return ""
	}
	return i.SearchHead
}

func (i *InputSplunkSearch) GetSearch() string {
	if i == nil {
		return ""
	}
	return i.Search
}

func (i *InputSplunkSearch) GetEarliest() *string {
	if i == nil {
		return nil
	}
	return i.Earliest
}

func (i *InputSplunkSearch) GetLatest() *string {
	if i == nil {
		return nil
	}
	return i.Latest
}

func (i *InputSplunkSearch) GetCronSchedule() string {
	if i == nil {
		return ""
	}
	return i.CronSchedule
}

func (i *InputSplunkSearch) GetEndpoint() string {
	if i == nil {
		return ""
	}
	return i.Endpoint
}

func (i *InputSplunkSearch) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if i == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return i.OutputMode
}

func (i *InputSplunkSearch) GetEndpointParams() []EndpointParam {
	if i == nil {
		return nil
	}
	return i.EndpointParams
}

func (i *InputSplunkSearch) GetEndpointHeaders() []EndpointHeader {
	if i == nil {
		return nil
	}
	return i.EndpointHeaders
}

func (i *InputSplunkSearch) GetLogLevel() *InputSplunkSearchLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputSplunkSearch) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputSplunkSearch) GetUseRoundRobinDNS() *bool {
	if i == nil {
		return nil
	}
	return i.UseRoundRobinDNS
}

func (i *InputSplunkSearch) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputSplunkSearch) GetEncoding() *string {
	if i == nil {
		return nil
	}
	return i.Encoding
}

func (i *InputSplunkSearch) GetKeepAliveTime() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTime
}

func (i *InputSplunkSearch) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputSplunkSearch) GetMaxMissedKeepAlives() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxMissedKeepAlives
}

func (i *InputSplunkSearch) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputSplunkSearch) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputSplunkSearch) GetMetadata() []ItemsTypeMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputSplunkSearch) GetRetryRules() *RetryRulesType {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputSplunkSearch) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputSplunkSearch) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputSplunkSearch) GetAuthType() *InputSplunkSearchAuthenticationType {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputSplunkSearch) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputSplunkSearch) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputSplunkSearch) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputSplunkSearch) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputSplunkSearch) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputSplunkSearch) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}
