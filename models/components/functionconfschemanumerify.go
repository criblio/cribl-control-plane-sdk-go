// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type NumerifyFormatNoneFormat string

const (
	// NumerifyFormatNoneFormatNone None
	NumerifyFormatNoneFormatNone NumerifyFormatNoneFormat = "none"
	// NumerifyFormatNoneFormatFix Fix
	NumerifyFormatNoneFormatFix NumerifyFormatNoneFormat = "fix"
	// NumerifyFormatNoneFormatFloor Floor
	NumerifyFormatNoneFormatFloor NumerifyFormatNoneFormat = "floor"
	// NumerifyFormatNoneFormatCeil Ceil
	NumerifyFormatNoneFormatCeil NumerifyFormatNoneFormat = "ceil"
)

func (e NumerifyFormatNoneFormat) ToPointer() *NumerifyFormatNoneFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *NumerifyFormatNoneFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "fix", "floor", "ceil":
			return true
		}
	}
	return false
}

type NumerifyFormatNone struct {
	Format *NumerifyFormatNoneFormat `json:"format,omitzero"`
	// Depth to which the Numerify Function will search within a nested event. Depth greater than 5 (the default) could decrease performance.
	Depth *int64 `json:"depth,omitzero"`
	// Fields to NOT numerify. Takes precedence over 'Include expression' when set. Supports wildcards. A '!' before field name(s) means: numerify all fields EXCEPT these. For syntax details, see [Wildcard Lists](https://docs.cribl.io/stream/introduction-reference/#wildcard-lists).
	IgnoreFields []string `json:"ignoreFields,omitzero"`
	// Optional JavaScript expression to determine whether a field should be numerified. If left blank, all fields will be numerified. Use the 'name' and 'value' global variables to access fields' names/values. Examples: `value != null`, `name=='fieldname'`. You can access other fields' values via `__e.<fieldName>`.
	FilterExpr *string `json:"filterExpr,omitzero"`
}

func (n NumerifyFormatNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumerifyFormatNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumerifyFormatNone) GetFormat() *NumerifyFormatNoneFormat {
	if n == nil {
		return nil
	}
	return n.Format
}

func (n *NumerifyFormatNone) GetDepth() *int64 {
	if n == nil {
		return nil
	}
	return n.Depth
}

func (n *NumerifyFormatNone) GetIgnoreFields() []string {
	if n == nil {
		return nil
	}
	return n.IgnoreFields
}

func (n *NumerifyFormatNone) GetFilterExpr() *string {
	if n == nil {
		return nil
	}
	return n.FilterExpr
}

type NumerifyFormatFixFormat string

const (
	// NumerifyFormatFixFormatNone None
	NumerifyFormatFixFormatNone NumerifyFormatFixFormat = "none"
	// NumerifyFormatFixFormatFix Fix
	NumerifyFormatFixFormatFix NumerifyFormatFixFormat = "fix"
	// NumerifyFormatFixFormatFloor Floor
	NumerifyFormatFixFormatFloor NumerifyFormatFixFormat = "floor"
	// NumerifyFormatFixFormatCeil Ceil
	NumerifyFormatFixFormatCeil NumerifyFormatFixFormat = "ceil"
)

func (e NumerifyFormatFixFormat) ToPointer() *NumerifyFormatFixFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *NumerifyFormatFixFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "fix", "floor", "ceil":
			return true
		}
	}
	return false
}

type NumerifyFormatFix struct {
	Format *NumerifyFormatFixFormat `json:"format,omitzero"`
	// Number of digits after the decimal point, between 0 and 20. If left blank, defaults to 2.
	Digits *float64 `json:"digits,omitzero"`
	// Depth to which the Numerify Function will search within a nested event. Depth greater than 5 (the default) could decrease performance.
	Depth *int64 `json:"depth,omitzero"`
	// Fields to NOT numerify. Takes precedence over 'Include expression' when set. Supports wildcards. A '!' before field name(s) means: numerify all fields EXCEPT these. For syntax details, see [Wildcard Lists](https://docs.cribl.io/stream/introduction-reference/#wildcard-lists).
	IgnoreFields []string `json:"ignoreFields,omitzero"`
	// Optional JavaScript expression to determine whether a field should be numerified. If left blank, all fields will be numerified. Use the 'name' and 'value' global variables to access fields' names/values. Examples: `value != null`, `name=='fieldname'`. You can access other fields' values via `__e.<fieldName>`.
	FilterExpr *string `json:"filterExpr,omitzero"`
}

func (n NumerifyFormatFix) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumerifyFormatFix) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumerifyFormatFix) GetFormat() *NumerifyFormatFixFormat {
	if n == nil {
		return nil
	}
	return n.Format
}

func (n *NumerifyFormatFix) GetDigits() *float64 {
	if n == nil {
		return nil
	}
	return n.Digits
}

func (n *NumerifyFormatFix) GetDepth() *int64 {
	if n == nil {
		return nil
	}
	return n.Depth
}

func (n *NumerifyFormatFix) GetIgnoreFields() []string {
	if n == nil {
		return nil
	}
	return n.IgnoreFields
}

func (n *NumerifyFormatFix) GetFilterExpr() *string {
	if n == nil {
		return nil
	}
	return n.FilterExpr
}

type FunctionConfSchemaNumerifyType string

const (
	FunctionConfSchemaNumerifyTypeFix     FunctionConfSchemaNumerifyType = "fix"
	FunctionConfSchemaNumerifyTypeNone    FunctionConfSchemaNumerifyType = "none"
	FunctionConfSchemaNumerifyTypeUnknown FunctionConfSchemaNumerifyType = "UNKNOWN"
)

type FunctionConfSchemaNumerify struct {
	NumerifyFormatFix  *NumerifyFormatFix  `queryParam:"inline" union:"member"`
	NumerifyFormatNone *NumerifyFormatNone `queryParam:"inline" union:"member"`
	UnknownRaw         json.RawMessage     `json:"-" union:"unknown"`

	Type FunctionConfSchemaNumerifyType
}

func CreateFunctionConfSchemaNumerifyFix(fix NumerifyFormatFix) FunctionConfSchemaNumerify {
	typ := FunctionConfSchemaNumerifyTypeFix

	typStr := NumerifyFormatFixFormat(typ)
	fix.Format = &typStr

	return FunctionConfSchemaNumerify{
		NumerifyFormatFix: &fix,
		Type:              typ,
	}
}

func CreateFunctionConfSchemaNumerifyNone(none NumerifyFormatNone) FunctionConfSchemaNumerify {
	typ := FunctionConfSchemaNumerifyTypeNone

	typStr := NumerifyFormatNoneFormat(typ)
	none.Format = &typStr

	return FunctionConfSchemaNumerify{
		NumerifyFormatNone: &none,
		Type:               typ,
	}
}

func CreateFunctionConfSchemaNumerifyUnknown(raw json.RawMessage) FunctionConfSchemaNumerify {
	return FunctionConfSchemaNumerify{
		UnknownRaw: raw,
		Type:       FunctionConfSchemaNumerifyTypeUnknown,
	}
}

func (u FunctionConfSchemaNumerify) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u FunctionConfSchemaNumerify) IsUnknown() bool {
	return u.Type == FunctionConfSchemaNumerifyTypeUnknown
}

func (u *FunctionConfSchemaNumerify) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Format string `json:"format"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = FunctionConfSchemaNumerifyTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = FunctionConfSchemaNumerifyTypeUnknown
		return nil
	}

	switch dis.Format {
	case "fix":
		numerifyFormatFix := new(NumerifyFormatFix)
		if err := utils.UnmarshalJSON(data, &numerifyFormatFix, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Format == fix) type NumerifyFormatFix within FunctionConfSchemaNumerify: %w", string(data), err)
		}

		u.NumerifyFormatFix = numerifyFormatFix
		u.Type = FunctionConfSchemaNumerifyTypeFix
		return nil
	case "none":
		numerifyFormatNone := new(NumerifyFormatNone)
		if err := utils.UnmarshalJSON(data, &numerifyFormatNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Format == none) type NumerifyFormatNone within FunctionConfSchemaNumerify: %w", string(data), err)
		}

		u.NumerifyFormatNone = numerifyFormatNone
		u.Type = FunctionConfSchemaNumerifyTypeNone
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = FunctionConfSchemaNumerifyTypeUnknown
		return nil
	}

}

func (u FunctionConfSchemaNumerify) MarshalJSON() ([]byte, error) {
	if u.NumerifyFormatFix != nil {
		return utils.MarshalJSON(u.NumerifyFormatFix, "", true)
	}

	if u.NumerifyFormatNone != nil {
		return utils.MarshalJSON(u.NumerifyFormatNone, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type FunctionConfSchemaNumerify: all fields are null")
}
