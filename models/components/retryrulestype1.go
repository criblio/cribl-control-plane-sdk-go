// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type RetryRulesType1 struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitempty"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitempty"`
	// Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
	Multiplier *float64 `json:"multiplier,omitempty"`
	// List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
	Codes []float64 `json:"codes,omitempty"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitempty"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitempty"`
	// Retry request when a connection reset (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitempty"`
}

func (r RetryRulesType1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RetryRulesType1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *RetryRulesType1) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if r == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return r.Type
}

func (r *RetryRulesType1) GetInterval() *float64 {
	if r == nil {
		return nil
	}
	return r.Interval
}

func (r *RetryRulesType1) GetLimit() *float64 {
	if r == nil {
		return nil
	}
	return r.Limit
}

func (r *RetryRulesType1) GetMultiplier() *float64 {
	if r == nil {
		return nil
	}
	return r.Multiplier
}

func (r *RetryRulesType1) GetCodes() []float64 {
	if r == nil {
		return nil
	}
	return r.Codes
}

func (r *RetryRulesType1) GetEnableHeader() *bool {
	if r == nil {
		return nil
	}
	return r.EnableHeader
}

func (r *RetryRulesType1) GetRetryConnectTimeout() *bool {
	if r == nil {
		return nil
	}
	return r.RetryConnectTimeout
}

func (r *RetryRulesType1) GetRetryConnectReset() *bool {
	if r == nil {
		return nil
	}
	return r.RetryConnectReset
}
