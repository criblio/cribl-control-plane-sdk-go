// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type OutputDatabricksType string

const (
	OutputDatabricksTypeDatabricks OutputDatabricksType = "databricks"
)

func (e OutputDatabricksType) ToPointer() *OutputDatabricksType {
	return &e
}
func (e *OutputDatabricksType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "databricks":
		*e = OutputDatabricksType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputDatabricksType: %v", v)
	}
}

// OutputDatabricksDataFormat - Format of the output data
type OutputDatabricksDataFormat string

const (
	OutputDatabricksDataFormatJSON    OutputDatabricksDataFormat = "json"
	OutputDatabricksDataFormatRaw     OutputDatabricksDataFormat = "raw"
	OutputDatabricksDataFormatParquet OutputDatabricksDataFormat = "parquet"
)

func (e OutputDatabricksDataFormat) ToPointer() *OutputDatabricksDataFormat {
	return &e
}

// OutputDatabricksBackpressureBehavior - How to handle events when all receivers are exerting backpressure
type OutputDatabricksBackpressureBehavior string

const (
	OutputDatabricksBackpressureBehaviorBlock OutputDatabricksBackpressureBehavior = "block"
	OutputDatabricksBackpressureBehaviorDrop  OutputDatabricksBackpressureBehavior = "drop"
)

func (e OutputDatabricksBackpressureBehavior) ToPointer() *OutputDatabricksBackpressureBehavior {
	return &e
}

// OutputDatabricksDiskSpaceProtection - How to handle events when disk space is below the global 'Min free disk space' limit
type OutputDatabricksDiskSpaceProtection string

const (
	OutputDatabricksDiskSpaceProtectionBlock OutputDatabricksDiskSpaceProtection = "block"
	OutputDatabricksDiskSpaceProtectionDrop  OutputDatabricksDiskSpaceProtection = "drop"
)

func (e OutputDatabricksDiskSpaceProtection) ToPointer() *OutputDatabricksDiskSpaceProtection {
	return &e
}

// OutputDatabricksAuthenticationMethod - Unity Catalog authentication method. Choose Manual to enter credentials directly, or Secret to use a stored secret.
type OutputDatabricksAuthenticationMethod string

const (
	OutputDatabricksAuthenticationMethodManual OutputDatabricksAuthenticationMethod = "manual"
	OutputDatabricksAuthenticationMethodSecret OutputDatabricksAuthenticationMethod = "secret"
)

func (e OutputDatabricksAuthenticationMethod) ToPointer() *OutputDatabricksAuthenticationMethod {
	return &e
}

type OutputDatabricks struct {
	// Unique ID for this output
	ID   *string              `json:"id,omitempty"`
	Type OutputDatabricksType `json:"type"`
	// Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`
	// Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields []string `json:"systemFields,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Optional path to prepend to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myEventsVolumePath-${C.vars.myVar}`
	DestPath *string `default:"" json:"destPath"`
	// Filesystem location in which to buffer files before compressing and moving to final destination. Use performant, stable storage.
	StagePath *string `default:"$CRIBL_HOME/state/outputs/staging" json:"stagePath"`
	// Add the Output ID value to staging location
	AddIDToStagePath *bool `default:"true" json:"addIdToStagePath"`
	// Remove empty staging directories after moving files
	RemoveEmptyDirs *bool `default:"true" json:"removeEmptyDirs"`
	// JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
	PartitionExpr *string `default:"C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')" json:"partitionExpr"`
	// Format of the output data
	Format *OutputDatabricksDataFormat `default:"json" json:"format"`
	// JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `default:"CriblOut" json:"baseFileName"`
	// JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string `default:".\\${C.env[\"CRIBL_WORKER_ID\"]}.\\${__format}\\${__compression === \"gzip\" ? \".gz\" : \"\"}" json:"fileNameSuffix"`
	// Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float64 `default:"32" json:"maxFileSizeMB"`
	// Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float64 `default:"300" json:"maxFileOpenTimeSec"`
	// Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float64 `default:"30" json:"maxFileIdleTimeSec"`
	// Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float64 `default:"100" json:"maxOpenFiles"`
	// If set, this line will be written to the beginning of each output file
	HeaderLine *string `default:"" json:"headerLine"`
	// Buffer size used to write to a file
	WriteHighWaterMark *float64 `default:"64" json:"writeHighWaterMark"`
	// How to handle events when all receivers are exerting backpressure
	OnBackpressure *OutputDatabricksBackpressureBehavior `default:"block" json:"onBackpressure"`
	// If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors
	DeadletterEnabled *bool `default:"false" json:"deadletterEnabled"`
	// How to handle events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputDatabricksDiskSpaceProtection `default:"block" json:"onDiskFullBackpressure"`
	// Unity Catalog authentication method. Choose Manual to enter credentials directly, or Secret to use a stored secret.
	UnityAuthMethod *OutputDatabricksAuthenticationMethod `default:"manual" json:"unityAuthMethod"`
	// URL for Unity Catalog OAuth token endpoint (example: 'https://your-workspace.cloud.databricks.com/oauth/token')
	LoginURL string `json:"loginUrl"`
	// OAuth scope for Unity Catalog authentication
	Scope *string `default:"all-apis" json:"scope"`
	// How often the OAuth token should be refreshed
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Name of the catalog to use for the output
	DefaultCatalog *string `default:"main" json:"defaultCatalog"`
	// Name of the catalog schema to use for the output
	DefaultSchema *string `default:"external" json:"defaultSchema"`
	// Name of the events volume in Databricks
	EventsVolumeName *string `default:"events" json:"eventsVolumeName"`
	// JavaScript expression to compute the OAuth client ID for Unity Catalog authentication. Can be a constant.
	ClientID string `json:"clientId"`
	// Uploaded files should be overwritten if they already exist. If disabled, upload will fail if a file already exists.
	OverWriteFiles *bool   `default:"false" json:"overWriteFiles"`
	Description    *string `json:"description,omitempty"`
	// JavaScript expression to compute the OAuth client secret for Unity Catalog authentication. Can be a constant.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// Select or create a stored text secret
	ClientTextSecret *string `json:"clientTextSecret,omitempty"`
}

func (o OutputDatabricks) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutputDatabricks) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"type", "loginUrl", "clientId"}); err != nil {
		return err
	}
	return nil
}

func (o *OutputDatabricks) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OutputDatabricks) GetType() OutputDatabricksType {
	if o == nil {
		return OutputDatabricksType("")
	}
	return o.Type
}

func (o *OutputDatabricks) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *OutputDatabricks) GetSystemFields() []string {
	if o == nil {
		return nil
	}
	return o.SystemFields
}

func (o *OutputDatabricks) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *OutputDatabricks) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *OutputDatabricks) GetDestPath() *string {
	if o == nil {
		return nil
	}
	return o.DestPath
}

func (o *OutputDatabricks) GetStagePath() *string {
	if o == nil {
		return nil
	}
	return o.StagePath
}

func (o *OutputDatabricks) GetAddIDToStagePath() *bool {
	if o == nil {
		return nil
	}
	return o.AddIDToStagePath
}

func (o *OutputDatabricks) GetRemoveEmptyDirs() *bool {
	if o == nil {
		return nil
	}
	return o.RemoveEmptyDirs
}

func (o *OutputDatabricks) GetPartitionExpr() *string {
	if o == nil {
		return nil
	}
	return o.PartitionExpr
}

func (o *OutputDatabricks) GetFormat() *OutputDatabricksDataFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *OutputDatabricks) GetBaseFileName() *string {
	if o == nil {
		return nil
	}
	return o.BaseFileName
}

func (o *OutputDatabricks) GetFileNameSuffix() *string {
	if o == nil {
		return nil
	}
	return o.FileNameSuffix
}

func (o *OutputDatabricks) GetMaxFileSizeMB() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxFileSizeMB
}

func (o *OutputDatabricks) GetMaxFileOpenTimeSec() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxFileOpenTimeSec
}

func (o *OutputDatabricks) GetMaxFileIdleTimeSec() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxFileIdleTimeSec
}

func (o *OutputDatabricks) GetMaxOpenFiles() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxOpenFiles
}

func (o *OutputDatabricks) GetHeaderLine() *string {
	if o == nil {
		return nil
	}
	return o.HeaderLine
}

func (o *OutputDatabricks) GetWriteHighWaterMark() *float64 {
	if o == nil {
		return nil
	}
	return o.WriteHighWaterMark
}

func (o *OutputDatabricks) GetOnBackpressure() *OutputDatabricksBackpressureBehavior {
	if o == nil {
		return nil
	}
	return o.OnBackpressure
}

func (o *OutputDatabricks) GetDeadletterEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.DeadletterEnabled
}

func (o *OutputDatabricks) GetOnDiskFullBackpressure() *OutputDatabricksDiskSpaceProtection {
	if o == nil {
		return nil
	}
	return o.OnDiskFullBackpressure
}

func (o *OutputDatabricks) GetUnityAuthMethod() *OutputDatabricksAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.UnityAuthMethod
}

func (o *OutputDatabricks) GetLoginURL() string {
	if o == nil {
		return ""
	}
	return o.LoginURL
}

func (o *OutputDatabricks) GetScope() *string {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *OutputDatabricks) GetTokenTimeoutSecs() *float64 {
	if o == nil {
		return nil
	}
	return o.TokenTimeoutSecs
}

func (o *OutputDatabricks) GetDefaultCatalog() *string {
	if o == nil {
		return nil
	}
	return o.DefaultCatalog
}

func (o *OutputDatabricks) GetDefaultSchema() *string {
	if o == nil {
		return nil
	}
	return o.DefaultSchema
}

func (o *OutputDatabricks) GetEventsVolumeName() *string {
	if o == nil {
		return nil
	}
	return o.EventsVolumeName
}

func (o *OutputDatabricks) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *OutputDatabricks) GetOverWriteFiles() *bool {
	if o == nil {
		return nil
	}
	return o.OverWriteFiles
}

func (o *OutputDatabricks) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OutputDatabricks) GetClientSecret() *string {
	if o == nil {
		return nil
	}
	return o.ClientSecret
}

func (o *OutputDatabricks) GetClientTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.ClientTextSecret
}
