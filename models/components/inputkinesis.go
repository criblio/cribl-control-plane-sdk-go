// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type InputKinesisPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool   `default:"false" json:"pqEnabled"`
	Pq        *PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       *string          `json:"id,omitempty"`
	Type     InputKinesisType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                     `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *SignatureVersionOptions2 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                         `json:"description,omitempty"`
	AwsAPIKey   *string                         `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesisPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetType() InputKinesisType {
	if i == nil {
		return InputKinesisType("")
	}
	return i.Type
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetStreamName() string {
	if i == nil {
		return ""
	}
	return i.StreamName
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetServiceInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.ServiceInterval
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetShardExpr() *string {
	if i == nil {
		return nil
	}
	return i.ShardExpr
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetShardIteratorType() *ShardIteratorStart {
	if i == nil {
		return nil
	}
	return i.ShardIteratorType
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetPayloadFormat() *RecordDataFormat {
	if i == nil {
		return nil
	}
	return i.PayloadFormat
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetGetRecordsLimit() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimit
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetGetRecordsLimitTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimitTotal
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if i == nil {
		return nil
	}
	return i.LoadBalancingAlgorithm
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetSignatureVersion() *SignatureVersionOptions2 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetVerifyKPLCheckSums() *bool {
	if i == nil {
		return nil
	}
	return i.VerifyKPLCheckSums
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAvoidDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.AvoidDuplicates
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputKinesisPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputKinesisPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool   `default:"false" json:"pqEnabled"`
	Pq        *PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       *string          `json:"id,omitempty"`
	Type     InputKinesisType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                     `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *SignatureVersionOptions2 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                         `json:"description,omitempty"`
	AwsAPIKey   *string                         `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesisPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetType() InputKinesisType {
	if i == nil {
		return InputKinesisType("")
	}
	return i.Type
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetStreamName() string {
	if i == nil {
		return ""
	}
	return i.StreamName
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetServiceInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.ServiceInterval
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetShardExpr() *string {
	if i == nil {
		return nil
	}
	return i.ShardExpr
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetShardIteratorType() *ShardIteratorStart {
	if i == nil {
		return nil
	}
	return i.ShardIteratorType
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetPayloadFormat() *RecordDataFormat {
	if i == nil {
		return nil
	}
	return i.PayloadFormat
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetGetRecordsLimit() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimit
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetGetRecordsLimitTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimitTotal
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if i == nil {
		return nil
	}
	return i.LoadBalancingAlgorithm
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetSignatureVersion() *SignatureVersionOptions2 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetVerifyKPLCheckSums() *bool {
	if i == nil {
		return nil
	}
	return i.VerifyKPLCheckSums
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAvoidDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.AvoidDuplicates
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputKinesisPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputKinesisSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       *string          `json:"id,omitempty"`
	Type     InputKinesisType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	Pq         *PqType  `json:"pq,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                     `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *SignatureVersionOptions2 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                         `json:"description,omitempty"`
	AwsAPIKey   *string                         `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesisSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetType() InputKinesisType {
	if i == nil {
		return InputKinesisType("")
	}
	return i.Type
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetStreamName() string {
	if i == nil {
		return ""
	}
	return i.StreamName
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetServiceInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.ServiceInterval
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetShardExpr() *string {
	if i == nil {
		return nil
	}
	return i.ShardExpr
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetShardIteratorType() *ShardIteratorStart {
	if i == nil {
		return nil
	}
	return i.ShardIteratorType
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetPayloadFormat() *RecordDataFormat {
	if i == nil {
		return nil
	}
	return i.PayloadFormat
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetGetRecordsLimit() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimit
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetGetRecordsLimitTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimitTotal
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if i == nil {
		return nil
	}
	return i.LoadBalancingAlgorithm
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *SignatureVersionOptions2 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetVerifyKPLCheckSums() *bool {
	if i == nil {
		return nil
	}
	return i.VerifyKPLCheckSums
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAvoidDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.AvoidDuplicates
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputKinesisSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputKinesisType string

const (
	InputKinesisTypeKinesis InputKinesisType = "kinesis"
)

func (e InputKinesisType) ToPointer() *InputKinesisType {
	return &e
}
func (e *InputKinesisType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kinesis":
		*e = InputKinesisType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputKinesisType: %v", v)
	}
}

// ShardIteratorStart - Location at which to start reading a shard for the first time
type ShardIteratorStart string

const (
	// ShardIteratorStartTrimHorizon Earliest record
	ShardIteratorStartTrimHorizon ShardIteratorStart = "TRIM_HORIZON"
	// ShardIteratorStartLatest Latest record
	ShardIteratorStartLatest ShardIteratorStart = "LATEST"
)

func (e ShardIteratorStart) ToPointer() *ShardIteratorStart {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ShardIteratorStart) IsExact() bool {
	if e != nil {
		switch *e {
		case "TRIM_HORIZON", "LATEST":
			return true
		}
	}
	return false
}

// RecordDataFormat - Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
type RecordDataFormat string

const (
	// RecordDataFormatCribl Cribl
	RecordDataFormatCribl RecordDataFormat = "cribl"
	// RecordDataFormatNdjson Newline JSON
	RecordDataFormatNdjson RecordDataFormat = "ndjson"
	// RecordDataFormatCloudwatch Cloudwatch Logs
	RecordDataFormatCloudwatch RecordDataFormat = "cloudwatch"
	// RecordDataFormatLine Event per line
	RecordDataFormatLine RecordDataFormat = "line"
)

func (e RecordDataFormat) ToPointer() *RecordDataFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *RecordDataFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "cribl", "ndjson", "cloudwatch", "line":
			return true
		}
	}
	return false
}

// ShardLoadBalancing - The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
type ShardLoadBalancing string

const (
	// ShardLoadBalancingConsistentHashing Consistent Hashing
	ShardLoadBalancingConsistentHashing ShardLoadBalancing = "ConsistentHashing"
	// ShardLoadBalancingRoundRobin Round Robin
	ShardLoadBalancingRoundRobin ShardLoadBalancing = "RoundRobin"
)

func (e ShardLoadBalancing) ToPointer() *ShardLoadBalancing {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ShardLoadBalancing) IsExact() bool {
	if e != nil {
		switch *e {
		case "ConsistentHashing", "RoundRobin":
			return true
		}
	}
	return false
}

type InputKinesisSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       *string          `json:"id,omitempty"`
	Type     InputKinesisType `json:"type"`
	Disabled *bool            `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	Pq         *PqType  `json:"pq,omitempty"`
	// Kinesis Data Stream to read data from
	StreamName string `json:"streamName"`
	// Time interval in minutes between consecutive service calls
	ServiceInterval *float64 `default:"1" json:"serviceInterval"`
	// A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
	ShardExpr *string `default:"true" json:"shardExpr"`
	// Location at which to start reading a shard for the first time
	ShardIteratorType *ShardIteratorStart `default:"TRIM_HORIZON" json:"shardIteratorType"`
	// Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *RecordDataFormat `default:"cribl" json:"payloadFormat"`
	// Maximum number of records per getRecords call
	GetRecordsLimit *float64 `default:"5000" json:"getRecordsLimit"`
	// Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float64 `default:"20000" json:"getRecordsLimitTotal"`
	// The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *ShardLoadBalancing `default:"ConsistentHashing" json:"loadBalancingAlgorithm"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsSecretKey            *string                                     `json:"awsSecretKey,omitempty"`
	// Region where the Kinesis stream is located
	Region string `json:"region"`
	// Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing Kinesis stream requests
	SignatureVersion *SignatureVersionOptions2 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `default:"false" json:"verifyKPLCheckSums"`
	// When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `default:"false" json:"avoidDuplicates"`
	// Fields to add to events from this input
	Metadata    []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Description *string                         `json:"description,omitempty"`
	AwsAPIKey   *string                         `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
}

func (i InputKinesisSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "streamName", "region"}); err != nil {
		return err
	}
	return nil
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetType() InputKinesisType {
	if i == nil {
		return InputKinesisType("")
	}
	return i.Type
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetStreamName() string {
	if i == nil {
		return ""
	}
	return i.StreamName
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetServiceInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.ServiceInterval
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetShardExpr() *string {
	if i == nil {
		return nil
	}
	return i.ShardExpr
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetShardIteratorType() *ShardIteratorStart {
	if i == nil {
		return nil
	}
	return i.ShardIteratorType
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetPayloadFormat() *RecordDataFormat {
	if i == nil {
		return nil
	}
	return i.PayloadFormat
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetGetRecordsLimit() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimit
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetGetRecordsLimitTotal() *float64 {
	if i == nil {
		return nil
	}
	return i.GetRecordsLimitTotal
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetLoadBalancingAlgorithm() *ShardLoadBalancing {
	if i == nil {
		return nil
	}
	return i.LoadBalancingAlgorithm
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetRegion() string {
	if i == nil {
		return ""
	}
	return i.Region
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *SignatureVersionOptions2 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetVerifyKPLCheckSums() *bool {
	if i == nil {
		return nil
	}
	return i.VerifyKPLCheckSums
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAvoidDuplicates() *bool {
	if i == nil {
		return nil
	}
	return i.AvoidDuplicates
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputKinesisSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

type InputKinesisUnionType string

const (
	InputKinesisUnionTypeInputKinesisSendToRoutesTrueWithConnectionsConstraint  InputKinesisUnionType = "InputKinesis_SendToRoutesTrueWithConnectionsConstraint"
	InputKinesisUnionTypeInputKinesisSendToRoutesFalseWithConnectionsConstraint InputKinesisUnionType = "InputKinesis_SendToRoutesFalseWithConnectionsConstraint"
	InputKinesisUnionTypeInputKinesisPqEnabledFalseWithPqConstraint             InputKinesisUnionType = "InputKinesis_PqEnabledFalseWithPqConstraint"
	InputKinesisUnionTypeInputKinesisPqEnabledTrueWithPqConstraint              InputKinesisUnionType = "InputKinesis_PqEnabledTrueWithPqConstraint"
)

type InputKinesis struct {
	InputKinesisSendToRoutesTrueWithConnectionsConstraint  *InputKinesisSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputKinesisSendToRoutesFalseWithConnectionsConstraint *InputKinesisSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputKinesisPqEnabledFalseWithPqConstraint             *InputKinesisPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputKinesisPqEnabledTrueWithPqConstraint              *InputKinesisPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputKinesisUnionType
}

func CreateInputKinesisInputKinesisSendToRoutesTrueWithConnectionsConstraint(inputKinesisSendToRoutesTrueWithConnectionsConstraint InputKinesisSendToRoutesTrueWithConnectionsConstraint) InputKinesis {
	typ := InputKinesisUnionTypeInputKinesisSendToRoutesTrueWithConnectionsConstraint

	return InputKinesis{
		InputKinesisSendToRoutesTrueWithConnectionsConstraint: &inputKinesisSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKinesisInputKinesisSendToRoutesFalseWithConnectionsConstraint(inputKinesisSendToRoutesFalseWithConnectionsConstraint InputKinesisSendToRoutesFalseWithConnectionsConstraint) InputKinesis {
	typ := InputKinesisUnionTypeInputKinesisSendToRoutesFalseWithConnectionsConstraint

	return InputKinesis{
		InputKinesisSendToRoutesFalseWithConnectionsConstraint: &inputKinesisSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputKinesisInputKinesisPqEnabledFalseWithPqConstraint(inputKinesisPqEnabledFalseWithPqConstraint InputKinesisPqEnabledFalseWithPqConstraint) InputKinesis {
	typ := InputKinesisUnionTypeInputKinesisPqEnabledFalseWithPqConstraint

	return InputKinesis{
		InputKinesisPqEnabledFalseWithPqConstraint: &inputKinesisPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputKinesisInputKinesisPqEnabledTrueWithPqConstraint(inputKinesisPqEnabledTrueWithPqConstraint InputKinesisPqEnabledTrueWithPqConstraint) InputKinesis {
	typ := InputKinesisUnionTypeInputKinesisPqEnabledTrueWithPqConstraint

	return InputKinesis{
		InputKinesisPqEnabledTrueWithPqConstraint: &inputKinesisPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputKinesis) UnmarshalJSON(data []byte) error {

	var inputKinesisSendToRoutesTrueWithConnectionsConstraint InputKinesisSendToRoutesTrueWithConnectionsConstraint = InputKinesisSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKinesisSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKinesisSendToRoutesTrueWithConnectionsConstraint = &inputKinesisSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputKinesisUnionTypeInputKinesisSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputKinesisSendToRoutesFalseWithConnectionsConstraint InputKinesisSendToRoutesFalseWithConnectionsConstraint = InputKinesisSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKinesisSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputKinesisSendToRoutesFalseWithConnectionsConstraint = &inputKinesisSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputKinesisUnionTypeInputKinesisSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputKinesisPqEnabledFalseWithPqConstraint InputKinesisPqEnabledFalseWithPqConstraint = InputKinesisPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKinesisPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputKinesisPqEnabledFalseWithPqConstraint = &inputKinesisPqEnabledFalseWithPqConstraint
		u.Type = InputKinesisUnionTypeInputKinesisPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputKinesisPqEnabledTrueWithPqConstraint InputKinesisPqEnabledTrueWithPqConstraint = InputKinesisPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputKinesisPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputKinesisPqEnabledTrueWithPqConstraint = &inputKinesisPqEnabledTrueWithPqConstraint
		u.Type = InputKinesisUnionTypeInputKinesisPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputKinesis", string(data))
}

func (u InputKinesis) MarshalJSON() ([]byte, error) {
	if u.InputKinesisSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKinesisSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputKinesisSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputKinesisSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputKinesisPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKinesisPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputKinesisPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputKinesisPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputKinesis: all fields are null")
}
