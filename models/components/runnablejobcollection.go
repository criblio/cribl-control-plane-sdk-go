// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// RunnableJobCollectionMode - Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job.
type RunnableJobCollectionMode string

const (
	RunnableJobCollectionModeList    RunnableJobCollectionMode = "list"
	RunnableJobCollectionModePreview RunnableJobCollectionMode = "preview"
	RunnableJobCollectionModeRun     RunnableJobCollectionMode = "run"
)

func (e RunnableJobCollectionMode) ToPointer() *RunnableJobCollectionMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *RunnableJobCollectionMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "list", "preview", "run":
			return true
		}
	}
	return false
}

type TimeRange string

const (
	TimeRangeAbsolute TimeRange = "absolute"
	TimeRangeRelative TimeRange = "relative"
)

func (e TimeRange) ToPointer() *TimeRange {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *TimeRange) IsExact() bool {
	if e != nil {
		switch *e {
		case "absolute", "relative":
			return true
		}
	}
	return false
}

type WhereToCapture int64

const (
	// WhereToCaptureZero 1. Before pre-processing Pipeline
	WhereToCaptureZero WhereToCapture = 0
	// WhereToCaptureOne 2. Before the Routes
	WhereToCaptureOne WhereToCapture = 1
	// WhereToCaptureTwo 3. Before post-processing Pipeline
	WhereToCaptureTwo WhereToCapture = 2
	// WhereToCaptureThree 4. Before the Destination
	WhereToCaptureThree WhereToCapture = 3
)

func (e WhereToCapture) ToPointer() *WhereToCapture {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *WhereToCapture) IsExact() bool {
	if e != nil {
		switch *e {
		case 0, 1, 2, 3:
			return true
		}
	}
	return false
}

type CaptureSettings struct {
	// Amount of time to keep capture open, in seconds
	Duration *float64 `json:"duration,omitempty"`
	// Maximum number of events to capture
	MaxEvents *float64        `json:"maxEvents,omitempty"`
	Level     *WhereToCapture `json:"level,omitempty"`
}

func (c CaptureSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CaptureSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CaptureSettings) GetDuration() *float64 {
	if c == nil {
		return nil
	}
	return c.Duration
}

func (c *CaptureSettings) GetMaxEvents() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxEvents
}

func (c *CaptureSettings) GetLevel() *WhereToCapture {
	if c == nil {
		return nil
	}
	return c.Level
}

type RunnableJobCollectionRun struct {
	// Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `json:"rescheduleDroppedTasks,omitempty"`
	// Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float64 `json:"maxTaskReschedule,omitempty"`
	// Level at which to set task logging
	LogLevel *LogLevelOptionsSavedJobCollectionScheduleRun `json:"logLevel,omitempty"`
	// Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`
	// Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job.
	Mode          RunnableJobCollectionMode `json:"mode"`
	TimeRangeType *TimeRange                `json:"timeRangeType,omitempty"`
	// Earliest time to collect data for the selected timezone
	Earliest *float64 `json:"earliest,omitempty"`
	// Latest time to collect data for the selected timezone
	Latest *float64 `json:"latest,omitempty"`
	// Timezone to use for Earliest and Latest times
	TimestampTimezone *string       `json:"timestampTimezone,omitempty"`
	TimeWarning       *MetricsStore `json:"timeWarning,omitempty"`
	// A filter for tokens in the provided collect path and/or the events being collected
	Expression *string `json:"expression,omitempty"`
	// Limits the bundle size for small tasks. For example,
	//
	//
	//         if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
	MinTaskSize *string `json:"minTaskSize,omitempty"`
	// Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB,
	//
	//
	//         you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
	MaxTaskSize *string `json:"maxTaskSize,omitempty"`
	// Send discover results to Routes
	DiscoverToRoutes *bool            `json:"discoverToRoutes,omitempty"`
	Capture          *CaptureSettings `json:"capture,omitempty"`
}

func (r RunnableJobCollectionRun) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RunnableJobCollectionRun) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"mode"}); err != nil {
		return err
	}
	return nil
}

func (r *RunnableJobCollectionRun) GetRescheduleDroppedTasks() *bool {
	if r == nil {
		return nil
	}
	return r.RescheduleDroppedTasks
}

func (r *RunnableJobCollectionRun) GetMaxTaskReschedule() *float64 {
	if r == nil {
		return nil
	}
	return r.MaxTaskReschedule
}

func (r *RunnableJobCollectionRun) GetLogLevel() *LogLevelOptionsSavedJobCollectionScheduleRun {
	if r == nil {
		return nil
	}
	return r.LogLevel
}

func (r *RunnableJobCollectionRun) GetJobTimeout() *string {
	if r == nil {
		return nil
	}
	return r.JobTimeout
}

func (r *RunnableJobCollectionRun) GetMode() RunnableJobCollectionMode {
	if r == nil {
		return RunnableJobCollectionMode("")
	}
	return r.Mode
}

func (r *RunnableJobCollectionRun) GetTimeRangeType() *TimeRange {
	if r == nil {
		return nil
	}
	return r.TimeRangeType
}

func (r *RunnableJobCollectionRun) GetEarliest() *float64 {
	if r == nil {
		return nil
	}
	return r.Earliest
}

func (r *RunnableJobCollectionRun) GetLatest() *float64 {
	if r == nil {
		return nil
	}
	return r.Latest
}

func (r *RunnableJobCollectionRun) GetTimestampTimezone() *string {
	if r == nil {
		return nil
	}
	return r.TimestampTimezone
}

func (r *RunnableJobCollectionRun) GetTimeWarning() *MetricsStore {
	if r == nil {
		return nil
	}
	return r.TimeWarning
}

func (r *RunnableJobCollectionRun) GetExpression() *string {
	if r == nil {
		return nil
	}
	return r.Expression
}

func (r *RunnableJobCollectionRun) GetMinTaskSize() *string {
	if r == nil {
		return nil
	}
	return r.MinTaskSize
}

func (r *RunnableJobCollectionRun) GetMaxTaskSize() *string {
	if r == nil {
		return nil
	}
	return r.MaxTaskSize
}

func (r *RunnableJobCollectionRun) GetDiscoverToRoutes() *bool {
	if r == nil {
		return nil
	}
	return r.DiscoverToRoutes
}

func (r *RunnableJobCollectionRun) GetCapture() *CaptureSettings {
	if r == nil {
		return nil
	}
	return r.Capture
}

type RunnableJobCollection struct {
	// Unique ID for this Job
	ID          *string                           `json:"id,omitempty"`
	Description *string                           `json:"description,omitempty"`
	Type        *JobTypeOptionsSavedJobCollection `json:"type,omitempty"`
	// Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	TTL *string `json:"ttl,omitempty"`
	// When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
	IgnoreGroupJobsLimit *bool `json:"ignoreGroupJobsLimit,omitempty"`
	// List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface.
	RemoveFields []string `json:"removeFields,omitempty"`
	// Resume the ad hoc job if a failure condition causes Stream to restart during job execution
	ResumeOnBoot *bool `json:"resumeOnBoot,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Configuration for a scheduled job
	Schedule *ScheduleTypeRunnableJobCollection `json:"schedule,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// If enabled, tasks are created and run by the same Worker Node
	WorkerAffinity *bool `json:"workerAffinity,omitempty"`
	// Collector configuration
	Collector Collector                                    `json:"collector"`
	Input     *TypeCollectionWithBreakerRulesetsConstraint `json:"input,omitempty"`
	Run       RunnableJobCollectionRun                     `json:"run"`
}

func (r RunnableJobCollection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RunnableJobCollection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"collector", "run"}); err != nil {
		return err
	}
	return nil
}

func (r *RunnableJobCollection) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RunnableJobCollection) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RunnableJobCollection) GetType() *JobTypeOptionsSavedJobCollection {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *RunnableJobCollection) GetTTL() *string {
	if r == nil {
		return nil
	}
	return r.TTL
}

func (r *RunnableJobCollection) GetIgnoreGroupJobsLimit() *bool {
	if r == nil {
		return nil
	}
	return r.IgnoreGroupJobsLimit
}

func (r *RunnableJobCollection) GetRemoveFields() []string {
	if r == nil {
		return nil
	}
	return r.RemoveFields
}

func (r *RunnableJobCollection) GetResumeOnBoot() *bool {
	if r == nil {
		return nil
	}
	return r.ResumeOnBoot
}

func (r *RunnableJobCollection) GetEnvironment() *string {
	if r == nil {
		return nil
	}
	return r.Environment
}

func (r *RunnableJobCollection) GetSchedule() *ScheduleTypeRunnableJobCollection {
	if r == nil {
		return nil
	}
	return r.Schedule
}

func (r *RunnableJobCollection) GetStreamtags() []string {
	if r == nil {
		return nil
	}
	return r.Streamtags
}

func (r *RunnableJobCollection) GetWorkerAffinity() *bool {
	if r == nil {
		return nil
	}
	return r.WorkerAffinity
}

func (r *RunnableJobCollection) GetCollector() Collector {
	if r == nil {
		return Collector{}
	}
	return r.Collector
}

func (r *RunnableJobCollection) GetCollectorAzureBlob() *CollectorAzureBlob {
	return r.GetCollector().CollectorAzureBlob
}

func (r *RunnableJobCollection) GetCollectorCriblLake() *CollectorCriblLake {
	return r.GetCollector().CollectorCriblLake
}

func (r *RunnableJobCollection) GetCollectorDatabase() *CollectorDatabase {
	return r.GetCollector().CollectorDatabase
}

func (r *RunnableJobCollection) GetCollectorFilesystem() *CollectorFilesystem {
	return r.GetCollector().CollectorFilesystem
}

func (r *RunnableJobCollection) GetCollectorGoogleCloudStorage() *CollectorGoogleCloudStorage {
	return r.GetCollector().CollectorGoogleCloudStorage
}

func (r *RunnableJobCollection) GetCollectorHealthCheck() *CollectorHealthCheck {
	return r.GetCollector().CollectorHealthCheck
}

func (r *RunnableJobCollection) GetCollectorRest() *CollectorRest {
	return r.GetCollector().CollectorRest
}

func (r *RunnableJobCollection) GetCollectorS3() *CollectorS3 {
	return r.GetCollector().CollectorS3
}

func (r *RunnableJobCollection) GetCollectorScript() *CollectorScript {
	return r.GetCollector().CollectorScript
}

func (r *RunnableJobCollection) GetCollectorSplunk() *CollectorSplunk {
	return r.GetCollector().CollectorSplunk
}

func (r *RunnableJobCollection) GetInput() *TypeCollectionWithBreakerRulesetsConstraint {
	if r == nil {
		return nil
	}
	return r.Input
}

func (r *RunnableJobCollection) GetRun() RunnableJobCollectionRun {
	if r == nil {
		return RunnableJobCollectionRun{}
	}
	return r.Run
}
