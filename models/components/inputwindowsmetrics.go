// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type InputWindowsMetricsInputCollectionPart1Type1 struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool   `default:"false" json:"pqEnabled"`
	Pq        *PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       *string                 `json:"id,omitempty"`
	Type     InputWindowsMetricsType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                 `default:"10" json:"interval"`
	Host     *InputWindowsMetricsHost `json:"host,omitempty"`
	Process  *ProcessType             `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputWindowsMetricsPersistence `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputWindowsMetricsInputCollectionPart1Type1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetType() InputWindowsMetricsType {
	if i == nil {
		return InputWindowsMetricsType("")
	}
	return i.Type
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetHost() *InputWindowsMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetProcess() *ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetPersistence() *InputWindowsMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWindowsMetricsInputCollectionPart1Type1) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWindowsMetricsInputCollectionPart0Type1 struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Unique ID for this input
	ID       *string                 `json:"id,omitempty"`
	Type     InputWindowsMetricsType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	Pq          *PqType                `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                 `default:"10" json:"interval"`
	Host     *InputWindowsMetricsHost `json:"host,omitempty"`
	Process  *ProcessType             `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputWindowsMetricsPersistence `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputWindowsMetricsInputCollectionPart0Type1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetType() InputWindowsMetricsType {
	if i == nil {
		return InputWindowsMetricsType("")
	}
	return i.Type
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetHost() *InputWindowsMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetProcess() *ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetPersistence() *InputWindowsMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWindowsMetricsInputCollectionPart0Type1) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWindowsMetricsInputCollectionPart1Type struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       *string                 `json:"id,omitempty"`
	Type     InputWindowsMetricsType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	Pq         *PqType  `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                 `default:"10" json:"interval"`
	Host     *InputWindowsMetricsHost `json:"host,omitempty"`
	Process  *ProcessType             `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputWindowsMetricsPersistence `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputWindowsMetricsInputCollectionPart1Type) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsInputCollectionPart1Type) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetType() InputWindowsMetricsType {
	if i == nil {
		return InputWindowsMetricsType("")
	}
	return i.Type
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetHost() *InputWindowsMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetProcess() *ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetPersistence() *InputWindowsMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWindowsMetricsInputCollectionPart1Type) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWindowsMetricsType string

const (
	InputWindowsMetricsTypeWindowsMetrics InputWindowsMetricsType = "windows_metrics"
)

func (e InputWindowsMetricsType) ToPointer() *InputWindowsMetricsType {
	return &e
}
func (e *InputWindowsMetricsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "windows_metrics":
		*e = InputWindowsMetricsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWindowsMetricsType: %v", v)
	}
}

// InputWindowsMetricsSystemMode - Select the level of details for system metrics
type InputWindowsMetricsSystemMode string

const (
	// InputWindowsMetricsSystemModeBasic Basic
	InputWindowsMetricsSystemModeBasic InputWindowsMetricsSystemMode = "basic"
	// InputWindowsMetricsSystemModeAll All
	InputWindowsMetricsSystemModeAll InputWindowsMetricsSystemMode = "all"
	// InputWindowsMetricsSystemModeCustom Custom
	InputWindowsMetricsSystemModeCustom InputWindowsMetricsSystemMode = "custom"
	// InputWindowsMetricsSystemModeDisabled Disabled
	InputWindowsMetricsSystemModeDisabled InputWindowsMetricsSystemMode = "disabled"
)

func (e InputWindowsMetricsSystemMode) ToPointer() *InputWindowsMetricsSystemMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsSystemMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsSystem struct {
	// Select the level of details for system metrics
	Mode *InputWindowsMetricsSystemMode `default:"basic" json:"mode"`
	// Generate metrics for all system information
	Detail *bool `default:"false" json:"detail"`
}

func (i InputWindowsMetricsSystem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsSystem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsSystem) GetMode() *InputWindowsMetricsSystemMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsSystem) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

// InputWindowsMetricsCPUMode - Select the level of details for CPU metrics
type InputWindowsMetricsCPUMode string

const (
	// InputWindowsMetricsCPUModeBasic Basic
	InputWindowsMetricsCPUModeBasic InputWindowsMetricsCPUMode = "basic"
	// InputWindowsMetricsCPUModeAll All
	InputWindowsMetricsCPUModeAll InputWindowsMetricsCPUMode = "all"
	// InputWindowsMetricsCPUModeCustom Custom
	InputWindowsMetricsCPUModeCustom InputWindowsMetricsCPUMode = "custom"
	// InputWindowsMetricsCPUModeDisabled Disabled
	InputWindowsMetricsCPUModeDisabled InputWindowsMetricsCPUMode = "disabled"
)

func (e InputWindowsMetricsCPUMode) ToPointer() *InputWindowsMetricsCPUMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsCPUMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsCPU struct {
	// Select the level of details for CPU metrics
	Mode *InputWindowsMetricsCPUMode `default:"basic" json:"mode"`
	// Generate metrics for each CPU
	PerCPU *bool `default:"false" json:"perCpu"`
	// Generate metrics for all CPU states
	Detail *bool `default:"false" json:"detail"`
	// Generate raw, monotonic CPU time counters
	Time *bool `default:"false" json:"time"`
}

func (i InputWindowsMetricsCPU) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsCPU) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsCPU) GetMode() *InputWindowsMetricsCPUMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsCPU) GetPerCPU() *bool {
	if i == nil {
		return nil
	}
	return i.PerCPU
}

func (i *InputWindowsMetricsCPU) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputWindowsMetricsCPU) GetTime() *bool {
	if i == nil {
		return nil
	}
	return i.Time
}

// InputWindowsMetricsMemoryMode - Select the level of details for memory metrics
type InputWindowsMetricsMemoryMode string

const (
	// InputWindowsMetricsMemoryModeBasic Basic
	InputWindowsMetricsMemoryModeBasic InputWindowsMetricsMemoryMode = "basic"
	// InputWindowsMetricsMemoryModeAll All
	InputWindowsMetricsMemoryModeAll InputWindowsMetricsMemoryMode = "all"
	// InputWindowsMetricsMemoryModeCustom Custom
	InputWindowsMetricsMemoryModeCustom InputWindowsMetricsMemoryMode = "custom"
	// InputWindowsMetricsMemoryModeDisabled Disabled
	InputWindowsMetricsMemoryModeDisabled InputWindowsMetricsMemoryMode = "disabled"
)

func (e InputWindowsMetricsMemoryMode) ToPointer() *InputWindowsMetricsMemoryMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsMemoryMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsMemory struct {
	// Select the level of details for memory metrics
	Mode *InputWindowsMetricsMemoryMode `default:"basic" json:"mode"`
	// Generate metrics for all memory states
	Detail *bool `default:"false" json:"detail"`
}

func (i InputWindowsMetricsMemory) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsMemory) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsMemory) GetMode() *InputWindowsMetricsMemoryMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsMemory) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

// InputWindowsMetricsNetworkMode - Select the level of details for network metrics
type InputWindowsMetricsNetworkMode string

const (
	// InputWindowsMetricsNetworkModeBasic Basic
	InputWindowsMetricsNetworkModeBasic InputWindowsMetricsNetworkMode = "basic"
	// InputWindowsMetricsNetworkModeAll All
	InputWindowsMetricsNetworkModeAll InputWindowsMetricsNetworkMode = "all"
	// InputWindowsMetricsNetworkModeCustom Custom
	InputWindowsMetricsNetworkModeCustom InputWindowsMetricsNetworkMode = "custom"
	// InputWindowsMetricsNetworkModeDisabled Disabled
	InputWindowsMetricsNetworkModeDisabled InputWindowsMetricsNetworkMode = "disabled"
)

func (e InputWindowsMetricsNetworkMode) ToPointer() *InputWindowsMetricsNetworkMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsNetworkMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsNetwork struct {
	// Select the level of details for network metrics
	Mode *InputWindowsMetricsNetworkMode `default:"basic" json:"mode"`
	// Generate full network metrics
	Detail *bool `default:"false" json:"detail"`
	// Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
	Protocols *bool `default:"false" json:"protocols"`
	// Network interfaces to include/exclude. All interfaces are included if this list is empty.
	Devices []string `json:"devices,omitempty"`
	// Generate separate metrics for each interface
	PerInterface *bool `default:"false" json:"perInterface"`
}

func (i InputWindowsMetricsNetwork) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsNetwork) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsNetwork) GetMode() *InputWindowsMetricsNetworkMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsNetwork) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputWindowsMetricsNetwork) GetProtocols() *bool {
	if i == nil {
		return nil
	}
	return i.Protocols
}

func (i *InputWindowsMetricsNetwork) GetDevices() []string {
	if i == nil {
		return nil
	}
	return i.Devices
}

func (i *InputWindowsMetricsNetwork) GetPerInterface() *bool {
	if i == nil {
		return nil
	}
	return i.PerInterface
}

// InputWindowsMetricsDiskMode - Select the level of details for disk metrics
type InputWindowsMetricsDiskMode string

const (
	// InputWindowsMetricsDiskModeBasic Basic
	InputWindowsMetricsDiskModeBasic InputWindowsMetricsDiskMode = "basic"
	// InputWindowsMetricsDiskModeAll All
	InputWindowsMetricsDiskModeAll InputWindowsMetricsDiskMode = "all"
	// InputWindowsMetricsDiskModeCustom Custom
	InputWindowsMetricsDiskModeCustom InputWindowsMetricsDiskMode = "custom"
	// InputWindowsMetricsDiskModeDisabled Disabled
	InputWindowsMetricsDiskModeDisabled InputWindowsMetricsDiskMode = "disabled"
)

func (e InputWindowsMetricsDiskMode) ToPointer() *InputWindowsMetricsDiskMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputWindowsMetricsDiskMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "basic", "all", "custom", "disabled":
			return true
		}
	}
	return false
}

type InputWindowsMetricsDisk struct {
	// Select the level of details for disk metrics
	Mode *InputWindowsMetricsDiskMode `default:"basic" json:"mode"`
	// Generate separate metrics for each volume
	PerVolume *bool `default:"false" json:"perVolume"`
	// Generate full disk metrics
	Detail *bool `default:"false" json:"detail"`
	// Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
	Volumes []string `json:"volumes,omitempty"`
}

func (i InputWindowsMetricsDisk) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsDisk) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsDisk) GetMode() *InputWindowsMetricsDiskMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsDisk) GetPerVolume() *bool {
	if i == nil {
		return nil
	}
	return i.PerVolume
}

func (i *InputWindowsMetricsDisk) GetDetail() *bool {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *InputWindowsMetricsDisk) GetVolumes() []string {
	if i == nil {
		return nil
	}
	return i.Volumes
}

type InputWindowsMetricsCustom struct {
	System  *InputWindowsMetricsSystem  `json:"system,omitempty"`
	CPU     *InputWindowsMetricsCPU     `json:"cpu,omitempty"`
	Memory  *InputWindowsMetricsMemory  `json:"memory,omitempty"`
	Network *InputWindowsMetricsNetwork `json:"network,omitempty"`
	Disk    *InputWindowsMetricsDisk    `json:"disk,omitempty"`
}

func (i InputWindowsMetricsCustom) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsCustom) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsCustom) GetSystem() *InputWindowsMetricsSystem {
	if i == nil {
		return nil
	}
	return i.System
}

func (i *InputWindowsMetricsCustom) GetCPU() *InputWindowsMetricsCPU {
	if i == nil {
		return nil
	}
	return i.CPU
}

func (i *InputWindowsMetricsCustom) GetMemory() *InputWindowsMetricsMemory {
	if i == nil {
		return nil
	}
	return i.Memory
}

func (i *InputWindowsMetricsCustom) GetNetwork() *InputWindowsMetricsNetwork {
	if i == nil {
		return nil
	}
	return i.Network
}

func (i *InputWindowsMetricsCustom) GetDisk() *InputWindowsMetricsDisk {
	if i == nil {
		return nil
	}
	return i.Disk
}

type InputWindowsMetricsHost struct {
	// Select level of detail for host metrics
	Mode   *ModeOptionsHost           `default:"basic" json:"mode"`
	Custom *InputWindowsMetricsCustom `json:"custom,omitempty"`
}

func (i InputWindowsMetricsHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsHost) GetMode() *ModeOptionsHost {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputWindowsMetricsHost) GetCustom() *InputWindowsMetricsCustom {
	if i == nil {
		return nil
	}
	return i.Custom
}

type InputWindowsMetricsPersistence struct {
	// Spool metrics to disk for Cribl Edge and Search
	Enable *bool `default:"false" json:"enable"`
	// Time span for each file bucket
	TimeWindow *string `default:"10m" json:"timeWindow"`
	// Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
	MaxDataSize *string `default:"1GB" json:"maxDataSize"`
	// Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
	MaxDataTime *string                                  `default:"24h" json:"maxDataTime"`
	Compress    *DataCompressionFormatOptionsPersistence `default:"gzip" json:"compress"`
	// Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
	DestPath *string `default:"$CRIBL_HOME/state/windows_metrics" json:"destPath"`
}

func (i InputWindowsMetricsPersistence) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsPersistence) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsPersistence) GetEnable() *bool {
	if i == nil {
		return nil
	}
	return i.Enable
}

func (i *InputWindowsMetricsPersistence) GetTimeWindow() *string {
	if i == nil {
		return nil
	}
	return i.TimeWindow
}

func (i *InputWindowsMetricsPersistence) GetMaxDataSize() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataSize
}

func (i *InputWindowsMetricsPersistence) GetMaxDataTime() *string {
	if i == nil {
		return nil
	}
	return i.MaxDataTime
}

func (i *InputWindowsMetricsPersistence) GetCompress() *DataCompressionFormatOptionsPersistence {
	if i == nil {
		return nil
	}
	return i.Compress
}

func (i *InputWindowsMetricsPersistence) GetDestPath() *string {
	if i == nil {
		return nil
	}
	return i.DestPath
}

type InputWindowsMetricsInputCollectionPart0Type struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Unique ID for this input
	ID       *string                 `json:"id,omitempty"`
	Type     InputWindowsMetricsType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	Pq          *PqType                `json:"pq,omitempty"`
	// Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float64                 `default:"10" json:"interval"`
	Host     *InputWindowsMetricsHost `json:"host,omitempty"`
	Process  *ProcessType             `json:"process,omitempty"`
	// Fields to add to events from this input
	Metadata    []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	Persistence *InputWindowsMetricsPersistence `json:"persistence,omitempty"`
	// Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool   `default:"false" json:"disableNativeModule"`
	Description         *string `json:"description,omitempty"`
}

func (i InputWindowsMetricsInputCollectionPart0Type) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputWindowsMetricsInputCollectionPart0Type) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetType() InputWindowsMetricsType {
	if i == nil {
		return InputWindowsMetricsType("")
	}
	return i.Type
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetHost() *InputWindowsMetricsHost {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetProcess() *ProcessType {
	if i == nil {
		return nil
	}
	return i.Process
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetPersistence() *InputWindowsMetricsPersistence {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetDisableNativeModule() *bool {
	if i == nil {
		return nil
	}
	return i.DisableNativeModule
}

func (i *InputWindowsMetricsInputCollectionPart0Type) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

type InputWindowsMetricsUnionType string

const (
	InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart0Type  InputWindowsMetricsUnionType = "InputWindowsMetrics_InputCollectionPart0Type"
	InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart1Type  InputWindowsMetricsUnionType = "InputWindowsMetrics_InputCollectionPart1Type"
	InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart0Type1 InputWindowsMetricsUnionType = "InputWindowsMetrics_InputCollectionPart0Type1"
	InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart1Type1 InputWindowsMetricsUnionType = "InputWindowsMetrics_InputCollectionPart1Type1"
)

type InputWindowsMetrics struct {
	InputWindowsMetricsInputCollectionPart0Type  *InputWindowsMetricsInputCollectionPart0Type  `queryParam:"inline" union:"member"`
	InputWindowsMetricsInputCollectionPart1Type  *InputWindowsMetricsInputCollectionPart1Type  `queryParam:"inline" union:"member"`
	InputWindowsMetricsInputCollectionPart0Type1 *InputWindowsMetricsInputCollectionPart0Type1 `queryParam:"inline" union:"member"`
	InputWindowsMetricsInputCollectionPart1Type1 *InputWindowsMetricsInputCollectionPart1Type1 `queryParam:"inline" union:"member"`

	Type InputWindowsMetricsUnionType
}

func CreateInputWindowsMetricsInputWindowsMetricsInputCollectionPart0Type(inputWindowsMetricsInputCollectionPart0Type InputWindowsMetricsInputCollectionPart0Type) InputWindowsMetrics {
	typ := InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart0Type

	return InputWindowsMetrics{
		InputWindowsMetricsInputCollectionPart0Type: &inputWindowsMetricsInputCollectionPart0Type,
		Type: typ,
	}
}

func CreateInputWindowsMetricsInputWindowsMetricsInputCollectionPart1Type(inputWindowsMetricsInputCollectionPart1Type InputWindowsMetricsInputCollectionPart1Type) InputWindowsMetrics {
	typ := InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart1Type

	return InputWindowsMetrics{
		InputWindowsMetricsInputCollectionPart1Type: &inputWindowsMetricsInputCollectionPart1Type,
		Type: typ,
	}
}

func CreateInputWindowsMetricsInputWindowsMetricsInputCollectionPart0Type1(inputWindowsMetricsInputCollectionPart0Type1 InputWindowsMetricsInputCollectionPart0Type1) InputWindowsMetrics {
	typ := InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart0Type1

	return InputWindowsMetrics{
		InputWindowsMetricsInputCollectionPart0Type1: &inputWindowsMetricsInputCollectionPart0Type1,
		Type: typ,
	}
}

func CreateInputWindowsMetricsInputWindowsMetricsInputCollectionPart1Type1(inputWindowsMetricsInputCollectionPart1Type1 InputWindowsMetricsInputCollectionPart1Type1) InputWindowsMetrics {
	typ := InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart1Type1

	return InputWindowsMetrics{
		InputWindowsMetricsInputCollectionPart1Type1: &inputWindowsMetricsInputCollectionPart1Type1,
		Type: typ,
	}
}

func (u *InputWindowsMetrics) UnmarshalJSON(data []byte) error {

	var inputWindowsMetricsInputCollectionPart0Type InputWindowsMetricsInputCollectionPart0Type = InputWindowsMetricsInputCollectionPart0Type{}
	if err := utils.UnmarshalJSON(data, &inputWindowsMetricsInputCollectionPart0Type, "", true, nil); err == nil {
		u.InputWindowsMetricsInputCollectionPart0Type = &inputWindowsMetricsInputCollectionPart0Type
		u.Type = InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart0Type
		return nil
	}

	var inputWindowsMetricsInputCollectionPart1Type InputWindowsMetricsInputCollectionPart1Type = InputWindowsMetricsInputCollectionPart1Type{}
	if err := utils.UnmarshalJSON(data, &inputWindowsMetricsInputCollectionPart1Type, "", true, nil); err == nil {
		u.InputWindowsMetricsInputCollectionPart1Type = &inputWindowsMetricsInputCollectionPart1Type
		u.Type = InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart1Type
		return nil
	}

	var inputWindowsMetricsInputCollectionPart0Type1 InputWindowsMetricsInputCollectionPart0Type1 = InputWindowsMetricsInputCollectionPart0Type1{}
	if err := utils.UnmarshalJSON(data, &inputWindowsMetricsInputCollectionPart0Type1, "", true, nil); err == nil {
		u.InputWindowsMetricsInputCollectionPart0Type1 = &inputWindowsMetricsInputCollectionPart0Type1
		u.Type = InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart0Type1
		return nil
	}

	var inputWindowsMetricsInputCollectionPart1Type1 InputWindowsMetricsInputCollectionPart1Type1 = InputWindowsMetricsInputCollectionPart1Type1{}
	if err := utils.UnmarshalJSON(data, &inputWindowsMetricsInputCollectionPart1Type1, "", true, nil); err == nil {
		u.InputWindowsMetricsInputCollectionPart1Type1 = &inputWindowsMetricsInputCollectionPart1Type1
		u.Type = InputWindowsMetricsUnionTypeInputWindowsMetricsInputCollectionPart1Type1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputWindowsMetrics", string(data))
}

func (u InputWindowsMetrics) MarshalJSON() ([]byte, error) {
	if u.InputWindowsMetricsInputCollectionPart0Type != nil {
		return utils.MarshalJSON(u.InputWindowsMetricsInputCollectionPart0Type, "", true)
	}

	if u.InputWindowsMetricsInputCollectionPart1Type != nil {
		return utils.MarshalJSON(u.InputWindowsMetricsInputCollectionPart1Type, "", true)
	}

	if u.InputWindowsMetricsInputCollectionPart0Type1 != nil {
		return utils.MarshalJSON(u.InputWindowsMetricsInputCollectionPart0Type1, "", true)
	}

	if u.InputWindowsMetricsInputCollectionPart1Type1 != nil {
		return utils.MarshalJSON(u.InputWindowsMetricsInputCollectionPart1Type1, "", true)
	}

	return nil, errors.New("could not marshal union type InputWindowsMetrics: all fields are null")
}
