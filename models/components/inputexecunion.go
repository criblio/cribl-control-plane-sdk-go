// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// ScheduleTypeEnum6 - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type ScheduleTypeEnum6 string

const (
	ScheduleTypeEnum6Interval     ScheduleTypeEnum6 = "interval"
	ScheduleTypeEnum6CronSchedule ScheduleTypeEnum6 = "cronSchedule"
)

func (e ScheduleTypeEnum6) ToPointer() *ScheduleTypeEnum6 {
	return &e
}

type InputExecType6 string

const (
	InputExecType6Exec InputExecType6 = "exec"
)

func (e InputExecType6) ToPointer() *InputExecType6 {
	return &e
}
func (e *InputExecType6) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = InputExecType6(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputExecType6: %v", v)
	}
}

type InputExec6 struct {
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *ScheduleTypeEnum6 `default:"interval" json:"scheduleType"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     InputExecType6 `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExec6) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExec6) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExec6) GetScheduleType() *ScheduleTypeEnum6 {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExec6) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputExec6) GetType() InputExecType6 {
	if i == nil {
		return InputExecType6("")
	}
	return i.Type
}

func (i *InputExec6) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExec6) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExec6) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExec6) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExec6) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExec6) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExec6) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExec6) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExec6) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExec6) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExec6) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExec6) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExec6) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExec6) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExec6) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExec6) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

// ScheduleTypeEnum5 - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type ScheduleTypeEnum5 string

const (
	ScheduleTypeEnum5Interval     ScheduleTypeEnum5 = "interval"
	ScheduleTypeEnum5CronSchedule ScheduleTypeEnum5 = "cronSchedule"
)

func (e ScheduleTypeEnum5) ToPointer() *ScheduleTypeEnum5 {
	return &e
}

type InputExecType5 string

const (
	InputExecType5Exec InputExecType5 = "exec"
)

func (e InputExecType5) ToPointer() *InputExecType5 {
	return &e
}
func (e *InputExecType5) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = InputExecType5(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputExecType5: %v", v)
	}
}

type InputExec5 struct {
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *ScheduleTypeEnum5 `default:"interval" json:"scheduleType"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     InputExecType5 `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExec5) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExec5) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExec5) GetScheduleType() *ScheduleTypeEnum5 {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExec5) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputExec5) GetType() InputExecType5 {
	if i == nil {
		return InputExecType5("")
	}
	return i.Type
}

func (i *InputExec5) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExec5) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExec5) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExec5) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExec5) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExec5) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExec5) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExec5) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExec5) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExec5) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExec5) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExec5) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExec5) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExec5) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExec5) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExec5) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type InputExecType4 string

const (
	InputExecType4Exec InputExecType4 = "exec"
)

func (e InputExecType4) ToPointer() *InputExecType4 {
	return &e
}
func (e *InputExecType4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = InputExecType4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputExecType4: %v", v)
	}
}

// ScheduleTypeEnum4 - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type ScheduleTypeEnum4 string

const (
	ScheduleTypeEnum4Interval     ScheduleTypeEnum4 = "interval"
	ScheduleTypeEnum4CronSchedule ScheduleTypeEnum4 = "cronSchedule"
)

func (e ScheduleTypeEnum4) ToPointer() *ScheduleTypeEnum4 {
	return &e
}

type InputExec4 struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     InputExecType4 `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          PqType            `json:"pq"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *ScheduleTypeEnum4 `default:"interval" json:"scheduleType"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExec4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExec4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "pq", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExec4) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExec4) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputExec4) GetType() InputExecType4 {
	if i == nil {
		return InputExecType4("")
	}
	return i.Type
}

func (i *InputExec4) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExec4) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExec4) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExec4) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExec4) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExec4) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExec4) GetPq() PqType {
	if i == nil {
		return PqType{}
	}
	return i.Pq
}

func (i *InputExec4) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExec4) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExec4) GetScheduleType() *ScheduleTypeEnum4 {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExec4) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExec4) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExec4) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExec4) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExec4) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExec4) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type InputExecType3 string

const (
	InputExecType3Exec InputExecType3 = "exec"
)

func (e InputExecType3) ToPointer() *InputExecType3 {
	return &e
}
func (e *InputExecType3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = InputExecType3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputExecType3: %v", v)
	}
}

// ScheduleTypeEnum3 - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type ScheduleTypeEnum3 string

const (
	ScheduleTypeEnum3Interval     ScheduleTypeEnum3 = "interval"
	ScheduleTypeEnum3CronSchedule ScheduleTypeEnum3 = "cronSchedule"
)

func (e ScheduleTypeEnum3) ToPointer() *ScheduleTypeEnum3 {
	return &e
}

type InputExec3 struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     InputExecType3 `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *ScheduleTypeEnum3 `default:"interval" json:"scheduleType"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExec3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExec3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExec3) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExec3) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputExec3) GetType() InputExecType3 {
	if i == nil {
		return InputExecType3("")
	}
	return i.Type
}

func (i *InputExec3) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExec3) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExec3) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExec3) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExec3) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExec3) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExec3) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExec3) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExec3) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExec3) GetScheduleType() *ScheduleTypeEnum3 {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExec3) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExec3) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExec3) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExec3) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExec3) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExec3) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type InputExecType2 string

const (
	InputExecType2Exec InputExecType2 = "exec"
)

func (e InputExecType2) ToPointer() *InputExecType2 {
	return &e
}
func (e *InputExecType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = InputExecType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputExecType2: %v", v)
	}
}

// ScheduleTypeEnum2 - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type ScheduleTypeEnum2 string

const (
	ScheduleTypeEnum2Interval     ScheduleTypeEnum2 = "interval"
	ScheduleTypeEnum2CronSchedule ScheduleTypeEnum2 = "cronSchedule"
)

func (e ScheduleTypeEnum2) ToPointer() *ScheduleTypeEnum2 {
	return &e
}

type InputExec2 struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     InputExecType2 `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *ScheduleTypeEnum2 `default:"interval" json:"scheduleType"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExec2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExec2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "connections", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExec2) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExec2) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputExec2) GetType() InputExecType2 {
	if i == nil {
		return InputExecType2("")
	}
	return i.Type
}

func (i *InputExec2) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExec2) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExec2) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExec2) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExec2) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExec2) GetConnections() []ConnectionsType {
	if i == nil {
		return []ConnectionsType{}
	}
	return i.Connections
}

func (i *InputExec2) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExec2) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExec2) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExec2) GetScheduleType() *ScheduleTypeEnum2 {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExec2) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExec2) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExec2) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExec2) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExec2) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExec2) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type InputExecType1 string

const (
	InputExecType1Exec InputExecType1 = "exec"
)

func (e InputExecType1) ToPointer() *InputExecType1 {
	return &e
}
func (e *InputExecType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exec":
		*e = InputExecType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputExecType1: %v", v)
	}
}

// ScheduleTypeEnum1 - Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type ScheduleTypeEnum1 string

const (
	ScheduleTypeEnum1Interval     ScheduleTypeEnum1 = "interval"
	ScheduleTypeEnum1CronSchedule ScheduleTypeEnum1 = "cronSchedule"
)

func (e ScheduleTypeEnum1) ToPointer() *ScheduleTypeEnum1 {
	return &e
}

type InputExec1 struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     InputExecType1 `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`
	// Maximum number of retry attempts in the event that the command fails
	Retries *float64 `default:"10" json:"retries"`
	// Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *ScheduleTypeEnum1 `default:"interval" json:"scheduleType"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	// Interval between command executions in seconds.
	Interval *float64 `default:"60" json:"interval"`
	// Cron schedule to execute the command on.
	CronSchedule *string `default:"* * * * *" json:"cronSchedule"`
}

func (i InputExec1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputExec1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "command"}); err != nil {
		return err
	}
	return nil
}

func (i *InputExec1) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputExec1) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputExec1) GetType() InputExecType1 {
	if i == nil {
		return InputExecType1("")
	}
	return i.Type
}

func (i *InputExec1) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputExec1) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputExec1) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputExec1) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputExec1) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputExec1) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputExec1) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputExec1) GetCommand() string {
	if i == nil {
		return ""
	}
	return i.Command
}

func (i *InputExec1) GetRetries() *float64 {
	if i == nil {
		return nil
	}
	return i.Retries
}

func (i *InputExec1) GetScheduleType() *ScheduleTypeEnum1 {
	if i == nil {
		return nil
	}
	return i.ScheduleType
}

func (i *InputExec1) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputExec1) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputExec1) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputExec1) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputExec1) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputExec1) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

type InputExecUnionType string

const (
	InputExecUnionTypeInputExec1 InputExecUnionType = "InputExec_1"
	InputExecUnionTypeInputExec2 InputExecUnionType = "InputExec_2"
	InputExecUnionTypeInputExec3 InputExecUnionType = "InputExec_3"
	InputExecUnionTypeInputExec4 InputExecUnionType = "InputExec_4"
	InputExecUnionTypeInputExec5 InputExecUnionType = "InputExec_5"
	InputExecUnionTypeInputExec6 InputExecUnionType = "InputExec_6"
)

type InputExecUnion struct {
	InputExec1 *InputExec1 `queryParam:"inline,name=InputExec"`
	InputExec2 *InputExec2 `queryParam:"inline,name=InputExec"`
	InputExec3 *InputExec3 `queryParam:"inline,name=InputExec"`
	InputExec4 *InputExec4 `queryParam:"inline,name=InputExec"`
	InputExec5 *InputExec5 `queryParam:"inline,name=InputExec"`
	InputExec6 *InputExec6 `queryParam:"inline,name=InputExec"`

	Type InputExecUnionType
}

func CreateInputExecUnionInputExec1(inputExec1 InputExec1) InputExecUnion {
	typ := InputExecUnionTypeInputExec1

	return InputExecUnion{
		InputExec1: &inputExec1,
		Type:       typ,
	}
}

func CreateInputExecUnionInputExec2(inputExec2 InputExec2) InputExecUnion {
	typ := InputExecUnionTypeInputExec2

	return InputExecUnion{
		InputExec2: &inputExec2,
		Type:       typ,
	}
}

func CreateInputExecUnionInputExec3(inputExec3 InputExec3) InputExecUnion {
	typ := InputExecUnionTypeInputExec3

	return InputExecUnion{
		InputExec3: &inputExec3,
		Type:       typ,
	}
}

func CreateInputExecUnionInputExec4(inputExec4 InputExec4) InputExecUnion {
	typ := InputExecUnionTypeInputExec4

	return InputExecUnion{
		InputExec4: &inputExec4,
		Type:       typ,
	}
}

func CreateInputExecUnionInputExec5(inputExec5 InputExec5) InputExecUnion {
	typ := InputExecUnionTypeInputExec5

	return InputExecUnion{
		InputExec5: &inputExec5,
		Type:       typ,
	}
}

func CreateInputExecUnionInputExec6(inputExec6 InputExec6) InputExecUnion {
	typ := InputExecUnionTypeInputExec6

	return InputExecUnion{
		InputExec6: &inputExec6,
		Type:       typ,
	}
}

func (u *InputExecUnion) UnmarshalJSON(data []byte) error {

	var inputExec2 InputExec2 = InputExec2{}
	if err := utils.UnmarshalJSON(data, &inputExec2, "", true, nil); err == nil {
		u.InputExec2 = &inputExec2
		u.Type = InputExecUnionTypeInputExec2
		return nil
	}

	var inputExec4 InputExec4 = InputExec4{}
	if err := utils.UnmarshalJSON(data, &inputExec4, "", true, nil); err == nil {
		u.InputExec4 = &inputExec4
		u.Type = InputExecUnionTypeInputExec4
		return nil
	}

	var inputExec1 InputExec1 = InputExec1{}
	if err := utils.UnmarshalJSON(data, &inputExec1, "", true, nil); err == nil {
		u.InputExec1 = &inputExec1
		u.Type = InputExecUnionTypeInputExec1
		return nil
	}

	var inputExec3 InputExec3 = InputExec3{}
	if err := utils.UnmarshalJSON(data, &inputExec3, "", true, nil); err == nil {
		u.InputExec3 = &inputExec3
		u.Type = InputExecUnionTypeInputExec3
		return nil
	}

	var inputExec5 InputExec5 = InputExec5{}
	if err := utils.UnmarshalJSON(data, &inputExec5, "", true, nil); err == nil {
		u.InputExec5 = &inputExec5
		u.Type = InputExecUnionTypeInputExec5
		return nil
	}

	var inputExec6 InputExec6 = InputExec6{}
	if err := utils.UnmarshalJSON(data, &inputExec6, "", true, nil); err == nil {
		u.InputExec6 = &inputExec6
		u.Type = InputExecUnionTypeInputExec6
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputExecUnion", string(data))
}

func (u InputExecUnion) MarshalJSON() ([]byte, error) {
	if u.InputExec1 != nil {
		return utils.MarshalJSON(u.InputExec1, "", true)
	}

	if u.InputExec2 != nil {
		return utils.MarshalJSON(u.InputExec2, "", true)
	}

	if u.InputExec3 != nil {
		return utils.MarshalJSON(u.InputExec3, "", true)
	}

	if u.InputExec4 != nil {
		return utils.MarshalJSON(u.InputExec4, "", true)
	}

	if u.InputExec5 != nil {
		return utils.MarshalJSON(u.InputExec5, "", true)
	}

	if u.InputExec6 != nil {
		return utils.MarshalJSON(u.InputExec6, "", true)
	}

	return nil, errors.New("could not marshal union type InputExecUnion: all fields are null")
}
