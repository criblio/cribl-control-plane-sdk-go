// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// PipelineFunctionLookupID - Function ID
type PipelineFunctionLookupID string

const (
	PipelineFunctionLookupIDLookup PipelineFunctionLookupID = "lookup"
)

func (e PipelineFunctionLookupID) ToPointer() *PipelineFunctionLookupID {
	return &e
}
func (e *PipelineFunctionLookupID) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "lookup":
		*e = PipelineFunctionLookupID(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PipelineFunctionLookupID: %v", v)
	}
}

// LookupDbLookupFalseMatchModeExactMatchMode - Specifies the matching method based on the format and logic used in the lookup file
type LookupDbLookupFalseMatchModeExactMatchMode string

const (
	// LookupDbLookupFalseMatchModeExactMatchModeExact Exact
	LookupDbLookupFalseMatchModeExactMatchModeExact LookupDbLookupFalseMatchModeExactMatchMode = "exact"
	// LookupDbLookupFalseMatchModeExactMatchModeCidr CIDR
	LookupDbLookupFalseMatchModeExactMatchModeCidr LookupDbLookupFalseMatchModeExactMatchMode = "cidr"
	// LookupDbLookupFalseMatchModeExactMatchModeRegex Regex
	LookupDbLookupFalseMatchModeExactMatchModeRegex LookupDbLookupFalseMatchModeExactMatchMode = "regex"
)

func (e LookupDbLookupFalseMatchModeExactMatchMode) ToPointer() *LookupDbLookupFalseMatchModeExactMatchMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *LookupDbLookupFalseMatchModeExactMatchMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "exact", "cidr", "regex":
			return true
		}
	}
	return false
}

type LookupDbLookupFalseMatchModeExactInField struct {
	// Field name as it appears in events
	EventField string `json:"eventField"`
	// Optional: The field name as it appears in the lookup file. Defaults to event field name
	LookupField *string `json:"lookupField,omitempty"`
}

func (l LookupDbLookupFalseMatchModeExactInField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupFalseMatchModeExactInField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupFalseMatchModeExactInField) GetEventField() string {
	if l == nil {
		return ""
	}
	return l.EventField
}

func (l *LookupDbLookupFalseMatchModeExactInField) GetLookupField() *string {
	if l == nil {
		return nil
	}
	return l.LookupField
}

type LookupDbLookupFalseMatchModeExactOutField struct {
	// The field name as it appears in the lookup file
	LookupField string `json:"lookupField"`
	// Optional: Field name to add to event. Defaults to lookup field name.
	EventField *string `json:"eventField,omitempty"`
	// Optional: Value to assign if lookup entry is not found
	DefaultValue *string `json:"defaultValue,omitempty"`
}

func (l LookupDbLookupFalseMatchModeExactOutField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupFalseMatchModeExactOutField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupFalseMatchModeExactOutField) GetLookupField() string {
	if l == nil {
		return ""
	}
	return l.LookupField
}

func (l *LookupDbLookupFalseMatchModeExactOutField) GetEventField() *string {
	if l == nil {
		return nil
	}
	return l.EventField
}

func (l *LookupDbLookupFalseMatchModeExactOutField) GetDefaultValue() *string {
	if l == nil {
		return nil
	}
	return l.DefaultValue
}

type LookupDbLookupFalseMatchModeExact struct {
	// Specifies the matching method based on the format and logic used in the lookup file
	MatchMode *LookupDbLookupFalseMatchModeExactMatchMode `json:"matchMode,omitempty"`
	// Whether to ignore case when performing lookups using Match Mode: Exact
	IgnoreCase *bool `json:"ignoreCase,omitempty"`
	// Enable to use a disk-based lookup. This option displays only the settings relevant to disk-based mode and hides those for in-memory lookups.
	DbLookup *bool `json:"dbLookup,omitempty"`
	// Checks the lookup file periodically for changes and reloads it if modified. Set to -1 to disable reloading (default). Useful for lookups not managed by Stream or not updated by an external process. [Learn more](https://docs.cribl.io/stream/lookup-function/#advanced-settings)
	ReloadPeriodSec *float64 `json:"reloadPeriodSec,omitempty"`
	// Path to the lookup file. Reference environment variables via $. Example: $HOME/file.csv
	File string `json:"file"`
	// Fields that should be used to key into the lookup table
	InFields []LookupDbLookupFalseMatchModeExactInField `json:"inFields,omitempty"`
	// Fields to add to events after matching lookup. Defaults to all if not specified.
	OutFields []LookupDbLookupFalseMatchModeExactOutField `json:"outFields,omitempty"`
	// Add the looked-up values to _raw, as key=value pairs
	AddToEvent *bool `json:"addToEvent,omitempty"`
}

func (l LookupDbLookupFalseMatchModeExact) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupFalseMatchModeExact) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupFalseMatchModeExact) GetMatchMode() *LookupDbLookupFalseMatchModeExactMatchMode {
	if l == nil {
		return nil
	}
	return l.MatchMode
}

func (l *LookupDbLookupFalseMatchModeExact) GetIgnoreCase() *bool {
	if l == nil {
		return nil
	}
	return l.IgnoreCase
}

func (l *LookupDbLookupFalseMatchModeExact) GetDbLookup() *bool {
	if l == nil {
		return nil
	}
	return l.DbLookup
}

func (l *LookupDbLookupFalseMatchModeExact) GetReloadPeriodSec() *float64 {
	if l == nil {
		return nil
	}
	return l.ReloadPeriodSec
}

func (l *LookupDbLookupFalseMatchModeExact) GetFile() string {
	if l == nil {
		return ""
	}
	return l.File
}

func (l *LookupDbLookupFalseMatchModeExact) GetInFields() []LookupDbLookupFalseMatchModeExactInField {
	if l == nil {
		return nil
	}
	return l.InFields
}

func (l *LookupDbLookupFalseMatchModeExact) GetOutFields() []LookupDbLookupFalseMatchModeExactOutField {
	if l == nil {
		return nil
	}
	return l.OutFields
}

func (l *LookupDbLookupFalseMatchModeExact) GetAddToEvent() *bool {
	if l == nil {
		return nil
	}
	return l.AddToEvent
}

// LookupDbLookupFalseMatchModeCidrMatchMode - Specifies the matching method based on the format and logic used in the lookup file
type LookupDbLookupFalseMatchModeCidrMatchMode string

const (
	// LookupDbLookupFalseMatchModeCidrMatchModeExact Exact
	LookupDbLookupFalseMatchModeCidrMatchModeExact LookupDbLookupFalseMatchModeCidrMatchMode = "exact"
	// LookupDbLookupFalseMatchModeCidrMatchModeCidr CIDR
	LookupDbLookupFalseMatchModeCidrMatchModeCidr LookupDbLookupFalseMatchModeCidrMatchMode = "cidr"
	// LookupDbLookupFalseMatchModeCidrMatchModeRegex Regex
	LookupDbLookupFalseMatchModeCidrMatchModeRegex LookupDbLookupFalseMatchModeCidrMatchMode = "regex"
)

func (e LookupDbLookupFalseMatchModeCidrMatchMode) ToPointer() *LookupDbLookupFalseMatchModeCidrMatchMode {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *LookupDbLookupFalseMatchModeCidrMatchMode) IsExact() bool {
	if e != nil {
		switch *e {
		case "exact", "cidr", "regex":
			return true
		}
	}
	return false
}

// MatchType - Further defines how to handle multiple matches: return the first match, the most specific match, or all matches
type MatchType string

const (
	MatchTypeFirst    MatchType = "first"
	MatchTypeSpecific MatchType = "specific"
	MatchTypeAll      MatchType = "all"
)

func (e MatchType) ToPointer() *MatchType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *MatchType) IsExact() bool {
	if e != nil {
		switch *e {
		case "first", "specific", "all":
			return true
		}
	}
	return false
}

type LookupDbLookupFalseMatchModeCidrInField struct {
	// Field name as it appears in events
	EventField string `json:"eventField"`
	// Optional: The field name as it appears in the lookup file. Defaults to event field name
	LookupField *string `json:"lookupField,omitempty"`
}

func (l LookupDbLookupFalseMatchModeCidrInField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupFalseMatchModeCidrInField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupFalseMatchModeCidrInField) GetEventField() string {
	if l == nil {
		return ""
	}
	return l.EventField
}

func (l *LookupDbLookupFalseMatchModeCidrInField) GetLookupField() *string {
	if l == nil {
		return nil
	}
	return l.LookupField
}

type LookupDbLookupFalseMatchModeCidrOutField struct {
	// The field name as it appears in the lookup file
	LookupField string `json:"lookupField"`
	// Optional: Field name to add to event. Defaults to lookup field name.
	EventField *string `json:"eventField,omitempty"`
	// Optional: Value to assign if lookup entry is not found
	DefaultValue *string `json:"defaultValue,omitempty"`
}

func (l LookupDbLookupFalseMatchModeCidrOutField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupFalseMatchModeCidrOutField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupFalseMatchModeCidrOutField) GetLookupField() string {
	if l == nil {
		return ""
	}
	return l.LookupField
}

func (l *LookupDbLookupFalseMatchModeCidrOutField) GetEventField() *string {
	if l == nil {
		return nil
	}
	return l.EventField
}

func (l *LookupDbLookupFalseMatchModeCidrOutField) GetDefaultValue() *string {
	if l == nil {
		return nil
	}
	return l.DefaultValue
}

type LookupDbLookupFalseMatchModeCidr struct {
	// Specifies the matching method based on the format and logic used in the lookup file
	MatchMode *LookupDbLookupFalseMatchModeCidrMatchMode `json:"matchMode,omitempty"`
	// Further defines how to handle multiple matches: return the first match, the most specific match, or all matches
	MatchType *MatchType `json:"matchType,omitempty"`
	// Enable to use a disk-based lookup. This option displays only the settings relevant to disk-based mode and hides those for in-memory lookups.
	DbLookup *bool `json:"dbLookup,omitempty"`
	// Checks the lookup file periodically for changes and reloads it if modified. Set to -1 to disable reloading (default). Useful for lookups not managed by Stream or not updated by an external process. [Learn more](https://docs.cribl.io/stream/lookup-function/#advanced-settings)
	ReloadPeriodSec *float64 `json:"reloadPeriodSec,omitempty"`
	// Path to the lookup file. Reference environment variables via $. Example: $HOME/file.csv
	File string `json:"file"`
	// Fields that should be used to key into the lookup table
	InFields []LookupDbLookupFalseMatchModeCidrInField `json:"inFields,omitempty"`
	// Fields to add to events after matching lookup. Defaults to all if not specified.
	OutFields []LookupDbLookupFalseMatchModeCidrOutField `json:"outFields,omitempty"`
	// Add the looked-up values to _raw, as key=value pairs
	AddToEvent *bool `json:"addToEvent,omitempty"`
}

func (l LookupDbLookupFalseMatchModeCidr) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupFalseMatchModeCidr) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupFalseMatchModeCidr) GetMatchMode() *LookupDbLookupFalseMatchModeCidrMatchMode {
	if l == nil {
		return nil
	}
	return l.MatchMode
}

func (l *LookupDbLookupFalseMatchModeCidr) GetMatchType() *MatchType {
	if l == nil {
		return nil
	}
	return l.MatchType
}

func (l *LookupDbLookupFalseMatchModeCidr) GetDbLookup() *bool {
	if l == nil {
		return nil
	}
	return l.DbLookup
}

func (l *LookupDbLookupFalseMatchModeCidr) GetReloadPeriodSec() *float64 {
	if l == nil {
		return nil
	}
	return l.ReloadPeriodSec
}

func (l *LookupDbLookupFalseMatchModeCidr) GetFile() string {
	if l == nil {
		return ""
	}
	return l.File
}

func (l *LookupDbLookupFalseMatchModeCidr) GetInFields() []LookupDbLookupFalseMatchModeCidrInField {
	if l == nil {
		return nil
	}
	return l.InFields
}

func (l *LookupDbLookupFalseMatchModeCidr) GetOutFields() []LookupDbLookupFalseMatchModeCidrOutField {
	if l == nil {
		return nil
	}
	return l.OutFields
}

func (l *LookupDbLookupFalseMatchModeCidr) GetAddToEvent() *bool {
	if l == nil {
		return nil
	}
	return l.AddToEvent
}

type LookupDbLookupFalseType string

const (
	LookupDbLookupFalseTypeCidr    LookupDbLookupFalseType = "cidr"
	LookupDbLookupFalseTypeExact   LookupDbLookupFalseType = "exact"
	LookupDbLookupFalseTypeUnknown LookupDbLookupFalseType = "UNKNOWN"
)

type LookupDbLookupFalse struct {
	LookupDbLookupFalseMatchModeCidr  *LookupDbLookupFalseMatchModeCidr  `queryParam:"inline" union:"member"`
	LookupDbLookupFalseMatchModeExact *LookupDbLookupFalseMatchModeExact `queryParam:"inline" union:"member"`
	UnknownRaw                        json.RawMessage                    `json:"-" union:"unknown"`

	Type LookupDbLookupFalseType
}

func CreateLookupDbLookupFalseCidr(cidr LookupDbLookupFalseMatchModeCidr) LookupDbLookupFalse {
	typ := LookupDbLookupFalseTypeCidr

	typStr := LookupDbLookupFalseMatchModeCidrMatchMode(typ)
	cidr.MatchMode = &typStr

	return LookupDbLookupFalse{
		LookupDbLookupFalseMatchModeCidr: &cidr,
		Type:                             typ,
	}
}

func CreateLookupDbLookupFalseExact(exact LookupDbLookupFalseMatchModeExact) LookupDbLookupFalse {
	typ := LookupDbLookupFalseTypeExact

	typStr := LookupDbLookupFalseMatchModeExactMatchMode(typ)
	exact.MatchMode = &typStr

	return LookupDbLookupFalse{
		LookupDbLookupFalseMatchModeExact: &exact,
		Type:                              typ,
	}
}

func CreateLookupDbLookupFalseUnknown(raw json.RawMessage) LookupDbLookupFalse {
	return LookupDbLookupFalse{
		UnknownRaw: raw,
		Type:       LookupDbLookupFalseTypeUnknown,
	}
}

func (u LookupDbLookupFalse) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u LookupDbLookupFalse) IsUnknown() bool {
	return u.Type == LookupDbLookupFalseTypeUnknown
}

func (u *LookupDbLookupFalse) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		MatchMode string `json:"matchMode"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = LookupDbLookupFalseTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = LookupDbLookupFalseTypeUnknown
		return nil
	}

	switch dis.MatchMode {
	case "cidr":
		lookupDbLookupFalseMatchModeCidr := new(LookupDbLookupFalseMatchModeCidr)
		if err := utils.UnmarshalJSON(data, &lookupDbLookupFalseMatchModeCidr, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (MatchMode == cidr) type LookupDbLookupFalseMatchModeCidr within LookupDbLookupFalse: %w", string(data), err)
		}

		u.LookupDbLookupFalseMatchModeCidr = lookupDbLookupFalseMatchModeCidr
		u.Type = LookupDbLookupFalseTypeCidr
		return nil
	case "exact":
		lookupDbLookupFalseMatchModeExact := new(LookupDbLookupFalseMatchModeExact)
		if err := utils.UnmarshalJSON(data, &lookupDbLookupFalseMatchModeExact, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (MatchMode == exact) type LookupDbLookupFalseMatchModeExact within LookupDbLookupFalse: %w", string(data), err)
		}

		u.LookupDbLookupFalseMatchModeExact = lookupDbLookupFalseMatchModeExact
		u.Type = LookupDbLookupFalseTypeExact
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = LookupDbLookupFalseTypeUnknown
		return nil
	}

}

func (u LookupDbLookupFalse) MarshalJSON() ([]byte, error) {
	if u.LookupDbLookupFalseMatchModeCidr != nil {
		return utils.MarshalJSON(u.LookupDbLookupFalseMatchModeCidr, "", true)
	}

	if u.LookupDbLookupFalseMatchModeExact != nil {
		return utils.MarshalJSON(u.LookupDbLookupFalseMatchModeExact, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type LookupDbLookupFalse: all fields are null")
}

type LookupDbLookupTrueInField struct {
	// Field name as it appears in events
	EventField string `json:"eventField"`
	// Optional: The field name as it appears in the lookup file. Defaults to event field name
	LookupField *string `json:"lookupField,omitempty"`
}

func (l LookupDbLookupTrueInField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupTrueInField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupTrueInField) GetEventField() string {
	if l == nil {
		return ""
	}
	return l.EventField
}

func (l *LookupDbLookupTrueInField) GetLookupField() *string {
	if l == nil {
		return nil
	}
	return l.LookupField
}

type LookupDbLookupTrueOutField struct {
	// The field name as it appears in the lookup file
	LookupField string `json:"lookupField"`
	// Optional: Field name to add to event. Defaults to lookup field name.
	EventField *string `json:"eventField,omitempty"`
	// Optional: Value to assign if lookup entry is not found
	DefaultValue *string `json:"defaultValue,omitempty"`
}

func (l LookupDbLookupTrueOutField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupTrueOutField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupTrueOutField) GetLookupField() string {
	if l == nil {
		return ""
	}
	return l.LookupField
}

func (l *LookupDbLookupTrueOutField) GetEventField() *string {
	if l == nil {
		return nil
	}
	return l.EventField
}

func (l *LookupDbLookupTrueOutField) GetDefaultValue() *string {
	if l == nil {
		return nil
	}
	return l.DefaultValue
}

type LookupDbLookupTrue struct {
	// Enable to use a disk-based lookup. This option displays only the settings relevant to disk-based mode and hides those for in-memory lookups.
	DbLookup *bool `json:"dbLookup,omitempty"`
	// Path to the lookup file. Reference environment variables via $. Example: $HOME/file.csv
	File string `json:"file"`
	// Fields that should be used to key into the lookup table
	InFields []LookupDbLookupTrueInField `json:"inFields,omitempty"`
	// Fields to add to events after matching lookup. Defaults to all if not specified.
	OutFields []LookupDbLookupTrueOutField `json:"outFields,omitempty"`
	// Add the looked-up values to _raw, as key=value pairs
	AddToEvent *bool `json:"addToEvent,omitempty"`
}

func (l LookupDbLookupTrue) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupDbLookupTrue) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LookupDbLookupTrue) GetDbLookup() *bool {
	if l == nil {
		return nil
	}
	return l.DbLookup
}

func (l *LookupDbLookupTrue) GetFile() string {
	if l == nil {
		return ""
	}
	return l.File
}

func (l *LookupDbLookupTrue) GetInFields() []LookupDbLookupTrueInField {
	if l == nil {
		return nil
	}
	return l.InFields
}

func (l *LookupDbLookupTrue) GetOutFields() []LookupDbLookupTrueOutField {
	if l == nil {
		return nil
	}
	return l.OutFields
}

func (l *LookupDbLookupTrue) GetAddToEvent() *bool {
	if l == nil {
		return nil
	}
	return l.AddToEvent
}

type PipelineFunctionLookupConfType string

const (
	PipelineFunctionLookupConfTypeLookupDbLookupTrue  PipelineFunctionLookupConfType = "LookupDbLookupTrue"
	PipelineFunctionLookupConfTypeLookupDbLookupFalse PipelineFunctionLookupConfType = "LookupDbLookupFalse"
)

type PipelineFunctionLookupConf struct {
	LookupDbLookupTrue  *LookupDbLookupTrue  `queryParam:"inline" union:"member"`
	LookupDbLookupFalse *LookupDbLookupFalse `queryParam:"inline" union:"member"`

	Type PipelineFunctionLookupConfType
}

func CreatePipelineFunctionLookupConfLookupDbLookupTrue(lookupDbLookupTrue LookupDbLookupTrue) PipelineFunctionLookupConf {
	typ := PipelineFunctionLookupConfTypeLookupDbLookupTrue

	return PipelineFunctionLookupConf{
		LookupDbLookupTrue: &lookupDbLookupTrue,
		Type:               typ,
	}
}

func CreatePipelineFunctionLookupConfLookupDbLookupFalse(lookupDbLookupFalse LookupDbLookupFalse) PipelineFunctionLookupConf {
	typ := PipelineFunctionLookupConfTypeLookupDbLookupFalse

	return PipelineFunctionLookupConf{
		LookupDbLookupFalse: &lookupDbLookupFalse,
		Type:                typ,
	}
}

func (u *PipelineFunctionLookupConf) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var lookupDbLookupTrue LookupDbLookupTrue = LookupDbLookupTrue{}
	if err := utils.UnmarshalJSON(data, &lookupDbLookupTrue, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PipelineFunctionLookupConfTypeLookupDbLookupTrue,
			Value: &lookupDbLookupTrue,
		})
	}

	var lookupDbLookupFalse LookupDbLookupFalse = LookupDbLookupFalse{}
	if err := utils.UnmarshalJSON(data, &lookupDbLookupFalse, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PipelineFunctionLookupConfTypeLookupDbLookupFalse,
			Value: &lookupDbLookupFalse,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PipelineFunctionLookupConf", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PipelineFunctionLookupConf", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PipelineFunctionLookupConfType)
	switch best.Type {
	case PipelineFunctionLookupConfTypeLookupDbLookupTrue:
		u.LookupDbLookupTrue = best.Value.(*LookupDbLookupTrue)
		return nil
	case PipelineFunctionLookupConfTypeLookupDbLookupFalse:
		u.LookupDbLookupFalse = best.Value.(*LookupDbLookupFalse)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PipelineFunctionLookupConf", string(data))
}

func (u PipelineFunctionLookupConf) MarshalJSON() ([]byte, error) {
	if u.LookupDbLookupTrue != nil {
		return utils.MarshalJSON(u.LookupDbLookupTrue, "", true)
	}

	if u.LookupDbLookupFalse != nil {
		return utils.MarshalJSON(u.LookupDbLookupFalse, "", true)
	}

	return nil, errors.New("could not marshal union type PipelineFunctionLookupConf: all fields are null")
}

type PipelineFunctionLookup struct {
	// Filter that selects data to be fed through this Function
	Filter *string `json:"filter,omitempty"`
	// Function ID
	ID PipelineFunctionLookupID `json:"id"`
	// Simple description of this step
	Description *string `json:"description,omitempty"`
	// If true, data will not be pushed through this function
	Disabled *bool `json:"disabled,omitempty"`
	// If enabled, stops the results of this Function from being passed to the downstream Functions
	Final *bool                      `json:"final,omitempty"`
	Conf  PipelineFunctionLookupConf `json:"conf"`
	// Group ID
	GroupID *string `json:"groupId,omitempty"`
}

func (p PipelineFunctionLookup) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PipelineFunctionLookup) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PipelineFunctionLookup) GetFilter() *string {
	if p == nil {
		return nil
	}
	return p.Filter
}

func (p *PipelineFunctionLookup) GetID() PipelineFunctionLookupID {
	if p == nil {
		return PipelineFunctionLookupID("")
	}
	return p.ID
}

func (p *PipelineFunctionLookup) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PipelineFunctionLookup) GetDisabled() *bool {
	if p == nil {
		return nil
	}
	return p.Disabled
}

func (p *PipelineFunctionLookup) GetFinal() *bool {
	if p == nil {
		return nil
	}
	return p.Final
}

func (p *PipelineFunctionLookup) GetConf() PipelineFunctionLookupConf {
	if p == nil {
		return PipelineFunctionLookupConf{}
	}
	return p.Conf
}

func (p *PipelineFunctionLookup) GetGroupID() *string {
	if p == nil {
		return nil
	}
	return p.GroupID
}
