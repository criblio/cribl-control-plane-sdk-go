// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type InputType string

const (
	InputTypeCollection           InputType = "collection"
	InputTypeKafka                InputType = "kafka"
	InputTypeMsk                  InputType = "msk"
	InputTypeHTTP                 InputType = "http"
	InputTypeSplunk               InputType = "splunk"
	InputTypeSplunkSearch         InputType = "splunk_search"
	InputTypeSplunkHec            InputType = "splunk_hec"
	InputTypeAzureBlob            InputType = "azure_blob"
	InputTypeElastic              InputType = "elastic"
	InputTypeConfluentCloud       InputType = "confluent_cloud"
	InputTypeGrafana              InputType = "grafana"
	InputTypeLoki                 InputType = "loki"
	InputTypePrometheusRw         InputType = "prometheus_rw"
	InputTypePrometheus           InputType = "prometheus"
	InputTypeEdgePrometheus       InputType = "edge_prometheus"
	InputTypeOffice365Mgmt        InputType = "office365_mgmt"
	InputTypeOffice365Service     InputType = "office365_service"
	InputTypeOffice365MsgTrace    InputType = "office365_msg_trace"
	InputTypeEventhub             InputType = "eventhub"
	InputTypeExec                 InputType = "exec"
	InputTypeFirehose             InputType = "firehose"
	InputTypeGooglePubsub         InputType = "google_pubsub"
	InputTypeCribl                InputType = "cribl"
	InputTypeCriblTCP             InputType = "cribl_tcp"
	InputTypeCriblHTTP            InputType = "cribl_http"
	InputTypeCriblLakeHTTP        InputType = "cribl_lake_http"
	InputTypeTcpjson              InputType = "tcpjson"
	InputTypeSystemMetrics        InputType = "system_metrics"
	InputTypeSystemState          InputType = "system_state"
	InputTypeKubeMetrics          InputType = "kube_metrics"
	InputTypeKubeLogs             InputType = "kube_logs"
	InputTypeKubeEvents           InputType = "kube_events"
	InputTypeWindowsMetrics       InputType = "windows_metrics"
	InputTypeCrowdstrike          InputType = "crowdstrike"
	InputTypeDatadogAgent         InputType = "datadog_agent"
	InputTypeDatagen              InputType = "datagen"
	InputTypeHTTPRaw              InputType = "http_raw"
	InputTypeKinesis              InputType = "kinesis"
	InputTypeCriblmetrics         InputType = "criblmetrics"
	InputTypeMetrics              InputType = "metrics"
	InputTypeS3                   InputType = "s3"
	InputTypeS3Inventory          InputType = "s3_inventory"
	InputTypeSnmp                 InputType = "snmp"
	InputTypeOpenTelemetry        InputType = "open_telemetry"
	InputTypeModelDrivenTelemetry InputType = "model_driven_telemetry"
	InputTypeSqs                  InputType = "sqs"
	InputTypeSyslog               InputType = "syslog"
	InputTypeFile                 InputType = "file"
	InputTypeTCP                  InputType = "tcp"
	InputTypeAppscope             InputType = "appscope"
	InputTypeWef                  InputType = "wef"
	InputTypeWinEventLogs         InputType = "win_event_logs"
	InputTypeRawUDP               InputType = "raw_udp"
	InputTypeJournalFiles         InputType = "journal_files"
	InputTypeWiz                  InputType = "wiz"
	InputTypeWizWebhook           InputType = "wiz_webhook"
	InputTypeNetflow              InputType = "netflow"
	InputTypeSecurityLake         InputType = "security_lake"
	InputTypeZscalerHec           InputType = "zscaler_hec"
	InputTypeCloudflareHec        InputType = "cloudflare_hec"
)

type Input struct {
	InputCollection           *InputCollection           `queryParam:"inline" union:"member"`
	InputKafka                *InputKafka                `queryParam:"inline" union:"member"`
	InputMsk                  *InputMsk                  `queryParam:"inline" union:"member"`
	InputHTTP                 *InputHTTP                 `queryParam:"inline" union:"member"`
	InputSplunk               *InputSplunk               `queryParam:"inline" union:"member"`
	InputSplunkSearch         *InputSplunkSearch         `queryParam:"inline" union:"member"`
	InputSplunkHec            *InputSplunkHec            `queryParam:"inline" union:"member"`
	InputAzureBlob            *InputAzureBlob            `queryParam:"inline" union:"member"`
	InputElastic              *InputElastic              `queryParam:"inline" union:"member"`
	InputConfluentCloud       *InputConfluentCloud       `queryParam:"inline" union:"member"`
	InputGrafana              *InputGrafana              `queryParam:"inline" union:"member"`
	InputLoki                 *InputLoki                 `queryParam:"inline" union:"member"`
	InputPrometheusRw         *InputPrometheusRw         `queryParam:"inline" union:"member"`
	InputPrometheus           *InputPrometheus           `queryParam:"inline" union:"member"`
	InputEdgePrometheus       *InputEdgePrometheus       `queryParam:"inline" union:"member"`
	InputOffice365Mgmt        *InputOffice365Mgmt        `queryParam:"inline" union:"member"`
	InputOffice365Service     *InputOffice365Service     `queryParam:"inline" union:"member"`
	InputOffice365MsgTrace    *InputOffice365MsgTrace    `queryParam:"inline" union:"member"`
	InputEventhub             *InputEventhub             `queryParam:"inline" union:"member"`
	InputExec                 *InputExec                 `queryParam:"inline" union:"member"`
	InputFirehose             *InputFirehose             `queryParam:"inline" union:"member"`
	InputGooglePubsub         *InputGooglePubsub         `queryParam:"inline" union:"member"`
	InputCribl                *InputCribl                `queryParam:"inline" union:"member"`
	InputCriblTCP             *InputCriblTCP             `queryParam:"inline" union:"member"`
	InputCriblHTTP            *InputCriblHTTP            `queryParam:"inline" union:"member"`
	InputCriblLakeHTTP        *InputCriblLakeHTTP        `queryParam:"inline" union:"member"`
	InputTcpjson              *InputTcpjson              `queryParam:"inline" union:"member"`
	InputSystemMetrics        *InputSystemMetrics        `queryParam:"inline" union:"member"`
	InputSystemState          *InputSystemState          `queryParam:"inline" union:"member"`
	InputKubeMetrics          *InputKubeMetrics          `queryParam:"inline" union:"member"`
	InputKubeLogs             *InputKubeLogs             `queryParam:"inline" union:"member"`
	InputKubeEvents           *InputKubeEvents           `queryParam:"inline" union:"member"`
	InputWindowsMetrics       *InputWindowsMetrics       `queryParam:"inline" union:"member"`
	InputCrowdstrike          *InputCrowdstrike          `queryParam:"inline" union:"member"`
	InputDatadogAgent         *InputDatadogAgent         `queryParam:"inline" union:"member"`
	InputDatagen              *InputDatagen              `queryParam:"inline" union:"member"`
	InputHTTPRaw              *InputHTTPRaw              `queryParam:"inline" union:"member"`
	InputKinesis              *InputKinesis              `queryParam:"inline" union:"member"`
	InputCriblmetrics         *InputCriblmetrics         `queryParam:"inline" union:"member"`
	InputMetrics              *InputMetrics              `queryParam:"inline" union:"member"`
	InputS3                   *InputS3                   `queryParam:"inline" union:"member"`
	InputS3Inventory          *InputS3Inventory          `queryParam:"inline" union:"member"`
	InputSnmp                 *InputSnmp                 `queryParam:"inline" union:"member"`
	InputOpenTelemetry        *InputOpenTelemetry        `queryParam:"inline" union:"member"`
	InputModelDrivenTelemetry *InputModelDrivenTelemetry `queryParam:"inline" union:"member"`
	InputSqs                  *InputSqs                  `queryParam:"inline" union:"member"`
	InputSyslog               *InputSyslog               `queryParam:"inline" union:"member"`
	InputFile                 *InputFile                 `queryParam:"inline" union:"member"`
	InputTCP                  *InputTCP                  `queryParam:"inline" union:"member"`
	InputAppscope             *InputAppscope             `queryParam:"inline" union:"member"`
	InputWef                  *InputWef                  `queryParam:"inline" union:"member"`
	InputWinEventLogs         *InputWinEventLogs         `queryParam:"inline" union:"member"`
	InputRawUDP               *InputRawUDP               `queryParam:"inline" union:"member"`
	InputJournalFiles         *InputJournalFiles         `queryParam:"inline" union:"member"`
	InputWiz                  *InputWiz                  `queryParam:"inline" union:"member"`
	InputWizWebhook           *InputWizWebhook           `queryParam:"inline" union:"member"`
	InputNetflow              *InputNetflow              `queryParam:"inline" union:"member"`
	InputSecurityLake         *InputSecurityLake         `queryParam:"inline" union:"member"`
	InputZscalerHec           *InputZscalerHec           `queryParam:"inline" union:"member"`
	InputCloudflareHec        *InputCloudflareHec        `queryParam:"inline" union:"member"`

	Type InputType
}

func CreateInputCollection(collection InputCollection) Input {
	typ := InputTypeCollection

	typStr := InputCollectionType(typ)
	collection.Type = typStr

	return Input{
		InputCollection: &collection,
		Type:            typ,
	}
}

func CreateInputKafka(kafka InputKafka) Input {
	typ := InputTypeKafka

	typStr := InputKafkaType(typ)
	kafka.Type = typStr

	return Input{
		InputKafka: &kafka,
		Type:       typ,
	}
}

func CreateInputMsk(msk InputMsk) Input {
	typ := InputTypeMsk

	typStr := InputMskType(typ)
	msk.Type = typStr

	return Input{
		InputMsk: &msk,
		Type:     typ,
	}
}

func CreateInputHTTP(http InputHTTP) Input {
	typ := InputTypeHTTP

	typStr := InputHTTPType(typ)
	http.Type = typStr

	return Input{
		InputHTTP: &http,
		Type:      typ,
	}
}

func CreateInputSplunk(splunk InputSplunk) Input {
	typ := InputTypeSplunk

	typStr := InputSplunkType(typ)
	splunk.Type = typStr

	return Input{
		InputSplunk: &splunk,
		Type:        typ,
	}
}

func CreateInputSplunkSearch(splunkSearch InputSplunkSearch) Input {
	typ := InputTypeSplunkSearch

	typStr := InputSplunkSearchType(typ)
	splunkSearch.Type = typStr

	return Input{
		InputSplunkSearch: &splunkSearch,
		Type:              typ,
	}
}

func CreateInputSplunkHec(splunkHec InputSplunkHec) Input {
	typ := InputTypeSplunkHec

	typStr := InputSplunkHecType(typ)
	splunkHec.Type = typStr

	return Input{
		InputSplunkHec: &splunkHec,
		Type:           typ,
	}
}

func CreateInputAzureBlob(azureBlob InputAzureBlob) Input {
	typ := InputTypeAzureBlob

	typStr := InputAzureBlobType(typ)
	azureBlob.Type = typStr

	return Input{
		InputAzureBlob: &azureBlob,
		Type:           typ,
	}
}

func CreateInputElastic(elastic InputElastic) Input {
	typ := InputTypeElastic

	typStr := InputElasticType(typ)
	elastic.Type = typStr

	return Input{
		InputElastic: &elastic,
		Type:         typ,
	}
}

func CreateInputConfluentCloud(confluentCloud InputConfluentCloud) Input {
	typ := InputTypeConfluentCloud

	typStr := InputConfluentCloudType(typ)
	confluentCloud.Type = typStr

	return Input{
		InputConfluentCloud: &confluentCloud,
		Type:                typ,
	}
}

func CreateInputGrafana(grafana InputGrafana) Input {
	typ := InputTypeGrafana

	return Input{
		InputGrafana: &grafana,
		Type:         typ,
	}
}

func CreateInputLoki(loki InputLoki) Input {
	typ := InputTypeLoki

	typStr := InputLokiType(typ)
	loki.Type = typStr

	return Input{
		InputLoki: &loki,
		Type:      typ,
	}
}

func CreateInputPrometheusRw(prometheusRw InputPrometheusRw) Input {
	typ := InputTypePrometheusRw

	typStr := InputPrometheusRwType(typ)
	prometheusRw.Type = typStr

	return Input{
		InputPrometheusRw: &prometheusRw,
		Type:              typ,
	}
}

func CreateInputPrometheus(prometheus InputPrometheus) Input {
	typ := InputTypePrometheus

	typStr := InputPrometheusType(typ)
	prometheus.Type = typStr

	return Input{
		InputPrometheus: &prometheus,
		Type:            typ,
	}
}

func CreateInputEdgePrometheus(edgePrometheus InputEdgePrometheus) Input {
	typ := InputTypeEdgePrometheus

	typStr := InputEdgePrometheusType(typ)
	edgePrometheus.Type = typStr

	return Input{
		InputEdgePrometheus: &edgePrometheus,
		Type:                typ,
	}
}

func CreateInputOffice365Mgmt(office365Mgmt InputOffice365Mgmt) Input {
	typ := InputTypeOffice365Mgmt

	typStr := InputOffice365MgmtType(typ)
	office365Mgmt.Type = typStr

	return Input{
		InputOffice365Mgmt: &office365Mgmt,
		Type:               typ,
	}
}

func CreateInputOffice365Service(office365Service InputOffice365Service) Input {
	typ := InputTypeOffice365Service

	typStr := InputOffice365ServiceType(typ)
	office365Service.Type = typStr

	return Input{
		InputOffice365Service: &office365Service,
		Type:                  typ,
	}
}

func CreateInputOffice365MsgTrace(office365MsgTrace InputOffice365MsgTrace) Input {
	typ := InputTypeOffice365MsgTrace

	typStr := InputOffice365MsgTraceType(typ)
	office365MsgTrace.Type = typStr

	return Input{
		InputOffice365MsgTrace: &office365MsgTrace,
		Type:                   typ,
	}
}

func CreateInputEventhub(eventhub InputEventhub) Input {
	typ := InputTypeEventhub

	typStr := InputEventhubType(typ)
	eventhub.Type = typStr

	return Input{
		InputEventhub: &eventhub,
		Type:          typ,
	}
}

func CreateInputExec(exec InputExec) Input {
	typ := InputTypeExec

	typStr := InputExecType(typ)
	exec.Type = typStr

	return Input{
		InputExec: &exec,
		Type:      typ,
	}
}

func CreateInputFirehose(firehose InputFirehose) Input {
	typ := InputTypeFirehose

	typStr := InputFirehoseType(typ)
	firehose.Type = typStr

	return Input{
		InputFirehose: &firehose,
		Type:          typ,
	}
}

func CreateInputGooglePubsub(googlePubsub InputGooglePubsub) Input {
	typ := InputTypeGooglePubsub

	typStr := InputGooglePubsubType(typ)
	googlePubsub.Type = typStr

	return Input{
		InputGooglePubsub: &googlePubsub,
		Type:              typ,
	}
}

func CreateInputCribl(cribl InputCribl) Input {
	typ := InputTypeCribl

	typStr := InputCriblType(typ)
	cribl.Type = typStr

	return Input{
		InputCribl: &cribl,
		Type:       typ,
	}
}

func CreateInputCriblTCP(criblTCP InputCriblTCP) Input {
	typ := InputTypeCriblTCP

	typStr := InputCriblTCPType(typ)
	criblTCP.Type = typStr

	return Input{
		InputCriblTCP: &criblTCP,
		Type:          typ,
	}
}

func CreateInputCriblHTTP(criblHTTP InputCriblHTTP) Input {
	typ := InputTypeCriblHTTP

	typStr := InputCriblHTTPType(typ)
	criblHTTP.Type = typStr

	return Input{
		InputCriblHTTP: &criblHTTP,
		Type:           typ,
	}
}

func CreateInputCriblLakeHTTP(criblLakeHTTP InputCriblLakeHTTP) Input {
	typ := InputTypeCriblLakeHTTP

	typStr := InputCriblLakeHTTPType(typ)
	criblLakeHTTP.Type = typStr

	return Input{
		InputCriblLakeHTTP: &criblLakeHTTP,
		Type:               typ,
	}
}

func CreateInputTcpjson(tcpjson InputTcpjson) Input {
	typ := InputTypeTcpjson

	typStr := InputTcpjsonType(typ)
	tcpjson.Type = typStr

	return Input{
		InputTcpjson: &tcpjson,
		Type:         typ,
	}
}

func CreateInputSystemMetrics(systemMetrics InputSystemMetrics) Input {
	typ := InputTypeSystemMetrics

	typStr := InputSystemMetricsType(typ)
	systemMetrics.Type = typStr

	return Input{
		InputSystemMetrics: &systemMetrics,
		Type:               typ,
	}
}

func CreateInputSystemState(systemState InputSystemState) Input {
	typ := InputTypeSystemState

	typStr := InputSystemStateType(typ)
	systemState.Type = typStr

	return Input{
		InputSystemState: &systemState,
		Type:             typ,
	}
}

func CreateInputKubeMetrics(kubeMetrics InputKubeMetrics) Input {
	typ := InputTypeKubeMetrics

	typStr := InputKubeMetricsType(typ)
	kubeMetrics.Type = typStr

	return Input{
		InputKubeMetrics: &kubeMetrics,
		Type:             typ,
	}
}

func CreateInputKubeLogs(kubeLogs InputKubeLogs) Input {
	typ := InputTypeKubeLogs

	typStr := InputKubeLogsType(typ)
	kubeLogs.Type = typStr

	return Input{
		InputKubeLogs: &kubeLogs,
		Type:          typ,
	}
}

func CreateInputKubeEvents(kubeEvents InputKubeEvents) Input {
	typ := InputTypeKubeEvents

	typStr := InputKubeEventsType(typ)
	kubeEvents.Type = typStr

	return Input{
		InputKubeEvents: &kubeEvents,
		Type:            typ,
	}
}

func CreateInputWindowsMetrics(windowsMetrics InputWindowsMetrics) Input {
	typ := InputTypeWindowsMetrics

	typStr := InputWindowsMetricsType(typ)
	windowsMetrics.Type = typStr

	return Input{
		InputWindowsMetrics: &windowsMetrics,
		Type:                typ,
	}
}

func CreateInputCrowdstrike(crowdstrike InputCrowdstrike) Input {
	typ := InputTypeCrowdstrike

	typStr := InputCrowdstrikeType(typ)
	crowdstrike.Type = typStr

	return Input{
		InputCrowdstrike: &crowdstrike,
		Type:             typ,
	}
}

func CreateInputDatadogAgent(datadogAgent InputDatadogAgent) Input {
	typ := InputTypeDatadogAgent

	typStr := InputDatadogAgentType(typ)
	datadogAgent.Type = typStr

	return Input{
		InputDatadogAgent: &datadogAgent,
		Type:              typ,
	}
}

func CreateInputDatagen(datagen InputDatagen) Input {
	typ := InputTypeDatagen

	typStr := InputDatagenType(typ)
	datagen.Type = typStr

	return Input{
		InputDatagen: &datagen,
		Type:         typ,
	}
}

func CreateInputHTTPRaw(httpRaw InputHTTPRaw) Input {
	typ := InputTypeHTTPRaw

	typStr := InputHTTPRawType(typ)
	httpRaw.Type = typStr

	return Input{
		InputHTTPRaw: &httpRaw,
		Type:         typ,
	}
}

func CreateInputKinesis(kinesis InputKinesis) Input {
	typ := InputTypeKinesis

	typStr := InputKinesisType(typ)
	kinesis.Type = typStr

	return Input{
		InputKinesis: &kinesis,
		Type:         typ,
	}
}

func CreateInputCriblmetrics(criblmetrics InputCriblmetrics) Input {
	typ := InputTypeCriblmetrics

	typStr := InputCriblmetricsType(typ)
	criblmetrics.Type = typStr

	return Input{
		InputCriblmetrics: &criblmetrics,
		Type:              typ,
	}
}

func CreateInputMetrics(metrics InputMetrics) Input {
	typ := InputTypeMetrics

	typStr := InputMetricsType(typ)
	metrics.Type = typStr

	return Input{
		InputMetrics: &metrics,
		Type:         typ,
	}
}

func CreateInputS3(s3 InputS3) Input {
	typ := InputTypeS3

	typStr := InputS3Type(typ)
	s3.Type = typStr

	return Input{
		InputS3: &s3,
		Type:    typ,
	}
}

func CreateInputS3Inventory(s3Inventory InputS3Inventory) Input {
	typ := InputTypeS3Inventory

	typStr := InputS3InventoryType(typ)
	s3Inventory.Type = typStr

	return Input{
		InputS3Inventory: &s3Inventory,
		Type:             typ,
	}
}

func CreateInputSnmp(snmp InputSnmp) Input {
	typ := InputTypeSnmp

	typStr := InputSnmpType(typ)
	snmp.Type = typStr

	return Input{
		InputSnmp: &snmp,
		Type:      typ,
	}
}

func CreateInputOpenTelemetry(openTelemetry InputOpenTelemetry) Input {
	typ := InputTypeOpenTelemetry

	typStr := InputOpenTelemetryType(typ)
	openTelemetry.Type = typStr

	return Input{
		InputOpenTelemetry: &openTelemetry,
		Type:               typ,
	}
}

func CreateInputModelDrivenTelemetry(modelDrivenTelemetry InputModelDrivenTelemetry) Input {
	typ := InputTypeModelDrivenTelemetry

	typStr := InputModelDrivenTelemetryType(typ)
	modelDrivenTelemetry.Type = typStr

	return Input{
		InputModelDrivenTelemetry: &modelDrivenTelemetry,
		Type:                      typ,
	}
}

func CreateInputSqs(sqs InputSqs) Input {
	typ := InputTypeSqs

	typStr := InputSqsType(typ)
	sqs.Type = typStr

	return Input{
		InputSqs: &sqs,
		Type:     typ,
	}
}

func CreateInputSyslog(syslog InputSyslog) Input {
	typ := InputTypeSyslog

	return Input{
		InputSyslog: &syslog,
		Type:        typ,
	}
}

func CreateInputFile(file InputFile) Input {
	typ := InputTypeFile

	typStr := InputFileType(typ)
	file.Type = typStr

	return Input{
		InputFile: &file,
		Type:      typ,
	}
}

func CreateInputTCP(tcp InputTCP) Input {
	typ := InputTypeTCP

	typStr := InputTCPType(typ)
	tcp.Type = typStr

	return Input{
		InputTCP: &tcp,
		Type:     typ,
	}
}

func CreateInputAppscope(appscope InputAppscope) Input {
	typ := InputTypeAppscope

	typStr := InputAppscopeType(typ)
	appscope.Type = typStr

	return Input{
		InputAppscope: &appscope,
		Type:          typ,
	}
}

func CreateInputWef(wef InputWef) Input {
	typ := InputTypeWef

	typStr := InputWefType(typ)
	wef.Type = typStr

	return Input{
		InputWef: &wef,
		Type:     typ,
	}
}

func CreateInputWinEventLogs(winEventLogs InputWinEventLogs) Input {
	typ := InputTypeWinEventLogs

	typStr := InputWinEventLogsType(typ)
	winEventLogs.Type = typStr

	return Input{
		InputWinEventLogs: &winEventLogs,
		Type:              typ,
	}
}

func CreateInputRawUDP(rawUDP InputRawUDP) Input {
	typ := InputTypeRawUDP

	typStr := InputRawUDPType(typ)
	rawUDP.Type = typStr

	return Input{
		InputRawUDP: &rawUDP,
		Type:        typ,
	}
}

func CreateInputJournalFiles(journalFiles InputJournalFiles) Input {
	typ := InputTypeJournalFiles

	typStr := InputJournalFilesType(typ)
	journalFiles.Type = typStr

	return Input{
		InputJournalFiles: &journalFiles,
		Type:              typ,
	}
}

func CreateInputWiz(wiz InputWiz) Input {
	typ := InputTypeWiz

	typStr := InputWizType(typ)
	wiz.Type = typStr

	return Input{
		InputWiz: &wiz,
		Type:     typ,
	}
}

func CreateInputWizWebhook(wizWebhook InputWizWebhook) Input {
	typ := InputTypeWizWebhook

	typStr := InputWizWebhookType(typ)
	wizWebhook.Type = typStr

	return Input{
		InputWizWebhook: &wizWebhook,
		Type:            typ,
	}
}

func CreateInputNetflow(netflow InputNetflow) Input {
	typ := InputTypeNetflow

	typStr := InputNetflowType(typ)
	netflow.Type = typStr

	return Input{
		InputNetflow: &netflow,
		Type:         typ,
	}
}

func CreateInputSecurityLake(securityLake InputSecurityLake) Input {
	typ := InputTypeSecurityLake

	typStr := InputSecurityLakeType(typ)
	securityLake.Type = typStr

	return Input{
		InputSecurityLake: &securityLake,
		Type:              typ,
	}
}

func CreateInputZscalerHec(zscalerHec InputZscalerHec) Input {
	typ := InputTypeZscalerHec

	typStr := InputZscalerHecType(typ)
	zscalerHec.Type = typStr

	return Input{
		InputZscalerHec: &zscalerHec,
		Type:            typ,
	}
}

func CreateInputCloudflareHec(cloudflareHec InputCloudflareHec) Input {
	typ := InputTypeCloudflareHec

	typStr := InputCloudflareHecType(typ)
	cloudflareHec.Type = typStr

	return Input{
		InputCloudflareHec: &cloudflareHec,
		Type:               typ,
	}
}

func (u *Input) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "collection":
		inputCollection := new(InputCollection)
		if err := utils.UnmarshalJSON(data, &inputCollection, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == collection) type InputCollection within Input: %w", string(data), err)
		}

		u.InputCollection = inputCollection
		u.Type = InputTypeCollection
		return nil
	case "kafka":
		inputKafka := new(InputKafka)
		if err := utils.UnmarshalJSON(data, &inputKafka, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kafka) type InputKafka within Input: %w", string(data), err)
		}

		u.InputKafka = inputKafka
		u.Type = InputTypeKafka
		return nil
	case "msk":
		inputMsk := new(InputMsk)
		if err := utils.UnmarshalJSON(data, &inputMsk, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == msk) type InputMsk within Input: %w", string(data), err)
		}

		u.InputMsk = inputMsk
		u.Type = InputTypeMsk
		return nil
	case "http":
		inputHTTP := new(InputHTTP)
		if err := utils.UnmarshalJSON(data, &inputHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http) type InputHTTP within Input: %w", string(data), err)
		}

		u.InputHTTP = inputHTTP
		u.Type = InputTypeHTTP
		return nil
	case "splunk":
		inputSplunk := new(InputSplunk)
		if err := utils.UnmarshalJSON(data, &inputSplunk, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk) type InputSplunk within Input: %w", string(data), err)
		}

		u.InputSplunk = inputSplunk
		u.Type = InputTypeSplunk
		return nil
	case "splunk_search":
		inputSplunkSearch := new(InputSplunkSearch)
		if err := utils.UnmarshalJSON(data, &inputSplunkSearch, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk_search) type InputSplunkSearch within Input: %w", string(data), err)
		}

		u.InputSplunkSearch = inputSplunkSearch
		u.Type = InputTypeSplunkSearch
		return nil
	case "splunk_hec":
		inputSplunkHec := new(InputSplunkHec)
		if err := utils.UnmarshalJSON(data, &inputSplunkHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == splunk_hec) type InputSplunkHec within Input: %w", string(data), err)
		}

		u.InputSplunkHec = inputSplunkHec
		u.Type = InputTypeSplunkHec
		return nil
	case "azure_blob":
		inputAzureBlob := new(InputAzureBlob)
		if err := utils.UnmarshalJSON(data, &inputAzureBlob, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == azure_blob) type InputAzureBlob within Input: %w", string(data), err)
		}

		u.InputAzureBlob = inputAzureBlob
		u.Type = InputTypeAzureBlob
		return nil
	case "elastic":
		inputElastic := new(InputElastic)
		if err := utils.UnmarshalJSON(data, &inputElastic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == elastic) type InputElastic within Input: %w", string(data), err)
		}

		u.InputElastic = inputElastic
		u.Type = InputTypeElastic
		return nil
	case "confluent_cloud":
		inputConfluentCloud := new(InputConfluentCloud)
		if err := utils.UnmarshalJSON(data, &inputConfluentCloud, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == confluent_cloud) type InputConfluentCloud within Input: %w", string(data), err)
		}

		u.InputConfluentCloud = inputConfluentCloud
		u.Type = InputTypeConfluentCloud
		return nil
	case "grafana":
		inputGrafana := new(InputGrafana)
		if err := utils.UnmarshalJSON(data, &inputGrafana, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == grafana) type InputGrafana within Input: %w", string(data), err)
		}

		u.InputGrafana = inputGrafana
		u.Type = InputTypeGrafana
		return nil
	case "loki":
		inputLoki := new(InputLoki)
		if err := utils.UnmarshalJSON(data, &inputLoki, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == loki) type InputLoki within Input: %w", string(data), err)
		}

		u.InputLoki = inputLoki
		u.Type = InputTypeLoki
		return nil
	case "prometheus_rw":
		inputPrometheusRw := new(InputPrometheusRw)
		if err := utils.UnmarshalJSON(data, &inputPrometheusRw, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == prometheus_rw) type InputPrometheusRw within Input: %w", string(data), err)
		}

		u.InputPrometheusRw = inputPrometheusRw
		u.Type = InputTypePrometheusRw
		return nil
	case "prometheus":
		inputPrometheus := new(InputPrometheus)
		if err := utils.UnmarshalJSON(data, &inputPrometheus, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == prometheus) type InputPrometheus within Input: %w", string(data), err)
		}

		u.InputPrometheus = inputPrometheus
		u.Type = InputTypePrometheus
		return nil
	case "edge_prometheus":
		inputEdgePrometheus := new(InputEdgePrometheus)
		if err := utils.UnmarshalJSON(data, &inputEdgePrometheus, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == edge_prometheus) type InputEdgePrometheus within Input: %w", string(data), err)
		}

		u.InputEdgePrometheus = inputEdgePrometheus
		u.Type = InputTypeEdgePrometheus
		return nil
	case "office365_mgmt":
		inputOffice365Mgmt := new(InputOffice365Mgmt)
		if err := utils.UnmarshalJSON(data, &inputOffice365Mgmt, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_mgmt) type InputOffice365Mgmt within Input: %w", string(data), err)
		}

		u.InputOffice365Mgmt = inputOffice365Mgmt
		u.Type = InputTypeOffice365Mgmt
		return nil
	case "office365_service":
		inputOffice365Service := new(InputOffice365Service)
		if err := utils.UnmarshalJSON(data, &inputOffice365Service, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_service) type InputOffice365Service within Input: %w", string(data), err)
		}

		u.InputOffice365Service = inputOffice365Service
		u.Type = InputTypeOffice365Service
		return nil
	case "office365_msg_trace":
		inputOffice365MsgTrace := new(InputOffice365MsgTrace)
		if err := utils.UnmarshalJSON(data, &inputOffice365MsgTrace, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == office365_msg_trace) type InputOffice365MsgTrace within Input: %w", string(data), err)
		}

		u.InputOffice365MsgTrace = inputOffice365MsgTrace
		u.Type = InputTypeOffice365MsgTrace
		return nil
	case "eventhub":
		inputEventhub := new(InputEventhub)
		if err := utils.UnmarshalJSON(data, &inputEventhub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == eventhub) type InputEventhub within Input: %w", string(data), err)
		}

		u.InputEventhub = inputEventhub
		u.Type = InputTypeEventhub
		return nil
	case "exec":
		inputExec := new(InputExec)
		if err := utils.UnmarshalJSON(data, &inputExec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == exec) type InputExec within Input: %w", string(data), err)
		}

		u.InputExec = inputExec
		u.Type = InputTypeExec
		return nil
	case "firehose":
		inputFirehose := new(InputFirehose)
		if err := utils.UnmarshalJSON(data, &inputFirehose, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == firehose) type InputFirehose within Input: %w", string(data), err)
		}

		u.InputFirehose = inputFirehose
		u.Type = InputTypeFirehose
		return nil
	case "google_pubsub":
		inputGooglePubsub := new(InputGooglePubsub)
		if err := utils.UnmarshalJSON(data, &inputGooglePubsub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == google_pubsub) type InputGooglePubsub within Input: %w", string(data), err)
		}

		u.InputGooglePubsub = inputGooglePubsub
		u.Type = InputTypeGooglePubsub
		return nil
	case "cribl":
		inputCribl := new(InputCribl)
		if err := utils.UnmarshalJSON(data, &inputCribl, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl) type InputCribl within Input: %w", string(data), err)
		}

		u.InputCribl = inputCribl
		u.Type = InputTypeCribl
		return nil
	case "cribl_tcp":
		inputCriblTCP := new(InputCriblTCP)
		if err := utils.UnmarshalJSON(data, &inputCriblTCP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_tcp) type InputCriblTCP within Input: %w", string(data), err)
		}

		u.InputCriblTCP = inputCriblTCP
		u.Type = InputTypeCriblTCP
		return nil
	case "cribl_http":
		inputCriblHTTP := new(InputCriblHTTP)
		if err := utils.UnmarshalJSON(data, &inputCriblHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_http) type InputCriblHTTP within Input: %w", string(data), err)
		}

		u.InputCriblHTTP = inputCriblHTTP
		u.Type = InputTypeCriblHTTP
		return nil
	case "cribl_lake_http":
		inputCriblLakeHTTP := new(InputCriblLakeHTTP)
		if err := utils.UnmarshalJSON(data, &inputCriblLakeHTTP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cribl_lake_http) type InputCriblLakeHTTP within Input: %w", string(data), err)
		}

		u.InputCriblLakeHTTP = inputCriblLakeHTTP
		u.Type = InputTypeCriblLakeHTTP
		return nil
	case "tcpjson":
		inputTcpjson := new(InputTcpjson)
		if err := utils.UnmarshalJSON(data, &inputTcpjson, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == tcpjson) type InputTcpjson within Input: %w", string(data), err)
		}

		u.InputTcpjson = inputTcpjson
		u.Type = InputTypeTcpjson
		return nil
	case "system_metrics":
		inputSystemMetrics := new(InputSystemMetrics)
		if err := utils.UnmarshalJSON(data, &inputSystemMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == system_metrics) type InputSystemMetrics within Input: %w", string(data), err)
		}

		u.InputSystemMetrics = inputSystemMetrics
		u.Type = InputTypeSystemMetrics
		return nil
	case "system_state":
		inputSystemState := new(InputSystemState)
		if err := utils.UnmarshalJSON(data, &inputSystemState, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == system_state) type InputSystemState within Input: %w", string(data), err)
		}

		u.InputSystemState = inputSystemState
		u.Type = InputTypeSystemState
		return nil
	case "kube_metrics":
		inputKubeMetrics := new(InputKubeMetrics)
		if err := utils.UnmarshalJSON(data, &inputKubeMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_metrics) type InputKubeMetrics within Input: %w", string(data), err)
		}

		u.InputKubeMetrics = inputKubeMetrics
		u.Type = InputTypeKubeMetrics
		return nil
	case "kube_logs":
		inputKubeLogs := new(InputKubeLogs)
		if err := utils.UnmarshalJSON(data, &inputKubeLogs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_logs) type InputKubeLogs within Input: %w", string(data), err)
		}

		u.InputKubeLogs = inputKubeLogs
		u.Type = InputTypeKubeLogs
		return nil
	case "kube_events":
		inputKubeEvents := new(InputKubeEvents)
		if err := utils.UnmarshalJSON(data, &inputKubeEvents, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kube_events) type InputKubeEvents within Input: %w", string(data), err)
		}

		u.InputKubeEvents = inputKubeEvents
		u.Type = InputTypeKubeEvents
		return nil
	case "windows_metrics":
		inputWindowsMetrics := new(InputWindowsMetrics)
		if err := utils.UnmarshalJSON(data, &inputWindowsMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == windows_metrics) type InputWindowsMetrics within Input: %w", string(data), err)
		}

		u.InputWindowsMetrics = inputWindowsMetrics
		u.Type = InputTypeWindowsMetrics
		return nil
	case "crowdstrike":
		inputCrowdstrike := new(InputCrowdstrike)
		if err := utils.UnmarshalJSON(data, &inputCrowdstrike, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == crowdstrike) type InputCrowdstrike within Input: %w", string(data), err)
		}

		u.InputCrowdstrike = inputCrowdstrike
		u.Type = InputTypeCrowdstrike
		return nil
	case "datadog_agent":
		inputDatadogAgent := new(InputDatadogAgent)
		if err := utils.UnmarshalJSON(data, &inputDatadogAgent, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == datadog_agent) type InputDatadogAgent within Input: %w", string(data), err)
		}

		u.InputDatadogAgent = inputDatadogAgent
		u.Type = InputTypeDatadogAgent
		return nil
	case "datagen":
		inputDatagen := new(InputDatagen)
		if err := utils.UnmarshalJSON(data, &inputDatagen, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == datagen) type InputDatagen within Input: %w", string(data), err)
		}

		u.InputDatagen = inputDatagen
		u.Type = InputTypeDatagen
		return nil
	case "http_raw":
		inputHTTPRaw := new(InputHTTPRaw)
		if err := utils.UnmarshalJSON(data, &inputHTTPRaw, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http_raw) type InputHTTPRaw within Input: %w", string(data), err)
		}

		u.InputHTTPRaw = inputHTTPRaw
		u.Type = InputTypeHTTPRaw
		return nil
	case "kinesis":
		inputKinesis := new(InputKinesis)
		if err := utils.UnmarshalJSON(data, &inputKinesis, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == kinesis) type InputKinesis within Input: %w", string(data), err)
		}

		u.InputKinesis = inputKinesis
		u.Type = InputTypeKinesis
		return nil
	case "criblmetrics":
		inputCriblmetrics := new(InputCriblmetrics)
		if err := utils.UnmarshalJSON(data, &inputCriblmetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == criblmetrics) type InputCriblmetrics within Input: %w", string(data), err)
		}

		u.InputCriblmetrics = inputCriblmetrics
		u.Type = InputTypeCriblmetrics
		return nil
	case "metrics":
		inputMetrics := new(InputMetrics)
		if err := utils.UnmarshalJSON(data, &inputMetrics, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == metrics) type InputMetrics within Input: %w", string(data), err)
		}

		u.InputMetrics = inputMetrics
		u.Type = InputTypeMetrics
		return nil
	case "s3":
		inputS3 := new(InputS3)
		if err := utils.UnmarshalJSON(data, &inputS3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == s3) type InputS3 within Input: %w", string(data), err)
		}

		u.InputS3 = inputS3
		u.Type = InputTypeS3
		return nil
	case "s3_inventory":
		inputS3Inventory := new(InputS3Inventory)
		if err := utils.UnmarshalJSON(data, &inputS3Inventory, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == s3_inventory) type InputS3Inventory within Input: %w", string(data), err)
		}

		u.InputS3Inventory = inputS3Inventory
		u.Type = InputTypeS3Inventory
		return nil
	case "snmp":
		inputSnmp := new(InputSnmp)
		if err := utils.UnmarshalJSON(data, &inputSnmp, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == snmp) type InputSnmp within Input: %w", string(data), err)
		}

		u.InputSnmp = inputSnmp
		u.Type = InputTypeSnmp
		return nil
	case "open_telemetry":
		inputOpenTelemetry := new(InputOpenTelemetry)
		if err := utils.UnmarshalJSON(data, &inputOpenTelemetry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == open_telemetry) type InputOpenTelemetry within Input: %w", string(data), err)
		}

		u.InputOpenTelemetry = inputOpenTelemetry
		u.Type = InputTypeOpenTelemetry
		return nil
	case "model_driven_telemetry":
		inputModelDrivenTelemetry := new(InputModelDrivenTelemetry)
		if err := utils.UnmarshalJSON(data, &inputModelDrivenTelemetry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == model_driven_telemetry) type InputModelDrivenTelemetry within Input: %w", string(data), err)
		}

		u.InputModelDrivenTelemetry = inputModelDrivenTelemetry
		u.Type = InputTypeModelDrivenTelemetry
		return nil
	case "sqs":
		inputSqs := new(InputSqs)
		if err := utils.UnmarshalJSON(data, &inputSqs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == sqs) type InputSqs within Input: %w", string(data), err)
		}

		u.InputSqs = inputSqs
		u.Type = InputTypeSqs
		return nil
	case "syslog":
		inputSyslog := new(InputSyslog)
		if err := utils.UnmarshalJSON(data, &inputSyslog, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == syslog) type InputSyslog within Input: %w", string(data), err)
		}

		u.InputSyslog = inputSyslog
		u.Type = InputTypeSyslog
		return nil
	case "file":
		inputFile := new(InputFile)
		if err := utils.UnmarshalJSON(data, &inputFile, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == file) type InputFile within Input: %w", string(data), err)
		}

		u.InputFile = inputFile
		u.Type = InputTypeFile
		return nil
	case "tcp":
		inputTCP := new(InputTCP)
		if err := utils.UnmarshalJSON(data, &inputTCP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == tcp) type InputTCP within Input: %w", string(data), err)
		}

		u.InputTCP = inputTCP
		u.Type = InputTypeTCP
		return nil
	case "appscope":
		inputAppscope := new(InputAppscope)
		if err := utils.UnmarshalJSON(data, &inputAppscope, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == appscope) type InputAppscope within Input: %w", string(data), err)
		}

		u.InputAppscope = inputAppscope
		u.Type = InputTypeAppscope
		return nil
	case "wef":
		inputWef := new(InputWef)
		if err := utils.UnmarshalJSON(data, &inputWef, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wef) type InputWef within Input: %w", string(data), err)
		}

		u.InputWef = inputWef
		u.Type = InputTypeWef
		return nil
	case "win_event_logs":
		inputWinEventLogs := new(InputWinEventLogs)
		if err := utils.UnmarshalJSON(data, &inputWinEventLogs, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == win_event_logs) type InputWinEventLogs within Input: %w", string(data), err)
		}

		u.InputWinEventLogs = inputWinEventLogs
		u.Type = InputTypeWinEventLogs
		return nil
	case "raw_udp":
		inputRawUDP := new(InputRawUDP)
		if err := utils.UnmarshalJSON(data, &inputRawUDP, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == raw_udp) type InputRawUDP within Input: %w", string(data), err)
		}

		u.InputRawUDP = inputRawUDP
		u.Type = InputTypeRawUDP
		return nil
	case "journal_files":
		inputJournalFiles := new(InputJournalFiles)
		if err := utils.UnmarshalJSON(data, &inputJournalFiles, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == journal_files) type InputJournalFiles within Input: %w", string(data), err)
		}

		u.InputJournalFiles = inputJournalFiles
		u.Type = InputTypeJournalFiles
		return nil
	case "wiz":
		inputWiz := new(InputWiz)
		if err := utils.UnmarshalJSON(data, &inputWiz, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wiz) type InputWiz within Input: %w", string(data), err)
		}

		u.InputWiz = inputWiz
		u.Type = InputTypeWiz
		return nil
	case "wiz_webhook":
		inputWizWebhook := new(InputWizWebhook)
		if err := utils.UnmarshalJSON(data, &inputWizWebhook, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == wiz_webhook) type InputWizWebhook within Input: %w", string(data), err)
		}

		u.InputWizWebhook = inputWizWebhook
		u.Type = InputTypeWizWebhook
		return nil
	case "netflow":
		inputNetflow := new(InputNetflow)
		if err := utils.UnmarshalJSON(data, &inputNetflow, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == netflow) type InputNetflow within Input: %w", string(data), err)
		}

		u.InputNetflow = inputNetflow
		u.Type = InputTypeNetflow
		return nil
	case "security_lake":
		inputSecurityLake := new(InputSecurityLake)
		if err := utils.UnmarshalJSON(data, &inputSecurityLake, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == security_lake) type InputSecurityLake within Input: %w", string(data), err)
		}

		u.InputSecurityLake = inputSecurityLake
		u.Type = InputTypeSecurityLake
		return nil
	case "zscaler_hec":
		inputZscalerHec := new(InputZscalerHec)
		if err := utils.UnmarshalJSON(data, &inputZscalerHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == zscaler_hec) type InputZscalerHec within Input: %w", string(data), err)
		}

		u.InputZscalerHec = inputZscalerHec
		u.Type = InputTypeZscalerHec
		return nil
	case "cloudflare_hec":
		inputCloudflareHec := new(InputCloudflareHec)
		if err := utils.UnmarshalJSON(data, &inputCloudflareHec, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cloudflare_hec) type InputCloudflareHec within Input: %w", string(data), err)
		}

		u.InputCloudflareHec = inputCloudflareHec
		u.Type = InputTypeCloudflareHec
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Input", string(data))
}

func (u Input) MarshalJSON() ([]byte, error) {
	if u.InputCollection != nil {
		return utils.MarshalJSON(u.InputCollection, "", true)
	}

	if u.InputKafka != nil {
		return utils.MarshalJSON(u.InputKafka, "", true)
	}

	if u.InputMsk != nil {
		return utils.MarshalJSON(u.InputMsk, "", true)
	}

	if u.InputHTTP != nil {
		return utils.MarshalJSON(u.InputHTTP, "", true)
	}

	if u.InputSplunk != nil {
		return utils.MarshalJSON(u.InputSplunk, "", true)
	}

	if u.InputSplunkSearch != nil {
		return utils.MarshalJSON(u.InputSplunkSearch, "", true)
	}

	if u.InputSplunkHec != nil {
		return utils.MarshalJSON(u.InputSplunkHec, "", true)
	}

	if u.InputAzureBlob != nil {
		return utils.MarshalJSON(u.InputAzureBlob, "", true)
	}

	if u.InputElastic != nil {
		return utils.MarshalJSON(u.InputElastic, "", true)
	}

	if u.InputConfluentCloud != nil {
		return utils.MarshalJSON(u.InputConfluentCloud, "", true)
	}

	if u.InputGrafana != nil {
		return utils.MarshalJSON(u.InputGrafana, "", true)
	}

	if u.InputLoki != nil {
		return utils.MarshalJSON(u.InputLoki, "", true)
	}

	if u.InputPrometheusRw != nil {
		return utils.MarshalJSON(u.InputPrometheusRw, "", true)
	}

	if u.InputPrometheus != nil {
		return utils.MarshalJSON(u.InputPrometheus, "", true)
	}

	if u.InputEdgePrometheus != nil {
		return utils.MarshalJSON(u.InputEdgePrometheus, "", true)
	}

	if u.InputOffice365Mgmt != nil {
		return utils.MarshalJSON(u.InputOffice365Mgmt, "", true)
	}

	if u.InputOffice365Service != nil {
		return utils.MarshalJSON(u.InputOffice365Service, "", true)
	}

	if u.InputOffice365MsgTrace != nil {
		return utils.MarshalJSON(u.InputOffice365MsgTrace, "", true)
	}

	if u.InputEventhub != nil {
		return utils.MarshalJSON(u.InputEventhub, "", true)
	}

	if u.InputExec != nil {
		return utils.MarshalJSON(u.InputExec, "", true)
	}

	if u.InputFirehose != nil {
		return utils.MarshalJSON(u.InputFirehose, "", true)
	}

	if u.InputGooglePubsub != nil {
		return utils.MarshalJSON(u.InputGooglePubsub, "", true)
	}

	if u.InputCribl != nil {
		return utils.MarshalJSON(u.InputCribl, "", true)
	}

	if u.InputCriblTCP != nil {
		return utils.MarshalJSON(u.InputCriblTCP, "", true)
	}

	if u.InputCriblHTTP != nil {
		return utils.MarshalJSON(u.InputCriblHTTP, "", true)
	}

	if u.InputCriblLakeHTTP != nil {
		return utils.MarshalJSON(u.InputCriblLakeHTTP, "", true)
	}

	if u.InputTcpjson != nil {
		return utils.MarshalJSON(u.InputTcpjson, "", true)
	}

	if u.InputSystemMetrics != nil {
		return utils.MarshalJSON(u.InputSystemMetrics, "", true)
	}

	if u.InputSystemState != nil {
		return utils.MarshalJSON(u.InputSystemState, "", true)
	}

	if u.InputKubeMetrics != nil {
		return utils.MarshalJSON(u.InputKubeMetrics, "", true)
	}

	if u.InputKubeLogs != nil {
		return utils.MarshalJSON(u.InputKubeLogs, "", true)
	}

	if u.InputKubeEvents != nil {
		return utils.MarshalJSON(u.InputKubeEvents, "", true)
	}

	if u.InputWindowsMetrics != nil {
		return utils.MarshalJSON(u.InputWindowsMetrics, "", true)
	}

	if u.InputCrowdstrike != nil {
		return utils.MarshalJSON(u.InputCrowdstrike, "", true)
	}

	if u.InputDatadogAgent != nil {
		return utils.MarshalJSON(u.InputDatadogAgent, "", true)
	}

	if u.InputDatagen != nil {
		return utils.MarshalJSON(u.InputDatagen, "", true)
	}

	if u.InputHTTPRaw != nil {
		return utils.MarshalJSON(u.InputHTTPRaw, "", true)
	}

	if u.InputKinesis != nil {
		return utils.MarshalJSON(u.InputKinesis, "", true)
	}

	if u.InputCriblmetrics != nil {
		return utils.MarshalJSON(u.InputCriblmetrics, "", true)
	}

	if u.InputMetrics != nil {
		return utils.MarshalJSON(u.InputMetrics, "", true)
	}

	if u.InputS3 != nil {
		return utils.MarshalJSON(u.InputS3, "", true)
	}

	if u.InputS3Inventory != nil {
		return utils.MarshalJSON(u.InputS3Inventory, "", true)
	}

	if u.InputSnmp != nil {
		return utils.MarshalJSON(u.InputSnmp, "", true)
	}

	if u.InputOpenTelemetry != nil {
		return utils.MarshalJSON(u.InputOpenTelemetry, "", true)
	}

	if u.InputModelDrivenTelemetry != nil {
		return utils.MarshalJSON(u.InputModelDrivenTelemetry, "", true)
	}

	if u.InputSqs != nil {
		return utils.MarshalJSON(u.InputSqs, "", true)
	}

	if u.InputSyslog != nil {
		return utils.MarshalJSON(u.InputSyslog, "", true)
	}

	if u.InputFile != nil {
		return utils.MarshalJSON(u.InputFile, "", true)
	}

	if u.InputTCP != nil {
		return utils.MarshalJSON(u.InputTCP, "", true)
	}

	if u.InputAppscope != nil {
		return utils.MarshalJSON(u.InputAppscope, "", true)
	}

	if u.InputWef != nil {
		return utils.MarshalJSON(u.InputWef, "", true)
	}

	if u.InputWinEventLogs != nil {
		return utils.MarshalJSON(u.InputWinEventLogs, "", true)
	}

	if u.InputRawUDP != nil {
		return utils.MarshalJSON(u.InputRawUDP, "", true)
	}

	if u.InputJournalFiles != nil {
		return utils.MarshalJSON(u.InputJournalFiles, "", true)
	}

	if u.InputWiz != nil {
		return utils.MarshalJSON(u.InputWiz, "", true)
	}

	if u.InputWizWebhook != nil {
		return utils.MarshalJSON(u.InputWizWebhook, "", true)
	}

	if u.InputNetflow != nil {
		return utils.MarshalJSON(u.InputNetflow, "", true)
	}

	if u.InputSecurityLake != nil {
		return utils.MarshalJSON(u.InputSecurityLake, "", true)
	}

	if u.InputZscalerHec != nil {
		return utils.MarshalJSON(u.InputZscalerHec, "", true)
	}

	if u.InputCloudflareHec != nil {
		return utils.MarshalJSON(u.InputCloudflareHec, "", true)
	}

	return nil, errors.New("could not marshal union type Input: all fields are null")
}
