// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type InputLokiLoki10 struct {
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL string `json:"loginUrl"`
	// Secret parameter name to pass in request body
	SecretParamName string `json:"secretParamName"`
	// Secret parameter value to pass in request body
	Secret string `json:"secret"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName string `json:"tokenAttributeName"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders"`
}

func (i InputLokiLoki10) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki10) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "port", "loginUrl", "secretParamName", "secret", "tokenAttributeName", "oauthParams", "oauthHeaders"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki10) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki10) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki10) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki10) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki10) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki10) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki10) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki10) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki10) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki10) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki10) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki10) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki10) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki10) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki10) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki10) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki10) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki10) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki10) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki10) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki10) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki10) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki10) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki10) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki10) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki10) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki10) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki10) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki10) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki10) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki10) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki10) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki10) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki10) GetLoginURL() string {
	if i == nil {
		return ""
	}
	return i.LoginURL
}

func (i *InputLokiLoki10) GetSecretParamName() string {
	if i == nil {
		return ""
	}
	return i.SecretParamName
}

func (i *InputLokiLoki10) GetSecret() string {
	if i == nil {
		return ""
	}
	return i.Secret
}

func (i *InputLokiLoki10) GetTokenAttributeName() string {
	if i == nil {
		return ""
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki10) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki10) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki10) GetOauthParams() []Metadata1Type {
	if i == nil {
		return []Metadata1Type{}
	}
	return i.OauthParams
}

func (i *InputLokiLoki10) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return []Metadata1Type{}
	}
	return i.OauthHeaders
}

type InputLokiLoki9 struct {
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret string `json:"textSecret"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki9) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki9) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "port", "textSecret"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki9) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki9) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki9) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki9) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki9) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki9) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki9) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki9) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki9) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki9) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki9) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki9) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki9) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki9) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki9) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki9) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki9) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki9) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki9) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki9) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki9) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki9) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki9) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki9) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki9) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki9) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki9) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki9) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki9) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki9) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki9) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki9) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki9) GetTextSecret() string {
	if i == nil {
		return ""
	}
	return i.TextSecret
}

func (i *InputLokiLoki9) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki9) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki9) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki9) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki9) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki9) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki9) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki9) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiLoki8 struct {
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret string `json:"credentialsSecret"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki8) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki8) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "port", "credentialsSecret"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki8) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki8) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki8) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki8) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki8) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki8) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki8) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki8) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki8) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki8) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki8) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki8) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki8) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki8) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki8) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki8) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki8) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki8) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki8) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki8) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki8) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki8) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki8) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki8) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki8) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki8) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki8) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki8) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki8) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki8) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki8) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki8) GetCredentialsSecret() string {
	if i == nil {
		return ""
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki8) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki8) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki8) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki8) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki8) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki8) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki8) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki8) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki8) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiLoki7 struct {
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token string `json:"token"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki7) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki7) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "port", "token"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki7) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki7) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki7) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki7) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki7) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki7) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki7) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki7) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki7) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki7) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki7) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki7) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki7) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki7) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki7) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki7) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki7) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki7) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki7) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki7) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki7) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki7) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki7) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki7) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki7) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki7) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki7) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki7) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki7) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki7) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki7) GetToken() string {
	if i == nil {
		return ""
	}
	return i.Token
}

func (i *InputLokiLoki7) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki7) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki7) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki7) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki7) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki7) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki7) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki7) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki7) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki7) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiLoki6 struct {
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    string          `json:"username"`
	Password    string          `json:"password"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki6) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki6) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "port", "username", "password"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki6) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki6) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki6) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki6) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki6) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki6) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki6) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki6) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki6) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki6) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki6) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki6) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki6) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki6) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki6) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki6) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki6) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki6) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki6) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki6) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki6) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki6) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki6) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki6) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki6) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki6) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki6) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki6) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki6) GetUsername() string {
	if i == nil {
		return ""
	}
	return i.Username
}

func (i *InputLokiLoki6) GetPassword() string {
	if i == nil {
		return ""
	}
	return i.Password
}

func (i *InputLokiLoki6) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki6) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki6) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki6) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki6) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki6) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki6) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki6) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki6) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki6) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki6) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiLoki5 struct {
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki5) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki5) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki5) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki5) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki5) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki5) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki5) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki5) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki5) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki5) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki5) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki5) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki5) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki5) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki5) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki5) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki5) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki5) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki5) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki5) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki5) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki5) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki5) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki5) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki5) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki5) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki5) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki5) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki5) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki5) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki5) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki5) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki5) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki5) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki5) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki5) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki5) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki5) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki5) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki5) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki5) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki5) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki5) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiLoki4 struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          PqType            `json:"pq"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "pq", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki4) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki4) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki4) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki4) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki4) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki4) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki4) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki4) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki4) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki4) GetPq() PqType {
	if i == nil {
		return PqType{}
	}
	return i.Pq
}

func (i *InputLokiLoki4) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki4) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki4) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki4) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki4) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki4) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki4) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki4) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki4) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki4) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki4) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki4) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki4) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki4) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki4) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki4) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki4) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki4) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki4) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki4) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki4) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki4) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki4) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki4) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki4) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki4) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki4) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki4) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki4) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki4) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki4) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiLoki3 struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki3) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki3) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki3) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki3) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki3) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki3) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki3) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki3) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki3) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki3) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki3) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki3) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki3) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki3) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki3) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki3) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki3) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki3) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki3) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki3) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki3) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki3) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki3) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki3) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki3) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki3) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki3) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki3) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki3) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki3) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki3) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki3) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki3) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki3) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki3) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki3) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki3) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki3) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki3) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki3) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki3) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiLoki2 struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "connections", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki2) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki2) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki2) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki2) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki2) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki2) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki2) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki2) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki2) GetConnections() []ConnectionsType {
	if i == nil {
		return []ConnectionsType{}
	}
	return i.Connections
}

func (i *InputLokiLoki2) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki2) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki2) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki2) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki2) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki2) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki2) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki2) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki2) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki2) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki2) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki2) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki2) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki2) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki2) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki2) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki2) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki2) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki2) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki2) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki2) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki2) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki2) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki2) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki2) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki2) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki2) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki2) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki2) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki2) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki2) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki2) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiLoki1 struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Unique ID for this input
	ID       *string        `json:"id,omitempty"`
	Type     TypeLokiOption `json:"type"`
	Disabled *bool          `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ConnectionsType `json:"connections,omitempty"`
	Pq          *PqType           `json:"pq,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `default:"0.0.0.0" json:"host"`
	// Port to listen on
	Port float64   `json:"port"`
	TLS  *Tls2Type `json:"tls,omitempty"`
	// Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
	MaxActiveReq *float64 `default:"256" json:"maxActiveReq"`
	// Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int64 `default:"0" json:"maxRequestsPerSocket"`
	// Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
	EnableProxyHeader *bool `default:"false" json:"enableProxyHeader"`
	// Add request headers to events, in the __headers field
	CaptureHeaders *bool `default:"false" json:"captureHeaders"`
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float64 `default:"100" json:"activityLogSampleRate"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float64 `default:"0" json:"requestTimeout"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float64 `default:"0" json:"socketTimeout"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
	KeepAliveTimeout *float64 `default:"5" json:"keepAliveTimeout"`
	// Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `default:"false" json:"enableHealthCheck"`
	// Messages from matched IP addresses will be processed, unless also matched by the denylist
	IPAllowlistRegex *string `default:"/.*/" json:"ipAllowlistRegex"`
	// Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IPDenylistRegex *string `default:"/^\\$/" json:"ipDenylistRegex"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI *string `default:"/loki/api/v1/push" json:"lokiAPI"`
	// Splunk Search authentication type
	AuthType *AuthTypeOptions `default:"basic" json:"authType"`
	// Fields to add to events from this input
	Metadata    []Metadata1Type `json:"metadata,omitempty"`
	Description *string         `json:"description,omitempty"`
	Username    *string         `json:"username,omitempty"`
	Password    *string         `json:"password,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `default:"Bearer \\${token}" json:"authHeaderExpr"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float64 `default:"3600" json:"tokenTimeoutSecs"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Metadata1Type `json:"oauthParams,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Metadata1Type `json:"oauthHeaders,omitempty"`
}

func (i InputLokiLoki1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputLokiLoki1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "port"}); err != nil {
		return err
	}
	return nil
}

func (i *InputLokiLoki1) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputLokiLoki1) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputLokiLoki1) GetType() TypeLokiOption {
	if i == nil {
		return TypeLokiOption("")
	}
	return i.Type
}

func (i *InputLokiLoki1) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputLokiLoki1) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputLokiLoki1) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputLokiLoki1) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputLokiLoki1) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputLokiLoki1) GetConnections() []ConnectionsType {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputLokiLoki1) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputLokiLoki1) GetHost() *string {
	if i == nil {
		return nil
	}
	return i.Host
}

func (i *InputLokiLoki1) GetPort() float64 {
	if i == nil {
		return 0.0
	}
	return i.Port
}

func (i *InputLokiLoki1) GetTLS() *Tls2Type {
	if i == nil {
		return nil
	}
	return i.TLS
}

func (i *InputLokiLoki1) GetMaxActiveReq() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxActiveReq
}

func (i *InputLokiLoki1) GetMaxRequestsPerSocket() *int64 {
	if i == nil {
		return nil
	}
	return i.MaxRequestsPerSocket
}

func (i *InputLokiLoki1) GetEnableProxyHeader() *bool {
	if i == nil {
		return nil
	}
	return i.EnableProxyHeader
}

func (i *InputLokiLoki1) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputLokiLoki1) GetActivityLogSampleRate() *float64 {
	if i == nil {
		return nil
	}
	return i.ActivityLogSampleRate
}

func (i *InputLokiLoki1) GetRequestTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.RequestTimeout
}

func (i *InputLokiLoki1) GetSocketTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.SocketTimeout
}

func (i *InputLokiLoki1) GetKeepAliveTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.KeepAliveTimeout
}

func (i *InputLokiLoki1) GetEnableHealthCheck() *bool {
	if i == nil {
		return nil
	}
	return i.EnableHealthCheck
}

func (i *InputLokiLoki1) GetIPAllowlistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPAllowlistRegex
}

func (i *InputLokiLoki1) GetIPDenylistRegex() *string {
	if i == nil {
		return nil
	}
	return i.IPDenylistRegex
}

func (i *InputLokiLoki1) GetLokiAPI() *string {
	if i == nil {
		return nil
	}
	return i.LokiAPI
}

func (i *InputLokiLoki1) GetAuthType() *AuthTypeOptions {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputLokiLoki1) GetMetadata() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputLokiLoki1) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputLokiLoki1) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputLokiLoki1) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputLokiLoki1) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputLokiLoki1) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputLokiLoki1) GetTextSecret() *string {
	if i == nil {
		return nil
	}
	return i.TextSecret
}

func (i *InputLokiLoki1) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputLokiLoki1) GetSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.SecretParamName
}

func (i *InputLokiLoki1) GetSecret() *string {
	if i == nil {
		return nil
	}
	return i.Secret
}

func (i *InputLokiLoki1) GetTokenAttributeName() *string {
	if i == nil {
		return nil
	}
	return i.TokenAttributeName
}

func (i *InputLokiLoki1) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputLokiLoki1) GetTokenTimeoutSecs() *float64 {
	if i == nil {
		return nil
	}
	return i.TokenTimeoutSecs
}

func (i *InputLokiLoki1) GetOauthParams() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthParams
}

func (i *InputLokiLoki1) GetOauthHeaders() []Metadata1Type {
	if i == nil {
		return nil
	}
	return i.OauthHeaders
}

type InputLokiType string

const (
	InputLokiTypeInputLokiLoki1  InputLokiType = "InputLoki_Loki_1"
	InputLokiTypeInputLokiLoki2  InputLokiType = "InputLoki_Loki_2"
	InputLokiTypeInputLokiLoki3  InputLokiType = "InputLoki_Loki_3"
	InputLokiTypeInputLokiLoki4  InputLokiType = "InputLoki_Loki_4"
	InputLokiTypeInputLokiLoki5  InputLokiType = "InputLoki_Loki_5"
	InputLokiTypeInputLokiLoki6  InputLokiType = "InputLoki_Loki_6"
	InputLokiTypeInputLokiLoki7  InputLokiType = "InputLoki_Loki_7"
	InputLokiTypeInputLokiLoki8  InputLokiType = "InputLoki_Loki_8"
	InputLokiTypeInputLokiLoki9  InputLokiType = "InputLoki_Loki_9"
	InputLokiTypeInputLokiLoki10 InputLokiType = "InputLoki_Loki_10"
)

type InputLoki struct {
	InputLokiLoki1  *InputLokiLoki1  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki2  *InputLokiLoki2  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki3  *InputLokiLoki3  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki4  *InputLokiLoki4  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki5  *InputLokiLoki5  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki6  *InputLokiLoki6  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki7  *InputLokiLoki7  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki8  *InputLokiLoki8  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki9  *InputLokiLoki9  `queryParam:"inline,name=InputLoki"`
	InputLokiLoki10 *InputLokiLoki10 `queryParam:"inline,name=InputLoki"`

	Type InputLokiType
}

func CreateInputLokiInputLokiLoki1(inputLokiLoki1 InputLokiLoki1) InputLoki {
	typ := InputLokiTypeInputLokiLoki1

	return InputLoki{
		InputLokiLoki1: &inputLokiLoki1,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki2(inputLokiLoki2 InputLokiLoki2) InputLoki {
	typ := InputLokiTypeInputLokiLoki2

	return InputLoki{
		InputLokiLoki2: &inputLokiLoki2,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki3(inputLokiLoki3 InputLokiLoki3) InputLoki {
	typ := InputLokiTypeInputLokiLoki3

	return InputLoki{
		InputLokiLoki3: &inputLokiLoki3,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki4(inputLokiLoki4 InputLokiLoki4) InputLoki {
	typ := InputLokiTypeInputLokiLoki4

	return InputLoki{
		InputLokiLoki4: &inputLokiLoki4,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki5(inputLokiLoki5 InputLokiLoki5) InputLoki {
	typ := InputLokiTypeInputLokiLoki5

	return InputLoki{
		InputLokiLoki5: &inputLokiLoki5,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki6(inputLokiLoki6 InputLokiLoki6) InputLoki {
	typ := InputLokiTypeInputLokiLoki6

	return InputLoki{
		InputLokiLoki6: &inputLokiLoki6,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki7(inputLokiLoki7 InputLokiLoki7) InputLoki {
	typ := InputLokiTypeInputLokiLoki7

	return InputLoki{
		InputLokiLoki7: &inputLokiLoki7,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki8(inputLokiLoki8 InputLokiLoki8) InputLoki {
	typ := InputLokiTypeInputLokiLoki8

	return InputLoki{
		InputLokiLoki8: &inputLokiLoki8,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki9(inputLokiLoki9 InputLokiLoki9) InputLoki {
	typ := InputLokiTypeInputLokiLoki9

	return InputLoki{
		InputLokiLoki9: &inputLokiLoki9,
		Type:           typ,
	}
}

func CreateInputLokiInputLokiLoki10(inputLokiLoki10 InputLokiLoki10) InputLoki {
	typ := InputLokiTypeInputLokiLoki10

	return InputLoki{
		InputLokiLoki10: &inputLokiLoki10,
		Type:            typ,
	}
}

func (u *InputLoki) UnmarshalJSON(data []byte) error {

	var inputLokiLoki10 InputLokiLoki10 = InputLokiLoki10{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki10, "", true, nil); err == nil {
		u.InputLokiLoki10 = &inputLokiLoki10
		u.Type = InputLokiTypeInputLokiLoki10
		return nil
	}

	var inputLokiLoki6 InputLokiLoki6 = InputLokiLoki6{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki6, "", true, nil); err == nil {
		u.InputLokiLoki6 = &inputLokiLoki6
		u.Type = InputLokiTypeInputLokiLoki6
		return nil
	}

	var inputLokiLoki2 InputLokiLoki2 = InputLokiLoki2{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki2, "", true, nil); err == nil {
		u.InputLokiLoki2 = &inputLokiLoki2
		u.Type = InputLokiTypeInputLokiLoki2
		return nil
	}

	var inputLokiLoki4 InputLokiLoki4 = InputLokiLoki4{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki4, "", true, nil); err == nil {
		u.InputLokiLoki4 = &inputLokiLoki4
		u.Type = InputLokiTypeInputLokiLoki4
		return nil
	}

	var inputLokiLoki7 InputLokiLoki7 = InputLokiLoki7{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki7, "", true, nil); err == nil {
		u.InputLokiLoki7 = &inputLokiLoki7
		u.Type = InputLokiTypeInputLokiLoki7
		return nil
	}

	var inputLokiLoki8 InputLokiLoki8 = InputLokiLoki8{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki8, "", true, nil); err == nil {
		u.InputLokiLoki8 = &inputLokiLoki8
		u.Type = InputLokiTypeInputLokiLoki8
		return nil
	}

	var inputLokiLoki9 InputLokiLoki9 = InputLokiLoki9{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki9, "", true, nil); err == nil {
		u.InputLokiLoki9 = &inputLokiLoki9
		u.Type = InputLokiTypeInputLokiLoki9
		return nil
	}

	var inputLokiLoki1 InputLokiLoki1 = InputLokiLoki1{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki1, "", true, nil); err == nil {
		u.InputLokiLoki1 = &inputLokiLoki1
		u.Type = InputLokiTypeInputLokiLoki1
		return nil
	}

	var inputLokiLoki3 InputLokiLoki3 = InputLokiLoki3{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki3, "", true, nil); err == nil {
		u.InputLokiLoki3 = &inputLokiLoki3
		u.Type = InputLokiTypeInputLokiLoki3
		return nil
	}

	var inputLokiLoki5 InputLokiLoki5 = InputLokiLoki5{}
	if err := utils.UnmarshalJSON(data, &inputLokiLoki5, "", true, nil); err == nil {
		u.InputLokiLoki5 = &inputLokiLoki5
		u.Type = InputLokiTypeInputLokiLoki5
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputLoki", string(data))
}

func (u InputLoki) MarshalJSON() ([]byte, error) {
	if u.InputLokiLoki1 != nil {
		return utils.MarshalJSON(u.InputLokiLoki1, "", true)
	}

	if u.InputLokiLoki2 != nil {
		return utils.MarshalJSON(u.InputLokiLoki2, "", true)
	}

	if u.InputLokiLoki3 != nil {
		return utils.MarshalJSON(u.InputLokiLoki3, "", true)
	}

	if u.InputLokiLoki4 != nil {
		return utils.MarshalJSON(u.InputLokiLoki4, "", true)
	}

	if u.InputLokiLoki5 != nil {
		return utils.MarshalJSON(u.InputLokiLoki5, "", true)
	}

	if u.InputLokiLoki6 != nil {
		return utils.MarshalJSON(u.InputLokiLoki6, "", true)
	}

	if u.InputLokiLoki7 != nil {
		return utils.MarshalJSON(u.InputLokiLoki7, "", true)
	}

	if u.InputLokiLoki8 != nil {
		return utils.MarshalJSON(u.InputLokiLoki8, "", true)
	}

	if u.InputLokiLoki9 != nil {
		return utils.MarshalJSON(u.InputLokiLoki9, "", true)
	}

	if u.InputLokiLoki10 != nil {
		return utils.MarshalJSON(u.InputLokiLoki10, "", true)
	}

	return nil, errors.New("could not marshal union type InputLoki: all fields are null")
}
