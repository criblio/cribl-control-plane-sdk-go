// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
// @generated-id: ab16cac9a4e7

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// AzureBlobAuthTypeClientCertAuthenticationMethod - Enter authentication data directly, or select a secret referencing your auth data
type AzureBlobAuthTypeClientCertAuthenticationMethod string

const (
	AzureBlobAuthTypeClientCertAuthenticationMethodManual       AzureBlobAuthTypeClientCertAuthenticationMethod = "manual"
	AzureBlobAuthTypeClientCertAuthenticationMethodSecret       AzureBlobAuthTypeClientCertAuthenticationMethod = "secret"
	AzureBlobAuthTypeClientCertAuthenticationMethodClientSecret AzureBlobAuthTypeClientCertAuthenticationMethod = "clientSecret"
	AzureBlobAuthTypeClientCertAuthenticationMethodClientCert   AzureBlobAuthTypeClientCertAuthenticationMethod = "clientCert"
)

func (e AzureBlobAuthTypeClientCertAuthenticationMethod) ToPointer() *AzureBlobAuthTypeClientCertAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *AzureBlobAuthTypeClientCertAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "clientSecret", "clientCert":
			return true
		}
	}
	return false
}

type AzureBlobAuthTypeClientCertExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// A JavaScript expression that accesses a corresponding <token> through the value variable and evaluates the token to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (a AzureBlobAuthTypeClientCertExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBlobAuthTypeClientCertExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzureBlobAuthTypeClientCertExtractor) GetKey() string {
	if a == nil {
		return ""
	}
	return a.Key
}

func (a *AzureBlobAuthTypeClientCertExtractor) GetExpression() string {
	if a == nil {
		return ""
	}
	return a.Expression
}

type AzureBlobAuthTypeClientCert struct {
	// Enter authentication data directly, or select a secret referencing your auth data
	AuthType *AzureBlobAuthTypeClientCertAuthenticationMethod `json:"authType,omitempty"`
	// The name of your Azure storage account
	StorageAccountName string `json:"storageAccountName"`
	// The service principal's tenant ID
	TenantID string `json:"tenantId"`
	// The service principal's client ID
	ClientID    string                                     `json:"clientId"`
	Certificate CertificateTypeAzureBlobAuthTypeClientCert `json:"certificate"`
	// The Azure cloud to use. Defaults to Azure Public Cloud.
	AzureCloud *string `json:"azureCloud,omitempty"`
	// The endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
	EndpointSuffix *string `json:"endpointSuffix,omitempty"`
	// An optional predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// Container to collect from. This value can be a constant, or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: myBucket-${C.vars.myVar}
	ContainerName string `json:"containerName"`
	// The directory from which to collect data. Templating is supported, such as myDir/${datacenter}/${host}/${app}/. Time-based tokens are supported, such as myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/.
	Path *string `json:"path,omitempty"`
	// Extractors allow use of template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)} will enrich discovery results with a human-readable "date" field.
	Extractors []AzureBlobAuthTypeClientCertExtractor `json:"extractors,omitempty"`
	// Recurse through subdirectories
	Recurse *bool `json:"recurse,omitempty"`
	// Include Azure Blob metadata in collected events. In each event, metadata will be located at: __collectible.metadata.
	IncludeMetadata *bool `json:"includeMetadata,omitempty"`
	// Include Azure Blob tags in collected events. In each event, tags will be located at: __collectible.tags. Disable this feature when using a Shared Access Signature Connection String, to prevent errors.
	IncludeTags *bool `json:"includeTags,omitempty"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `json:"maxBatchSize,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `json:"parquetChunkDownloadTimeout,omitempty"`
}

func (a AzureBlobAuthTypeClientCert) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBlobAuthTypeClientCert) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzureBlobAuthTypeClientCert) GetAuthType() *AzureBlobAuthTypeClientCertAuthenticationMethod {
	if a == nil {
		return nil
	}
	return a.AuthType
}

func (a *AzureBlobAuthTypeClientCert) GetStorageAccountName() string {
	if a == nil {
		return ""
	}
	return a.StorageAccountName
}

func (a *AzureBlobAuthTypeClientCert) GetTenantID() string {
	if a == nil {
		return ""
	}
	return a.TenantID
}

func (a *AzureBlobAuthTypeClientCert) GetClientID() string {
	if a == nil {
		return ""
	}
	return a.ClientID
}

func (a *AzureBlobAuthTypeClientCert) GetCertificate() CertificateTypeAzureBlobAuthTypeClientCert {
	if a == nil {
		return CertificateTypeAzureBlobAuthTypeClientCert{}
	}
	return a.Certificate
}

func (a *AzureBlobAuthTypeClientCert) GetAzureCloud() *string {
	if a == nil {
		return nil
	}
	return a.AzureCloud
}

func (a *AzureBlobAuthTypeClientCert) GetEndpointSuffix() *string {
	if a == nil {
		return nil
	}
	return a.EndpointSuffix
}

func (a *AzureBlobAuthTypeClientCert) GetOutputName() *string {
	if a == nil {
		return nil
	}
	return a.OutputName
}

func (a *AzureBlobAuthTypeClientCert) GetContainerName() string {
	if a == nil {
		return ""
	}
	return a.ContainerName
}

func (a *AzureBlobAuthTypeClientCert) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

func (a *AzureBlobAuthTypeClientCert) GetExtractors() []AzureBlobAuthTypeClientCertExtractor {
	if a == nil {
		return nil
	}
	return a.Extractors
}

func (a *AzureBlobAuthTypeClientCert) GetRecurse() *bool {
	if a == nil {
		return nil
	}
	return a.Recurse
}

func (a *AzureBlobAuthTypeClientCert) GetIncludeMetadata() *bool {
	if a == nil {
		return nil
	}
	return a.IncludeMetadata
}

func (a *AzureBlobAuthTypeClientCert) GetIncludeTags() *bool {
	if a == nil {
		return nil
	}
	return a.IncludeTags
}

func (a *AzureBlobAuthTypeClientCert) GetMaxBatchSize() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxBatchSize
}

func (a *AzureBlobAuthTypeClientCert) GetParquetChunkSizeMB() *float64 {
	if a == nil {
		return nil
	}
	return a.ParquetChunkSizeMB
}

func (a *AzureBlobAuthTypeClientCert) GetParquetChunkDownloadTimeout() *float64 {
	if a == nil {
		return nil
	}
	return a.ParquetChunkDownloadTimeout
}

// AzureBlobAuthTypeClientSecretAuthenticationMethod - Enter authentication data directly, or select a secret referencing your auth data
type AzureBlobAuthTypeClientSecretAuthenticationMethod string

const (
	AzureBlobAuthTypeClientSecretAuthenticationMethodManual       AzureBlobAuthTypeClientSecretAuthenticationMethod = "manual"
	AzureBlobAuthTypeClientSecretAuthenticationMethodSecret       AzureBlobAuthTypeClientSecretAuthenticationMethod = "secret"
	AzureBlobAuthTypeClientSecretAuthenticationMethodClientSecret AzureBlobAuthTypeClientSecretAuthenticationMethod = "clientSecret"
	AzureBlobAuthTypeClientSecretAuthenticationMethodClientCert   AzureBlobAuthTypeClientSecretAuthenticationMethod = "clientCert"
)

func (e AzureBlobAuthTypeClientSecretAuthenticationMethod) ToPointer() *AzureBlobAuthTypeClientSecretAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *AzureBlobAuthTypeClientSecretAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "clientSecret", "clientCert":
			return true
		}
	}
	return false
}

type AzureBlobAuthTypeClientSecretExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// A JavaScript expression that accesses a corresponding <token> through the value variable and evaluates the token to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (a AzureBlobAuthTypeClientSecretExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBlobAuthTypeClientSecretExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzureBlobAuthTypeClientSecretExtractor) GetKey() string {
	if a == nil {
		return ""
	}
	return a.Key
}

func (a *AzureBlobAuthTypeClientSecretExtractor) GetExpression() string {
	if a == nil {
		return ""
	}
	return a.Expression
}

type AzureBlobAuthTypeClientSecret struct {
	// Enter authentication data directly, or select a secret referencing your auth data
	AuthType *AzureBlobAuthTypeClientSecretAuthenticationMethod `json:"authType,omitempty"`
	// The name of your Azure storage account
	StorageAccountName string `json:"storageAccountName"`
	// The service principal's tenant ID
	TenantID string `json:"tenantId"`
	// The service principal's client ID
	ClientID string `json:"clientId"`
	// Text secret containing the client secret
	ClientTextSecret string `json:"clientTextSecret"`
	// The endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
	EndpointSuffix *string `json:"endpointSuffix,omitempty"`
	// The Azure cloud to use. Defaults to Azure Public Cloud.
	AzureCloud *string `json:"azureCloud,omitempty"`
	// An optional predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// Container to collect from. This value can be a constant, or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: myBucket-${C.vars.myVar}
	ContainerName string `json:"containerName"`
	// The directory from which to collect data. Templating is supported, such as myDir/${datacenter}/${host}/${app}/. Time-based tokens are supported, such as myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/.
	Path *string `json:"path,omitempty"`
	// Extractors allow use of template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)} will enrich discovery results with a human-readable "date" field.
	Extractors []AzureBlobAuthTypeClientSecretExtractor `json:"extractors,omitempty"`
	// Recurse through subdirectories
	Recurse *bool `json:"recurse,omitempty"`
	// Include Azure Blob metadata in collected events. In each event, metadata will be located at: __collectible.metadata.
	IncludeMetadata *bool `json:"includeMetadata,omitempty"`
	// Include Azure Blob tags in collected events. In each event, tags will be located at: __collectible.tags. Disable this feature when using a Shared Access Signature Connection String, to prevent errors.
	IncludeTags *bool `json:"includeTags,omitempty"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `json:"maxBatchSize,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `json:"parquetChunkDownloadTimeout,omitempty"`
}

func (a AzureBlobAuthTypeClientSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBlobAuthTypeClientSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzureBlobAuthTypeClientSecret) GetAuthType() *AzureBlobAuthTypeClientSecretAuthenticationMethod {
	if a == nil {
		return nil
	}
	return a.AuthType
}

func (a *AzureBlobAuthTypeClientSecret) GetStorageAccountName() string {
	if a == nil {
		return ""
	}
	return a.StorageAccountName
}

func (a *AzureBlobAuthTypeClientSecret) GetTenantID() string {
	if a == nil {
		return ""
	}
	return a.TenantID
}

func (a *AzureBlobAuthTypeClientSecret) GetClientID() string {
	if a == nil {
		return ""
	}
	return a.ClientID
}

func (a *AzureBlobAuthTypeClientSecret) GetClientTextSecret() string {
	if a == nil {
		return ""
	}
	return a.ClientTextSecret
}

func (a *AzureBlobAuthTypeClientSecret) GetEndpointSuffix() *string {
	if a == nil {
		return nil
	}
	return a.EndpointSuffix
}

func (a *AzureBlobAuthTypeClientSecret) GetAzureCloud() *string {
	if a == nil {
		return nil
	}
	return a.AzureCloud
}

func (a *AzureBlobAuthTypeClientSecret) GetOutputName() *string {
	if a == nil {
		return nil
	}
	return a.OutputName
}

func (a *AzureBlobAuthTypeClientSecret) GetContainerName() string {
	if a == nil {
		return ""
	}
	return a.ContainerName
}

func (a *AzureBlobAuthTypeClientSecret) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

func (a *AzureBlobAuthTypeClientSecret) GetExtractors() []AzureBlobAuthTypeClientSecretExtractor {
	if a == nil {
		return nil
	}
	return a.Extractors
}

func (a *AzureBlobAuthTypeClientSecret) GetRecurse() *bool {
	if a == nil {
		return nil
	}
	return a.Recurse
}

func (a *AzureBlobAuthTypeClientSecret) GetIncludeMetadata() *bool {
	if a == nil {
		return nil
	}
	return a.IncludeMetadata
}

func (a *AzureBlobAuthTypeClientSecret) GetIncludeTags() *bool {
	if a == nil {
		return nil
	}
	return a.IncludeTags
}

func (a *AzureBlobAuthTypeClientSecret) GetMaxBatchSize() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxBatchSize
}

func (a *AzureBlobAuthTypeClientSecret) GetParquetChunkSizeMB() *float64 {
	if a == nil {
		return nil
	}
	return a.ParquetChunkSizeMB
}

func (a *AzureBlobAuthTypeClientSecret) GetParquetChunkDownloadTimeout() *float64 {
	if a == nil {
		return nil
	}
	return a.ParquetChunkDownloadTimeout
}

// AzureBlobAuthTypeSecretAuthenticationMethod - Enter authentication data directly, or select a secret referencing your auth data
type AzureBlobAuthTypeSecretAuthenticationMethod string

const (
	AzureBlobAuthTypeSecretAuthenticationMethodManual       AzureBlobAuthTypeSecretAuthenticationMethod = "manual"
	AzureBlobAuthTypeSecretAuthenticationMethodSecret       AzureBlobAuthTypeSecretAuthenticationMethod = "secret"
	AzureBlobAuthTypeSecretAuthenticationMethodClientSecret AzureBlobAuthTypeSecretAuthenticationMethod = "clientSecret"
	AzureBlobAuthTypeSecretAuthenticationMethodClientCert   AzureBlobAuthTypeSecretAuthenticationMethod = "clientCert"
)

func (e AzureBlobAuthTypeSecretAuthenticationMethod) ToPointer() *AzureBlobAuthTypeSecretAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *AzureBlobAuthTypeSecretAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "clientSecret", "clientCert":
			return true
		}
	}
	return false
}

type AzureBlobAuthTypeSecretExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// A JavaScript expression that accesses a corresponding <token> through the value variable and evaluates the token to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (a AzureBlobAuthTypeSecretExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBlobAuthTypeSecretExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzureBlobAuthTypeSecretExtractor) GetKey() string {
	if a == nil {
		return ""
	}
	return a.Key
}

func (a *AzureBlobAuthTypeSecretExtractor) GetExpression() string {
	if a == nil {
		return ""
	}
	return a.Expression
}

type AzureBlobAuthTypeSecret struct {
	// Enter authentication data directly, or select a secret referencing your auth data
	AuthType *AzureBlobAuthTypeSecretAuthenticationMethod `json:"authType,omitempty"`
	// Text secret
	TextSecret string `json:"textSecret"`
	// An optional predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// Container to collect from. This value can be a constant, or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: myBucket-${C.vars.myVar}
	ContainerName string `json:"containerName"`
	// The directory from which to collect data. Templating is supported, such as myDir/${datacenter}/${host}/${app}/. Time-based tokens are supported, such as myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/.
	Path *string `json:"path,omitempty"`
	// Extractors allow use of template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)} will enrich discovery results with a human-readable "date" field.
	Extractors []AzureBlobAuthTypeSecretExtractor `json:"extractors,omitempty"`
	// Recurse through subdirectories
	Recurse *bool `json:"recurse,omitempty"`
	// Include Azure Blob metadata in collected events. In each event, metadata will be located at: __collectible.metadata.
	IncludeMetadata *bool `json:"includeMetadata,omitempty"`
	// Include Azure Blob tags in collected events. In each event, tags will be located at: __collectible.tags. Disable this feature when using a Shared Access Signature Connection String, to prevent errors.
	IncludeTags *bool `json:"includeTags,omitempty"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `json:"maxBatchSize,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `json:"parquetChunkDownloadTimeout,omitempty"`
}

func (a AzureBlobAuthTypeSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBlobAuthTypeSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzureBlobAuthTypeSecret) GetAuthType() *AzureBlobAuthTypeSecretAuthenticationMethod {
	if a == nil {
		return nil
	}
	return a.AuthType
}

func (a *AzureBlobAuthTypeSecret) GetTextSecret() string {
	if a == nil {
		return ""
	}
	return a.TextSecret
}

func (a *AzureBlobAuthTypeSecret) GetOutputName() *string {
	if a == nil {
		return nil
	}
	return a.OutputName
}

func (a *AzureBlobAuthTypeSecret) GetContainerName() string {
	if a == nil {
		return ""
	}
	return a.ContainerName
}

func (a *AzureBlobAuthTypeSecret) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

func (a *AzureBlobAuthTypeSecret) GetExtractors() []AzureBlobAuthTypeSecretExtractor {
	if a == nil {
		return nil
	}
	return a.Extractors
}

func (a *AzureBlobAuthTypeSecret) GetRecurse() *bool {
	if a == nil {
		return nil
	}
	return a.Recurse
}

func (a *AzureBlobAuthTypeSecret) GetIncludeMetadata() *bool {
	if a == nil {
		return nil
	}
	return a.IncludeMetadata
}

func (a *AzureBlobAuthTypeSecret) GetIncludeTags() *bool {
	if a == nil {
		return nil
	}
	return a.IncludeTags
}

func (a *AzureBlobAuthTypeSecret) GetMaxBatchSize() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxBatchSize
}

func (a *AzureBlobAuthTypeSecret) GetParquetChunkSizeMB() *float64 {
	if a == nil {
		return nil
	}
	return a.ParquetChunkSizeMB
}

func (a *AzureBlobAuthTypeSecret) GetParquetChunkDownloadTimeout() *float64 {
	if a == nil {
		return nil
	}
	return a.ParquetChunkDownloadTimeout
}

// AzureBlobAuthTypeManualAuthenticationMethod - Enter authentication data directly, or select a secret referencing your auth data
type AzureBlobAuthTypeManualAuthenticationMethod string

const (
	AzureBlobAuthTypeManualAuthenticationMethodManual       AzureBlobAuthTypeManualAuthenticationMethod = "manual"
	AzureBlobAuthTypeManualAuthenticationMethodSecret       AzureBlobAuthTypeManualAuthenticationMethod = "secret"
	AzureBlobAuthTypeManualAuthenticationMethodClientSecret AzureBlobAuthTypeManualAuthenticationMethod = "clientSecret"
	AzureBlobAuthTypeManualAuthenticationMethodClientCert   AzureBlobAuthTypeManualAuthenticationMethod = "clientCert"
)

func (e AzureBlobAuthTypeManualAuthenticationMethod) ToPointer() *AzureBlobAuthTypeManualAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *AzureBlobAuthTypeManualAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "clientSecret", "clientCert":
			return true
		}
	}
	return false
}

type AzureBlobAuthTypeManualExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// A JavaScript expression that accesses a corresponding <token> through the value variable and evaluates the token to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (a AzureBlobAuthTypeManualExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBlobAuthTypeManualExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzureBlobAuthTypeManualExtractor) GetKey() string {
	if a == nil {
		return ""
	}
	return a.Key
}

func (a *AzureBlobAuthTypeManualExtractor) GetExpression() string {
	if a == nil {
		return ""
	}
	return a.Expression
}

type AzureBlobAuthTypeManual struct {
	// Enter authentication data directly, or select a secret referencing your auth data
	AuthType *AzureBlobAuthTypeManualAuthenticationMethod `json:"authType,omitempty"`
	// Enter your Azure storage account Connection String. If left blank, Cribl Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString string `json:"connectionString"`
	// An optional predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// Container to collect from. This value can be a constant, or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: myBucket-${C.vars.myVar}
	ContainerName string `json:"containerName"`
	// The directory from which to collect data. Templating is supported, such as myDir/${datacenter}/${host}/${app}/. Time-based tokens are supported, such as myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/.
	Path *string `json:"path,omitempty"`
	// Extractors allow use of template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)} will enrich discovery results with a human-readable "date" field.
	Extractors []AzureBlobAuthTypeManualExtractor `json:"extractors,omitempty"`
	// Recurse through subdirectories
	Recurse *bool `json:"recurse,omitempty"`
	// Include Azure Blob metadata in collected events. In each event, metadata will be located at: __collectible.metadata.
	IncludeMetadata *bool `json:"includeMetadata,omitempty"`
	// Include Azure Blob tags in collected events. In each event, tags will be located at: __collectible.tags. Disable this feature when using a Shared Access Signature Connection String, to prevent errors.
	IncludeTags *bool `json:"includeTags,omitempty"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `json:"maxBatchSize,omitempty"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `json:"parquetChunkSizeMB,omitempty"`
	// The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `json:"parquetChunkDownloadTimeout,omitempty"`
}

func (a AzureBlobAuthTypeManual) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzureBlobAuthTypeManual) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzureBlobAuthTypeManual) GetAuthType() *AzureBlobAuthTypeManualAuthenticationMethod {
	if a == nil {
		return nil
	}
	return a.AuthType
}

func (a *AzureBlobAuthTypeManual) GetConnectionString() string {
	if a == nil {
		return ""
	}
	return a.ConnectionString
}

func (a *AzureBlobAuthTypeManual) GetOutputName() *string {
	if a == nil {
		return nil
	}
	return a.OutputName
}

func (a *AzureBlobAuthTypeManual) GetContainerName() string {
	if a == nil {
		return ""
	}
	return a.ContainerName
}

func (a *AzureBlobAuthTypeManual) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

func (a *AzureBlobAuthTypeManual) GetExtractors() []AzureBlobAuthTypeManualExtractor {
	if a == nil {
		return nil
	}
	return a.Extractors
}

func (a *AzureBlobAuthTypeManual) GetRecurse() *bool {
	if a == nil {
		return nil
	}
	return a.Recurse
}

func (a *AzureBlobAuthTypeManual) GetIncludeMetadata() *bool {
	if a == nil {
		return nil
	}
	return a.IncludeMetadata
}

func (a *AzureBlobAuthTypeManual) GetIncludeTags() *bool {
	if a == nil {
		return nil
	}
	return a.IncludeTags
}

func (a *AzureBlobAuthTypeManual) GetMaxBatchSize() *float64 {
	if a == nil {
		return nil
	}
	return a.MaxBatchSize
}

func (a *AzureBlobAuthTypeManual) GetParquetChunkSizeMB() *float64 {
	if a == nil {
		return nil
	}
	return a.ParquetChunkSizeMB
}

func (a *AzureBlobAuthTypeManual) GetParquetChunkDownloadTimeout() *float64 {
	if a == nil {
		return nil
	}
	return a.ParquetChunkDownloadTimeout
}

type AzureBlobCollectorConfType string

const (
	AzureBlobCollectorConfTypeManual       AzureBlobCollectorConfType = "manual"
	AzureBlobCollectorConfTypeSecret       AzureBlobCollectorConfType = "secret"
	AzureBlobCollectorConfTypeClientSecret AzureBlobCollectorConfType = "clientSecret"
	AzureBlobCollectorConfTypeClientCert   AzureBlobCollectorConfType = "clientCert"
	AzureBlobCollectorConfTypeUnknown      AzureBlobCollectorConfType = "UNKNOWN"
)

type AzureBlobCollectorConf struct {
	AzureBlobAuthTypeManual       *AzureBlobAuthTypeManual       `queryParam:"inline" union:"member"`
	AzureBlobAuthTypeSecret       *AzureBlobAuthTypeSecret       `queryParam:"inline" union:"member"`
	AzureBlobAuthTypeClientSecret *AzureBlobAuthTypeClientSecret `queryParam:"inline" union:"member"`
	AzureBlobAuthTypeClientCert   *AzureBlobAuthTypeClientCert   `queryParam:"inline" union:"member"`
	UnknownRaw                    json.RawMessage                `json:"-" union:"unknown"`

	Type AzureBlobCollectorConfType
}

func CreateAzureBlobCollectorConfManual(manual AzureBlobAuthTypeManual) AzureBlobCollectorConf {
	typ := AzureBlobCollectorConfTypeManual

	typStr := AzureBlobAuthTypeManualAuthenticationMethod(typ)
	manual.AuthType = &typStr

	return AzureBlobCollectorConf{
		AzureBlobAuthTypeManual: &manual,
		Type:                    typ,
	}
}

func CreateAzureBlobCollectorConfSecret(secret AzureBlobAuthTypeSecret) AzureBlobCollectorConf {
	typ := AzureBlobCollectorConfTypeSecret

	typStr := AzureBlobAuthTypeSecretAuthenticationMethod(typ)
	secret.AuthType = &typStr

	return AzureBlobCollectorConf{
		AzureBlobAuthTypeSecret: &secret,
		Type:                    typ,
	}
}

func CreateAzureBlobCollectorConfClientSecret(clientSecret AzureBlobAuthTypeClientSecret) AzureBlobCollectorConf {
	typ := AzureBlobCollectorConfTypeClientSecret

	typStr := AzureBlobAuthTypeClientSecretAuthenticationMethod(typ)
	clientSecret.AuthType = &typStr

	return AzureBlobCollectorConf{
		AzureBlobAuthTypeClientSecret: &clientSecret,
		Type:                          typ,
	}
}

func CreateAzureBlobCollectorConfClientCert(clientCert AzureBlobAuthTypeClientCert) AzureBlobCollectorConf {
	typ := AzureBlobCollectorConfTypeClientCert

	typStr := AzureBlobAuthTypeClientCertAuthenticationMethod(typ)
	clientCert.AuthType = &typStr

	return AzureBlobCollectorConf{
		AzureBlobAuthTypeClientCert: &clientCert,
		Type:                        typ,
	}
}

func CreateAzureBlobCollectorConfUnknown(raw json.RawMessage) AzureBlobCollectorConf {
	return AzureBlobCollectorConf{
		UnknownRaw: raw,
		Type:       AzureBlobCollectorConfTypeUnknown,
	}
}

func (u AzureBlobCollectorConf) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u AzureBlobCollectorConf) IsUnknown() bool {
	return u.Type == AzureBlobCollectorConfTypeUnknown
}

func (u *AzureBlobCollectorConf) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		AuthType string `json:"authType"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = AzureBlobCollectorConfTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = AzureBlobCollectorConfTypeUnknown
		return nil
	}

	switch dis.AuthType {
	case "manual":
		azureBlobAuthTypeManual := new(AzureBlobAuthTypeManual)
		if err := utils.UnmarshalJSON(data, &azureBlobAuthTypeManual, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AuthType == manual) type AzureBlobAuthTypeManual within AzureBlobCollectorConf: %w", string(data), err)
		}

		u.AzureBlobAuthTypeManual = azureBlobAuthTypeManual
		u.Type = AzureBlobCollectorConfTypeManual
		return nil
	case "secret":
		azureBlobAuthTypeSecret := new(AzureBlobAuthTypeSecret)
		if err := utils.UnmarshalJSON(data, &azureBlobAuthTypeSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AuthType == secret) type AzureBlobAuthTypeSecret within AzureBlobCollectorConf: %w", string(data), err)
		}

		u.AzureBlobAuthTypeSecret = azureBlobAuthTypeSecret
		u.Type = AzureBlobCollectorConfTypeSecret
		return nil
	case "clientSecret":
		azureBlobAuthTypeClientSecret := new(AzureBlobAuthTypeClientSecret)
		if err := utils.UnmarshalJSON(data, &azureBlobAuthTypeClientSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AuthType == clientSecret) type AzureBlobAuthTypeClientSecret within AzureBlobCollectorConf: %w", string(data), err)
		}

		u.AzureBlobAuthTypeClientSecret = azureBlobAuthTypeClientSecret
		u.Type = AzureBlobCollectorConfTypeClientSecret
		return nil
	case "clientCert":
		azureBlobAuthTypeClientCert := new(AzureBlobAuthTypeClientCert)
		if err := utils.UnmarshalJSON(data, &azureBlobAuthTypeClientCert, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AuthType == clientCert) type AzureBlobAuthTypeClientCert within AzureBlobCollectorConf: %w", string(data), err)
		}

		u.AzureBlobAuthTypeClientCert = azureBlobAuthTypeClientCert
		u.Type = AzureBlobCollectorConfTypeClientCert
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = AzureBlobCollectorConfTypeUnknown
		return nil
	}

}

func (u AzureBlobCollectorConf) MarshalJSON() ([]byte, error) {
	if u.AzureBlobAuthTypeManual != nil {
		return utils.MarshalJSON(u.AzureBlobAuthTypeManual, "", true)
	}

	if u.AzureBlobAuthTypeSecret != nil {
		return utils.MarshalJSON(u.AzureBlobAuthTypeSecret, "", true)
	}

	if u.AzureBlobAuthTypeClientSecret != nil {
		return utils.MarshalJSON(u.AzureBlobAuthTypeClientSecret, "", true)
	}

	if u.AzureBlobAuthTypeClientCert != nil {
		return utils.MarshalJSON(u.AzureBlobAuthTypeClientCert, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type AzureBlobCollectorConf: all fields are null")
}
