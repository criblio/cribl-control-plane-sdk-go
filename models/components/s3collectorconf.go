// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// S3AwsAuthenticationMethodSecretPartitioningScheme - Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
type S3AwsAuthenticationMethodSecretPartitioningScheme string

const (
	// S3AwsAuthenticationMethodSecretPartitioningSchemeNone Defined in Path
	S3AwsAuthenticationMethodSecretPartitioningSchemeNone S3AwsAuthenticationMethodSecretPartitioningScheme = "none"
	// S3AwsAuthenticationMethodSecretPartitioningSchemeDdss DDSS
	S3AwsAuthenticationMethodSecretPartitioningSchemeDdss S3AwsAuthenticationMethodSecretPartitioningScheme = "ddss"
)

func (e S3AwsAuthenticationMethodSecretPartitioningScheme) ToPointer() *S3AwsAuthenticationMethodSecretPartitioningScheme {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *S3AwsAuthenticationMethodSecretPartitioningScheme) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "ddss":
			return true
		}
	}
	return false
}

type S3AwsAuthenticationMethodSecretExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// JavaScript expression that receives token under "value" variable, and evaluates to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (s S3AwsAuthenticationMethodSecretExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3AwsAuthenticationMethodSecretExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"key", "expression"}); err != nil {
		return err
	}
	return nil
}

func (s *S3AwsAuthenticationMethodSecretExtractor) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *S3AwsAuthenticationMethodSecretExtractor) GetExpression() string {
	if s == nil {
		return ""
	}
	return s.Expression
}

type S3AwsAuthenticationMethodSecret struct {
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	// Select or create a stored secret that references AWS access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Name of the predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// S3 Bucket from which to collect data
	Bucket string `json:"bucket"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// Maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `default:"600" json:"parquetChunkDownloadTimeout"`
	// Region from which to retrieve data
	Region *string `json:"region,omitempty"`
	// Directory where data will be collected. Templating (such as 'myDir/${datacenter}/${host}/${app}/') and time-based tokens (such as 'myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/') are supported. Can be a constant (enclosed in quotes) or a JavaScript expression.
	Path *string `json:"path,omitempty"`
	// Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
	PartitioningScheme *S3AwsAuthenticationMethodSecretPartitioningScheme `default:"none" json:"partitioningScheme"`
	// Allows using template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)}, will enrich discovery results with a human readable "date" field.
	Extractors []S3AwsAuthenticationMethodSecretExtractor `json:"extractors,omitempty"`
	// Must point to an S3-compatible endpoint. If empty, defaults to an AWS region-specific endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Use AssumeRole credentials
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the Assumed Role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `default:"10" json:"maxBatchSize"`
	Recurse      any      `json:"recurse,omitempty"`
	// Reuse connections between requests to improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA (such as a self-signed certificate)
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Disable if you can access files within the bucket but not the bucket itself. Resolves errors of the form "discover task initialization failed...error: Forbidden".
	VerifyPermissions *bool `default:"true" json:"verifyPermissions"`
	// Disable Collector event time filtering when a date range is specified
	DisableTimeFilter *bool `default:"false" json:"disableTimeFilter"`
}

func (s S3AwsAuthenticationMethodSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3AwsAuthenticationMethodSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"bucket"}); err != nil {
		return err
	}
	return nil
}

func (s *S3AwsAuthenticationMethodSecret) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.AwsAuthenticationMethod
}

func (s *S3AwsAuthenticationMethodSecret) GetAwsSecret() *string {
	if s == nil {
		return nil
	}
	return s.AwsSecret
}

func (s *S3AwsAuthenticationMethodSecret) GetOutputName() *string {
	if s == nil {
		return nil
	}
	return s.OutputName
}

func (s *S3AwsAuthenticationMethodSecret) GetBucket() string {
	if s == nil {
		return ""
	}
	return s.Bucket
}

func (s *S3AwsAuthenticationMethodSecret) GetParquetChunkSizeMB() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkSizeMB
}

func (s *S3AwsAuthenticationMethodSecret) GetParquetChunkDownloadTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkDownloadTimeout
}

func (s *S3AwsAuthenticationMethodSecret) GetRegion() *string {
	if s == nil {
		return nil
	}
	return s.Region
}

func (s *S3AwsAuthenticationMethodSecret) GetPath() *string {
	if s == nil {
		return nil
	}
	return s.Path
}

func (s *S3AwsAuthenticationMethodSecret) GetPartitioningScheme() *S3AwsAuthenticationMethodSecretPartitioningScheme {
	if s == nil {
		return nil
	}
	return s.PartitioningScheme
}

func (s *S3AwsAuthenticationMethodSecret) GetExtractors() []S3AwsAuthenticationMethodSecretExtractor {
	if s == nil {
		return nil
	}
	return s.Extractors
}

func (s *S3AwsAuthenticationMethodSecret) GetEndpoint() *string {
	if s == nil {
		return nil
	}
	return s.Endpoint
}

func (s *S3AwsAuthenticationMethodSecret) GetSignatureVersion() *SignatureVersionOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.SignatureVersion
}

func (s *S3AwsAuthenticationMethodSecret) GetEnableAssumeRole() *bool {
	if s == nil {
		return nil
	}
	return s.EnableAssumeRole
}

func (s *S3AwsAuthenticationMethodSecret) GetAssumeRoleArn() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleArn
}

func (s *S3AwsAuthenticationMethodSecret) GetAssumeRoleExternalID() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleExternalID
}

func (s *S3AwsAuthenticationMethodSecret) GetDurationSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.DurationSeconds
}

func (s *S3AwsAuthenticationMethodSecret) GetMaxBatchSize() *float64 {
	if s == nil {
		return nil
	}
	return s.MaxBatchSize
}

func (s *S3AwsAuthenticationMethodSecret) GetRecurse() any {
	if s == nil {
		return nil
	}
	return s.Recurse
}

func (s *S3AwsAuthenticationMethodSecret) GetReuseConnections() *bool {
	if s == nil {
		return nil
	}
	return s.ReuseConnections
}

func (s *S3AwsAuthenticationMethodSecret) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *S3AwsAuthenticationMethodSecret) GetVerifyPermissions() *bool {
	if s == nil {
		return nil
	}
	return s.VerifyPermissions
}

func (s *S3AwsAuthenticationMethodSecret) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

// S3AwsAuthenticationMethodManualPartitioningScheme - Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
type S3AwsAuthenticationMethodManualPartitioningScheme string

const (
	// S3AwsAuthenticationMethodManualPartitioningSchemeNone Defined in Path
	S3AwsAuthenticationMethodManualPartitioningSchemeNone S3AwsAuthenticationMethodManualPartitioningScheme = "none"
	// S3AwsAuthenticationMethodManualPartitioningSchemeDdss DDSS
	S3AwsAuthenticationMethodManualPartitioningSchemeDdss S3AwsAuthenticationMethodManualPartitioningScheme = "ddss"
)

func (e S3AwsAuthenticationMethodManualPartitioningScheme) ToPointer() *S3AwsAuthenticationMethodManualPartitioningScheme {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *S3AwsAuthenticationMethodManualPartitioningScheme) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "ddss":
			return true
		}
	}
	return false
}

type S3AwsAuthenticationMethodManualExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// JavaScript expression that receives token under "value" variable, and evaluates to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (s S3AwsAuthenticationMethodManualExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3AwsAuthenticationMethodManualExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"key", "expression"}); err != nil {
		return err
	}
	return nil
}

func (s *S3AwsAuthenticationMethodManualExtractor) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *S3AwsAuthenticationMethodManualExtractor) GetExpression() string {
	if s == nil {
		return ""
	}
	return s.Expression
}

type S3AwsAuthenticationMethodManual struct {
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	// Access key. If not present, will fall back to env.AWS_ACCESS_KEY_ID, or to the metadata endpoint for IAM creds. Optional when running on AWS. This value can be a constant or a JavaScript expression.
	AwsAPIKey *string `json:"awsApiKey,omitempty"`
	// Secret key. If not present, will fall back to env.AWS_SECRET_ACCESS_KEY, or to the metadata endpoint for IAM creds. Optional when running on AWS. This value can be a constant or a JavaScript expression.
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`
	// Name of the predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// S3 Bucket from which to collect data
	Bucket string `json:"bucket"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// Maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `default:"600" json:"parquetChunkDownloadTimeout"`
	// Region from which to retrieve data
	Region *string `json:"region,omitempty"`
	// Directory where data will be collected. Templating (such as 'myDir/${datacenter}/${host}/${app}/') and time-based tokens (such as 'myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/') are supported. Can be a constant (enclosed in quotes) or a JavaScript expression.
	Path *string `json:"path,omitempty"`
	// Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
	PartitioningScheme *S3AwsAuthenticationMethodManualPartitioningScheme `default:"none" json:"partitioningScheme"`
	// Allows using template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)}, will enrich discovery results with a human readable "date" field.
	Extractors []S3AwsAuthenticationMethodManualExtractor `json:"extractors,omitempty"`
	// Must point to an S3-compatible endpoint. If empty, defaults to an AWS region-specific endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Use AssumeRole credentials
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the Assumed Role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `default:"10" json:"maxBatchSize"`
	Recurse      any      `json:"recurse,omitempty"`
	// Reuse connections between requests to improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA (such as a self-signed certificate)
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Disable if you can access files within the bucket but not the bucket itself. Resolves errors of the form "discover task initialization failed...error: Forbidden".
	VerifyPermissions *bool `default:"true" json:"verifyPermissions"`
	// Disable Collector event time filtering when a date range is specified
	DisableTimeFilter *bool `default:"false" json:"disableTimeFilter"`
}

func (s S3AwsAuthenticationMethodManual) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3AwsAuthenticationMethodManual) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"bucket"}); err != nil {
		return err
	}
	return nil
}

func (s *S3AwsAuthenticationMethodManual) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.AwsAuthenticationMethod
}

func (s *S3AwsAuthenticationMethodManual) GetAwsAPIKey() *string {
	if s == nil {
		return nil
	}
	return s.AwsAPIKey
}

func (s *S3AwsAuthenticationMethodManual) GetAwsSecretKey() *string {
	if s == nil {
		return nil
	}
	return s.AwsSecretKey
}

func (s *S3AwsAuthenticationMethodManual) GetOutputName() *string {
	if s == nil {
		return nil
	}
	return s.OutputName
}

func (s *S3AwsAuthenticationMethodManual) GetBucket() string {
	if s == nil {
		return ""
	}
	return s.Bucket
}

func (s *S3AwsAuthenticationMethodManual) GetParquetChunkSizeMB() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkSizeMB
}

func (s *S3AwsAuthenticationMethodManual) GetParquetChunkDownloadTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkDownloadTimeout
}

func (s *S3AwsAuthenticationMethodManual) GetRegion() *string {
	if s == nil {
		return nil
	}
	return s.Region
}

func (s *S3AwsAuthenticationMethodManual) GetPath() *string {
	if s == nil {
		return nil
	}
	return s.Path
}

func (s *S3AwsAuthenticationMethodManual) GetPartitioningScheme() *S3AwsAuthenticationMethodManualPartitioningScheme {
	if s == nil {
		return nil
	}
	return s.PartitioningScheme
}

func (s *S3AwsAuthenticationMethodManual) GetExtractors() []S3AwsAuthenticationMethodManualExtractor {
	if s == nil {
		return nil
	}
	return s.Extractors
}

func (s *S3AwsAuthenticationMethodManual) GetEndpoint() *string {
	if s == nil {
		return nil
	}
	return s.Endpoint
}

func (s *S3AwsAuthenticationMethodManual) GetSignatureVersion() *SignatureVersionOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.SignatureVersion
}

func (s *S3AwsAuthenticationMethodManual) GetEnableAssumeRole() *bool {
	if s == nil {
		return nil
	}
	return s.EnableAssumeRole
}

func (s *S3AwsAuthenticationMethodManual) GetAssumeRoleArn() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleArn
}

func (s *S3AwsAuthenticationMethodManual) GetAssumeRoleExternalID() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleExternalID
}

func (s *S3AwsAuthenticationMethodManual) GetDurationSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.DurationSeconds
}

func (s *S3AwsAuthenticationMethodManual) GetMaxBatchSize() *float64 {
	if s == nil {
		return nil
	}
	return s.MaxBatchSize
}

func (s *S3AwsAuthenticationMethodManual) GetRecurse() any {
	if s == nil {
		return nil
	}
	return s.Recurse
}

func (s *S3AwsAuthenticationMethodManual) GetReuseConnections() *bool {
	if s == nil {
		return nil
	}
	return s.ReuseConnections
}

func (s *S3AwsAuthenticationMethodManual) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *S3AwsAuthenticationMethodManual) GetVerifyPermissions() *bool {
	if s == nil {
		return nil
	}
	return s.VerifyPermissions
}

func (s *S3AwsAuthenticationMethodManual) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

// S3AwsAuthenticationMethodAutoPartitioningScheme - Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
type S3AwsAuthenticationMethodAutoPartitioningScheme string

const (
	// S3AwsAuthenticationMethodAutoPartitioningSchemeNone Defined in Path
	S3AwsAuthenticationMethodAutoPartitioningSchemeNone S3AwsAuthenticationMethodAutoPartitioningScheme = "none"
	// S3AwsAuthenticationMethodAutoPartitioningSchemeDdss DDSS
	S3AwsAuthenticationMethodAutoPartitioningSchemeDdss S3AwsAuthenticationMethodAutoPartitioningScheme = "ddss"
)

func (e S3AwsAuthenticationMethodAutoPartitioningScheme) ToPointer() *S3AwsAuthenticationMethodAutoPartitioningScheme {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *S3AwsAuthenticationMethodAutoPartitioningScheme) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "ddss":
			return true
		}
	}
	return false
}

type S3AwsAuthenticationMethodAutoExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// JavaScript expression that receives token under "value" variable, and evaluates to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (s S3AwsAuthenticationMethodAutoExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3AwsAuthenticationMethodAutoExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"key", "expression"}); err != nil {
		return err
	}
	return nil
}

func (s *S3AwsAuthenticationMethodAutoExtractor) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *S3AwsAuthenticationMethodAutoExtractor) GetExpression() string {
	if s == nil {
		return ""
	}
	return s.Expression
}

type S3AwsAuthenticationMethodAuto struct {
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	// Name of the predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// S3 Bucket from which to collect data
	Bucket string `json:"bucket"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// Maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `default:"600" json:"parquetChunkDownloadTimeout"`
	// Region from which to retrieve data
	Region *string `json:"region,omitempty"`
	// Directory where data will be collected. Templating (such as 'myDir/${datacenter}/${host}/${app}/') and time-based tokens (such as 'myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/') are supported. Can be a constant (enclosed in quotes) or a JavaScript expression.
	Path *string `json:"path,omitempty"`
	// Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
	PartitioningScheme *S3AwsAuthenticationMethodAutoPartitioningScheme `default:"none" json:"partitioningScheme"`
	// Allows using template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)}, will enrich discovery results with a human readable "date" field.
	Extractors []S3AwsAuthenticationMethodAutoExtractor `json:"extractors,omitempty"`
	// Must point to an S3-compatible endpoint. If empty, defaults to an AWS region-specific endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Use AssumeRole credentials
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the Assumed Role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `default:"10" json:"maxBatchSize"`
	Recurse      any      `json:"recurse,omitempty"`
	// Reuse connections between requests to improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA (such as a self-signed certificate)
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Disable if you can access files within the bucket but not the bucket itself. Resolves errors of the form "discover task initialization failed...error: Forbidden".
	VerifyPermissions *bool `default:"true" json:"verifyPermissions"`
	// Disable Collector event time filtering when a date range is specified
	DisableTimeFilter *bool `default:"false" json:"disableTimeFilter"`
}

func (s S3AwsAuthenticationMethodAuto) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3AwsAuthenticationMethodAuto) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"bucket"}); err != nil {
		return err
	}
	return nil
}

func (s *S3AwsAuthenticationMethodAuto) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.AwsAuthenticationMethod
}

func (s *S3AwsAuthenticationMethodAuto) GetOutputName() *string {
	if s == nil {
		return nil
	}
	return s.OutputName
}

func (s *S3AwsAuthenticationMethodAuto) GetBucket() string {
	if s == nil {
		return ""
	}
	return s.Bucket
}

func (s *S3AwsAuthenticationMethodAuto) GetParquetChunkSizeMB() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkSizeMB
}

func (s *S3AwsAuthenticationMethodAuto) GetParquetChunkDownloadTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkDownloadTimeout
}

func (s *S3AwsAuthenticationMethodAuto) GetRegion() *string {
	if s == nil {
		return nil
	}
	return s.Region
}

func (s *S3AwsAuthenticationMethodAuto) GetPath() *string {
	if s == nil {
		return nil
	}
	return s.Path
}

func (s *S3AwsAuthenticationMethodAuto) GetPartitioningScheme() *S3AwsAuthenticationMethodAutoPartitioningScheme {
	if s == nil {
		return nil
	}
	return s.PartitioningScheme
}

func (s *S3AwsAuthenticationMethodAuto) GetExtractors() []S3AwsAuthenticationMethodAutoExtractor {
	if s == nil {
		return nil
	}
	return s.Extractors
}

func (s *S3AwsAuthenticationMethodAuto) GetEndpoint() *string {
	if s == nil {
		return nil
	}
	return s.Endpoint
}

func (s *S3AwsAuthenticationMethodAuto) GetSignatureVersion() *SignatureVersionOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.SignatureVersion
}

func (s *S3AwsAuthenticationMethodAuto) GetEnableAssumeRole() *bool {
	if s == nil {
		return nil
	}
	return s.EnableAssumeRole
}

func (s *S3AwsAuthenticationMethodAuto) GetAssumeRoleArn() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleArn
}

func (s *S3AwsAuthenticationMethodAuto) GetAssumeRoleExternalID() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleExternalID
}

func (s *S3AwsAuthenticationMethodAuto) GetDurationSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.DurationSeconds
}

func (s *S3AwsAuthenticationMethodAuto) GetMaxBatchSize() *float64 {
	if s == nil {
		return nil
	}
	return s.MaxBatchSize
}

func (s *S3AwsAuthenticationMethodAuto) GetRecurse() any {
	if s == nil {
		return nil
	}
	return s.Recurse
}

func (s *S3AwsAuthenticationMethodAuto) GetReuseConnections() *bool {
	if s == nil {
		return nil
	}
	return s.ReuseConnections
}

func (s *S3AwsAuthenticationMethodAuto) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *S3AwsAuthenticationMethodAuto) GetVerifyPermissions() *bool {
	if s == nil {
		return nil
	}
	return s.VerifyPermissions
}

func (s *S3AwsAuthenticationMethodAuto) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

// S3PartitioningSchemeNonePartitioningScheme - Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
type S3PartitioningSchemeNonePartitioningScheme string

const (
	// S3PartitioningSchemeNonePartitioningSchemeNone Defined in Path
	S3PartitioningSchemeNonePartitioningSchemeNone S3PartitioningSchemeNonePartitioningScheme = "none"
	// S3PartitioningSchemeNonePartitioningSchemeDdss DDSS
	S3PartitioningSchemeNonePartitioningSchemeDdss S3PartitioningSchemeNonePartitioningScheme = "ddss"
)

func (e S3PartitioningSchemeNonePartitioningScheme) ToPointer() *S3PartitioningSchemeNonePartitioningScheme {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *S3PartitioningSchemeNonePartitioningScheme) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "ddss":
			return true
		}
	}
	return false
}

type S3PartitioningSchemeNoneExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// JavaScript expression that receives token under "value" variable, and evaluates to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (s S3PartitioningSchemeNoneExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3PartitioningSchemeNoneExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"key", "expression"}); err != nil {
		return err
	}
	return nil
}

func (s *S3PartitioningSchemeNoneExtractor) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *S3PartitioningSchemeNoneExtractor) GetExpression() string {
	if s == nil {
		return ""
	}
	return s.Expression
}

type S3PartitioningSchemeNone struct {
	// Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
	PartitioningScheme *S3PartitioningSchemeNonePartitioningScheme `default:"none" json:"partitioningScheme"`
	Recurse            any                                         `json:"recurse,omitempty"`
	// Name of the predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// S3 Bucket from which to collect data
	Bucket string `json:"bucket"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// Maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `default:"600" json:"parquetChunkDownloadTimeout"`
	// Region from which to retrieve data
	Region *string `json:"region,omitempty"`
	// Directory where data will be collected. Templating (such as 'myDir/${datacenter}/${host}/${app}/') and time-based tokens (such as 'myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/') are supported. Can be a constant (enclosed in quotes) or a JavaScript expression.
	Path *string `json:"path,omitempty"`
	// Allows using template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)}, will enrich discovery results with a human readable "date" field.
	Extractors []S3PartitioningSchemeNoneExtractor `json:"extractors,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	// Must point to an S3-compatible endpoint. If empty, defaults to an AWS region-specific endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Use AssumeRole credentials
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the Assumed Role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `default:"10" json:"maxBatchSize"`
	// Reuse connections between requests to improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA (such as a self-signed certificate)
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Disable if you can access files within the bucket but not the bucket itself. Resolves errors of the form "discover task initialization failed...error: Forbidden".
	VerifyPermissions *bool `default:"true" json:"verifyPermissions"`
	// Disable Collector event time filtering when a date range is specified
	DisableTimeFilter *bool `default:"false" json:"disableTimeFilter"`
}

func (s S3PartitioningSchemeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3PartitioningSchemeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"bucket"}); err != nil {
		return err
	}
	return nil
}

func (s *S3PartitioningSchemeNone) GetPartitioningScheme() *S3PartitioningSchemeNonePartitioningScheme {
	if s == nil {
		return nil
	}
	return s.PartitioningScheme
}

func (s *S3PartitioningSchemeNone) GetRecurse() any {
	if s == nil {
		return nil
	}
	return s.Recurse
}

func (s *S3PartitioningSchemeNone) GetOutputName() *string {
	if s == nil {
		return nil
	}
	return s.OutputName
}

func (s *S3PartitioningSchemeNone) GetBucket() string {
	if s == nil {
		return ""
	}
	return s.Bucket
}

func (s *S3PartitioningSchemeNone) GetParquetChunkSizeMB() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkSizeMB
}

func (s *S3PartitioningSchemeNone) GetParquetChunkDownloadTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkDownloadTimeout
}

func (s *S3PartitioningSchemeNone) GetRegion() *string {
	if s == nil {
		return nil
	}
	return s.Region
}

func (s *S3PartitioningSchemeNone) GetPath() *string {
	if s == nil {
		return nil
	}
	return s.Path
}

func (s *S3PartitioningSchemeNone) GetExtractors() []S3PartitioningSchemeNoneExtractor {
	if s == nil {
		return nil
	}
	return s.Extractors
}

func (s *S3PartitioningSchemeNone) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.AwsAuthenticationMethod
}

func (s *S3PartitioningSchemeNone) GetEndpoint() *string {
	if s == nil {
		return nil
	}
	return s.Endpoint
}

func (s *S3PartitioningSchemeNone) GetSignatureVersion() *SignatureVersionOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.SignatureVersion
}

func (s *S3PartitioningSchemeNone) GetEnableAssumeRole() *bool {
	if s == nil {
		return nil
	}
	return s.EnableAssumeRole
}

func (s *S3PartitioningSchemeNone) GetAssumeRoleArn() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleArn
}

func (s *S3PartitioningSchemeNone) GetAssumeRoleExternalID() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleExternalID
}

func (s *S3PartitioningSchemeNone) GetDurationSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.DurationSeconds
}

func (s *S3PartitioningSchemeNone) GetMaxBatchSize() *float64 {
	if s == nil {
		return nil
	}
	return s.MaxBatchSize
}

func (s *S3PartitioningSchemeNone) GetReuseConnections() *bool {
	if s == nil {
		return nil
	}
	return s.ReuseConnections
}

func (s *S3PartitioningSchemeNone) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *S3PartitioningSchemeNone) GetVerifyPermissions() *bool {
	if s == nil {
		return nil
	}
	return s.VerifyPermissions
}

func (s *S3PartitioningSchemeNone) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

// S3PartitioningSchemeDdssPartitioningScheme - Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
type S3PartitioningSchemeDdssPartitioningScheme string

const (
	// S3PartitioningSchemeDdssPartitioningSchemeNone Defined in Path
	S3PartitioningSchemeDdssPartitioningSchemeNone S3PartitioningSchemeDdssPartitioningScheme = "none"
	// S3PartitioningSchemeDdssPartitioningSchemeDdss DDSS
	S3PartitioningSchemeDdssPartitioningSchemeDdss S3PartitioningSchemeDdssPartitioningScheme = "ddss"
)

func (e S3PartitioningSchemeDdssPartitioningScheme) ToPointer() *S3PartitioningSchemeDdssPartitioningScheme {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *S3PartitioningSchemeDdssPartitioningScheme) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "ddss":
			return true
		}
	}
	return false
}

type S3PartitioningSchemeDdssExtractor struct {
	// A token from the template path, such as epoch
	Key string `json:"key"`
	// JavaScript expression that receives token under "value" variable, and evaluates to populate event fields. Example: {date: new Date(+value*1000)}
	Expression string `json:"expression"`
}

func (s S3PartitioningSchemeDdssExtractor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3PartitioningSchemeDdssExtractor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"key", "expression"}); err != nil {
		return err
	}
	return nil
}

func (s *S3PartitioningSchemeDdssExtractor) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *S3PartitioningSchemeDdssExtractor) GetExpression() string {
	if s == nil {
		return ""
	}
	return s.Expression
}

type S3PartitioningSchemeDdss struct {
	// Partitioning scheme used for this dataset. Using a known scheme like DDSS enables more efficient data reading and retrieval.
	PartitioningScheme *S3PartitioningSchemeDdssPartitioningScheme `default:"none" json:"partitioningScheme"`
	// Name of the predefined Destination that will be used to auto-populate Collector settings
	OutputName *string `json:"outputName,omitempty"`
	// S3 Bucket from which to collect data
	Bucket string `json:"bucket"`
	// Maximum file size for each Parquet chunk
	ParquetChunkSizeMB *float64 `default:"5" json:"parquetChunkSizeMB"`
	// Maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float64 `default:"600" json:"parquetChunkDownloadTimeout"`
	// Region from which to retrieve data
	Region *string `json:"region,omitempty"`
	// Directory where data will be collected. Templating (such as 'myDir/${datacenter}/${host}/${app}/') and time-based tokens (such as 'myOtherDir/${_time:%Y}/${_time:%m}/${_time:%d}/') are supported. Can be a constant (enclosed in quotes) or a JavaScript expression.
	Path *string `json:"path,omitempty"`
	// Allows using template tokens as context for expressions that enrich discovery results. For example, given a template /path/${epoch}, an extractor under key "epoch" with an expression {date: new Date(+value*1000)}, will enrich discovery results with a human readable "date" field.
	Extractors []S3PartitioningSchemeDdssExtractor `json:"extractors,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	// Must point to an S3-compatible endpoint. If empty, defaults to an AWS region-specific endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing S3 requests
	SignatureVersion *SignatureVersionOptionsS3CollectorConf `default:"v4" json:"signatureVersion"`
	// Use AssumeRole credentials
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the Assumed Role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Maximum number of metadata objects to batch before recording as results
	MaxBatchSize *float64 `default:"10" json:"maxBatchSize"`
	Recurse      any      `json:"recurse,omitempty"`
	// Reuse connections between requests to improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA (such as a self-signed certificate)
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Disable if you can access files within the bucket but not the bucket itself. Resolves errors of the form "discover task initialization failed...error: Forbidden".
	VerifyPermissions *bool `default:"true" json:"verifyPermissions"`
	// Disable Collector event time filtering when a date range is specified
	DisableTimeFilter *bool `default:"false" json:"disableTimeFilter"`
}

func (s S3PartitioningSchemeDdss) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *S3PartitioningSchemeDdss) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"bucket"}); err != nil {
		return err
	}
	return nil
}

func (s *S3PartitioningSchemeDdss) GetPartitioningScheme() *S3PartitioningSchemeDdssPartitioningScheme {
	if s == nil {
		return nil
	}
	return s.PartitioningScheme
}

func (s *S3PartitioningSchemeDdss) GetOutputName() *string {
	if s == nil {
		return nil
	}
	return s.OutputName
}

func (s *S3PartitioningSchemeDdss) GetBucket() string {
	if s == nil {
		return ""
	}
	return s.Bucket
}

func (s *S3PartitioningSchemeDdss) GetParquetChunkSizeMB() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkSizeMB
}

func (s *S3PartitioningSchemeDdss) GetParquetChunkDownloadTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.ParquetChunkDownloadTimeout
}

func (s *S3PartitioningSchemeDdss) GetRegion() *string {
	if s == nil {
		return nil
	}
	return s.Region
}

func (s *S3PartitioningSchemeDdss) GetPath() *string {
	if s == nil {
		return nil
	}
	return s.Path
}

func (s *S3PartitioningSchemeDdss) GetExtractors() []S3PartitioningSchemeDdssExtractor {
	if s == nil {
		return nil
	}
	return s.Extractors
}

func (s *S3PartitioningSchemeDdss) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.AwsAuthenticationMethod
}

func (s *S3PartitioningSchemeDdss) GetEndpoint() *string {
	if s == nil {
		return nil
	}
	return s.Endpoint
}

func (s *S3PartitioningSchemeDdss) GetSignatureVersion() *SignatureVersionOptionsS3CollectorConf {
	if s == nil {
		return nil
	}
	return s.SignatureVersion
}

func (s *S3PartitioningSchemeDdss) GetEnableAssumeRole() *bool {
	if s == nil {
		return nil
	}
	return s.EnableAssumeRole
}

func (s *S3PartitioningSchemeDdss) GetAssumeRoleArn() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleArn
}

func (s *S3PartitioningSchemeDdss) GetAssumeRoleExternalID() *string {
	if s == nil {
		return nil
	}
	return s.AssumeRoleExternalID
}

func (s *S3PartitioningSchemeDdss) GetDurationSeconds() *float64 {
	if s == nil {
		return nil
	}
	return s.DurationSeconds
}

func (s *S3PartitioningSchemeDdss) GetMaxBatchSize() *float64 {
	if s == nil {
		return nil
	}
	return s.MaxBatchSize
}

func (s *S3PartitioningSchemeDdss) GetRecurse() any {
	if s == nil {
		return nil
	}
	return s.Recurse
}

func (s *S3PartitioningSchemeDdss) GetReuseConnections() *bool {
	if s == nil {
		return nil
	}
	return s.ReuseConnections
}

func (s *S3PartitioningSchemeDdss) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *S3PartitioningSchemeDdss) GetVerifyPermissions() *bool {
	if s == nil {
		return nil
	}
	return s.VerifyPermissions
}

func (s *S3PartitioningSchemeDdss) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

type S3CollectorConfType string

const (
	S3CollectorConfTypeAuto   S3CollectorConfType = "auto"
	S3CollectorConfTypeManual S3CollectorConfType = "manual"
	S3CollectorConfTypeSecret S3CollectorConfType = "secret"
)

type S3CollectorConf struct {
	S3PartitioningSchemeDdss        *S3PartitioningSchemeDdss        `queryParam:"inline,name=S3CollectorConf" union:"member"`
	S3PartitioningSchemeNone        *S3PartitioningSchemeNone        `queryParam:"inline,name=S3CollectorConf" union:"member"`
	S3AwsAuthenticationMethodAuto   *S3AwsAuthenticationMethodAuto   `queryParam:"inline,name=S3CollectorConf" union:"member"`
	S3AwsAuthenticationMethodManual *S3AwsAuthenticationMethodManual `queryParam:"inline,name=S3CollectorConf" union:"member"`
	S3AwsAuthenticationMethodSecret *S3AwsAuthenticationMethodSecret `queryParam:"inline,name=S3CollectorConf" union:"member"`

	Type S3CollectorConfType
}

func CreateS3CollectorConfAuto(auto S3AwsAuthenticationMethodAuto) S3CollectorConf {
	typ := S3CollectorConfTypeAuto

	typStr := AuthenticationMethodOptionsS3CollectorConf(typ)
	auto.AwsAuthenticationMethod = &typStr

	return S3CollectorConf{
		S3AwsAuthenticationMethodAuto: &auto,
		Type:                          typ,
	}
}

func CreateS3CollectorConfManual(manual S3AwsAuthenticationMethodManual) S3CollectorConf {
	typ := S3CollectorConfTypeManual

	typStr := AuthenticationMethodOptionsS3CollectorConf(typ)
	manual.AwsAuthenticationMethod = &typStr

	return S3CollectorConf{
		S3AwsAuthenticationMethodManual: &manual,
		Type:                            typ,
	}
}

func CreateS3CollectorConfSecret(secret S3AwsAuthenticationMethodSecret) S3CollectorConf {
	typ := S3CollectorConfTypeSecret

	typStr := AuthenticationMethodOptionsS3CollectorConf(typ)
	secret.AwsAuthenticationMethod = &typStr

	return S3CollectorConf{
		S3AwsAuthenticationMethodSecret: &secret,
		Type:                            typ,
	}
}

func (u *S3CollectorConf) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		AwsAuthenticationMethod string `json:"awsAuthenticationMethod"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.AwsAuthenticationMethod {
	case "auto":
		s3AwsAuthenticationMethodAuto := new(S3AwsAuthenticationMethodAuto)
		if err := utils.UnmarshalJSON(data, &s3AwsAuthenticationMethodAuto, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AwsAuthenticationMethod == auto) type S3AwsAuthenticationMethodAuto within S3CollectorConf: %w", string(data), err)
		}

		u.S3AwsAuthenticationMethodAuto = s3AwsAuthenticationMethodAuto
		u.Type = S3CollectorConfTypeAuto
		return nil
	case "manual":
		s3AwsAuthenticationMethodManual := new(S3AwsAuthenticationMethodManual)
		if err := utils.UnmarshalJSON(data, &s3AwsAuthenticationMethodManual, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AwsAuthenticationMethod == manual) type S3AwsAuthenticationMethodManual within S3CollectorConf: %w", string(data), err)
		}

		u.S3AwsAuthenticationMethodManual = s3AwsAuthenticationMethodManual
		u.Type = S3CollectorConfTypeManual
		return nil
	case "secret":
		s3AwsAuthenticationMethodSecret := new(S3AwsAuthenticationMethodSecret)
		if err := utils.UnmarshalJSON(data, &s3AwsAuthenticationMethodSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AwsAuthenticationMethod == secret) type S3AwsAuthenticationMethodSecret within S3CollectorConf: %w", string(data), err)
		}

		u.S3AwsAuthenticationMethodSecret = s3AwsAuthenticationMethodSecret
		u.Type = S3CollectorConfTypeSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for S3CollectorConf", string(data))
}

func (u S3CollectorConf) MarshalJSON() ([]byte, error) {
	if u.S3PartitioningSchemeDdss != nil {
		return utils.MarshalJSON(u.S3PartitioningSchemeDdss, "", true)
	}

	if u.S3PartitioningSchemeNone != nil {
		return utils.MarshalJSON(u.S3PartitioningSchemeNone, "", true)
	}

	if u.S3AwsAuthenticationMethodAuto != nil {
		return utils.MarshalJSON(u.S3AwsAuthenticationMethodAuto, "", true)
	}

	if u.S3AwsAuthenticationMethodManual != nil {
		return utils.MarshalJSON(u.S3AwsAuthenticationMethodManual, "", true)
	}

	if u.S3AwsAuthenticationMethodSecret != nil {
		return utils.MarshalJSON(u.S3AwsAuthenticationMethodSecret, "", true)
	}

	return nil, errors.New("could not marshal union type S3CollectorConf: all fields are null")
}
