// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// ResourceRecordType - The DNS record type (RR) to return. Defaults to 'A'.
type ResourceRecordType string

const (
	// ResourceRecordTypeA A
	ResourceRecordTypeA ResourceRecordType = "A"
	// ResourceRecordTypeAaaa AAAA
	ResourceRecordTypeAaaa ResourceRecordType = "AAAA"
	// ResourceRecordTypeAny ANY
	ResourceRecordTypeAny ResourceRecordType = "ANY"
	// ResourceRecordTypeCname CNAME
	ResourceRecordTypeCname ResourceRecordType = "CNAME"
	// ResourceRecordTypeMx MX
	ResourceRecordTypeMx ResourceRecordType = "MX"
	// ResourceRecordTypeNaptr NAPTR
	ResourceRecordTypeNaptr ResourceRecordType = "NAPTR"
	// ResourceRecordTypeNs NS
	ResourceRecordTypeNs ResourceRecordType = "NS"
	// ResourceRecordTypePtr PTR
	ResourceRecordTypePtr ResourceRecordType = "PTR"
	// ResourceRecordTypeSoa SOA
	ResourceRecordTypeSoa ResourceRecordType = "SOA"
	// ResourceRecordTypeSrv SRV
	ResourceRecordTypeSrv ResourceRecordType = "SRV"
	// ResourceRecordTypeTxt TXT
	ResourceRecordTypeTxt ResourceRecordType = "TXT"
)

func (e ResourceRecordType) ToPointer() *ResourceRecordType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ResourceRecordType) IsExact() bool {
	if e != nil {
		switch *e {
		case "A", "AAAA", "ANY", "CNAME", "MX", "NAPTR", "NS", "PTR", "SOA", "SRV", "TXT":
			return true
		}
	}
	return false
}

type DNSLookupField struct {
	InFieldName *string `json:"inFieldName,omitempty"`
	// The DNS record type (RR) to return. Defaults to 'A'.
	ResourceRecordType *ResourceRecordType `default:"A" json:"resourceRecordType"`
	// Name of field to add lookup results to. Leave blank to overwrite the lookup field.
	OutFieldName *string `json:"outFieldName,omitempty"`
}

func (d DNSLookupField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DNSLookupField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DNSLookupField) GetInFieldName() *string {
	if d == nil {
		return nil
	}
	return d.InFieldName
}

func (d *DNSLookupField) GetResourceRecordType() *ResourceRecordType {
	if d == nil {
		return nil
	}
	return d.ResourceRecordType
}

func (d *DNSLookupField) GetOutFieldName() *string {
	if d == nil {
		return nil
	}
	return d.OutFieldName
}

type ReverseLookupField struct {
	// Name of the field containing the IP to look up. If the field value is not in IPv4 or IPv6 format, the lookup is skipped.
	InFieldName *string `json:"inFieldName,omitempty"`
	// Name of field to add the resolved domain to. Leave blank to overwrite the lookup field.
	OutFieldName *string `json:"outFieldName,omitempty"`
}

func (r ReverseLookupField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReverseLookupField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ReverseLookupField) GetInFieldName() *string {
	if r == nil {
		return nil
	}
	return r.InFieldName
}

func (r *ReverseLookupField) GetOutFieldName() *string {
	if r == nil {
		return nil
	}
	return r.OutFieldName
}

type LogLevelForFailedLookups string

const (
	// LogLevelForFailedLookupsSilly silly
	LogLevelForFailedLookupsSilly LogLevelForFailedLookups = "silly"
	// LogLevelForFailedLookupsDebug debug
	LogLevelForFailedLookupsDebug LogLevelForFailedLookups = "debug"
	// LogLevelForFailedLookupsInfo info
	LogLevelForFailedLookupsInfo LogLevelForFailedLookups = "info"
	// LogLevelForFailedLookupsWarn warn
	LogLevelForFailedLookupsWarn LogLevelForFailedLookups = "warn"
	// LogLevelForFailedLookupsError error
	LogLevelForFailedLookupsError LogLevelForFailedLookups = "error"
)

func (e LogLevelForFailedLookups) ToPointer() *LogLevelForFailedLookups {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *LogLevelForFailedLookups) IsExact() bool {
	if e != nil {
		switch *e {
		case "silly", "debug", "info", "warn", "error":
			return true
		}
	}
	return false
}

type FunctionConfSchemaDNSLookup struct {
	// List of field names on which to perform DNS lookup
	DNSLookupFields []DNSLookupField `json:"dnsLookupFields,omitempty"`
	// List of field names on which to perform reverse DNS lookup
	ReverseLookupFields []ReverseLookupField `json:"reverseLookupFields,omitempty"`
	// IPs, in RFC 5952 format, of the DNS servers to use for resolution. Examples: IPv4 1.1.1.1, 4.2.2.2:53, or IPv6 [2001:4860:4860::8888], [2001:4860:4860::8888]:1053. If not specified, system's DNS will be used.
	DNSServers []string `json:"dnsServers,omitempty"`
	// How frequently to expire and refetch DNS cache. Use 0 to disable.
	CacheTTL *float64 `default:"30" json:"cacheTTL"`
	// The maximum number of DNS resolutions to be cached locally. Leave at default unless you understand the implications of changing.
	MaxCacheSize *float64 `default:"5000" json:"maxCacheSize"`
	// Attempt to resolve DNS short names using the search or domain directive from /etc/resolv.conf
	UseResolvConf *bool `default:"false" json:"useResolvConf"`
	// If unable to resolve a DNS short name, make a DNS.lookup() call to resolve it. Caution: This might degrade performance in unrelated areas of @{product}.
	LookupFallback *bool `default:"false" json:"lookupFallback"`
	// Specify fallback values for the DNS resolver to use when it cannot resolve a DNS short name
	DomainOverrides      []string                  `json:"domainOverrides,omitempty"`
	LookupFailLogLevel   *LogLevelForFailedLookups `default:"error" json:"lookupFailLogLevel"`
	AdditionalProperties map[string]any            `additionalProperties:"true" json:"-"`
}

func (f FunctionConfSchemaDNSLookup) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FunctionConfSchemaDNSLookup) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *FunctionConfSchemaDNSLookup) GetDNSLookupFields() []DNSLookupField {
	if f == nil {
		return nil
	}
	return f.DNSLookupFields
}

func (f *FunctionConfSchemaDNSLookup) GetReverseLookupFields() []ReverseLookupField {
	if f == nil {
		return nil
	}
	return f.ReverseLookupFields
}

func (f *FunctionConfSchemaDNSLookup) GetDNSServers() []string {
	if f == nil {
		return nil
	}
	return f.DNSServers
}

func (f *FunctionConfSchemaDNSLookup) GetCacheTTL() *float64 {
	if f == nil {
		return nil
	}
	return f.CacheTTL
}

func (f *FunctionConfSchemaDNSLookup) GetMaxCacheSize() *float64 {
	if f == nil {
		return nil
	}
	return f.MaxCacheSize
}

func (f *FunctionConfSchemaDNSLookup) GetUseResolvConf() *bool {
	if f == nil {
		return nil
	}
	return f.UseResolvConf
}

func (f *FunctionConfSchemaDNSLookup) GetLookupFallback() *bool {
	if f == nil {
		return nil
	}
	return f.LookupFallback
}

func (f *FunctionConfSchemaDNSLookup) GetDomainOverrides() []string {
	if f == nil {
		return nil
	}
	return f.DomainOverrides
}

func (f *FunctionConfSchemaDNSLookup) GetLookupFailLogLevel() *LogLevelForFailedLookups {
	if f == nil {
		return nil
	}
	return f.LookupFailLogLevel
}

func (f *FunctionConfSchemaDNSLookup) GetAdditionalProperties() map[string]any {
	if f == nil {
		return nil
	}
	return f.AdditionalProperties
}
