// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
// @generated-id: 106ac46ca0fc

package components

import (
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type TLSSettings2 struct {
}

func (t TLSSettings2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TLSSettings2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

type TLSSettings1 struct {
	DefaultCipherList  string `json:"defaultCipherList"`
	DefaultEcdhCurve   string `json:"defaultEcdhCurve"`
	MaxVersion         string `json:"maxVersion"`
	MinVersion         string `json:"minVersion"`
	RejectUnauthorized bool   `json:"rejectUnauthorized"`
}

func (t TLSSettings1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TLSSettings1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TLSSettings1) GetDefaultCipherList() string {
	if t == nil {
		return ""
	}
	return t.DefaultCipherList
}

func (t *TLSSettings1) GetDefaultEcdhCurve() string {
	if t == nil {
		return ""
	}
	return t.DefaultEcdhCurve
}

func (t *TLSSettings1) GetMaxVersion() string {
	if t == nil {
		return ""
	}
	return t.MaxVersion
}

func (t *TLSSettings1) GetMinVersion() string {
	if t == nil {
		return ""
	}
	return t.MinVersion
}

func (t *TLSSettings1) GetRejectUnauthorized() bool {
	if t == nil {
		return false
	}
	return t.RejectUnauthorized
}

type TLSSettingsUnionType string

const (
	TLSSettingsUnionTypeTLSSettings1 TLSSettingsUnionType = "TlsSettings_1"
	TLSSettingsUnionTypeTLSSettings2 TLSSettingsUnionType = "TlsSettings_2"
)

type TLSSettingsUnion struct {
	TLSSettings1 *TLSSettings1 `queryParam:"inline" union:"member"`
	TLSSettings2 *TLSSettings2 `queryParam:"inline" union:"member"`

	Type TLSSettingsUnionType
}

func CreateTLSSettingsUnionTLSSettings1(tlsSettings1 TLSSettings1) TLSSettingsUnion {
	typ := TLSSettingsUnionTypeTLSSettings1

	return TLSSettingsUnion{
		TLSSettings1: &tlsSettings1,
		Type:         typ,
	}
}

func CreateTLSSettingsUnionTLSSettings2(tlsSettings2 TLSSettings2) TLSSettingsUnion {
	typ := TLSSettingsUnionTypeTLSSettings2

	return TLSSettingsUnion{
		TLSSettings2: &tlsSettings2,
		Type:         typ,
	}
}

func (u *TLSSettingsUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var tlsSettings1 TLSSettings1 = TLSSettings1{}
	if err := utils.UnmarshalJSON(data, &tlsSettings1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TLSSettingsUnionTypeTLSSettings1,
			Value: &tlsSettings1,
		})
	}

	var tlsSettings2 TLSSettings2 = TLSSettings2{}
	if err := utils.UnmarshalJSON(data, &tlsSettings2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TLSSettingsUnionTypeTLSSettings2,
			Value: &tlsSettings2,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for TLSSettingsUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for TLSSettingsUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(TLSSettingsUnionType)
	switch best.Type {
	case TLSSettingsUnionTypeTLSSettings1:
		u.TLSSettings1 = best.Value.(*TLSSettings1)
		return nil
	case TLSSettingsUnionTypeTLSSettings2:
		u.TLSSettings2 = best.Value.(*TLSSettings2)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TLSSettingsUnion", string(data))
}

func (u TLSSettingsUnion) MarshalJSON() ([]byte, error) {
	if u.TLSSettings1 != nil {
		return utils.MarshalJSON(u.TLSSettings1, "", true)
	}

	if u.TLSSettings2 != nil {
		return utils.MarshalJSON(u.TLSSettings2, "", true)
	}

	return nil, errors.New("could not marshal union type TLSSettingsUnion: all fields are null")
}
