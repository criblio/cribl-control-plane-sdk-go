// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type OutputNetflowType string

const (
	OutputNetflowTypeNetflow OutputNetflowType = "netflow"
)

func (e OutputNetflowType) ToPointer() *OutputNetflowType {
	return &e
}
func (e *OutputNetflowType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "netflow":
		*e = OutputNetflowType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputNetflowType: %v", v)
	}
}

type OutputNetflowHost struct {
	// Destination host
	Host string `json:"host"`
	// Destination port, default is 2055
	Port *float64 `default:"2055" json:"port"`
}

func (o OutputNetflowHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutputNetflowHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"host"}); err != nil {
		return err
	}
	return nil
}

func (o *OutputNetflowHost) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *OutputNetflowHost) GetPort() *float64 {
	if o == nil {
		return nil
	}
	return o.Port
}

type OutputNetflow struct {
	// Unique ID for this output
	ID   *string           `json:"id,omitempty"`
	Type OutputNetflowType `json:"type"`
	// Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`
	// Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields []string `json:"systemFields,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// One or more NetFlow Destinations to forward events to
	Hosts []OutputNetflowHost `json:"hosts"`
	// How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup.
	DNSResolvePeriodSec *float64 `default:"0" json:"dnsResolvePeriodSec"`
	// Send NetFlow traffic using the original event's Source IP and port. To enable this, you must install the external `udp-sender` helper binary at `/usr/bin/udp-sender` on all Worker Nodes and grant it the `CAP_NET_RAW` capability.
	EnableIPSpoofing *bool   `default:"false" json:"enableIpSpoofing"`
	Description      *string `json:"description,omitempty"`
	// MTU in bytes. The actual maximum NetFlow payload size will be MTU minus IP and UDP headers (28 bytes for IPv4, 48 bytes for IPv6). For example, with the default MTU of 1500, the max payload is 1472 bytes for IPv4. Payloads exceeding this limit will be dropped.
	MaxRecordSize *float64 `default:"1500" json:"maxRecordSize"`
}

func (o OutputNetflow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutputNetflow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"type", "hosts"}); err != nil {
		return err
	}
	return nil
}

func (o *OutputNetflow) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OutputNetflow) GetType() OutputNetflowType {
	if o == nil {
		return OutputNetflowType("")
	}
	return o.Type
}

func (o *OutputNetflow) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *OutputNetflow) GetSystemFields() []string {
	if o == nil {
		return nil
	}
	return o.SystemFields
}

func (o *OutputNetflow) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *OutputNetflow) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *OutputNetflow) GetHosts() []OutputNetflowHost {
	if o == nil {
		return []OutputNetflowHost{}
	}
	return o.Hosts
}

func (o *OutputNetflow) GetDNSResolvePeriodSec() *float64 {
	if o == nil {
		return nil
	}
	return o.DNSResolvePeriodSec
}

func (o *OutputNetflow) GetEnableIPSpoofing() *bool {
	if o == nil {
		return nil
	}
	return o.EnableIPSpoofing
}

func (o *OutputNetflow) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OutputNetflow) GetMaxRecordSize() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxRecordSize
}
