// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// RetryType - The algorithm to use when performing HTTP retries
type RetryType string

const (
	// RetryTypeNone Disabled
	RetryTypeNone RetryType = "none"
	// RetryTypeBackoff Backoff
	RetryTypeBackoff RetryType = "backoff"
	// RetryTypeStatic Static
	RetryTypeStatic RetryType = "static"
)

func (e RetryType) ToPointer() *RetryType {
	return &e
}

type RetryRulesType struct {
	// The algorithm to use when performing HTTP retries
	Type *RetryType `default:"backoff" json:"type"`
	// Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `default:"1000" json:"interval"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `default:"5" json:"limit"`
	// Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
	Multiplier *float64 `default:"2" json:"multiplier"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitempty"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `default:"true" json:"enableHeader"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `default:"false" json:"retryConnectTimeout"`
	// Retry request when a connection reset (ECONNRESET) error occurs
	RetryConnectReset *bool `default:"false" json:"retryConnectReset"`
}

func (r RetryRulesType) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RetryRulesType) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *RetryRulesType) GetType() *RetryType {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *RetryRulesType) GetInterval() *float64 {
	if r == nil {
		return nil
	}
	return r.Interval
}

func (r *RetryRulesType) GetLimit() *float64 {
	if r == nil {
		return nil
	}
	return r.Limit
}

func (r *RetryRulesType) GetMultiplier() *float64 {
	if r == nil {
		return nil
	}
	return r.Multiplier
}

func (r *RetryRulesType) GetCodes() []float64 {
	if r == nil {
		return nil
	}
	return r.Codes
}

func (r *RetryRulesType) GetEnableHeader() *bool {
	if r == nil {
		return nil
	}
	return r.EnableHeader
}

func (r *RetryRulesType) GetRetryConnectTimeout() *bool {
	if r == nil {
		return nil
	}
	return r.RetryConnectTimeout
}

func (r *RetryRulesType) GetRetryConnectReset() *bool {
	if r == nil {
		return nil
	}
	return r.RetryConnectReset
}
