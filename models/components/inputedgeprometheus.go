// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type InputEdgePrometheusPqEnabledTrueWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool   `default:"false" json:"pqEnabled"`
	Pq        *PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       *string                 `json:"id,omitempty"`
	Type     InputEdgePrometheusType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputEdgePrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval *float64 `default:"15" json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64          `default:"5000" json:"timeout"`
	Persistence *DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *InputEdgePrometheusAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	Targets     []Target                                 `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *ProtocolOptionsTargetsItems `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                     `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                 `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `default:"metadata.annotations['prometheus.io/scheme'] || 'http'" json:"scrapeProtocolExpr"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `default:"metadata.annotations['prometheus.io/port'] || 9090" json:"scrapePortExpr"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `default:"metadata.annotations['prometheus.io/path'] || '/metrics'" json:"scrapePathExpr"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []PodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputEdgePrometheusPqEnabledTrueWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetType() InputEdgePrometheusType {
	if i == nil {
		return InputEdgePrometheusType("")
	}
	return i.Type
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDiscoveryType() *InputEdgePrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPersistence() *DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAuthType() *InputEdgePrometheusAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetTargets() []Target {
	if i == nil {
		return nil
	}
	return i.Targets
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetRecordType() *RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapeProtocol() *ProtocolOptionsTargetsItems {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetSearchFilter() []ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetSignatureVersion() *SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapeProtocolExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocolExpr
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapePortExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePortExpr
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetScrapePathExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePathExpr
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPodFilter() []PodFilter {
	if i == nil {
		return nil
	}
	return i.PodFilter
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputEdgePrometheusPqEnabledTrueWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputEdgePrometheusPqEnabledFalseWithPqConstraint struct {
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool   `default:"false" json:"pqEnabled"`
	Pq        *PqType `json:"pq,omitempty"`
	// Unique ID for this input
	ID       *string                 `json:"id,omitempty"`
	Type     InputEdgePrometheusType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputEdgePrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval *float64 `default:"15" json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64          `default:"5000" json:"timeout"`
	Persistence *DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *InputEdgePrometheusAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	Targets     []Target                                 `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *ProtocolOptionsTargetsItems `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                     `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                 `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `default:"metadata.annotations['prometheus.io/scheme'] || 'http'" json:"scrapeProtocolExpr"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `default:"metadata.annotations['prometheus.io/port'] || 9090" json:"scrapePortExpr"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `default:"metadata.annotations['prometheus.io/path'] || '/metrics'" json:"scrapePathExpr"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []PodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputEdgePrometheusPqEnabledFalseWithPqConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetType() InputEdgePrometheusType {
	if i == nil {
		return InputEdgePrometheusType("")
	}
	return i.Type
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDiscoveryType() *InputEdgePrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPersistence() *DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAuthType() *InputEdgePrometheusAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetTargets() []Target {
	if i == nil {
		return nil
	}
	return i.Targets
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetRecordType() *RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapeProtocol() *ProtocolOptionsTargetsItems {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetSearchFilter() []ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetSignatureVersion() *SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapeProtocolExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocolExpr
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapePortExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePortExpr
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetScrapePathExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePathExpr
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPodFilter() []PodFilter {
	if i == nil {
		return nil
	}
	return i.PodFilter
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputEdgePrometheusPqEnabledFalseWithPqConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       *string                 `json:"id,omitempty"`
	Type     InputEdgePrometheusType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	Pq         *PqType  `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputEdgePrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval *float64 `default:"15" json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64          `default:"5000" json:"timeout"`
	Persistence *DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *InputEdgePrometheusAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	Targets     []Target                                 `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *ProtocolOptionsTargetsItems `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                     `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                 `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `default:"metadata.annotations['prometheus.io/scheme'] || 'http'" json:"scrapeProtocolExpr"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `default:"metadata.annotations['prometheus.io/port'] || 9090" json:"scrapePortExpr"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `default:"metadata.annotations['prometheus.io/path'] || '/metrics'" json:"scrapePathExpr"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []PodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetType() InputEdgePrometheusType {
	if i == nil {
		return InputEdgePrometheusType("")
	}
	return i.Type
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDiscoveryType() *InputEdgePrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPersistence() *DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAuthType() *InputEdgePrometheusAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetTargets() []Target {
	if i == nil {
		return nil
	}
	return i.Targets
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetRecordType() *RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapeProtocol() *ProtocolOptionsTargetsItems {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetSearchFilter() []ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetSignatureVersion() *SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapeProtocolExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocolExpr
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePortExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePortExpr
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetScrapePathExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePathExpr
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPodFilter() []PodFilter {
	if i == nil {
		return nil
	}
	return i.PodFilter
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputEdgePrometheusType string

const (
	InputEdgePrometheusTypeEdgePrometheus InputEdgePrometheusType = "edge_prometheus"
)

func (e InputEdgePrometheusType) ToPointer() *InputEdgePrometheusType {
	return &e
}
func (e *InputEdgePrometheusType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "edge_prometheus":
		*e = InputEdgePrometheusType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputEdgePrometheusType: %v", v)
	}
}

// InputEdgePrometheusDiscoveryType - Target discovery mechanism. Use static to manually enter a list of targets.
type InputEdgePrometheusDiscoveryType string

const (
	// InputEdgePrometheusDiscoveryTypeStatic Static
	InputEdgePrometheusDiscoveryTypeStatic InputEdgePrometheusDiscoveryType = "static"
	// InputEdgePrometheusDiscoveryTypeDNS DNS
	InputEdgePrometheusDiscoveryTypeDNS InputEdgePrometheusDiscoveryType = "dns"
	// InputEdgePrometheusDiscoveryTypeEc2 AWS EC2
	InputEdgePrometheusDiscoveryTypeEc2 InputEdgePrometheusDiscoveryType = "ec2"
	// InputEdgePrometheusDiscoveryTypeK8sNode Kubernetes Node
	InputEdgePrometheusDiscoveryTypeK8sNode InputEdgePrometheusDiscoveryType = "k8s-node"
	// InputEdgePrometheusDiscoveryTypeK8sPods Kubernetes Pods
	InputEdgePrometheusDiscoveryTypeK8sPods InputEdgePrometheusDiscoveryType = "k8s-pods"
)

func (e InputEdgePrometheusDiscoveryType) ToPointer() *InputEdgePrometheusDiscoveryType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputEdgePrometheusDiscoveryType) IsExact() bool {
	if e != nil {
		switch *e {
		case "static", "dns", "ec2", "k8s-node", "k8s-pods":
			return true
		}
	}
	return false
}

// InputEdgePrometheusAuthenticationMethod - Enter credentials directly, or select a stored secret
type InputEdgePrometheusAuthenticationMethod string

const (
	InputEdgePrometheusAuthenticationMethodManual     InputEdgePrometheusAuthenticationMethod = "manual"
	InputEdgePrometheusAuthenticationMethodSecret     InputEdgePrometheusAuthenticationMethod = "secret"
	InputEdgePrometheusAuthenticationMethodKubernetes InputEdgePrometheusAuthenticationMethod = "kubernetes"
)

func (e InputEdgePrometheusAuthenticationMethod) ToPointer() *InputEdgePrometheusAuthenticationMethod {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *InputEdgePrometheusAuthenticationMethod) IsExact() bool {
	if e != nil {
		switch *e {
		case "manual", "secret", "kubernetes":
			return true
		}
	}
	return false
}

type Target struct {
	// Protocol to use when collecting metrics
	Protocol *ProtocolOptionsTargetsItems `default:"http" json:"protocol"`
	// Name of host from which to pull metrics.
	Host string `json:"host"`
	// The port number in the metrics URL for discovered targets.
	Port *float64 `default:"9090" json:"port"`
	// Path to use when collecting metrics from discovered targets
	Path *string `default:"/metrics" json:"path"`
}

func (t Target) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Target) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"host"}); err != nil {
		return err
	}
	return nil
}

func (t *Target) GetProtocol() *ProtocolOptionsTargetsItems {
	if t == nil {
		return nil
	}
	return t.Protocol
}

func (t *Target) GetHost() string {
	if t == nil {
		return ""
	}
	return t.Host
}

func (t *Target) GetPort() *float64 {
	if t == nil {
		return nil
	}
	return t.Port
}

func (t *Target) GetPath() *string {
	if t == nil {
		return nil
	}
	return t.Path
}

type PodFilter struct {
	// JavaScript expression applied to pods objects. Return 'true' to include it.
	Filter string `json:"filter"`
	// Optional description of this rule's purpose
	Description *string `json:"description,omitempty"`
}

func (p PodFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PodFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"filter"}); err != nil {
		return err
	}
	return nil
}

func (p *PodFilter) GetFilter() string {
	if p == nil {
		return ""
	}
	return p.Filter
}

func (p *PodFilter) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

type InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint struct {
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `default:"true" json:"sendToRoutes"`
	// Direct connections to Destinations, and optionally via a Pipeline or a Pack
	Connections []ItemsTypeConnections `json:"connections,omitempty"`
	// Unique ID for this input
	ID       *string                 `json:"id,omitempty"`
	Type     InputEdgePrometheusType `json:"type"`
	Disabled *bool                   `default:"false" json:"disabled"`
	// Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *bool `default:"false" json:"pqEnabled"`
	// Tags for filtering and grouping in @{product}
	Streamtags []string `json:"streamtags,omitempty"`
	Pq         *PqType  `json:"pq,omitempty"`
	// Other dimensions to include in events
	DimensionList []string `json:"dimensionList,omitempty"`
	// Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputEdgePrometheusDiscoveryType `default:"static" json:"discoveryType"`
	// How often in seconds to scrape targets for metrics.
	Interval *float64 `default:"15" json:"interval"`
	// Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout     *float64          `default:"5000" json:"timeout"`
	Persistence *DiskSpoolingType `json:"persistence,omitempty"`
	// Fields to add to events from this input
	Metadata []ItemsTypeNotificationMetadata `json:"metadata,omitempty"`
	// Enter credentials directly, or select a stored secret
	AuthType    *InputEdgePrometheusAuthenticationMethod `default:"manual" json:"authType"`
	Description *string                                  `json:"description,omitempty"`
	Targets     []Target                                 `json:"targets,omitempty"`
	// DNS record type to resolve
	RecordType *RecordTypeOptions `default:"SRV" json:"recordType"`
	// The port number in the metrics URL for discovered targets.
	ScrapePort *float64 `default:"9090" json:"scrapePort"`
	// List of DNS names to resolve
	NameList []string `json:"nameList,omitempty"`
	// Protocol to use when collecting metrics
	ScrapeProtocol *ProtocolOptionsTargetsItems `default:"http" json:"scrapeProtocol"`
	// Path to use when collecting metrics from discovered targets
	ScrapePath *string `default:"/metrics" json:"scrapePath"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *AuthenticationMethodOptionsS3CollectorConf `default:"auto" json:"awsAuthenticationMethod"`
	AwsAPIKey               *string                                     `json:"awsApiKey,omitempty"`
	// Select or create a stored secret that references your access key and secret key
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Use public IP address for discovered targets. Disable to use the private IP address.
	UsePublicIP *bool `default:"true" json:"usePublicIp"`
	// Filter to apply when searching for EC2 instances
	SearchFilter []ItemsTypeSearchFilter `json:"searchFilter,omitempty"`
	AwsSecretKey *string                 `json:"awsSecretKey,omitempty"`
	// Region where the EC2 is located
	Region *string `json:"region,omitempty"`
	// EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Signature version to use for signing EC2 requests
	SignatureVersion *SignatureVersionOptions1 `default:"v4" json:"signatureVersion"`
	// Reuse connections between requests, which can improve performance
	ReuseConnections *bool `default:"true" json:"reuseConnections"`
	// Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `default:"false" json:"enableAssumeRole"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float64 `default:"3600" json:"durationSeconds"`
	// Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `default:"metadata.annotations['prometheus.io/scheme'] || 'http'" json:"scrapeProtocolExpr"`
	// The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `default:"metadata.annotations['prometheus.io/port'] || 9090" json:"scrapePortExpr"`
	// Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `default:"metadata.annotations['prometheus.io/path'] || '/metrics'" json:"scrapePathExpr"`
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	//
	PodFilter []PodFilter `json:"podFilter,omitempty"`
	// Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
	// Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`
	// Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
}

func (i InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetConnections() []ItemsTypeConnections {
	if i == nil {
		return nil
	}
	return i.Connections
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetType() InputEdgePrometheusType {
	if i == nil {
		return InputEdgePrometheusType("")
	}
	return i.Type
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPqEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.PqEnabled
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPq() *PqType {
	if i == nil {
		return nil
	}
	return i.Pq
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDimensionList() []string {
	if i == nil {
		return nil
	}
	return i.DimensionList
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDiscoveryType() *InputEdgePrometheusDiscoveryType {
	if i == nil {
		return nil
	}
	return i.DiscoveryType
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetInterval() *float64 {
	if i == nil {
		return nil
	}
	return i.Interval
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetTimeout() *float64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPersistence() *DiskSpoolingType {
	if i == nil {
		return nil
	}
	return i.Persistence
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetMetadata() []ItemsTypeNotificationMetadata {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAuthType() *InputEdgePrometheusAuthenticationMethod {
	if i == nil {
		return nil
	}
	return i.AuthType
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetTargets() []Target {
	if i == nil {
		return nil
	}
	return i.Targets
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetRecordType() *RecordTypeOptions {
	if i == nil {
		return nil
	}
	return i.RecordType
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePort() *float64 {
	if i == nil {
		return nil
	}
	return i.ScrapePort
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetNameList() []string {
	if i == nil {
		return nil
	}
	return i.NameList
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapeProtocol() *ProtocolOptionsTargetsItems {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocol
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePath() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePath
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsAuthenticationMethod() *AuthenticationMethodOptionsS3CollectorConf {
	if i == nil {
		return nil
	}
	return i.AwsAuthenticationMethod
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsAPIKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsAPIKey
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsSecret() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecret
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetUsePublicIP() *bool {
	if i == nil {
		return nil
	}
	return i.UsePublicIP
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetSearchFilter() []ItemsTypeSearchFilter {
	if i == nil {
		return nil
	}
	return i.SearchFilter
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAwsSecretKey() *string {
	if i == nil {
		return nil
	}
	return i.AwsSecretKey
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetRegion() *string {
	if i == nil {
		return nil
	}
	return i.Region
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetEndpoint() *string {
	if i == nil {
		return nil
	}
	return i.Endpoint
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetSignatureVersion() *SignatureVersionOptions1 {
	if i == nil {
		return nil
	}
	return i.SignatureVersion
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetReuseConnections() *bool {
	if i == nil {
		return nil
	}
	return i.ReuseConnections
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetEnableAssumeRole() *bool {
	if i == nil {
		return nil
	}
	return i.EnableAssumeRole
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleArn() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleArn
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetAssumeRoleExternalID() *string {
	if i == nil {
		return nil
	}
	return i.AssumeRoleExternalID
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetDurationSeconds() *float64 {
	if i == nil {
		return nil
	}
	return i.DurationSeconds
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapeProtocolExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapeProtocolExpr
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePortExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePortExpr
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetScrapePathExpr() *string {
	if i == nil {
		return nil
	}
	return i.ScrapePathExpr
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPodFilter() []PodFilter {
	if i == nil {
		return nil
	}
	return i.PodFilter
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

type InputEdgePrometheusUnionType string

const (
	InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint  InputEdgePrometheusUnionType = "InputEdgePrometheus_SendToRoutesTrueWithConnectionsConstraint"
	InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint InputEdgePrometheusUnionType = "InputEdgePrometheus_SendToRoutesFalseWithConnectionsConstraint"
	InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledFalseWithPqConstraint             InputEdgePrometheusUnionType = "InputEdgePrometheus_PqEnabledFalseWithPqConstraint"
	InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledTrueWithPqConstraint              InputEdgePrometheusUnionType = "InputEdgePrometheus_PqEnabledTrueWithPqConstraint"
)

type InputEdgePrometheus struct {
	InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint  *InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint  `queryParam:"inline" union:"member"`
	InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint *InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint `queryParam:"inline" union:"member"`
	InputEdgePrometheusPqEnabledFalseWithPqConstraint             *InputEdgePrometheusPqEnabledFalseWithPqConstraint             `queryParam:"inline" union:"member"`
	InputEdgePrometheusPqEnabledTrueWithPqConstraint              *InputEdgePrometheusPqEnabledTrueWithPqConstraint              `queryParam:"inline" union:"member"`

	Type InputEdgePrometheusUnionType
}

func CreateInputEdgePrometheusInputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint(inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint) InputEdgePrometheus {
	typ := InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint

	return InputEdgePrometheus{
		InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint: &inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputEdgePrometheusInputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint(inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint) InputEdgePrometheus {
	typ := InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint

	return InputEdgePrometheus{
		InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint: &inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint,
		Type: typ,
	}
}

func CreateInputEdgePrometheusInputEdgePrometheusPqEnabledFalseWithPqConstraint(inputEdgePrometheusPqEnabledFalseWithPqConstraint InputEdgePrometheusPqEnabledFalseWithPqConstraint) InputEdgePrometheus {
	typ := InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledFalseWithPqConstraint

	return InputEdgePrometheus{
		InputEdgePrometheusPqEnabledFalseWithPqConstraint: &inputEdgePrometheusPqEnabledFalseWithPqConstraint,
		Type: typ,
	}
}

func CreateInputEdgePrometheusInputEdgePrometheusPqEnabledTrueWithPqConstraint(inputEdgePrometheusPqEnabledTrueWithPqConstraint InputEdgePrometheusPqEnabledTrueWithPqConstraint) InputEdgePrometheus {
	typ := InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledTrueWithPqConstraint

	return InputEdgePrometheus{
		InputEdgePrometheusPqEnabledTrueWithPqConstraint: &inputEdgePrometheusPqEnabledTrueWithPqConstraint,
		Type: typ,
	}
}

func (u *InputEdgePrometheus) UnmarshalJSON(data []byte) error {

	var inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint = InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint = &inputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint
		u.Type = InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint
		return nil
	}

	var inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint = InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint, "", true, nil); err == nil {
		u.InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint = &inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint
		u.Type = InputEdgePrometheusUnionTypeInputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint
		return nil
	}

	var inputEdgePrometheusPqEnabledFalseWithPqConstraint InputEdgePrometheusPqEnabledFalseWithPqConstraint = InputEdgePrometheusPqEnabledFalseWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEdgePrometheusPqEnabledFalseWithPqConstraint, "", true, nil); err == nil {
		u.InputEdgePrometheusPqEnabledFalseWithPqConstraint = &inputEdgePrometheusPqEnabledFalseWithPqConstraint
		u.Type = InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledFalseWithPqConstraint
		return nil
	}

	var inputEdgePrometheusPqEnabledTrueWithPqConstraint InputEdgePrometheusPqEnabledTrueWithPqConstraint = InputEdgePrometheusPqEnabledTrueWithPqConstraint{}
	if err := utils.UnmarshalJSON(data, &inputEdgePrometheusPqEnabledTrueWithPqConstraint, "", true, nil); err == nil {
		u.InputEdgePrometheusPqEnabledTrueWithPqConstraint = &inputEdgePrometheusPqEnabledTrueWithPqConstraint
		u.Type = InputEdgePrometheusUnionTypeInputEdgePrometheusPqEnabledTrueWithPqConstraint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputEdgePrometheus", string(data))
}

func (u InputEdgePrometheus) MarshalJSON() ([]byte, error) {
	if u.InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputEdgePrometheusSendToRoutesTrueWithConnectionsConstraint, "", true)
	}

	if u.InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint != nil {
		return utils.MarshalJSON(u.InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint, "", true)
	}

	if u.InputEdgePrometheusPqEnabledFalseWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputEdgePrometheusPqEnabledFalseWithPqConstraint, "", true)
	}

	if u.InputEdgePrometheusPqEnabledTrueWithPqConstraint != nil {
		return utils.MarshalJSON(u.InputEdgePrometheusPqEnabledTrueWithPqConstraint, "", true)
	}

	return nil, errors.New("could not marshal union type InputEdgePrometheus: all fields are null")
}
