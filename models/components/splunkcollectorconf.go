// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// SplunkAuthenticationTokenSecretAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationTokenSecretAuthentication string

const (
	// SplunkAuthenticationTokenSecretAuthenticationNone None
	SplunkAuthenticationTokenSecretAuthenticationNone SplunkAuthenticationTokenSecretAuthentication = "none"
	// SplunkAuthenticationTokenSecretAuthenticationBasic Basic
	SplunkAuthenticationTokenSecretAuthenticationBasic SplunkAuthenticationTokenSecretAuthentication = "basic"
	// SplunkAuthenticationTokenSecretAuthenticationBasicSecret Basic (credentials secret)
	SplunkAuthenticationTokenSecretAuthenticationBasicSecret SplunkAuthenticationTokenSecretAuthentication = "basicSecret"
	// SplunkAuthenticationTokenSecretAuthenticationToken Bearer Token
	SplunkAuthenticationTokenSecretAuthenticationToken SplunkAuthenticationTokenSecretAuthentication = "token"
	// SplunkAuthenticationTokenSecretAuthenticationTokenSecret Bearer Token (text secret)
	SplunkAuthenticationTokenSecretAuthenticationTokenSecret SplunkAuthenticationTokenSecretAuthentication = "tokenSecret"
)

func (e SplunkAuthenticationTokenSecretAuthentication) ToPointer() *SplunkAuthenticationTokenSecretAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationTokenSecretAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationTokenSecretCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationTokenSecretCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationTokenSecretCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationTokenSecretCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationTokenSecretCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationTokenSecretCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
	Multiplier *float64 `json:"multiplier,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetMultiplier() *float64 {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
}

func (s SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

type SplunkAuthenticationTokenSecretRetryRulesType string

const (
	SplunkAuthenticationTokenSecretRetryRulesTypeNone    SplunkAuthenticationTokenSecretRetryRulesType = "none"
	SplunkAuthenticationTokenSecretRetryRulesTypeStatic  SplunkAuthenticationTokenSecretRetryRulesType = "static"
	SplunkAuthenticationTokenSecretRetryRulesTypeBackoff SplunkAuthenticationTokenSecretRetryRulesType = "backoff"
	SplunkAuthenticationTokenSecretRetryRulesTypeUnknown SplunkAuthenticationTokenSecretRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationTokenSecretRetryRules struct {
	SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone    *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic  *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                                 json.RawMessage                                             `json:"-" union:"unknown"`

	Type SplunkAuthenticationTokenSecretRetryRulesType
}

func CreateSplunkAuthenticationTokenSecretRetryRulesNone(none SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) SplunkAuthenticationTokenSecretRetryRules {
	typ := SplunkAuthenticationTokenSecretRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationTokenSecretRetryRules{
		SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenSecretRetryRulesStatic(static SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) SplunkAuthenticationTokenSecretRetryRules {
	typ := SplunkAuthenticationTokenSecretRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationTokenSecretRetryRules{
		SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenSecretRetryRulesBackoff(backoff SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) SplunkAuthenticationTokenSecretRetryRules {
	typ := SplunkAuthenticationTokenSecretRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationTokenSecretRetryRules{
		SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenSecretRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationTokenSecretRetryRules {
	return SplunkAuthenticationTokenSecretRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationTokenSecretRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationTokenSecretRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationTokenSecretRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationTokenSecretRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationTokenSecretRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationTokenSecretSplunkRetryRulesTypeNone := new(SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSecretSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone within SplunkAuthenticationTokenSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone = splunkAuthenticationTokenSecretSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic := new(SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic within SplunkAuthenticationTokenSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic = splunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff within SplunkAuthenticationTokenSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff = splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationTokenSecretRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationTokenSecretRetryRules: all fields are null")
}

type SplunkAuthenticationTokenSecret struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationTokenSecretAuthentication `json:"authentication"`
	// Select or create a stored secret that references your Bearer token
	TokenSecret string `json:"tokenSecret"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationTokenSecretCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationTokenSecretCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                      `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationTokenSecretRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationTokenSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecret) GetAuthentication() SplunkAuthenticationTokenSecretAuthentication {
	if s == nil {
		return SplunkAuthenticationTokenSecretAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationTokenSecret) GetTokenSecret() string {
	if s == nil {
		return ""
	}
	return s.TokenSecret
}

func (s *SplunkAuthenticationTokenSecret) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationTokenSecret) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationTokenSecret) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationTokenSecret) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationTokenSecret) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationTokenSecret) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationTokenSecret) GetCollectRequestParams() []SplunkAuthenticationTokenSecretCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationTokenSecret) GetCollectRequestHeaders() []SplunkAuthenticationTokenSecretCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationTokenSecret) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationTokenSecret) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationTokenSecret) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationTokenSecret) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationTokenSecret) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationTokenSecret) GetRetryRules() *SplunkAuthenticationTokenSecretRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationTokenSecret) GetRetryRulesNone() *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecret) GetRetryRulesStatic() *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecret) GetRetryRulesBackoff() *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationTokenAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationTokenAuthentication string

const (
	// SplunkAuthenticationTokenAuthenticationNone None
	SplunkAuthenticationTokenAuthenticationNone SplunkAuthenticationTokenAuthentication = "none"
	// SplunkAuthenticationTokenAuthenticationBasic Basic
	SplunkAuthenticationTokenAuthenticationBasic SplunkAuthenticationTokenAuthentication = "basic"
	// SplunkAuthenticationTokenAuthenticationBasicSecret Basic (credentials secret)
	SplunkAuthenticationTokenAuthenticationBasicSecret SplunkAuthenticationTokenAuthentication = "basicSecret"
	// SplunkAuthenticationTokenAuthenticationToken Bearer Token
	SplunkAuthenticationTokenAuthenticationToken SplunkAuthenticationTokenAuthentication = "token"
	// SplunkAuthenticationTokenAuthenticationTokenSecret Bearer Token (text secret)
	SplunkAuthenticationTokenAuthenticationTokenSecret SplunkAuthenticationTokenAuthentication = "tokenSecret"
)

func (e SplunkAuthenticationTokenAuthentication) ToPointer() *SplunkAuthenticationTokenAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationTokenAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationTokenCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationTokenCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationTokenCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationTokenCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationTokenCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationTokenCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
	Multiplier *float64 `json:"multiplier,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetMultiplier() *float64 {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationTokenSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationTokenSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
}

func (s SplunkAuthenticationTokenSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

type SplunkAuthenticationTokenRetryRulesType string

const (
	SplunkAuthenticationTokenRetryRulesTypeNone    SplunkAuthenticationTokenRetryRulesType = "none"
	SplunkAuthenticationTokenRetryRulesTypeStatic  SplunkAuthenticationTokenRetryRulesType = "static"
	SplunkAuthenticationTokenRetryRulesTypeBackoff SplunkAuthenticationTokenRetryRulesType = "backoff"
	SplunkAuthenticationTokenRetryRulesTypeUnknown SplunkAuthenticationTokenRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationTokenRetryRules struct {
	SplunkAuthenticationTokenSplunkRetryRulesTypeNone    *SplunkAuthenticationTokenSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSplunkRetryRulesTypeStatic  *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                           json.RawMessage                                       `json:"-" union:"unknown"`

	Type SplunkAuthenticationTokenRetryRulesType
}

func CreateSplunkAuthenticationTokenRetryRulesNone(none SplunkAuthenticationTokenSplunkRetryRulesTypeNone) SplunkAuthenticationTokenRetryRules {
	typ := SplunkAuthenticationTokenRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationTokenRetryRules{
		SplunkAuthenticationTokenSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenRetryRulesStatic(static SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) SplunkAuthenticationTokenRetryRules {
	typ := SplunkAuthenticationTokenRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationTokenRetryRules{
		SplunkAuthenticationTokenSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenRetryRulesBackoff(backoff SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) SplunkAuthenticationTokenRetryRules {
	typ := SplunkAuthenticationTokenRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationTokenRetryRules{
		SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationTokenRetryRules {
	return SplunkAuthenticationTokenRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationTokenRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationTokenRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationTokenRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationTokenRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationTokenRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationTokenSplunkRetryRulesTypeNone := new(SplunkAuthenticationTokenSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationTokenSplunkRetryRulesTypeNone within SplunkAuthenticationTokenRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSplunkRetryRulesTypeNone = splunkAuthenticationTokenSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationTokenRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationTokenSplunkRetryRulesTypeStatic := new(SplunkAuthenticationTokenSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationTokenSplunkRetryRulesTypeStatic within SplunkAuthenticationTokenRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSplunkRetryRulesTypeStatic = splunkAuthenticationTokenSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationTokenRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationTokenSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff within SplunkAuthenticationTokenRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff = splunkAuthenticationTokenSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationTokenRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationTokenRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationTokenSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationTokenSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationTokenRetryRules: all fields are null")
}

type SplunkAuthenticationToken struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationTokenAuthentication `json:"authentication"`
	Token          string                                  `json:"token"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationTokenCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationTokenCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationTokenRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationToken) GetAuthentication() SplunkAuthenticationTokenAuthentication {
	if s == nil {
		return SplunkAuthenticationTokenAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationToken) GetToken() string {
	if s == nil {
		return ""
	}
	return s.Token
}

func (s *SplunkAuthenticationToken) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationToken) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationToken) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationToken) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationToken) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationToken) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationToken) GetCollectRequestParams() []SplunkAuthenticationTokenCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationToken) GetCollectRequestHeaders() []SplunkAuthenticationTokenCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationToken) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationToken) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationToken) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationToken) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationToken) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationToken) GetRetryRules() *SplunkAuthenticationTokenRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationToken) GetRetryRulesNone() *SplunkAuthenticationTokenSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationToken) GetRetryRulesStatic() *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationToken) GetRetryRulesBackoff() *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationBasicSecretAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationBasicSecretAuthentication string

const (
	// SplunkAuthenticationBasicSecretAuthenticationNone None
	SplunkAuthenticationBasicSecretAuthenticationNone SplunkAuthenticationBasicSecretAuthentication = "none"
	// SplunkAuthenticationBasicSecretAuthenticationBasic Basic
	SplunkAuthenticationBasicSecretAuthenticationBasic SplunkAuthenticationBasicSecretAuthentication = "basic"
	// SplunkAuthenticationBasicSecretAuthenticationBasicSecret Basic (credentials secret)
	SplunkAuthenticationBasicSecretAuthenticationBasicSecret SplunkAuthenticationBasicSecretAuthentication = "basicSecret"
	// SplunkAuthenticationBasicSecretAuthenticationToken Bearer Token
	SplunkAuthenticationBasicSecretAuthenticationToken SplunkAuthenticationBasicSecretAuthentication = "token"
	// SplunkAuthenticationBasicSecretAuthenticationTokenSecret Bearer Token (text secret)
	SplunkAuthenticationBasicSecretAuthenticationTokenSecret SplunkAuthenticationBasicSecretAuthentication = "tokenSecret"
)

func (e SplunkAuthenticationBasicSecretAuthentication) ToPointer() *SplunkAuthenticationBasicSecretAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationBasicSecretAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationBasicSecretCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationBasicSecretCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationBasicSecretCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationBasicSecretCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationBasicSecretCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationBasicSecretCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
	Multiplier *float64 `json:"multiplier,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetMultiplier() *float64 {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
}

func (s SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

type SplunkAuthenticationBasicSecretRetryRulesType string

const (
	SplunkAuthenticationBasicSecretRetryRulesTypeNone    SplunkAuthenticationBasicSecretRetryRulesType = "none"
	SplunkAuthenticationBasicSecretRetryRulesTypeStatic  SplunkAuthenticationBasicSecretRetryRulesType = "static"
	SplunkAuthenticationBasicSecretRetryRulesTypeBackoff SplunkAuthenticationBasicSecretRetryRulesType = "backoff"
	SplunkAuthenticationBasicSecretRetryRulesTypeUnknown SplunkAuthenticationBasicSecretRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationBasicSecretRetryRules struct {
	SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone    *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic  *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                                 json.RawMessage                                             `json:"-" union:"unknown"`

	Type SplunkAuthenticationBasicSecretRetryRulesType
}

func CreateSplunkAuthenticationBasicSecretRetryRulesNone(none SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) SplunkAuthenticationBasicSecretRetryRules {
	typ := SplunkAuthenticationBasicSecretRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationBasicSecretRetryRules{
		SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicSecretRetryRulesStatic(static SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) SplunkAuthenticationBasicSecretRetryRules {
	typ := SplunkAuthenticationBasicSecretRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationBasicSecretRetryRules{
		SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicSecretRetryRulesBackoff(backoff SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) SplunkAuthenticationBasicSecretRetryRules {
	typ := SplunkAuthenticationBasicSecretRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationBasicSecretRetryRules{
		SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicSecretRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationBasicSecretRetryRules {
	return SplunkAuthenticationBasicSecretRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationBasicSecretRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationBasicSecretRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationBasicSecretRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationBasicSecretRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationBasicSecretRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationBasicSecretSplunkRetryRulesTypeNone := new(SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSecretSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone within SplunkAuthenticationBasicSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone = splunkAuthenticationBasicSecretSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic := new(SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic within SplunkAuthenticationBasicSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic = splunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff within SplunkAuthenticationBasicSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff = splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationBasicSecretRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationBasicSecretRetryRules: all fields are null")
}

type SplunkAuthenticationBasicSecret struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationBasicSecretAuthentication `json:"authentication"`
	// Select or create a stored secret that references your credentials
	CredentialsSecret string `json:"credentialsSecret"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationBasicSecretCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationBasicSecretCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                      `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationBasicSecretRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationBasicSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecret) GetAuthentication() SplunkAuthenticationBasicSecretAuthentication {
	if s == nil {
		return SplunkAuthenticationBasicSecretAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationBasicSecret) GetCredentialsSecret() string {
	if s == nil {
		return ""
	}
	return s.CredentialsSecret
}

func (s *SplunkAuthenticationBasicSecret) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationBasicSecret) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationBasicSecret) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationBasicSecret) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationBasicSecret) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationBasicSecret) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationBasicSecret) GetCollectRequestParams() []SplunkAuthenticationBasicSecretCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationBasicSecret) GetCollectRequestHeaders() []SplunkAuthenticationBasicSecretCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationBasicSecret) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationBasicSecret) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationBasicSecret) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationBasicSecret) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationBasicSecret) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationBasicSecret) GetRetryRules() *SplunkAuthenticationBasicSecretRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationBasicSecret) GetRetryRulesNone() *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecret) GetRetryRulesStatic() *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecret) GetRetryRulesBackoff() *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationBasicAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationBasicAuthentication string

const (
	// SplunkAuthenticationBasicAuthenticationNone None
	SplunkAuthenticationBasicAuthenticationNone SplunkAuthenticationBasicAuthentication = "none"
	// SplunkAuthenticationBasicAuthenticationBasic Basic
	SplunkAuthenticationBasicAuthenticationBasic SplunkAuthenticationBasicAuthentication = "basic"
	// SplunkAuthenticationBasicAuthenticationBasicSecret Basic (credentials secret)
	SplunkAuthenticationBasicAuthenticationBasicSecret SplunkAuthenticationBasicAuthentication = "basicSecret"
	// SplunkAuthenticationBasicAuthenticationToken Bearer Token
	SplunkAuthenticationBasicAuthenticationToken SplunkAuthenticationBasicAuthentication = "token"
	// SplunkAuthenticationBasicAuthenticationTokenSecret Bearer Token (text secret)
	SplunkAuthenticationBasicAuthenticationTokenSecret SplunkAuthenticationBasicAuthentication = "tokenSecret"
)

func (e SplunkAuthenticationBasicAuthentication) ToPointer() *SplunkAuthenticationBasicAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationBasicAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationBasicCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationBasicCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationBasicCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationBasicCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationBasicCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationBasicCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
	Multiplier *float64 `json:"multiplier,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetMultiplier() *float64 {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationBasicSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationBasicSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
}

func (s SplunkAuthenticationBasicSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

type SplunkAuthenticationBasicRetryRulesType string

const (
	SplunkAuthenticationBasicRetryRulesTypeNone    SplunkAuthenticationBasicRetryRulesType = "none"
	SplunkAuthenticationBasicRetryRulesTypeStatic  SplunkAuthenticationBasicRetryRulesType = "static"
	SplunkAuthenticationBasicRetryRulesTypeBackoff SplunkAuthenticationBasicRetryRulesType = "backoff"
	SplunkAuthenticationBasicRetryRulesTypeUnknown SplunkAuthenticationBasicRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationBasicRetryRules struct {
	SplunkAuthenticationBasicSplunkRetryRulesTypeNone    *SplunkAuthenticationBasicSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSplunkRetryRulesTypeStatic  *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                           json.RawMessage                                       `json:"-" union:"unknown"`

	Type SplunkAuthenticationBasicRetryRulesType
}

func CreateSplunkAuthenticationBasicRetryRulesNone(none SplunkAuthenticationBasicSplunkRetryRulesTypeNone) SplunkAuthenticationBasicRetryRules {
	typ := SplunkAuthenticationBasicRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationBasicRetryRules{
		SplunkAuthenticationBasicSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicRetryRulesStatic(static SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) SplunkAuthenticationBasicRetryRules {
	typ := SplunkAuthenticationBasicRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationBasicRetryRules{
		SplunkAuthenticationBasicSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicRetryRulesBackoff(backoff SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) SplunkAuthenticationBasicRetryRules {
	typ := SplunkAuthenticationBasicRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationBasicRetryRules{
		SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationBasicRetryRules {
	return SplunkAuthenticationBasicRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationBasicRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationBasicRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationBasicRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationBasicRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationBasicRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationBasicSplunkRetryRulesTypeNone := new(SplunkAuthenticationBasicSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationBasicSplunkRetryRulesTypeNone within SplunkAuthenticationBasicRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSplunkRetryRulesTypeNone = splunkAuthenticationBasicSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationBasicRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationBasicSplunkRetryRulesTypeStatic := new(SplunkAuthenticationBasicSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationBasicSplunkRetryRulesTypeStatic within SplunkAuthenticationBasicRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSplunkRetryRulesTypeStatic = splunkAuthenticationBasicSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationBasicRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationBasicSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff within SplunkAuthenticationBasicRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff = splunkAuthenticationBasicSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationBasicRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationBasicRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationBasicSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationBasicSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationBasicRetryRules: all fields are null")
}

type SplunkAuthenticationBasic struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationBasicAuthentication `json:"authentication"`
	// Basic authentication username
	Username string `json:"username"`
	// Basic authentication password
	Password string `json:"password"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationBasicCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationBasicCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationBasicRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationBasic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasic) GetAuthentication() SplunkAuthenticationBasicAuthentication {
	if s == nil {
		return SplunkAuthenticationBasicAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationBasic) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SplunkAuthenticationBasic) GetPassword() string {
	if s == nil {
		return ""
	}
	return s.Password
}

func (s *SplunkAuthenticationBasic) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationBasic) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationBasic) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationBasic) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationBasic) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationBasic) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationBasic) GetCollectRequestParams() []SplunkAuthenticationBasicCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationBasic) GetCollectRequestHeaders() []SplunkAuthenticationBasicCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationBasic) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationBasic) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationBasic) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationBasic) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationBasic) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationBasic) GetRetryRules() *SplunkAuthenticationBasicRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationBasic) GetRetryRulesNone() *SplunkAuthenticationBasicSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationBasic) GetRetryRulesStatic() *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationBasic) GetRetryRulesBackoff() *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationNoneAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationNoneAuthentication string

const (
	// SplunkAuthenticationNoneAuthenticationNone None
	SplunkAuthenticationNoneAuthenticationNone SplunkAuthenticationNoneAuthentication = "none"
	// SplunkAuthenticationNoneAuthenticationBasic Basic
	SplunkAuthenticationNoneAuthenticationBasic SplunkAuthenticationNoneAuthentication = "basic"
	// SplunkAuthenticationNoneAuthenticationBasicSecret Basic (credentials secret)
	SplunkAuthenticationNoneAuthenticationBasicSecret SplunkAuthenticationNoneAuthentication = "basicSecret"
	// SplunkAuthenticationNoneAuthenticationToken Bearer Token
	SplunkAuthenticationNoneAuthenticationToken SplunkAuthenticationNoneAuthentication = "token"
	// SplunkAuthenticationNoneAuthenticationTokenSecret Bearer Token (text secret)
	SplunkAuthenticationNoneAuthenticationTokenSecret SplunkAuthenticationNoneAuthentication = "tokenSecret"
)

func (e SplunkAuthenticationNoneAuthentication) ToPointer() *SplunkAuthenticationNoneAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationNoneAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationNoneCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationNoneCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationNoneCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationNoneCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationNoneCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationNoneCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
	Multiplier *float64 `json:"multiplier,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetMultiplier() *float64 {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationNoneSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	// Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
	Interval *float64 `json:"interval,omitzero"`
	// The maximum number of times to retry a failed HTTP request
	Limit *float64 `json:"limit,omitzero"`
	// List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
	Codes []float64 `json:"codes,omitzero"`
	// Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
	EnableHeader *bool `json:"enableHeader,omitzero"`
	// Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
	RetryConnectTimeout *bool `json:"retryConnectTimeout,omitzero"`
	// Retry request when a connection reset error (ECONNRESET) error occurs
	RetryConnectReset *bool `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetInterval() *float64 {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetLimit() *float64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetCodes() []float64 {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetEnableHeader() *bool {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetRetryConnectReset() *bool {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationNoneSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
}

func (s SplunkAuthenticationNoneSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

type SplunkAuthenticationNoneRetryRulesType string

const (
	SplunkAuthenticationNoneRetryRulesTypeNone    SplunkAuthenticationNoneRetryRulesType = "none"
	SplunkAuthenticationNoneRetryRulesTypeStatic  SplunkAuthenticationNoneRetryRulesType = "static"
	SplunkAuthenticationNoneRetryRulesTypeBackoff SplunkAuthenticationNoneRetryRulesType = "backoff"
	SplunkAuthenticationNoneRetryRulesTypeUnknown SplunkAuthenticationNoneRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationNoneRetryRules struct {
	SplunkAuthenticationNoneSplunkRetryRulesTypeNone    *SplunkAuthenticationNoneSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationNoneSplunkRetryRulesTypeStatic  *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                          json.RawMessage                                      `json:"-" union:"unknown"`

	Type SplunkAuthenticationNoneRetryRulesType
}

func CreateSplunkAuthenticationNoneRetryRulesNone(none SplunkAuthenticationNoneSplunkRetryRulesTypeNone) SplunkAuthenticationNoneRetryRules {
	typ := SplunkAuthenticationNoneRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationNoneRetryRules{
		SplunkAuthenticationNoneSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationNoneRetryRulesStatic(static SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) SplunkAuthenticationNoneRetryRules {
	typ := SplunkAuthenticationNoneRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationNoneRetryRules{
		SplunkAuthenticationNoneSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationNoneRetryRulesBackoff(backoff SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) SplunkAuthenticationNoneRetryRules {
	typ := SplunkAuthenticationNoneRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationNoneRetryRules{
		SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationNoneRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationNoneRetryRules {
	return SplunkAuthenticationNoneRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationNoneRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationNoneRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationNoneRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationNoneRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationNoneRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationNoneRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationNoneRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationNoneSplunkRetryRulesTypeNone := new(SplunkAuthenticationNoneSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationNoneSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationNoneSplunkRetryRulesTypeNone within SplunkAuthenticationNoneRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationNoneSplunkRetryRulesTypeNone = splunkAuthenticationNoneSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationNoneRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationNoneSplunkRetryRulesTypeStatic := new(SplunkAuthenticationNoneSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationNoneSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationNoneSplunkRetryRulesTypeStatic within SplunkAuthenticationNoneRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationNoneSplunkRetryRulesTypeStatic = splunkAuthenticationNoneSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationNoneRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationNoneSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationNoneSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff within SplunkAuthenticationNoneRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff = splunkAuthenticationNoneSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationNoneRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationNoneRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationNoneRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationNoneSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationNoneSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationNoneSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationNoneSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationNoneRetryRules: all fields are null")
}

type SplunkAuthenticationNone struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationNoneAuthentication `json:"authentication"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationNoneCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationNoneCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                               `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationNoneRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNone) GetAuthentication() SplunkAuthenticationNoneAuthentication {
	if s == nil {
		return SplunkAuthenticationNoneAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationNone) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationNone) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationNone) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationNone) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationNone) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationNone) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationNone) GetCollectRequestParams() []SplunkAuthenticationNoneCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationNone) GetCollectRequestHeaders() []SplunkAuthenticationNoneCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationNone) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationNone) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationNone) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationNone) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationNone) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationNone) GetRetryRules() *SplunkAuthenticationNoneRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationNone) GetRetryRulesNone() *SplunkAuthenticationNoneSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationNoneSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationNone) GetRetryRulesStatic() *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationNoneSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationNone) GetRetryRulesBackoff() *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff
	}
	return nil
}

type SplunkCollectorConfType string

const (
	SplunkCollectorConfTypeNone        SplunkCollectorConfType = "none"
	SplunkCollectorConfTypeBasic       SplunkCollectorConfType = "basic"
	SplunkCollectorConfTypeBasicSecret SplunkCollectorConfType = "basicSecret"
	SplunkCollectorConfTypeToken       SplunkCollectorConfType = "token"
	SplunkCollectorConfTypeTokenSecret SplunkCollectorConfType = "tokenSecret"
	SplunkCollectorConfTypeUnknown     SplunkCollectorConfType = "UNKNOWN"
)

type SplunkCollectorConf struct {
	SplunkAuthenticationNone        *SplunkAuthenticationNone        `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasic       *SplunkAuthenticationBasic       `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSecret *SplunkAuthenticationBasicSecret `queryParam:"inline" union:"member"`
	SplunkAuthenticationToken       *SplunkAuthenticationToken       `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSecret *SplunkAuthenticationTokenSecret `queryParam:"inline" union:"member"`
	UnknownRaw                      json.RawMessage                  `json:"-" union:"unknown"`

	Type SplunkCollectorConfType
}

func CreateSplunkCollectorConfNone(none SplunkAuthenticationNone) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeNone

	typStr := SplunkAuthenticationNoneAuthentication(typ)
	none.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationNone: &none,
		Type:                     typ,
	}
}

func CreateSplunkCollectorConfBasic(basic SplunkAuthenticationBasic) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeBasic

	typStr := SplunkAuthenticationBasicAuthentication(typ)
	basic.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationBasic: &basic,
		Type:                      typ,
	}
}

func CreateSplunkCollectorConfBasicSecret(basicSecret SplunkAuthenticationBasicSecret) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeBasicSecret

	typStr := SplunkAuthenticationBasicSecretAuthentication(typ)
	basicSecret.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationBasicSecret: &basicSecret,
		Type:                            typ,
	}
}

func CreateSplunkCollectorConfToken(token SplunkAuthenticationToken) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeToken

	typStr := SplunkAuthenticationTokenAuthentication(typ)
	token.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationToken: &token,
		Type:                      typ,
	}
}

func CreateSplunkCollectorConfTokenSecret(tokenSecret SplunkAuthenticationTokenSecret) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeTokenSecret

	typStr := SplunkAuthenticationTokenSecretAuthentication(typ)
	tokenSecret.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationTokenSecret: &tokenSecret,
		Type:                            typ,
	}
}

func CreateSplunkCollectorConfUnknown(raw json.RawMessage) SplunkCollectorConf {
	return SplunkCollectorConf{
		UnknownRaw: raw,
		Type:       SplunkCollectorConfTypeUnknown,
	}
}

func (u SplunkCollectorConf) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkCollectorConf) IsUnknown() bool {
	return u.Type == SplunkCollectorConfTypeUnknown
}

func (u *SplunkCollectorConf) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Authentication string `json:"authentication"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkCollectorConfTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkCollectorConfTypeUnknown
		return nil
	}

	switch dis.Authentication {
	case "none":
		splunkAuthenticationNone := new(SplunkAuthenticationNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == none) type SplunkAuthenticationNone within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationNone = splunkAuthenticationNone
		u.Type = SplunkCollectorConfTypeNone
		return nil
	case "basic":
		splunkAuthenticationBasic := new(SplunkAuthenticationBasic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == basic) type SplunkAuthenticationBasic within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationBasic = splunkAuthenticationBasic
		u.Type = SplunkCollectorConfTypeBasic
		return nil
	case "basicSecret":
		splunkAuthenticationBasicSecret := new(SplunkAuthenticationBasicSecret)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == basicSecret) type SplunkAuthenticationBasicSecret within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSecret = splunkAuthenticationBasicSecret
		u.Type = SplunkCollectorConfTypeBasicSecret
		return nil
	case "token":
		splunkAuthenticationToken := new(SplunkAuthenticationToken)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationToken, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == token) type SplunkAuthenticationToken within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationToken = splunkAuthenticationToken
		u.Type = SplunkCollectorConfTypeToken
		return nil
	case "tokenSecret":
		splunkAuthenticationTokenSecret := new(SplunkAuthenticationTokenSecret)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == tokenSecret) type SplunkAuthenticationTokenSecret within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSecret = splunkAuthenticationTokenSecret
		u.Type = SplunkCollectorConfTypeTokenSecret
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkCollectorConfTypeUnknown
		return nil
	}

}

func (u SplunkCollectorConf) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationNone, "", true)
	}

	if u.SplunkAuthenticationBasic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasic, "", true)
	}

	if u.SplunkAuthenticationBasicSecret != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSecret, "", true)
	}

	if u.SplunkAuthenticationToken != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationToken, "", true)
	}

	if u.SplunkAuthenticationTokenSecret != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSecret, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkCollectorConf: all fields are null")
}
