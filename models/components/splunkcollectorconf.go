// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

// SplunkAuthenticationLoginSecretAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationLoginSecretAuthentication string

const (
	SplunkAuthenticationLoginSecretAuthenticationNone        SplunkAuthenticationLoginSecretAuthentication = "none"
	SplunkAuthenticationLoginSecretAuthenticationBasic       SplunkAuthenticationLoginSecretAuthentication = "basic"
	SplunkAuthenticationLoginSecretAuthenticationBasicSecret SplunkAuthenticationLoginSecretAuthentication = "basicSecret"
	SplunkAuthenticationLoginSecretAuthenticationToken       SplunkAuthenticationLoginSecretAuthentication = "token"
	SplunkAuthenticationLoginSecretAuthenticationTokenSecret SplunkAuthenticationLoginSecretAuthentication = "tokenSecret"
	SplunkAuthenticationLoginSecretAuthenticationLogin       SplunkAuthenticationLoginSecretAuthentication = "login"
	SplunkAuthenticationLoginSecretAuthenticationLoginSecret SplunkAuthenticationLoginSecretAuthentication = "loginSecret"
)

func (e SplunkAuthenticationLoginSecretAuthentication) ToPointer() *SplunkAuthenticationLoginSecretAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationLoginSecretAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationLoginSecretCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationLoginSecretCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSecretCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSecretCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationLoginSecretCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationLoginSecretCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationLoginSecretCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSecretCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSecretCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationLoginSecretCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
}

func (s SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

type SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationLoginSecretRetryRulesType string

const (
	SplunkAuthenticationLoginSecretRetryRulesTypeNone    SplunkAuthenticationLoginSecretRetryRulesType = "none"
	SplunkAuthenticationLoginSecretRetryRulesTypeStatic  SplunkAuthenticationLoginSecretRetryRulesType = "static"
	SplunkAuthenticationLoginSecretRetryRulesTypeBackoff SplunkAuthenticationLoginSecretRetryRulesType = "backoff"
	SplunkAuthenticationLoginSecretRetryRulesTypeUnknown SplunkAuthenticationLoginSecretRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationLoginSecretRetryRules struct {
	SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone    *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic  *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                                 json.RawMessage                                             `json:"-" union:"unknown"`

	Type SplunkAuthenticationLoginSecretRetryRulesType
}

func CreateSplunkAuthenticationLoginSecretRetryRulesNone(none SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone) SplunkAuthenticationLoginSecretRetryRules {
	typ := SplunkAuthenticationLoginSecretRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationLoginSecretRetryRules{
		SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationLoginSecretRetryRulesStatic(static SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic) SplunkAuthenticationLoginSecretRetryRules {
	typ := SplunkAuthenticationLoginSecretRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationLoginSecretRetryRules{
		SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationLoginSecretRetryRulesBackoff(backoff SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff) SplunkAuthenticationLoginSecretRetryRules {
	typ := SplunkAuthenticationLoginSecretRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationLoginSecretRetryRules{
		SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationLoginSecretRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationLoginSecretRetryRules {
	return SplunkAuthenticationLoginSecretRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationLoginSecretRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationLoginSecretRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationLoginSecretRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationLoginSecretRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationLoginSecretRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationLoginSecretRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationLoginSecretRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationLoginSecretSplunkRetryRulesTypeNone := new(SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationLoginSecretSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone within SplunkAuthenticationLoginSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone = splunkAuthenticationLoginSecretSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationLoginSecretRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic := new(SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic within SplunkAuthenticationLoginSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic = splunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationLoginSecretRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff within SplunkAuthenticationLoginSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff = splunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationLoginSecretRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationLoginSecretRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationLoginSecretRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationLoginSecretRetryRules: all fields are null")
}

type SplunkAuthenticationLoginSecret struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationLoginSecretAuthentication `json:"authentication"`
	// URL to use for login API call, this call is expected to be a POST.
	LoginURL string `json:"loginUrl"`
	// Select or create a stored secret that references your login credentials
	CredentialsSecret string `json:"credentialsSecret"`
	// Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
	LoginBody string `json:"loginBody"`
	// Path to token attribute in login response body. Nested attributes are allowed.
	TokenRespAttribute string `json:"tokenRespAttribute"`
	// JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
	AuthHeaderExpr string `json:"authHeaderExpr"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationLoginSecretCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationLoginSecretCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                      `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationLoginSecretRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationLoginSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSecret) GetAuthentication() SplunkAuthenticationLoginSecretAuthentication {
	if s == nil {
		return SplunkAuthenticationLoginSecretAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationLoginSecret) GetLoginURL() string {
	if s == nil {
		return ""
	}
	return s.LoginURL
}

func (s *SplunkAuthenticationLoginSecret) GetCredentialsSecret() string {
	if s == nil {
		return ""
	}
	return s.CredentialsSecret
}

func (s *SplunkAuthenticationLoginSecret) GetLoginBody() string {
	if s == nil {
		return ""
	}
	return s.LoginBody
}

func (s *SplunkAuthenticationLoginSecret) GetTokenRespAttribute() string {
	if s == nil {
		return ""
	}
	return s.TokenRespAttribute
}

func (s *SplunkAuthenticationLoginSecret) GetAuthHeaderExpr() string {
	if s == nil {
		return ""
	}
	return s.AuthHeaderExpr
}

func (s *SplunkAuthenticationLoginSecret) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationLoginSecret) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationLoginSecret) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationLoginSecret) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationLoginSecret) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationLoginSecret) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationLoginSecret) GetCollectRequestParams() []SplunkAuthenticationLoginSecretCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationLoginSecret) GetCollectRequestHeaders() []SplunkAuthenticationLoginSecretCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationLoginSecret) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationLoginSecret) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationLoginSecret) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationLoginSecret) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationLoginSecret) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationLoginSecret) GetRetryRules() *SplunkAuthenticationLoginSecretRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationLoginSecret) GetRetryRulesNone() *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationLoginSecret) GetRetryRulesStatic() *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationLoginSecret) GetRetryRulesBackoff() *SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationLoginSecretSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationLoginAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationLoginAuthentication string

const (
	SplunkAuthenticationLoginAuthenticationNone        SplunkAuthenticationLoginAuthentication = "none"
	SplunkAuthenticationLoginAuthenticationBasic       SplunkAuthenticationLoginAuthentication = "basic"
	SplunkAuthenticationLoginAuthenticationBasicSecret SplunkAuthenticationLoginAuthentication = "basicSecret"
	SplunkAuthenticationLoginAuthenticationToken       SplunkAuthenticationLoginAuthentication = "token"
	SplunkAuthenticationLoginAuthenticationTokenSecret SplunkAuthenticationLoginAuthentication = "tokenSecret"
	SplunkAuthenticationLoginAuthenticationLogin       SplunkAuthenticationLoginAuthentication = "login"
	SplunkAuthenticationLoginAuthenticationLoginSecret SplunkAuthenticationLoginAuthentication = "loginSecret"
)

func (e SplunkAuthenticationLoginAuthentication) ToPointer() *SplunkAuthenticationLoginAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationLoginAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationLoginCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationLoginCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationLoginCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationLoginCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationLoginCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationLoginCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationLoginSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
}

func (s SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

type SplunkAuthenticationLoginSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationLoginSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationLoginSplunkRetryRulesTypeNone) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationLoginRetryRulesType string

const (
	SplunkAuthenticationLoginRetryRulesTypeNone    SplunkAuthenticationLoginRetryRulesType = "none"
	SplunkAuthenticationLoginRetryRulesTypeStatic  SplunkAuthenticationLoginRetryRulesType = "static"
	SplunkAuthenticationLoginRetryRulesTypeBackoff SplunkAuthenticationLoginRetryRulesType = "backoff"
	SplunkAuthenticationLoginRetryRulesTypeUnknown SplunkAuthenticationLoginRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationLoginRetryRules struct {
	SplunkAuthenticationLoginSplunkRetryRulesTypeNone    *SplunkAuthenticationLoginSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationLoginSplunkRetryRulesTypeStatic  *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                           json.RawMessage                                       `json:"-" union:"unknown"`

	Type SplunkAuthenticationLoginRetryRulesType
}

func CreateSplunkAuthenticationLoginRetryRulesNone(none SplunkAuthenticationLoginSplunkRetryRulesTypeNone) SplunkAuthenticationLoginRetryRules {
	typ := SplunkAuthenticationLoginRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationLoginRetryRules{
		SplunkAuthenticationLoginSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationLoginRetryRulesStatic(static SplunkAuthenticationLoginSplunkRetryRulesTypeStatic) SplunkAuthenticationLoginRetryRules {
	typ := SplunkAuthenticationLoginRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationLoginRetryRules{
		SplunkAuthenticationLoginSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationLoginRetryRulesBackoff(backoff SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff) SplunkAuthenticationLoginRetryRules {
	typ := SplunkAuthenticationLoginRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationLoginRetryRules{
		SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationLoginRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationLoginRetryRules {
	return SplunkAuthenticationLoginRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationLoginRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationLoginRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationLoginRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationLoginRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationLoginRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationLoginRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationLoginRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationLoginSplunkRetryRulesTypeNone := new(SplunkAuthenticationLoginSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationLoginSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationLoginSplunkRetryRulesTypeNone within SplunkAuthenticationLoginRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationLoginSplunkRetryRulesTypeNone = splunkAuthenticationLoginSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationLoginRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationLoginSplunkRetryRulesTypeStatic := new(SplunkAuthenticationLoginSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationLoginSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationLoginSplunkRetryRulesTypeStatic within SplunkAuthenticationLoginRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationLoginSplunkRetryRulesTypeStatic = splunkAuthenticationLoginSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationLoginRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationLoginSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationLoginSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff within SplunkAuthenticationLoginRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff = splunkAuthenticationLoginSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationLoginRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationLoginRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationLoginRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationLoginSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationLoginSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationLoginSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationLoginSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationLoginRetryRules: all fields are null")
}

type SplunkAuthenticationLogin struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationLoginAuthentication `json:"authentication"`
	// URL to use for login API call. This call is expected to be a POST.
	LoginURL string `json:"loginUrl"`
	Username string `json:"username"`
	Password string `json:"password"`
	// Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
	LoginBody string `json:"loginBody"`
	// Path to token attribute in login response body. Nested attributes are allowed.
	TokenRespAttribute string `json:"tokenRespAttribute"`
	// JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
	AuthHeaderExpr string `json:"authHeaderExpr"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationLoginCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationLoginCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationLoginRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationLogin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationLogin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationLogin) GetAuthentication() SplunkAuthenticationLoginAuthentication {
	if s == nil {
		return SplunkAuthenticationLoginAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationLogin) GetLoginURL() string {
	if s == nil {
		return ""
	}
	return s.LoginURL
}

func (s *SplunkAuthenticationLogin) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SplunkAuthenticationLogin) GetPassword() string {
	if s == nil {
		return ""
	}
	return s.Password
}

func (s *SplunkAuthenticationLogin) GetLoginBody() string {
	if s == nil {
		return ""
	}
	return s.LoginBody
}

func (s *SplunkAuthenticationLogin) GetTokenRespAttribute() string {
	if s == nil {
		return ""
	}
	return s.TokenRespAttribute
}

func (s *SplunkAuthenticationLogin) GetAuthHeaderExpr() string {
	if s == nil {
		return ""
	}
	return s.AuthHeaderExpr
}

func (s *SplunkAuthenticationLogin) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationLogin) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationLogin) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationLogin) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationLogin) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationLogin) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationLogin) GetCollectRequestParams() []SplunkAuthenticationLoginCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationLogin) GetCollectRequestHeaders() []SplunkAuthenticationLoginCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationLogin) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationLogin) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationLogin) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationLogin) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationLogin) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationLogin) GetRetryRules() *SplunkAuthenticationLoginRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationLogin) GetRetryRulesNone() *SplunkAuthenticationLoginSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationLoginSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationLogin) GetRetryRulesStatic() *SplunkAuthenticationLoginSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationLoginSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationLogin) GetRetryRulesBackoff() *SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationLoginSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationTokenSecretAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationTokenSecretAuthentication string

const (
	SplunkAuthenticationTokenSecretAuthenticationNone        SplunkAuthenticationTokenSecretAuthentication = "none"
	SplunkAuthenticationTokenSecretAuthenticationBasic       SplunkAuthenticationTokenSecretAuthentication = "basic"
	SplunkAuthenticationTokenSecretAuthenticationBasicSecret SplunkAuthenticationTokenSecretAuthentication = "basicSecret"
	SplunkAuthenticationTokenSecretAuthenticationToken       SplunkAuthenticationTokenSecretAuthentication = "token"
	SplunkAuthenticationTokenSecretAuthenticationTokenSecret SplunkAuthenticationTokenSecretAuthentication = "tokenSecret"
	SplunkAuthenticationTokenSecretAuthenticationLogin       SplunkAuthenticationTokenSecretAuthentication = "login"
	SplunkAuthenticationTokenSecretAuthenticationLoginSecret SplunkAuthenticationTokenSecretAuthentication = "loginSecret"
)

func (e SplunkAuthenticationTokenSecretAuthentication) ToPointer() *SplunkAuthenticationTokenSecretAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationTokenSecretAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationTokenSecretCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationTokenSecretCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationTokenSecretCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationTokenSecretCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationTokenSecretCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationTokenSecretCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
}

func (s SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationTokenSecretRetryRulesType string

const (
	SplunkAuthenticationTokenSecretRetryRulesTypeNone    SplunkAuthenticationTokenSecretRetryRulesType = "none"
	SplunkAuthenticationTokenSecretRetryRulesTypeStatic  SplunkAuthenticationTokenSecretRetryRulesType = "static"
	SplunkAuthenticationTokenSecretRetryRulesTypeBackoff SplunkAuthenticationTokenSecretRetryRulesType = "backoff"
	SplunkAuthenticationTokenSecretRetryRulesTypeUnknown SplunkAuthenticationTokenSecretRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationTokenSecretRetryRules struct {
	SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone    *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic  *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                                 json.RawMessage                                             `json:"-" union:"unknown"`

	Type SplunkAuthenticationTokenSecretRetryRulesType
}

func CreateSplunkAuthenticationTokenSecretRetryRulesNone(none SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone) SplunkAuthenticationTokenSecretRetryRules {
	typ := SplunkAuthenticationTokenSecretRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationTokenSecretRetryRules{
		SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenSecretRetryRulesStatic(static SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic) SplunkAuthenticationTokenSecretRetryRules {
	typ := SplunkAuthenticationTokenSecretRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationTokenSecretRetryRules{
		SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenSecretRetryRulesBackoff(backoff SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff) SplunkAuthenticationTokenSecretRetryRules {
	typ := SplunkAuthenticationTokenSecretRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationTokenSecretRetryRules{
		SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenSecretRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationTokenSecretRetryRules {
	return SplunkAuthenticationTokenSecretRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationTokenSecretRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationTokenSecretRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationTokenSecretRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationTokenSecretRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationTokenSecretRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationTokenSecretSplunkRetryRulesTypeNone := new(SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSecretSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone within SplunkAuthenticationTokenSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone = splunkAuthenticationTokenSecretSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic := new(SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic within SplunkAuthenticationTokenSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic = splunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff within SplunkAuthenticationTokenSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff = splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenSecretRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationTokenSecretRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationTokenSecretRetryRules: all fields are null")
}

type SplunkAuthenticationTokenSecret struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationTokenSecretAuthentication `json:"authentication"`
	// Select or create a stored secret that references your Bearer token
	TokenSecret string `json:"tokenSecret"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationTokenSecretCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationTokenSecretCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                      `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationTokenSecretRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationTokenSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecret) GetAuthentication() SplunkAuthenticationTokenSecretAuthentication {
	if s == nil {
		return SplunkAuthenticationTokenSecretAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationTokenSecret) GetTokenSecret() string {
	if s == nil {
		return ""
	}
	return s.TokenSecret
}

func (s *SplunkAuthenticationTokenSecret) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationTokenSecret) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationTokenSecret) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationTokenSecret) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationTokenSecret) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationTokenSecret) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationTokenSecret) GetCollectRequestParams() []SplunkAuthenticationTokenSecretCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationTokenSecret) GetCollectRequestHeaders() []SplunkAuthenticationTokenSecretCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationTokenSecret) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationTokenSecret) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationTokenSecret) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationTokenSecret) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationTokenSecret) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationTokenSecret) GetRetryRules() *SplunkAuthenticationTokenSecretRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationTokenSecret) GetRetryRulesNone() *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecret) GetRetryRulesStatic() *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationTokenSecret) GetRetryRulesBackoff() *SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationTokenAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationTokenAuthentication string

const (
	SplunkAuthenticationTokenAuthenticationNone        SplunkAuthenticationTokenAuthentication = "none"
	SplunkAuthenticationTokenAuthenticationBasic       SplunkAuthenticationTokenAuthentication = "basic"
	SplunkAuthenticationTokenAuthenticationBasicSecret SplunkAuthenticationTokenAuthentication = "basicSecret"
	SplunkAuthenticationTokenAuthenticationToken       SplunkAuthenticationTokenAuthentication = "token"
	SplunkAuthenticationTokenAuthenticationTokenSecret SplunkAuthenticationTokenAuthentication = "tokenSecret"
	SplunkAuthenticationTokenAuthenticationLogin       SplunkAuthenticationTokenAuthentication = "login"
	SplunkAuthenticationTokenAuthenticationLoginSecret SplunkAuthenticationTokenAuthentication = "loginSecret"
)

func (e SplunkAuthenticationTokenAuthentication) ToPointer() *SplunkAuthenticationTokenAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationTokenAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationTokenCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationTokenCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationTokenCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationTokenCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationTokenCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationTokenCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationTokenSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
}

func (s SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

type SplunkAuthenticationTokenSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationTokenSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationTokenSplunkRetryRulesTypeNone) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationTokenRetryRulesType string

const (
	SplunkAuthenticationTokenRetryRulesTypeNone    SplunkAuthenticationTokenRetryRulesType = "none"
	SplunkAuthenticationTokenRetryRulesTypeStatic  SplunkAuthenticationTokenRetryRulesType = "static"
	SplunkAuthenticationTokenRetryRulesTypeBackoff SplunkAuthenticationTokenRetryRulesType = "backoff"
	SplunkAuthenticationTokenRetryRulesTypeUnknown SplunkAuthenticationTokenRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationTokenRetryRules struct {
	SplunkAuthenticationTokenSplunkRetryRulesTypeNone    *SplunkAuthenticationTokenSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSplunkRetryRulesTypeStatic  *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                           json.RawMessage                                       `json:"-" union:"unknown"`

	Type SplunkAuthenticationTokenRetryRulesType
}

func CreateSplunkAuthenticationTokenRetryRulesNone(none SplunkAuthenticationTokenSplunkRetryRulesTypeNone) SplunkAuthenticationTokenRetryRules {
	typ := SplunkAuthenticationTokenRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationTokenRetryRules{
		SplunkAuthenticationTokenSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenRetryRulesStatic(static SplunkAuthenticationTokenSplunkRetryRulesTypeStatic) SplunkAuthenticationTokenRetryRules {
	typ := SplunkAuthenticationTokenRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationTokenRetryRules{
		SplunkAuthenticationTokenSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenRetryRulesBackoff(backoff SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff) SplunkAuthenticationTokenRetryRules {
	typ := SplunkAuthenticationTokenRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationTokenRetryRules{
		SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationTokenRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationTokenRetryRules {
	return SplunkAuthenticationTokenRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationTokenRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationTokenRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationTokenRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationTokenRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationTokenRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationTokenSplunkRetryRulesTypeNone := new(SplunkAuthenticationTokenSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationTokenSplunkRetryRulesTypeNone within SplunkAuthenticationTokenRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSplunkRetryRulesTypeNone = splunkAuthenticationTokenSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationTokenRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationTokenSplunkRetryRulesTypeStatic := new(SplunkAuthenticationTokenSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationTokenSplunkRetryRulesTypeStatic within SplunkAuthenticationTokenRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSplunkRetryRulesTypeStatic = splunkAuthenticationTokenSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationTokenRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationTokenSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff within SplunkAuthenticationTokenRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff = splunkAuthenticationTokenSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationTokenRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationTokenRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationTokenRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationTokenSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationTokenSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationTokenRetryRules: all fields are null")
}

type SplunkAuthenticationToken struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationTokenAuthentication `json:"authentication"`
	Token          string                                  `json:"token"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationTokenCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationTokenCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationTokenRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationToken) GetAuthentication() SplunkAuthenticationTokenAuthentication {
	if s == nil {
		return SplunkAuthenticationTokenAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationToken) GetToken() string {
	if s == nil {
		return ""
	}
	return s.Token
}

func (s *SplunkAuthenticationToken) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationToken) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationToken) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationToken) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationToken) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationToken) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationToken) GetCollectRequestParams() []SplunkAuthenticationTokenCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationToken) GetCollectRequestHeaders() []SplunkAuthenticationTokenCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationToken) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationToken) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationToken) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationToken) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationToken) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationToken) GetRetryRules() *SplunkAuthenticationTokenRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationToken) GetRetryRulesNone() *SplunkAuthenticationTokenSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationToken) GetRetryRulesStatic() *SplunkAuthenticationTokenSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationToken) GetRetryRulesBackoff() *SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationBasicSecretAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationBasicSecretAuthentication string

const (
	SplunkAuthenticationBasicSecretAuthenticationNone        SplunkAuthenticationBasicSecretAuthentication = "none"
	SplunkAuthenticationBasicSecretAuthenticationBasic       SplunkAuthenticationBasicSecretAuthentication = "basic"
	SplunkAuthenticationBasicSecretAuthenticationBasicSecret SplunkAuthenticationBasicSecretAuthentication = "basicSecret"
	SplunkAuthenticationBasicSecretAuthenticationToken       SplunkAuthenticationBasicSecretAuthentication = "token"
	SplunkAuthenticationBasicSecretAuthenticationTokenSecret SplunkAuthenticationBasicSecretAuthentication = "tokenSecret"
	SplunkAuthenticationBasicSecretAuthenticationLogin       SplunkAuthenticationBasicSecretAuthentication = "login"
	SplunkAuthenticationBasicSecretAuthenticationLoginSecret SplunkAuthenticationBasicSecretAuthentication = "loginSecret"
)

func (e SplunkAuthenticationBasicSecretAuthentication) ToPointer() *SplunkAuthenticationBasicSecretAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationBasicSecretAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationBasicSecretCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationBasicSecretCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationBasicSecretCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationBasicSecretCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationBasicSecretCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationBasicSecretCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
}

func (s SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationBasicSecretRetryRulesType string

const (
	SplunkAuthenticationBasicSecretRetryRulesTypeNone    SplunkAuthenticationBasicSecretRetryRulesType = "none"
	SplunkAuthenticationBasicSecretRetryRulesTypeStatic  SplunkAuthenticationBasicSecretRetryRulesType = "static"
	SplunkAuthenticationBasicSecretRetryRulesTypeBackoff SplunkAuthenticationBasicSecretRetryRulesType = "backoff"
	SplunkAuthenticationBasicSecretRetryRulesTypeUnknown SplunkAuthenticationBasicSecretRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationBasicSecretRetryRules struct {
	SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone    *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic  *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                                 json.RawMessage                                             `json:"-" union:"unknown"`

	Type SplunkAuthenticationBasicSecretRetryRulesType
}

func CreateSplunkAuthenticationBasicSecretRetryRulesNone(none SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone) SplunkAuthenticationBasicSecretRetryRules {
	typ := SplunkAuthenticationBasicSecretRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationBasicSecretRetryRules{
		SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicSecretRetryRulesStatic(static SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic) SplunkAuthenticationBasicSecretRetryRules {
	typ := SplunkAuthenticationBasicSecretRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationBasicSecretRetryRules{
		SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicSecretRetryRulesBackoff(backoff SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff) SplunkAuthenticationBasicSecretRetryRules {
	typ := SplunkAuthenticationBasicSecretRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationBasicSecretRetryRules{
		SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicSecretRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationBasicSecretRetryRules {
	return SplunkAuthenticationBasicSecretRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationBasicSecretRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationBasicSecretRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationBasicSecretRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationBasicSecretRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationBasicSecretRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationBasicSecretSplunkRetryRulesTypeNone := new(SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSecretSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone within SplunkAuthenticationBasicSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone = splunkAuthenticationBasicSecretSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic := new(SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic within SplunkAuthenticationBasicSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic = splunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff within SplunkAuthenticationBasicSecretRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff = splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicSecretRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationBasicSecretRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationBasicSecretRetryRules: all fields are null")
}

type SplunkAuthenticationBasicSecret struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationBasicSecretAuthentication `json:"authentication"`
	// Select or create a stored secret that references your credentials
	CredentialsSecret string `json:"credentialsSecret"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationBasicSecretCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationBasicSecretCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                      `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationBasicSecretRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationBasicSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecret) GetAuthentication() SplunkAuthenticationBasicSecretAuthentication {
	if s == nil {
		return SplunkAuthenticationBasicSecretAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationBasicSecret) GetCredentialsSecret() string {
	if s == nil {
		return ""
	}
	return s.CredentialsSecret
}

func (s *SplunkAuthenticationBasicSecret) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationBasicSecret) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationBasicSecret) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationBasicSecret) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationBasicSecret) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationBasicSecret) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationBasicSecret) GetCollectRequestParams() []SplunkAuthenticationBasicSecretCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationBasicSecret) GetCollectRequestHeaders() []SplunkAuthenticationBasicSecretCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationBasicSecret) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationBasicSecret) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationBasicSecret) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationBasicSecret) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationBasicSecret) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationBasicSecret) GetRetryRules() *SplunkAuthenticationBasicSecretRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationBasicSecret) GetRetryRulesNone() *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecret) GetRetryRulesStatic() *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationBasicSecret) GetRetryRulesBackoff() *SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationBasicAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationBasicAuthentication string

const (
	SplunkAuthenticationBasicAuthenticationNone        SplunkAuthenticationBasicAuthentication = "none"
	SplunkAuthenticationBasicAuthenticationBasic       SplunkAuthenticationBasicAuthentication = "basic"
	SplunkAuthenticationBasicAuthenticationBasicSecret SplunkAuthenticationBasicAuthentication = "basicSecret"
	SplunkAuthenticationBasicAuthenticationToken       SplunkAuthenticationBasicAuthentication = "token"
	SplunkAuthenticationBasicAuthenticationTokenSecret SplunkAuthenticationBasicAuthentication = "tokenSecret"
	SplunkAuthenticationBasicAuthenticationLogin       SplunkAuthenticationBasicAuthentication = "login"
	SplunkAuthenticationBasicAuthenticationLoginSecret SplunkAuthenticationBasicAuthentication = "loginSecret"
)

func (e SplunkAuthenticationBasicAuthentication) ToPointer() *SplunkAuthenticationBasicAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationBasicAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationBasicCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationBasicCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationBasicCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationBasicCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationBasicCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationBasicCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationBasicSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
}

func (s SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

type SplunkAuthenticationBasicSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationBasicSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationBasicSplunkRetryRulesTypeNone) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationBasicRetryRulesType string

const (
	SplunkAuthenticationBasicRetryRulesTypeNone    SplunkAuthenticationBasicRetryRulesType = "none"
	SplunkAuthenticationBasicRetryRulesTypeStatic  SplunkAuthenticationBasicRetryRulesType = "static"
	SplunkAuthenticationBasicRetryRulesTypeBackoff SplunkAuthenticationBasicRetryRulesType = "backoff"
	SplunkAuthenticationBasicRetryRulesTypeUnknown SplunkAuthenticationBasicRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationBasicRetryRules struct {
	SplunkAuthenticationBasicSplunkRetryRulesTypeNone    *SplunkAuthenticationBasicSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSplunkRetryRulesTypeStatic  *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                           json.RawMessage                                       `json:"-" union:"unknown"`

	Type SplunkAuthenticationBasicRetryRulesType
}

func CreateSplunkAuthenticationBasicRetryRulesNone(none SplunkAuthenticationBasicSplunkRetryRulesTypeNone) SplunkAuthenticationBasicRetryRules {
	typ := SplunkAuthenticationBasicRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationBasicRetryRules{
		SplunkAuthenticationBasicSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicRetryRulesStatic(static SplunkAuthenticationBasicSplunkRetryRulesTypeStatic) SplunkAuthenticationBasicRetryRules {
	typ := SplunkAuthenticationBasicRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationBasicRetryRules{
		SplunkAuthenticationBasicSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicRetryRulesBackoff(backoff SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff) SplunkAuthenticationBasicRetryRules {
	typ := SplunkAuthenticationBasicRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationBasicRetryRules{
		SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationBasicRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationBasicRetryRules {
	return SplunkAuthenticationBasicRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationBasicRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationBasicRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationBasicRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationBasicRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationBasicRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationBasicSplunkRetryRulesTypeNone := new(SplunkAuthenticationBasicSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationBasicSplunkRetryRulesTypeNone within SplunkAuthenticationBasicRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSplunkRetryRulesTypeNone = splunkAuthenticationBasicSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationBasicRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationBasicSplunkRetryRulesTypeStatic := new(SplunkAuthenticationBasicSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationBasicSplunkRetryRulesTypeStatic within SplunkAuthenticationBasicRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSplunkRetryRulesTypeStatic = splunkAuthenticationBasicSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationBasicRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationBasicSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff within SplunkAuthenticationBasicRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff = splunkAuthenticationBasicSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationBasicRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationBasicRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationBasicRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationBasicSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationBasicSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationBasicRetryRules: all fields are null")
}

type SplunkAuthenticationBasic struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationBasicAuthentication `json:"authentication"`
	// Basic authentication username
	Username string `json:"username"`
	// Basic authentication password
	Password string `json:"password"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationBasicCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationBasicCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                                `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationBasicRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationBasic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationBasic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationBasic) GetAuthentication() SplunkAuthenticationBasicAuthentication {
	if s == nil {
		return SplunkAuthenticationBasicAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationBasic) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SplunkAuthenticationBasic) GetPassword() string {
	if s == nil {
		return ""
	}
	return s.Password
}

func (s *SplunkAuthenticationBasic) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationBasic) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationBasic) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationBasic) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationBasic) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationBasic) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationBasic) GetCollectRequestParams() []SplunkAuthenticationBasicCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationBasic) GetCollectRequestHeaders() []SplunkAuthenticationBasicCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationBasic) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationBasic) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationBasic) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationBasic) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationBasic) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationBasic) GetRetryRules() *SplunkAuthenticationBasicRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationBasic) GetRetryRulesNone() *SplunkAuthenticationBasicSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationBasic) GetRetryRulesStatic() *SplunkAuthenticationBasicSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationBasic) GetRetryRulesBackoff() *SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff
	}
	return nil
}

// SplunkAuthenticationNoneAuthentication - Authentication method for Discover and Collect REST calls
type SplunkAuthenticationNoneAuthentication string

const (
	SplunkAuthenticationNoneAuthenticationNone        SplunkAuthenticationNoneAuthentication = "none"
	SplunkAuthenticationNoneAuthenticationBasic       SplunkAuthenticationNoneAuthentication = "basic"
	SplunkAuthenticationNoneAuthenticationBasicSecret SplunkAuthenticationNoneAuthentication = "basicSecret"
	SplunkAuthenticationNoneAuthenticationToken       SplunkAuthenticationNoneAuthentication = "token"
	SplunkAuthenticationNoneAuthenticationTokenSecret SplunkAuthenticationNoneAuthentication = "tokenSecret"
	SplunkAuthenticationNoneAuthenticationLogin       SplunkAuthenticationNoneAuthentication = "login"
	SplunkAuthenticationNoneAuthenticationLoginSecret SplunkAuthenticationNoneAuthentication = "loginSecret"
)

func (e SplunkAuthenticationNoneAuthentication) ToPointer() *SplunkAuthenticationNoneAuthentication {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SplunkAuthenticationNoneAuthentication) IsExact() bool {
	if e != nil {
		switch *e {
		case "none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret":
			return true
		}
	}
	return false
}

type SplunkAuthenticationNoneCollectRequestParam struct {
	Name string `json:"name"`
	// JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationNoneCollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneCollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneCollectRequestParam) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationNoneCollectRequestParam) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationNoneCollectRequestHeader struct {
	Name string `json:"name"`
	// JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
	Value string `json:"value"`
}

func (s SplunkAuthenticationNoneCollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneCollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneCollectRequestHeader) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SplunkAuthenticationNoneCollectRequestHeader) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

type SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationNoneSplunkRetryRulesTypeStatic struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
}

func (s SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

type SplunkAuthenticationNoneSplunkRetryRulesTypeNone struct {
	// The algorithm to use when performing HTTP retries
	Type                RetryTypeOptionsHealthCheckCollectorConfRetryRules `json:"type"`
	Interval            any                                                `json:"interval,omitzero"`
	Limit               any                                                `json:"limit,omitzero"`
	Multiplier          any                                                `json:"multiplier,omitzero"`
	Codes               any                                                `json:"codes,omitzero"`
	EnableHeader        any                                                `json:"enableHeader,omitzero"`
	RetryConnectTimeout any                                                `json:"retryConnectTimeout,omitzero"`
	RetryConnectReset   any                                                `json:"retryConnectReset,omitzero"`
}

func (s SplunkAuthenticationNoneSplunkRetryRulesTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetType() RetryTypeOptionsHealthCheckCollectorConfRetryRules {
	if s == nil {
		return RetryTypeOptionsHealthCheckCollectorConfRetryRules("")
	}
	return s.Type
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetInterval() any {
	if s == nil {
		return nil
	}
	return s.Interval
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetLimit() any {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetMultiplier() any {
	if s == nil {
		return nil
	}
	return s.Multiplier
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetCodes() any {
	if s == nil {
		return nil
	}
	return s.Codes
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetEnableHeader() any {
	if s == nil {
		return nil
	}
	return s.EnableHeader
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetRetryConnectTimeout() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectTimeout
}

func (s *SplunkAuthenticationNoneSplunkRetryRulesTypeNone) GetRetryConnectReset() any {
	if s == nil {
		return nil
	}
	return s.RetryConnectReset
}

type SplunkAuthenticationNoneRetryRulesType string

const (
	SplunkAuthenticationNoneRetryRulesTypeNone    SplunkAuthenticationNoneRetryRulesType = "none"
	SplunkAuthenticationNoneRetryRulesTypeStatic  SplunkAuthenticationNoneRetryRulesType = "static"
	SplunkAuthenticationNoneRetryRulesTypeBackoff SplunkAuthenticationNoneRetryRulesType = "backoff"
	SplunkAuthenticationNoneRetryRulesTypeUnknown SplunkAuthenticationNoneRetryRulesType = "UNKNOWN"
)

type SplunkAuthenticationNoneRetryRules struct {
	SplunkAuthenticationNoneSplunkRetryRulesTypeNone    *SplunkAuthenticationNoneSplunkRetryRulesTypeNone    `queryParam:"inline" union:"member"`
	SplunkAuthenticationNoneSplunkRetryRulesTypeStatic  *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic  `queryParam:"inline" union:"member"`
	SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff `queryParam:"inline" union:"member"`
	UnknownRaw                                          json.RawMessage                                      `json:"-" union:"unknown"`

	Type SplunkAuthenticationNoneRetryRulesType
}

func CreateSplunkAuthenticationNoneRetryRulesNone(none SplunkAuthenticationNoneSplunkRetryRulesTypeNone) SplunkAuthenticationNoneRetryRules {
	typ := SplunkAuthenticationNoneRetryRulesTypeNone

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	none.Type = typStr

	return SplunkAuthenticationNoneRetryRules{
		SplunkAuthenticationNoneSplunkRetryRulesTypeNone: &none,
		Type: typ,
	}
}

func CreateSplunkAuthenticationNoneRetryRulesStatic(static SplunkAuthenticationNoneSplunkRetryRulesTypeStatic) SplunkAuthenticationNoneRetryRules {
	typ := SplunkAuthenticationNoneRetryRulesTypeStatic

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	static.Type = typStr

	return SplunkAuthenticationNoneRetryRules{
		SplunkAuthenticationNoneSplunkRetryRulesTypeStatic: &static,
		Type: typ,
	}
}

func CreateSplunkAuthenticationNoneRetryRulesBackoff(backoff SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff) SplunkAuthenticationNoneRetryRules {
	typ := SplunkAuthenticationNoneRetryRulesTypeBackoff

	typStr := RetryTypeOptionsHealthCheckCollectorConfRetryRules(typ)
	backoff.Type = typStr

	return SplunkAuthenticationNoneRetryRules{
		SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff: &backoff,
		Type: typ,
	}
}

func CreateSplunkAuthenticationNoneRetryRulesUnknown(raw json.RawMessage) SplunkAuthenticationNoneRetryRules {
	return SplunkAuthenticationNoneRetryRules{
		UnknownRaw: raw,
		Type:       SplunkAuthenticationNoneRetryRulesTypeUnknown,
	}
}

func (u SplunkAuthenticationNoneRetryRules) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkAuthenticationNoneRetryRules) IsUnknown() bool {
	return u.Type == SplunkAuthenticationNoneRetryRulesTypeUnknown
}

func (u *SplunkAuthenticationNoneRetryRules) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationNoneRetryRulesTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationNoneRetryRulesTypeUnknown
		return nil
	}

	switch dis.Type {
	case "none":
		splunkAuthenticationNoneSplunkRetryRulesTypeNone := new(SplunkAuthenticationNoneSplunkRetryRulesTypeNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationNoneSplunkRetryRulesTypeNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == none) type SplunkAuthenticationNoneSplunkRetryRulesTypeNone within SplunkAuthenticationNoneRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationNoneSplunkRetryRulesTypeNone = splunkAuthenticationNoneSplunkRetryRulesTypeNone
		u.Type = SplunkAuthenticationNoneRetryRulesTypeNone
		return nil
	case "static":
		splunkAuthenticationNoneSplunkRetryRulesTypeStatic := new(SplunkAuthenticationNoneSplunkRetryRulesTypeStatic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationNoneSplunkRetryRulesTypeStatic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == static) type SplunkAuthenticationNoneSplunkRetryRulesTypeStatic within SplunkAuthenticationNoneRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationNoneSplunkRetryRulesTypeStatic = splunkAuthenticationNoneSplunkRetryRulesTypeStatic
		u.Type = SplunkAuthenticationNoneRetryRulesTypeStatic
		return nil
	case "backoff":
		splunkAuthenticationNoneSplunkRetryRulesTypeBackoff := new(SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationNoneSplunkRetryRulesTypeBackoff, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == backoff) type SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff within SplunkAuthenticationNoneRetryRules: %w", string(data), err)
		}

		u.SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff = splunkAuthenticationNoneSplunkRetryRulesTypeBackoff
		u.Type = SplunkAuthenticationNoneRetryRulesTypeBackoff
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkAuthenticationNoneRetryRulesTypeUnknown
		return nil
	}

}

func (u SplunkAuthenticationNoneRetryRules) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationNoneSplunkRetryRulesTypeNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationNoneSplunkRetryRulesTypeNone, "", true)
	}

	if u.SplunkAuthenticationNoneSplunkRetryRulesTypeStatic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationNoneSplunkRetryRulesTypeStatic, "", true)
	}

	if u.SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkAuthenticationNoneRetryRules: all fields are null")
}

type SplunkAuthenticationNone struct {
	// Authentication method for Discover and Collect REST calls
	Authentication SplunkAuthenticationNoneAuthentication `json:"authentication"`
	// Search head base URL. Can be an expression. Default is https://localhost:8089.
	SearchHead string `json:"searchHead"`
	// Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`
	// The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitzero"`
	// The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitzero"`
	// REST API used to create a search
	Endpoint string `json:"endpoint"`
	// Format of the returned output
	OutputMode OutputModeOptionsSplunkCollectorConf `json:"outputMode"`
	// Optional collect request parameters
	CollectRequestParams []SplunkAuthenticationNoneCollectRequestParam `json:"collectRequestParams,omitzero"`
	// Optional collect request headers
	CollectRequestHeaders []SplunkAuthenticationNoneCollectRequestHeader `json:"collectRequestHeaders,omitzero"`
	// HTTP request inactivity timeout. Use 0 for no timeout.
	Timeout *float64 `json:"timeout,omitzero"`
	// Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitzero"`
	// Disable collector event time filtering when a date range is specified
	DisableTimeFilter *bool `json:"disableTimeFilter,omitzero"`
	// Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitzero"`
	// Escape characters (\") in search queries will be passed directly to Splunk
	HandleEscapedChars *bool                               `json:"handleEscapedChars,omitzero"`
	RetryRules         *SplunkAuthenticationNoneRetryRules `json:"retryRules,omitzero"`
}

func (s SplunkAuthenticationNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SplunkAuthenticationNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SplunkAuthenticationNone) GetAuthentication() SplunkAuthenticationNoneAuthentication {
	if s == nil {
		return SplunkAuthenticationNoneAuthentication("")
	}
	return s.Authentication
}

func (s *SplunkAuthenticationNone) GetSearchHead() string {
	if s == nil {
		return ""
	}
	return s.SearchHead
}

func (s *SplunkAuthenticationNone) GetSearch() string {
	if s == nil {
		return ""
	}
	return s.Search
}

func (s *SplunkAuthenticationNone) GetEarliest() *string {
	if s == nil {
		return nil
	}
	return s.Earliest
}

func (s *SplunkAuthenticationNone) GetLatest() *string {
	if s == nil {
		return nil
	}
	return s.Latest
}

func (s *SplunkAuthenticationNone) GetEndpoint() string {
	if s == nil {
		return ""
	}
	return s.Endpoint
}

func (s *SplunkAuthenticationNone) GetOutputMode() OutputModeOptionsSplunkCollectorConf {
	if s == nil {
		return OutputModeOptionsSplunkCollectorConf("")
	}
	return s.OutputMode
}

func (s *SplunkAuthenticationNone) GetCollectRequestParams() []SplunkAuthenticationNoneCollectRequestParam {
	if s == nil {
		return nil
	}
	return s.CollectRequestParams
}

func (s *SplunkAuthenticationNone) GetCollectRequestHeaders() []SplunkAuthenticationNoneCollectRequestHeader {
	if s == nil {
		return nil
	}
	return s.CollectRequestHeaders
}

func (s *SplunkAuthenticationNone) GetTimeout() *float64 {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SplunkAuthenticationNone) GetUseRoundRobinDNS() *bool {
	if s == nil {
		return nil
	}
	return s.UseRoundRobinDNS
}

func (s *SplunkAuthenticationNone) GetDisableTimeFilter() *bool {
	if s == nil {
		return nil
	}
	return s.DisableTimeFilter
}

func (s *SplunkAuthenticationNone) GetRejectUnauthorized() *bool {
	if s == nil {
		return nil
	}
	return s.RejectUnauthorized
}

func (s *SplunkAuthenticationNone) GetHandleEscapedChars() *bool {
	if s == nil {
		return nil
	}
	return s.HandleEscapedChars
}

func (s *SplunkAuthenticationNone) GetRetryRules() *SplunkAuthenticationNoneRetryRules {
	if s == nil {
		return nil
	}
	return s.RetryRules
}

func (s *SplunkAuthenticationNone) GetRetryRulesNone() *SplunkAuthenticationNoneSplunkRetryRulesTypeNone {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationNoneSplunkRetryRulesTypeNone
	}
	return nil
}

func (s *SplunkAuthenticationNone) GetRetryRulesStatic() *SplunkAuthenticationNoneSplunkRetryRulesTypeStatic {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationNoneSplunkRetryRulesTypeStatic
	}
	return nil
}

func (s *SplunkAuthenticationNone) GetRetryRulesBackoff() *SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff {
	if v := s.GetRetryRules(); v != nil {
		return v.SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff
	}
	return nil
}

type SplunkCollectorConfType string

const (
	SplunkCollectorConfTypeNone        SplunkCollectorConfType = "none"
	SplunkCollectorConfTypeBasic       SplunkCollectorConfType = "basic"
	SplunkCollectorConfTypeBasicSecret SplunkCollectorConfType = "basicSecret"
	SplunkCollectorConfTypeToken       SplunkCollectorConfType = "token"
	SplunkCollectorConfTypeTokenSecret SplunkCollectorConfType = "tokenSecret"
	SplunkCollectorConfTypeLogin       SplunkCollectorConfType = "login"
	SplunkCollectorConfTypeLoginSecret SplunkCollectorConfType = "loginSecret"
	SplunkCollectorConfTypeUnknown     SplunkCollectorConfType = "UNKNOWN"
)

type SplunkCollectorConf struct {
	SplunkAuthenticationNone        *SplunkAuthenticationNone        `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasic       *SplunkAuthenticationBasic       `queryParam:"inline" union:"member"`
	SplunkAuthenticationBasicSecret *SplunkAuthenticationBasicSecret `queryParam:"inline" union:"member"`
	SplunkAuthenticationToken       *SplunkAuthenticationToken       `queryParam:"inline" union:"member"`
	SplunkAuthenticationTokenSecret *SplunkAuthenticationTokenSecret `queryParam:"inline" union:"member"`
	SplunkAuthenticationLogin       *SplunkAuthenticationLogin       `queryParam:"inline" union:"member"`
	SplunkAuthenticationLoginSecret *SplunkAuthenticationLoginSecret `queryParam:"inline" union:"member"`
	UnknownRaw                      json.RawMessage                  `json:"-" union:"unknown"`

	Type SplunkCollectorConfType
}

func CreateSplunkCollectorConfNone(none SplunkAuthenticationNone) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeNone

	typStr := SplunkAuthenticationNoneAuthentication(typ)
	none.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationNone: &none,
		Type:                     typ,
	}
}

func CreateSplunkCollectorConfBasic(basic SplunkAuthenticationBasic) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeBasic

	typStr := SplunkAuthenticationBasicAuthentication(typ)
	basic.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationBasic: &basic,
		Type:                      typ,
	}
}

func CreateSplunkCollectorConfBasicSecret(basicSecret SplunkAuthenticationBasicSecret) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeBasicSecret

	typStr := SplunkAuthenticationBasicSecretAuthentication(typ)
	basicSecret.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationBasicSecret: &basicSecret,
		Type:                            typ,
	}
}

func CreateSplunkCollectorConfToken(token SplunkAuthenticationToken) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeToken

	typStr := SplunkAuthenticationTokenAuthentication(typ)
	token.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationToken: &token,
		Type:                      typ,
	}
}

func CreateSplunkCollectorConfTokenSecret(tokenSecret SplunkAuthenticationTokenSecret) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeTokenSecret

	typStr := SplunkAuthenticationTokenSecretAuthentication(typ)
	tokenSecret.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationTokenSecret: &tokenSecret,
		Type:                            typ,
	}
}

func CreateSplunkCollectorConfLogin(login SplunkAuthenticationLogin) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeLogin

	typStr := SplunkAuthenticationLoginAuthentication(typ)
	login.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationLogin: &login,
		Type:                      typ,
	}
}

func CreateSplunkCollectorConfLoginSecret(loginSecret SplunkAuthenticationLoginSecret) SplunkCollectorConf {
	typ := SplunkCollectorConfTypeLoginSecret

	typStr := SplunkAuthenticationLoginSecretAuthentication(typ)
	loginSecret.Authentication = typStr

	return SplunkCollectorConf{
		SplunkAuthenticationLoginSecret: &loginSecret,
		Type:                            typ,
	}
}

func CreateSplunkCollectorConfUnknown(raw json.RawMessage) SplunkCollectorConf {
	return SplunkCollectorConf{
		UnknownRaw: raw,
		Type:       SplunkCollectorConfTypeUnknown,
	}
}

func (u SplunkCollectorConf) GetUnknownRaw() json.RawMessage {
	return u.UnknownRaw
}

func (u SplunkCollectorConf) IsUnknown() bool {
	return u.Type == SplunkCollectorConfTypeUnknown
}

func (u *SplunkCollectorConf) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Authentication string `json:"authentication"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkCollectorConfTypeUnknown
		return nil
	}
	if dis == nil {
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkCollectorConfTypeUnknown
		return nil
	}

	switch dis.Authentication {
	case "none":
		splunkAuthenticationNone := new(SplunkAuthenticationNone)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationNone, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == none) type SplunkAuthenticationNone within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationNone = splunkAuthenticationNone
		u.Type = SplunkCollectorConfTypeNone
		return nil
	case "basic":
		splunkAuthenticationBasic := new(SplunkAuthenticationBasic)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasic, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == basic) type SplunkAuthenticationBasic within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationBasic = splunkAuthenticationBasic
		u.Type = SplunkCollectorConfTypeBasic
		return nil
	case "basicSecret":
		splunkAuthenticationBasicSecret := new(SplunkAuthenticationBasicSecret)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationBasicSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == basicSecret) type SplunkAuthenticationBasicSecret within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationBasicSecret = splunkAuthenticationBasicSecret
		u.Type = SplunkCollectorConfTypeBasicSecret
		return nil
	case "token":
		splunkAuthenticationToken := new(SplunkAuthenticationToken)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationToken, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == token) type SplunkAuthenticationToken within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationToken = splunkAuthenticationToken
		u.Type = SplunkCollectorConfTypeToken
		return nil
	case "tokenSecret":
		splunkAuthenticationTokenSecret := new(SplunkAuthenticationTokenSecret)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationTokenSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == tokenSecret) type SplunkAuthenticationTokenSecret within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationTokenSecret = splunkAuthenticationTokenSecret
		u.Type = SplunkCollectorConfTypeTokenSecret
		return nil
	case "login":
		splunkAuthenticationLogin := new(SplunkAuthenticationLogin)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationLogin, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == login) type SplunkAuthenticationLogin within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationLogin = splunkAuthenticationLogin
		u.Type = SplunkCollectorConfTypeLogin
		return nil
	case "loginSecret":
		splunkAuthenticationLoginSecret := new(SplunkAuthenticationLoginSecret)
		if err := utils.UnmarshalJSON(data, &splunkAuthenticationLoginSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Authentication == loginSecret) type SplunkAuthenticationLoginSecret within SplunkCollectorConf: %w", string(data), err)
		}

		u.SplunkAuthenticationLoginSecret = splunkAuthenticationLoginSecret
		u.Type = SplunkCollectorConfTypeLoginSecret
		return nil
	default:
		u.UnknownRaw = json.RawMessage(data)
		u.Type = SplunkCollectorConfTypeUnknown
		return nil
	}

}

func (u SplunkCollectorConf) MarshalJSON() ([]byte, error) {
	if u.SplunkAuthenticationNone != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationNone, "", true)
	}

	if u.SplunkAuthenticationBasic != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasic, "", true)
	}

	if u.SplunkAuthenticationBasicSecret != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationBasicSecret, "", true)
	}

	if u.SplunkAuthenticationToken != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationToken, "", true)
	}

	if u.SplunkAuthenticationTokenSecret != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationTokenSecret, "", true)
	}

	if u.SplunkAuthenticationLogin != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationLogin, "", true)
	}

	if u.SplunkAuthenticationLoginSecret != nil {
		return utils.MarshalJSON(u.SplunkAuthenticationLoginSecret, "", true)
	}

	if u.UnknownRaw != nil {
		return json.RawMessage(u.UnknownRaw), nil
	}
	return nil, errors.New("could not marshal union type SplunkCollectorConf: all fields are null")
}
