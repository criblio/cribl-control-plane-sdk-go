// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type FunctionAggregateMetricsID string

const (
	FunctionAggregateMetricsIDAggregateMetrics FunctionAggregateMetricsID = "aggregate_metrics"
)

func (e FunctionAggregateMetricsID) ToPointer() *FunctionAggregateMetricsID {
	return &e
}
func (e *FunctionAggregateMetricsID) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aggregate_metrics":
		*e = FunctionAggregateMetricsID(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FunctionAggregateMetricsID: %v", v)
	}
}

// FunctionAggregateMetricsMetricType - The output metric type
type FunctionAggregateMetricsMetricType string

const (
	FunctionAggregateMetricsMetricTypeAutomatic    FunctionAggregateMetricsMetricType = "automatic"
	FunctionAggregateMetricsMetricTypeCounter      FunctionAggregateMetricsMetricType = "counter"
	FunctionAggregateMetricsMetricTypeDistribution FunctionAggregateMetricsMetricType = "distribution"
	FunctionAggregateMetricsMetricTypeGauge        FunctionAggregateMetricsMetricType = "gauge"
	FunctionAggregateMetricsMetricTypeHistogram    FunctionAggregateMetricsMetricType = "histogram"
	FunctionAggregateMetricsMetricTypeSummary      FunctionAggregateMetricsMetricType = "summary"
	FunctionAggregateMetricsMetricTypeTimer        FunctionAggregateMetricsMetricType = "timer"
)

func (e FunctionAggregateMetricsMetricType) ToPointer() *FunctionAggregateMetricsMetricType {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *FunctionAggregateMetricsMetricType) IsExact() bool {
	if e != nil {
		switch *e {
		case "automatic", "counter", "distribution", "gauge", "histogram", "summary", "timer":
			return true
		}
	}
	return false
}

type Aggregation struct {
	// The output metric type
	MetricType *FunctionAggregateMetricsMetricType `default:"automatic" json:"metricType"`
	// Aggregate function to perform on events. Example: sum(bytes).where(action=='REJECT').as(TotalBytes)
	Agg string `json:"agg"`
}

func (a Aggregation) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Aggregation) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"agg"}); err != nil {
		return err
	}
	return nil
}

func (a *Aggregation) GetMetricType() *FunctionAggregateMetricsMetricType {
	if a == nil {
		return nil
	}
	return a.MetricType
}

func (a *Aggregation) GetAgg() string {
	if a == nil {
		return ""
	}
	return a.Agg
}

type FunctionAggregateMetricsAdd struct {
	Name *string `json:"name,omitempty"`
	// JavaScript expression to compute the value (can be constant)
	Value string `json:"value"`
}

func (f FunctionAggregateMetricsAdd) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FunctionAggregateMetricsAdd) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (f *FunctionAggregateMetricsAdd) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FunctionAggregateMetricsAdd) GetValue() string {
	if f == nil {
		return ""
	}
	return f.Value
}

type FunctionAggregateMetricsSchema struct {
	// Pass through the original events along with the aggregation events
	Passthrough *bool `default:"false" json:"passthrough"`
	// Preserve the structure of the original aggregation event's groupby fields
	PreserveGroupBys *bool `default:"false" json:"preserveGroupBys"`
	// Output only statistics that are sufficient for the supplied aggregations
	SufficientStatsOnly *bool `default:"false" json:"sufficientStatsOnly"`
	// A prefix that is prepended to all of the fields output by this Aggregations Function
	Prefix *string `json:"prefix,omitempty"`
	// The time span of the tumbling window for aggregating events. Must be a valid time string (such as 10s).
	TimeWindow *string `default:"10s" json:"timeWindow"`
	// Combination of Aggregation function and output metric type
	Aggregations []Aggregation `json:"aggregations,omitempty"`
	// Optional: One or more dimensions to group aggregates by. Supports wildcard expressions. Wrap dimension names in quotes if using literal identifiers, such as 'service.name'. Warning: Using wildcard '*' causes all dimensions in the event to be included, which can result in high cardinality and increased memory usage. Exclude dimensions that can result in high cardinality before using wildcards. Example: !_time, !_numericValue, *
	Groupbys []string `json:"groupbys,omitempty"`
	// The maximum number of events to include in any given aggregation event
	FlushEventLimit *float64 `json:"flushEventLimit,omitempty"`
	// The memory usage limit to impose upon aggregations. Defaults to 80% of the process memory; value configured above default limit is ignored. Accepts numerals with units like KB and MB (example: 128MB).
	FlushMemLimit *string `json:"flushMemLimit,omitempty"`
	// Enable to retain aggregations for cumulative aggregations when flushing out an aggregation table event. When disabled (the default), aggregations are reset to 0 on flush.
	Cumulative *bool `default:"false" json:"cumulative"`
	// Treat dots in dimension names as literals. This is useful for top-level dimensions that contain dots, such as 'service.name'.
	ShouldTreatDotsAsLiterals *bool `default:"true" json:"shouldTreatDotsAsLiterals"`
	// Set of key-value pairs to evaluate and add/set
	Add []FunctionAggregateMetricsAdd `json:"add,omitempty"`
	// Flush aggregations when an input stream is closed. If disabled, Time Window Settings control flush behavior.
	FlushOnInputClose *bool `default:"true" json:"flushOnInputClose"`
}

func (f FunctionAggregateMetricsSchema) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FunctionAggregateMetricsSchema) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *FunctionAggregateMetricsSchema) GetPassthrough() *bool {
	if f == nil {
		return nil
	}
	return f.Passthrough
}

func (f *FunctionAggregateMetricsSchema) GetPreserveGroupBys() *bool {
	if f == nil {
		return nil
	}
	return f.PreserveGroupBys
}

func (f *FunctionAggregateMetricsSchema) GetSufficientStatsOnly() *bool {
	if f == nil {
		return nil
	}
	return f.SufficientStatsOnly
}

func (f *FunctionAggregateMetricsSchema) GetPrefix() *string {
	if f == nil {
		return nil
	}
	return f.Prefix
}

func (f *FunctionAggregateMetricsSchema) GetTimeWindow() *string {
	if f == nil {
		return nil
	}
	return f.TimeWindow
}

func (f *FunctionAggregateMetricsSchema) GetAggregations() []Aggregation {
	if f == nil {
		return nil
	}
	return f.Aggregations
}

func (f *FunctionAggregateMetricsSchema) GetGroupbys() []string {
	if f == nil {
		return nil
	}
	return f.Groupbys
}

func (f *FunctionAggregateMetricsSchema) GetFlushEventLimit() *float64 {
	if f == nil {
		return nil
	}
	return f.FlushEventLimit
}

func (f *FunctionAggregateMetricsSchema) GetFlushMemLimit() *string {
	if f == nil {
		return nil
	}
	return f.FlushMemLimit
}

func (f *FunctionAggregateMetricsSchema) GetCumulative() *bool {
	if f == nil {
		return nil
	}
	return f.Cumulative
}

func (f *FunctionAggregateMetricsSchema) GetShouldTreatDotsAsLiterals() *bool {
	if f == nil {
		return nil
	}
	return f.ShouldTreatDotsAsLiterals
}

func (f *FunctionAggregateMetricsSchema) GetAdd() []FunctionAggregateMetricsAdd {
	if f == nil {
		return nil
	}
	return f.Add
}

func (f *FunctionAggregateMetricsSchema) GetFlushOnInputClose() *bool {
	if f == nil {
		return nil
	}
	return f.FlushOnInputClose
}

type FunctionAggregateMetrics struct {
	Filename      string                          `json:"__filename"`
	AsyncTimeout  *float64                        `json:"asyncTimeout,omitempty"`
	CriblVersion  *string                         `json:"cribl_version,omitempty"`
	Disabled      *bool                           `json:"disabled,omitempty"`
	Group         string                          `json:"group"`
	HandleSignals *bool                           `json:"handleSignals,omitempty"`
	ID            FunctionAggregateMetricsID      `json:"id"`
	LoadTime      float64                         `json:"loadTime"`
	ModTime       float64                         `json:"modTime"`
	Name          string                          `json:"name"`
	Sync          *bool                           `json:"sync,omitempty"`
	Uischema      map[string]any                  `json:"uischema"`
	Version       string                          `json:"version"`
	Schema        *FunctionAggregateMetricsSchema `json:"schema,omitempty"`
}

func (f FunctionAggregateMetrics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FunctionAggregateMetrics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"__filename", "group", "id", "loadTime", "modTime", "name", "uischema", "version"}); err != nil {
		return err
	}
	return nil
}

func (f *FunctionAggregateMetrics) GetFilename() string {
	if f == nil {
		return ""
	}
	return f.Filename
}

func (f *FunctionAggregateMetrics) GetAsyncTimeout() *float64 {
	if f == nil {
		return nil
	}
	return f.AsyncTimeout
}

func (f *FunctionAggregateMetrics) GetCriblVersion() *string {
	if f == nil {
		return nil
	}
	return f.CriblVersion
}

func (f *FunctionAggregateMetrics) GetDisabled() *bool {
	if f == nil {
		return nil
	}
	return f.Disabled
}

func (f *FunctionAggregateMetrics) GetGroup() string {
	if f == nil {
		return ""
	}
	return f.Group
}

func (f *FunctionAggregateMetrics) GetHandleSignals() *bool {
	if f == nil {
		return nil
	}
	return f.HandleSignals
}

func (f *FunctionAggregateMetrics) GetID() FunctionAggregateMetricsID {
	if f == nil {
		return FunctionAggregateMetricsID("")
	}
	return f.ID
}

func (f *FunctionAggregateMetrics) GetLoadTime() float64 {
	if f == nil {
		return 0.0
	}
	return f.LoadTime
}

func (f *FunctionAggregateMetrics) GetModTime() float64 {
	if f == nil {
		return 0.0
	}
	return f.ModTime
}

func (f *FunctionAggregateMetrics) GetName() string {
	if f == nil {
		return ""
	}
	return f.Name
}

func (f *FunctionAggregateMetrics) GetSync() *bool {
	if f == nil {
		return nil
	}
	return f.Sync
}

func (f *FunctionAggregateMetrics) GetUischema() map[string]any {
	if f == nil {
		return map[string]any{}
	}
	return f.Uischema
}

func (f *FunctionAggregateMetrics) GetVersion() string {
	if f == nil {
		return ""
	}
	return f.Version
}

func (f *FunctionAggregateMetrics) GetSchema() *FunctionAggregateMetricsSchema {
	if f == nil {
		return nil
	}
	return f.Schema
}
