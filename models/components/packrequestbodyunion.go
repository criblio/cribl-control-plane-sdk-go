// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
// @generated-id: 4c04f47997d9

package components

import (
	"errors"
	"fmt"
	"github.com/criblio/cribl-control-plane-sdk-go/internal/utils"
)

type PackRequestBody2 struct {
	ID                  *string `json:"id,omitempty"`
	Spec                *string `json:"spec,omitempty"`
	Version             *string `json:"version,omitempty"`
	MinLogStreamVersion *string `json:"minLogStreamVersion,omitempty"`
	DisplayName         *string `json:"displayName,omitempty"`
	Author              *string `json:"author,omitempty"`
	Description         *string `json:"description,omitempty"`
	// The source of the pack. If not present, an empty pack will be created
	Source               string                   `json:"source"`
	Tags                 *TagsTypePackInstallInfo `json:"tags,omitempty"`
	AllowCustomFunctions *bool                    `json:"allowCustomFunctions,omitempty"`
	Force                *bool                    `json:"force,omitempty"`
}

func (p PackRequestBody2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PackRequestBody2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PackRequestBody2) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *PackRequestBody2) GetSpec() *string {
	if p == nil {
		return nil
	}
	return p.Spec
}

func (p *PackRequestBody2) GetVersion() *string {
	if p == nil {
		return nil
	}
	return p.Version
}

func (p *PackRequestBody2) GetMinLogStreamVersion() *string {
	if p == nil {
		return nil
	}
	return p.MinLogStreamVersion
}

func (p *PackRequestBody2) GetDisplayName() *string {
	if p == nil {
		return nil
	}
	return p.DisplayName
}

func (p *PackRequestBody2) GetAuthor() *string {
	if p == nil {
		return nil
	}
	return p.Author
}

func (p *PackRequestBody2) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PackRequestBody2) GetSource() string {
	if p == nil {
		return ""
	}
	return p.Source
}

func (p *PackRequestBody2) GetTags() *TagsTypePackInstallInfo {
	if p == nil {
		return nil
	}
	return p.Tags
}

func (p *PackRequestBody2) GetAllowCustomFunctions() *bool {
	if p == nil {
		return nil
	}
	return p.AllowCustomFunctions
}

func (p *PackRequestBody2) GetForce() *bool {
	if p == nil {
		return nil
	}
	return p.Force
}

type PackRequestBody1 struct {
	ID                  string  `json:"id"`
	Spec                *string `json:"spec,omitempty"`
	Version             *string `json:"version,omitempty"`
	MinLogStreamVersion *string `json:"minLogStreamVersion,omitempty"`
	DisplayName         *string `json:"displayName,omitempty"`
	Author              *string `json:"author,omitempty"`
	Description         *string `json:"description,omitempty"`
	// The source of the pack. If not present, an empty pack will be created
	Source               *string                  `json:"source,omitempty"`
	Tags                 *TagsTypePackInstallInfo `json:"tags,omitempty"`
	AllowCustomFunctions *bool                    `json:"allowCustomFunctions,omitempty"`
	Force                *bool                    `json:"force,omitempty"`
}

func (p PackRequestBody1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PackRequestBody1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PackRequestBody1) GetID() string {
	if p == nil {
		return ""
	}
	return p.ID
}

func (p *PackRequestBody1) GetSpec() *string {
	if p == nil {
		return nil
	}
	return p.Spec
}

func (p *PackRequestBody1) GetVersion() *string {
	if p == nil {
		return nil
	}
	return p.Version
}

func (p *PackRequestBody1) GetMinLogStreamVersion() *string {
	if p == nil {
		return nil
	}
	return p.MinLogStreamVersion
}

func (p *PackRequestBody1) GetDisplayName() *string {
	if p == nil {
		return nil
	}
	return p.DisplayName
}

func (p *PackRequestBody1) GetAuthor() *string {
	if p == nil {
		return nil
	}
	return p.Author
}

func (p *PackRequestBody1) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PackRequestBody1) GetSource() *string {
	if p == nil {
		return nil
	}
	return p.Source
}

func (p *PackRequestBody1) GetTags() *TagsTypePackInstallInfo {
	if p == nil {
		return nil
	}
	return p.Tags
}

func (p *PackRequestBody1) GetAllowCustomFunctions() *bool {
	if p == nil {
		return nil
	}
	return p.AllowCustomFunctions
}

func (p *PackRequestBody1) GetForce() *bool {
	if p == nil {
		return nil
	}
	return p.Force
}

type PackRequestBodyUnionType string

const (
	PackRequestBodyUnionTypePackRequestBody1 PackRequestBodyUnionType = "PackRequestBody_1"
	PackRequestBodyUnionTypePackRequestBody2 PackRequestBodyUnionType = "PackRequestBody_2"
)

type PackRequestBodyUnion struct {
	PackRequestBody1 *PackRequestBody1 `queryParam:"inline" union:"member"`
	PackRequestBody2 *PackRequestBody2 `queryParam:"inline" union:"member"`

	Type PackRequestBodyUnionType
}

func CreatePackRequestBodyUnionPackRequestBody1(packRequestBody1 PackRequestBody1) PackRequestBodyUnion {
	typ := PackRequestBodyUnionTypePackRequestBody1

	return PackRequestBodyUnion{
		PackRequestBody1: &packRequestBody1,
		Type:             typ,
	}
}

func CreatePackRequestBodyUnionPackRequestBody2(packRequestBody2 PackRequestBody2) PackRequestBodyUnion {
	typ := PackRequestBodyUnionTypePackRequestBody2

	return PackRequestBodyUnion{
		PackRequestBody2: &packRequestBody2,
		Type:             typ,
	}
}

func (u *PackRequestBodyUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var packRequestBody1 PackRequestBody1 = PackRequestBody1{}
	if err := utils.UnmarshalJSON(data, &packRequestBody1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PackRequestBodyUnionTypePackRequestBody1,
			Value: &packRequestBody1,
		})
	}

	var packRequestBody2 PackRequestBody2 = PackRequestBody2{}
	if err := utils.UnmarshalJSON(data, &packRequestBody2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PackRequestBodyUnionTypePackRequestBody2,
			Value: &packRequestBody2,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PackRequestBodyUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PackRequestBodyUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PackRequestBodyUnionType)
	switch best.Type {
	case PackRequestBodyUnionTypePackRequestBody1:
		u.PackRequestBody1 = best.Value.(*PackRequestBody1)
		return nil
	case PackRequestBodyUnionTypePackRequestBody2:
		u.PackRequestBody2 = best.Value.(*PackRequestBody2)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PackRequestBodyUnion", string(data))
}

func (u PackRequestBodyUnion) MarshalJSON() ([]byte, error) {
	if u.PackRequestBody1 != nil {
		return utils.MarshalJSON(u.PackRequestBody1, "", true)
	}

	if u.PackRequestBody2 != nil {
		return utils.MarshalJSON(u.PackRequestBody2, "", true)
	}

	return nil, errors.New("could not marshal union type PackRequestBodyUnion: all fields are null")
}
